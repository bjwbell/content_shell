diff --git a/DEPS b/DEPS
index 0c39260..f4da164 100644
--- a/DEPS
+++ b/DEPS
@@ -40,7 +40,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling V8
   # and whatever else without interference from each other.
-  'v8_revision': '9a1caf5d806b5ed6c4872bb8df4fdc2c5d6f5e52',
+  'v8_revision': '2faaf5ec4a9b5eb82bdf0c1eb67d9fab9b505fb3',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling swarming_client
   # and whatever else without interference from each other.
@@ -56,7 +56,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling PDFium
   # and whatever else without interference from each other.
-  'pdfium_revision': 'dbc7716e1b8d67a5ca422ef0bbfe87ff8c5cf4ea',
+  'pdfium_revision': '3c27a84d15c06f85cc7f455f96dc124673f9f9d2',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling openmax_dl
   # and whatever else without interference from each other.
@@ -88,7 +88,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling catapult
   # and whatever else without interference from each other.
-  'catapult_revision': '94d2faa8c3fbe1dec9d497d4bd69fa7379b65370',
+  'catapult_revision': '13aca87891c16ce452da5e26b52063f934e0a31b',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling libFuzzer
   # and whatever else without interference from each other.
@@ -366,7 +366,7 @@ deps_os = {
 
     # For Linux and Chromium OS.
     'src/third_party/cros_system_api':
-     Var('chromium_git') + '/chromiumos/platform/system_api.git' + '@' + 'c74bf51d2bc256adf09b6cfb2e353262fa43a736',
+     Var('chromium_git') + '/chromiumos/platform/system_api.git' + '@' + '2cf87623ebe64dbff665490900713695ba7c5113',
 
     # Note that this is different from Android's freetype repo.
     'src/third_party/freetype2/src':
diff --git a/base/bind_internal.h b/base/bind_internal.h
index 3d6ca09..e3ccb25 100644
--- a/base/bind_internal.h
+++ b/base/bind_internal.h
@@ -295,7 +295,7 @@ struct InvokeHelper<true, ReturnType> {
 
   template <typename Functor, typename BoundWeakPtr, typename... RunArgs>
   static inline void MakeItSo(Functor&& functor,
-                              BoundWeakPtr&& weak_ptr,
+                              BoundWeakPtr weak_ptr,
                               RunArgs&&... args) {
     if (!weak_ptr)
       return;
diff --git a/cc/ipc/render_pass_struct_traits.cc b/cc/ipc/render_pass_struct_traits.cc
index 8679729..274cbc7 100644
--- a/cc/ipc/render_pass_struct_traits.cc
+++ b/cc/ipc/render_pass_struct_traits.cc
@@ -12,6 +12,7 @@ namespace mojo {
 // static
 void* StructTraits<cc::mojom::RenderPass, std::unique_ptr<cc::RenderPass>>::
     SetUpContext(const std::unique_ptr<cc::RenderPass>& input) {
+  DCHECK_GT(input->quad_list.size(), 0u);
   std::unique_ptr<mojo::Array<uint32_t>> sqs_references(
       new mojo::Array<uint32_t>(input->quad_list.size()));
   cc::SharedQuadStateList::ConstIterator sqs_iter =
@@ -24,8 +25,7 @@ void* StructTraits<cc::mojom::RenderPass, std::unique_ptr<cc::RenderPass>>::
     DCHECK_NE(nullptr, (*it)->shared_quad_state);
     DCHECK_EQ(*sqs_iter, (*it)->shared_quad_state);
   }
-  DCHECK(input->shared_quad_state_list.empty() ||
-         input->shared_quad_state_list.size() - 1 == sqs_iter.index());
+  DCHECK_EQ(input->shared_quad_state_list.size() - 1, sqs_iter.index());
   return sqs_references.release();
 }
 
diff --git a/cc/raster/gpu_raster_buffer_provider.cc b/cc/raster/gpu_raster_buffer_provider.cc
index 865a993..81ae944 100644
--- a/cc/raster/gpu_raster_buffer_provider.cc
+++ b/cc/raster/gpu_raster_buffer_provider.cc
@@ -59,8 +59,9 @@ static sk_sp<SkPicture> PlaybackToPicture(
 
   // Play back raster_source into temp SkPicture.
   SkPictureRecorder recorder;
-  sk_sp<SkCanvas> canvas = sk_ref_sp(
-      recorder.beginRecording(resource_size.width(), resource_size.height()));
+  const int flags = SkPictureRecorder::kComputeSaveLayerInfo_RecordFlag;
+  sk_sp<SkCanvas> canvas = sk_ref_sp(recorder.beginRecording(
+      resource_size.width(), resource_size.height(), NULL, flags));
   canvas->save();
   raster_source->PlaybackToCanvas(canvas.get(), raster_full_rect, playback_rect,
                                   scale, playback_settings);
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/payments/PaymentRequestNoShippingTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/payments/PaymentRequestNoShippingTest.java
index 62f42c3..b35c0e7 100644
--- a/chrome/android/javatests/src/org/chromium/chrome/browser/payments/PaymentRequestNoShippingTest.java
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/payments/PaymentRequestNoShippingTest.java
@@ -7,7 +7,6 @@ package org.chromium.chrome.browser.payments;
 import android.content.DialogInterface;
 import android.test.suitebuilder.annotation.MediumTest;
 
-import org.chromium.base.test.util.FlakyTest;
 import org.chromium.chrome.R;
 import org.chromium.chrome.browser.autofill.AutofillTestHelper;
 import org.chromium.chrome.browser.autofill.PersonalDataManager.AutofillProfile;
@@ -72,7 +71,6 @@ public class PaymentRequestNoShippingTest extends PaymentRequestTestBase {
                 "123"});
     }
 
-    @FlakyTest(message = "crbug.com/628143")
     @MediumTest
     public void testCancelUnmaskAndRetry()
             throws InterruptedException, ExecutionException, TimeoutException {
diff --git a/chrome/browser/chromeos/accessibility/spoken_feedback_browsertest.cc b/chrome/browser/chromeos/accessibility/spoken_feedback_browsertest.cc
index 329f017..fe3fc29 100644
--- a/chrome/browser/chromeos/accessibility/spoken_feedback_browsertest.cc
+++ b/chrome/browser/chromeos/accessibility/spoken_feedback_browsertest.cc
@@ -573,7 +573,7 @@ IN_PROC_BROWSER_TEST_P(SpokenFeedbackTest, MAYBE_ChromeVoxNavigateAndSelect) {
 #else
 #define MAYBE_ChromeVoxStickyMode ChromeVoxStickyMode
 #endif
-IN_PROC_BROWSER_TEST_P(SpokenFeedbackTest, MAYBE_ChromeVoxStickyMode) {
+IN_PROC_BROWSER_TEST_P(SpokenFeedbackTest, ChromeVoxStickyMode) {
   LoadChromeVoxAndThenNavigateToURL(
       GURL("data:text/html;charset=utf-8,"
            "<label>Enter your name <input autofocus></label>"
diff --git a/chrome/browser/devtools/devtools_ui_bindings.cc b/chrome/browser/devtools/devtools_ui_bindings.cc
index 2ad277b..e083cfb 100644
--- a/chrome/browser/devtools/devtools_ui_bindings.cc
+++ b/chrome/browser/devtools/devtools_ui_bindings.cc
@@ -44,6 +44,7 @@
 #include "components/zoom/page_zoom.h"
 #include "content/public/browser/devtools_external_agent_proxy.h"
 #include "content/public/browser/devtools_external_agent_proxy_delegate.h"
+#include "content/public/browser/invalidate_type.h"
 #include "content/public/browser/navigation_controller.h"
 #include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/notification_source.h"
@@ -535,8 +536,9 @@ void DevToolsUIBindings::InspectedURLChanged(const std::string& url) {
   content::NavigationController& controller = web_contents()->GetController();
   content::NavigationEntry* entry = controller.GetActiveEntry();
   // DevTools UI is not localized.
-  web_contents()->UpdateTitleForEntry(
-      entry, base::UTF8ToUTF16(base::StringPrintf(kTitleFormat, url.c_str())));
+  entry->SetTitle(
+      base::UTF8ToUTF16(base::StringPrintf(kTitleFormat, url.c_str())));
+  web_contents()->NotifyNavigationStateChanged(content::INVALIDATE_TYPE_TITLE);
 }
 
 void DevToolsUIBindings::LoadNetworkResource(const DispatchCallback& callback,
diff --git a/chrome/browser/extensions/extension_loading_browsertest.cc b/chrome/browser/extensions/extension_loading_browsertest.cc
index 430c531..3967881 100644
--- a/chrome/browser/extensions/extension_loading_browsertest.cc
+++ b/chrome/browser/extensions/extension_loading_browsertest.cc
@@ -101,6 +101,12 @@ IN_PROC_BROWSER_TEST_F(ExtensionLoadingTest,
 // Tests the behavior described in http://crbug.com/532088.
 IN_PROC_BROWSER_TEST_F(ExtensionLoadingTest,
                        KeepAliveWithDevToolsOpenOnReload) {
+#if defined(OS_WIN)
+  // Flaky on Win XP SP3. http://crbug.com/560716.
+  if (base::win::GetVersion() <= base::win::VERSION_SERVER_2003)
+    return;
+#endif
+
   embedded_test_server()->ServeFilesFromDirectory(
       base::FilePath(FILE_PATH_LITERAL("chrome/test/data")));
   ASSERT_TRUE(embedded_test_server()->Start());
diff --git a/chrome/browser/media/media_stream_devices_controller.cc b/chrome/browser/media/media_stream_devices_controller.cc
index 57e1dbc..8995a28 100644
--- a/chrome/browser/media/media_stream_devices_controller.cc
+++ b/chrome/browser/media/media_stream_devices_controller.cc
@@ -72,23 +72,25 @@ bool ContentTypeIsRequested(content::PermissionType type,
 }
 
 using PermissionActionCallback =
-    base::Callback<void(content::PermissionType, const GURL&)>;
+    base::Callback<void(content::PermissionType, const GURL&, Profile*)>;
 
 void RecordSinglePermissionAction(const content::MediaStreamRequest& request,
                                   content::PermissionType permission_type,
+                                  Profile* profile,
                                   PermissionActionCallback callback) {
   if (ContentTypeIsRequested(permission_type, request)) {
-    callback.Run(permission_type, request.security_origin);
+    callback.Run(permission_type, request.security_origin, profile);
   }
 }
 
 // Calls |action_function| for each permission requested by |request|.
 void RecordPermissionAction(const content::MediaStreamRequest& request,
+                            Profile* profile,
                             PermissionActionCallback callback) {
   RecordSinglePermissionAction(request, content::PermissionType::AUDIO_CAPTURE,
-                               callback);
+                               profile, callback);
   RecordSinglePermissionAction(request, content::PermissionType::VIDEO_CAPTURE,
-                               callback);
+                               profile, callback);
 }
 
 // This helper class helps to measure the number of media stream requests that
@@ -204,8 +206,8 @@ MediaStreamDevicesController::MediaStreamDevicesController(
 
 MediaStreamDevicesController::~MediaStreamDevicesController() {
   if (!callback_.is_null()) {
-    RecordPermissionAction(
-        request_, base::Bind(PermissionUmaUtil::PermissionIgnored));
+    RecordPermissionAction(request_, profile_,
+                           base::Bind(PermissionUmaUtil::PermissionIgnored));
     callback_.Run(content::MediaStreamDevices(),
                   content::MEDIA_DEVICE_FAILED_DUE_TO_SHUTDOWN,
                   std::unique_ptr<content::MediaStreamUI>());
@@ -280,8 +282,8 @@ GURL MediaStreamDevicesController::GetOrigin() const {
 }
 
 void MediaStreamDevicesController::PermissionGranted() {
-  RecordPermissionAction(
-      request_, base::Bind(PermissionUmaUtil::PermissionGranted));
+  RecordPermissionAction(request_, profile_,
+                         base::Bind(PermissionUmaUtil::PermissionGranted));
   RunCallback(GetNewSetting(CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC,
                             old_audio_setting_, CONTENT_SETTING_ALLOW),
               GetNewSetting(CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA,
@@ -290,8 +292,8 @@ void MediaStreamDevicesController::PermissionGranted() {
 }
 
 void MediaStreamDevicesController::PermissionDenied() {
-  RecordPermissionAction(
-      request_, base::Bind(PermissionUmaUtil::PermissionDenied));
+  RecordPermissionAction(request_, profile_,
+                         base::Bind(PermissionUmaUtil::PermissionDenied));
   RunCallback(GetNewSetting(CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC,
                             old_audio_setting_, CONTENT_SETTING_BLOCK),
               GetNewSetting(CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA,
@@ -302,11 +304,11 @@ void MediaStreamDevicesController::PermissionDenied() {
 void MediaStreamDevicesController::GroupedRequestFinished(bool audio_accepted,
                                                           bool video_accepted) {
   RecordSinglePermissionAction(
-      request_, content::PermissionType::AUDIO_CAPTURE,
+      request_, content::PermissionType::AUDIO_CAPTURE, profile_,
       base::Bind(audio_accepted ? PermissionUmaUtil::PermissionGranted
                                 : PermissionUmaUtil::PermissionDenied));
   RecordSinglePermissionAction(
-      request_, content::PermissionType::VIDEO_CAPTURE,
+      request_, content::PermissionType::VIDEO_CAPTURE, profile_,
       base::Bind(video_accepted ? PermissionUmaUtil::PermissionGranted
                                 : PermissionUmaUtil::PermissionDenied));
 
@@ -322,8 +324,8 @@ void MediaStreamDevicesController::GroupedRequestFinished(bool audio_accepted,
 }
 
 void MediaStreamDevicesController::Cancelled() {
-  RecordPermissionAction(
-      request_, base::Bind(PermissionUmaUtil::PermissionDismissed));
+  RecordPermissionAction(request_, profile_,
+                         base::Bind(PermissionUmaUtil::PermissionDismissed));
   RunCallback(old_audio_setting_, old_video_setting_,
               content::MEDIA_DEVICE_PERMISSION_DISMISSED);
 }
diff --git a/chrome/browser/media/tab_desktop_media_list_unittest.cc b/chrome/browser/media/tab_desktop_media_list_unittest.cc
index 80c7a50..f1117f0 100644
--- a/chrome/browser/media/tab_desktop_media_list_unittest.cc
+++ b/chrome/browser/media/tab_desktop_media_list_unittest.cc
@@ -139,7 +139,7 @@ class TabDesktopMediaListTest : public testing::Test {
       entry = contents->GetController().GetTransientEntry();
     }
 
-    contents->UpdateTitleForEntry(entry, base::ASCIIToUTF16("Test tab"));
+    entry->SetTitle(base::UTF8ToUTF16("Test tab"));
 
     content::FaviconStatus favicon_info;
     favicon_info.image =
@@ -325,9 +325,8 @@ TEST_F(TabDesktopMediaListTest, UpdateTitle) {
   WebContents* contents =
       tab_strip_model->GetWebContentsAt(kDefaultSourceCount - 1);
   ASSERT_TRUE(contents);
-  const content::NavigationController& controller = contents->GetController();
-  contents->UpdateTitleForEntry(controller.GetTransientEntry(),
-                                base::ASCIIToUTF16("New test tab"));
+  contents->GetController().GetTransientEntry()->SetTitle(
+      base::UTF8ToUTF16("New test tab"));
 
   EXPECT_CALL(observer_, OnSourceNameChanged(list_.get(), 0))
       .WillOnce(QuitMessageLoop());
diff --git a/chrome/browser/password_manager/account_chooser_dialog_android_unittest.cc b/chrome/browser/password_manager/account_chooser_dialog_android_unittest.cc
index da58fdb..bb12485 100644
--- a/chrome/browser/password_manager/account_chooser_dialog_android_unittest.cc
+++ b/chrome/browser/password_manager/account_chooser_dialog_android_unittest.cc
@@ -30,6 +30,7 @@ password_manager::PasswordFormData kFormData = {
     L"",
     L"",
     true,
+    false,
     1,
 };
 
diff --git a/chrome/browser/password_manager/native_backend_gnome_x.cc b/chrome/browser/password_manager/native_backend_gnome_x.cc
index c69587e..5b3e38e 100644
--- a/chrome/browser/password_manager/native_backend_gnome_x.cc
+++ b/chrome/browser/password_manager/native_backend_gnome_x.cc
@@ -135,6 +135,7 @@ std::unique_ptr<PasswordForm> FormFromAttributes(
   form->password_element = UTF8ToUTF16(string_attr_map["password_element"]);
   form->submit_element = UTF8ToUTF16(string_attr_map["submit_element"]);
   form->signon_realm = string_attr_map["signon_realm"];
+  form->ssl_valid = uint_attr_map["ssl_valid"];
   form->preferred = uint_attr_map["preferred"];
   int64_t date_created = 0;
   bool date_ok = base::StringToInt64(string_attr_map["date_created"],
@@ -234,7 +235,7 @@ ScopedVector<PasswordForm> ConvertFormList(GList* found,
   return forms;
 }
 
-// Schema is analogous to the fields in PasswordForm.
+// Schema is analagous to the fields in PasswordForm.
 const GnomeKeyringPasswordSchema kGnomeSchema = {
     GNOME_KEYRING_ITEM_GENERIC_SECRET,
     {{"origin_url", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING},
@@ -244,6 +245,7 @@ const GnomeKeyringPasswordSchema kGnomeSchema = {
      {"password_element", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING},
      {"submit_element", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING},
      {"signon_realm", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING},
+     {"ssl_valid", GNOME_KEYRING_ATTRIBUTE_TYPE_UINT32},
      {"preferred", GNOME_KEYRING_ATTRIBUTE_TYPE_UINT32},
      {"date_created", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING},
      {"blacklisted_by_user", GNOME_KEYRING_ATTRIBUTE_TYPE_UINT32},
@@ -370,6 +372,7 @@ void GKRMethod::AddLogin(const PasswordForm& form, const char* app_string) {
       "password_element", UTF16ToUTF8(form.password_element).c_str(),
       "submit_element", UTF16ToUTF8(form.submit_element).c_str(),
       "signon_realm", form.signon_realm.c_str(),
+      "ssl_valid", form.ssl_valid,
       "preferred", form.preferred,
       "date_created", base::Int64ToString(date_created).c_str(),
       "blacklisted_by_user", form.blacklisted_by_user,
diff --git a/chrome/browser/password_manager/native_backend_gnome_x_unittest.cc b/chrome/browser/password_manager/native_backend_gnome_x_unittest.cc
index 5b0d9b6..5f0d40b 100644
--- a/chrome/browser/password_manager/native_backend_gnome_x_unittest.cc
+++ b/chrome/browser/password_manager/native_backend_gnome_x_unittest.cc
@@ -307,6 +307,7 @@ void CheckPasswordChanges(const PasswordStoreChangeList& expected_list,
     EXPECT_EQ(expected.password_element, actual.password_element);
     EXPECT_EQ(expected.submit_element, actual.submit_element);
     EXPECT_EQ(expected.signon_realm, actual.signon_realm);
+    EXPECT_EQ(expected.ssl_valid, actual.ssl_valid);
     EXPECT_EQ(expected.preferred, actual.preferred);
     EXPECT_EQ(expected.date_created, actual.date_created);
     EXPECT_EQ(expected.blacklisted_by_user, actual.blacklisted_by_user);
@@ -467,7 +468,7 @@ class NativeBackendGnomeTest : public testing::Test {
     EXPECT_EQ("login", item->keyring);
     EXPECT_EQ(form.origin.spec(), item->display_name);
     EXPECT_EQ(UTF16ToUTF8(form.password_value), item->password);
-    EXPECT_EQ(21u, item->attributes.size());
+    EXPECT_EQ(22u, item->attributes.size());
     CheckStringAttribute(item, "origin_url", form.origin.spec());
     CheckStringAttribute(item, "action_url", form.action.spec());
     CheckStringAttribute(item, "username_element",
@@ -479,6 +480,7 @@ class NativeBackendGnomeTest : public testing::Test {
     CheckStringAttribute(item, "submit_element",
                          UTF16ToUTF8(form.submit_element));
     CheckStringAttribute(item, "signon_realm", form.signon_realm);
+    CheckUint32Attribute(item, "ssl_valid", form.ssl_valid);
     CheckUint32Attribute(item, "preferred", form.preferred);
     // We don't check the date created. It varies.
     CheckUint32Attribute(item, "blacklisted_by_user", form.blacklisted_by_user);
diff --git a/chrome/browser/password_manager/native_backend_kwallet_x.cc b/chrome/browser/password_manager/native_backend_kwallet_x.cc
index e2b63d1..a2346ba 100644
--- a/chrome/browser/password_manager/native_backend_kwallet_x.cc
+++ b/chrome/browser/password_manager/native_backend_kwallet_x.cc
@@ -36,7 +36,7 @@ namespace {
 
 // In case the fields in the pickle ever change, version them so we can try to
 // read old pickles. (Note: do not eat old pickles past the expiration date.)
-const int kPickleVersion = 9;
+const int kPickleVersion = 8;
 
 // We could localize this string, but then changing your locale would cause
 // you to lose access to all your stored passwords. Maybe best not to do that.
@@ -164,24 +164,16 @@ bool DeserializeValueSize(const std::string& signon_realm,
     int generation_upload_status = 0;
     // Note that these will be read back in the order listed due to
     // short-circuit evaluation. This is important.
-    if (!iter.ReadInt(&scheme) || !ReadGURL(&iter, warn_only, &form->origin) ||
+    if (!iter.ReadInt(&scheme) ||
+        !ReadGURL(&iter, warn_only, &form->origin) ||
         !ReadGURL(&iter, warn_only, &form->action) ||
         !iter.ReadString16(&form->username_element) ||
         !iter.ReadString16(&form->username_value) ||
         !iter.ReadString16(&form->password_element) ||
         !iter.ReadString16(&form->password_value) ||
-        !iter.ReadString16(&form->submit_element)) {
-      LogDeserializationWarning(version, signon_realm, warn_only);
-      return false;
-    }
-    if (version <= 8) {
-      bool dummy_unused_flag = false;
-      if (!iter.ReadBool(&dummy_unused_flag)) {
-        LogDeserializationWarning(version, signon_realm, warn_only);
-        return false;
-      }
-    }
-    if (!iter.ReadBool(&form->preferred) ||
+        !iter.ReadString16(&form->submit_element) ||
+        !iter.ReadBool(&form->ssl_valid) ||
+        !iter.ReadBool(&form->preferred) ||
         !iter.ReadBool(&form->blacklisted_by_user) ||
         !iter.ReadInt64(&date_created)) {
       LogDeserializationWarning(version, signon_realm, warn_only);
@@ -262,6 +254,7 @@ void SerializeValue(const std::vector<autofill::PasswordForm*>& forms,
     pickle->WriteString16(form->password_element);
     pickle->WriteString16(form->password_value);
     pickle->WriteString16(form->submit_element);
+    pickle->WriteBool(form->ssl_valid);
     pickle->WriteBool(form->preferred);
     pickle->WriteBool(form->blacklisted_by_user);
     pickle->WriteInt64(form->date_created.ToInternalValue());
diff --git a/chrome/browser/password_manager/native_backend_kwallet_x_unittest.cc b/chrome/browser/password_manager/native_backend_kwallet_x_unittest.cc
index ac64487..ac77b99 100644
--- a/chrome/browser/password_manager/native_backend_kwallet_x_unittest.cc
+++ b/chrome/browser/password_manager/native_backend_kwallet_x_unittest.cc
@@ -246,6 +246,7 @@ void NativeBackendKWalletTestBase::CheckPasswordForm(
   EXPECT_EQ(expected.password_element, actual.password_element);
   EXPECT_EQ(expected.submit_element, actual.submit_element);
   EXPECT_EQ(expected.signon_realm, actual.signon_realm);
+  EXPECT_EQ(expected.ssl_valid, actual.ssl_valid);
   EXPECT_EQ(expected.preferred, actual.preferred);
   if (check_date_created) {
     EXPECT_EQ(expected.date_created, actual.date_created);
@@ -1171,7 +1172,6 @@ class NativeBackendKWalletPickleTest : public NativeBackendKWalletTestBase {
   void CreateVersion0Pickle(bool size_32,
                             const PasswordForm& form,
                             base::Pickle* pickle);
-  void CheckVersion9Pickle();
   void CheckVersion8Pickle();
   void CheckVersion7Pickle();
   // As explained in http://crbug.com/494229#c11, version 6 added a new optional
@@ -1194,8 +1194,7 @@ void NativeBackendKWalletPickleTest::CreateVersion1PlusPickle(
   pickle->WriteInt(stored_version);
   pickle->WriteUInt64(1);  // Number of forms in the pickle.
   WriteHTMLAttributes(form, pickle);
-  if (effective_version < 9)
-    pickle->WriteBool(true);  // Unused flag.
+  pickle->WriteBool(form.ssl_valid);
   WritePreferenceMetadata(form, pickle);
   pickle->WriteInt64(form.date_created.ToInternalValue());
   if (effective_version < 2)
@@ -1228,28 +1227,12 @@ void NativeBackendKWalletPickleTest::CreateVersion0Pickle(
   else
     pickle->WriteUInt64(1);
   WriteHTMLAttributes(form, pickle);
-  pickle->WriteBool(true);  // Unused flag.
+  pickle->WriteBool(form.ssl_valid);
   WritePreferenceMetadata(form, pickle);
   // Old way to store the date.
   pickle->WriteInt64(form.date_created.ToTimeT());
 }
 
-void NativeBackendKWalletPickleTest::CheckVersion9Pickle() {
-  // Pickle 9+ dropped an old flag in the middle of PasswordForm. This test
-  // makes sure that the attributes after the dropped flag are deserialised
-  // correctly.
-  base::Pickle pickle;
-  PasswordForm default_values;
-  PasswordForm form = form_google_;
-
-  CreateVersion1PlusPickle(form, &pickle, 9, 9);
-  ScopedVector<PasswordForm> form_list =
-      NativeBackendKWalletStub::DeserializeValue(form.signon_realm, pickle);
-  EXPECT_EQ(1u, form_list.size());
-  if (form_list.size() > 0)
-    CheckPasswordForm(form, *form_list[0], true);
-}
-
 void NativeBackendKWalletPickleTest::CheckVersion8Pickle() {
   base::Pickle pickle;
   PasswordForm default_values;
@@ -1432,7 +1415,3 @@ TEST_F(NativeBackendKWalletPickleTest, CheckVersion7Pickle) {
 TEST_F(NativeBackendKWalletPickleTest, CheckVersion8Pickle) {
   CheckVersion8Pickle();
 }
-
-TEST_F(NativeBackendKWalletPickleTest, CheckVersion9Pickle) {
-  CheckVersion9Pickle();
-}
diff --git a/chrome/browser/password_manager/native_backend_libsecret.cc b/chrome/browser/password_manager/native_backend_libsecret.cc
index 90711f8..7ad4ed4 100644
--- a/chrome/browser/password_manager/native_backend_libsecret.cc
+++ b/chrome/browser/password_manager/native_backend_libsecret.cc
@@ -50,6 +50,7 @@ const SecretSchema kLibsecretSchema = {
      {"password_element", SECRET_SCHEMA_ATTRIBUTE_STRING},
      {"submit_element", SECRET_SCHEMA_ATTRIBUTE_STRING},
      {"signon_realm", SECRET_SCHEMA_ATTRIBUTE_STRING},
+     {"ssl_valid", SECRET_SCHEMA_ATTRIBUTE_INTEGER},
      {"preferred", SECRET_SCHEMA_ATTRIBUTE_INTEGER},
      {"date_created", SECRET_SCHEMA_ATTRIBUTE_STRING},
      {"blacklisted_by_user", SECRET_SCHEMA_ATTRIBUTE_INTEGER},
@@ -102,6 +103,7 @@ std::unique_ptr<PasswordForm> FormOutOfAttributes(GHashTable* attrs) {
   form->submit_element =
       UTF8ToUTF16(GetStringFromAttributes(attrs, "submit_element"));
   form->signon_realm = GetStringFromAttributes(attrs, "signon_realm");
+  form->ssl_valid = GetUintFromAttributes(attrs, "ssl_valid");
   form->preferred = GetUintFromAttributes(attrs, "preferred");
   int64_t date_created = 0;
   bool date_ok = base::StringToInt64(
@@ -357,6 +359,7 @@ bool NativeBackendLibsecret::RawAddLogin(const PasswordForm& form) {
       "password_element", UTF16ToUTF8(form.password_element).c_str(),
       "submit_element", UTF16ToUTF8(form.submit_element).c_str(),
       "signon_realm", form.signon_realm.c_str(),
+      "ssl_valid", form.ssl_valid,
       "preferred", form.preferred,
       "date_created", base::Int64ToString(date_created).c_str(),
       "blacklisted_by_user", form.blacklisted_by_user,
diff --git a/chrome/browser/password_manager/native_backend_libsecret_unittest.cc b/chrome/browser/password_manager/native_backend_libsecret_unittest.cc
index b7ea954..f3ecee1 100644
--- a/chrome/browser/password_manager/native_backend_libsecret_unittest.cc
+++ b/chrome/browser/password_manager/native_backend_libsecret_unittest.cc
@@ -374,7 +374,7 @@ class NativeBackendLibsecretTest : public testing::Test {
                            const PasswordForm& form,
                            const std::string& app_string) {
     EXPECT_EQ(UTF16ToUTF8(form.password_value), item->value->password);
-    EXPECT_EQ(21u, g_hash_table_size(item->attributes));
+    EXPECT_EQ(22u, g_hash_table_size(item->attributes));
     CheckStringAttribute(item, "origin_url", form.origin.spec());
     CheckStringAttribute(item, "action_url", form.action.spec());
     CheckStringAttribute(item, "username_element",
@@ -386,6 +386,7 @@ class NativeBackendLibsecretTest : public testing::Test {
     CheckStringAttribute(item, "submit_element",
                          UTF16ToUTF8(form.submit_element));
     CheckStringAttribute(item, "signon_realm", form.signon_realm);
+    CheckUint32Attribute(item, "ssl_valid", form.ssl_valid);
     CheckUint32Attribute(item, "preferred", form.preferred);
     // We don't check the date created. It varies.
     CheckUint32Attribute(item, "blacklisted_by_user", form.blacklisted_by_user);
@@ -933,14 +934,14 @@ TEST_F(NativeBackendLibsecretTest, SomeKeyringAttributesAreMissing) {
   // Remove a string attribute.
   (*global_mock_libsecret_items)[0]->RemoveAttribute("avatar_url");
   // Remove an integer attribute.
-  (*global_mock_libsecret_items)[0]->RemoveAttribute("times_used");
+  (*global_mock_libsecret_items)[0]->RemoveAttribute("ssl_valid");
 
   ScopedVector<autofill::PasswordForm> form_list;
   EXPECT_TRUE(backend.GetAutofillableLogins(&form_list));
 
   EXPECT_EQ(1u, form_list.size());
   EXPECT_EQ(GURL(""), form_list[0]->icon_url);
-  EXPECT_EQ(0, form_list[0]->times_used);
+  EXPECT_FALSE(form_list[0]->ssl_valid);
 }
 
 TEST_F(NativeBackendLibsecretTest, ReadDuplicateForms) {
diff --git a/chrome/browser/password_manager/password_store_mac.cc b/chrome/browser/password_manager/password_store_mac.cc
index b7d1b14..b39fdef 100644
--- a/chrome/browser/password_manager/password_store_mac.cc
+++ b/chrome/browser/password_manager/password_store_mac.cc
@@ -363,7 +363,6 @@ bool FillPasswordFormFromKeychainItem(const AppleKeychain& keychain,
   std::string server;
   std::string security_domain;
   std::string path;
-  bool is_secure = false;
   for (unsigned int i = 0; i < attrList->count; i++) {
     SecKeychainAttribute attr = attrList->attr[i];
     if (!attr.data) {
@@ -387,7 +386,7 @@ bool FillPasswordFormFromKeychainItem(const AppleKeychain& keychain,
       {
         SecProtocolType protocol = *(static_cast<SecProtocolType*>(attr.data));
         // TODO(stuartmorgan): Handle proxy types
-        is_secure = (protocol == kSecProtocolTypeHTTPS);
+        form->ssl_valid = (protocol == kSecProtocolTypeHTTPS);
         break;
       }
       case kSecAuthenticationTypeItemAttr:
@@ -430,8 +429,9 @@ bool FillPasswordFormFromKeychainItem(const AppleKeychain& keychain,
   if (password_manager::IsValidAndroidFacetURI(server)) {
     form->signon_realm = server;
     form->origin = GURL();
+    form->ssl_valid = true;
   } else {
-    form->origin = URLFromComponents(is_secure, server, port, path);
+    form->origin = URLFromComponents(form->ssl_valid, server, port, path);
     // TODO(stuartmorgan): Handle proxies, which need a different signon_realm
     // format.
     form->signon_realm = form->origin.GetOrigin().spec();
diff --git a/chrome/browser/password_manager/password_store_mac_unittest.cc b/chrome/browser/password_manager/password_store_mac_unittest.cc
index 6bf4784..76836e7 100644
--- a/chrome/browser/password_manager/password_store_mac_unittest.cc
+++ b/chrome/browser/password_manager/password_store_mac_unittest.cc
@@ -158,6 +158,7 @@ void CheckFormsAgainstExpectations(
       EXPECT_TRUE(form->blacklisted_by_user);
     }
     EXPECT_EQ(expectation->preferred, form->preferred);
+    EXPECT_EQ(expectation->ssl_valid, form->ssl_valid);
     EXPECT_DOUBLE_EQ(expectation->creation_time,
                      form->date_created.ToDoubleT());
     base::Time created = base::Time::FromDoubleT(expectation->creation_time);
@@ -334,6 +335,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainToFormTranslation) {
     const char* origin;
     const wchar_t* username;  // Set to NULL to check for a blacklist entry.
     const wchar_t* password;
+    const bool ssl_valid;
     const int creation_year;
     const int creation_month;
     const int creation_day;
@@ -344,32 +346,32 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainToFormTranslation) {
 
   TestExpectations expected[] = {
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
-       "http://some.domain.com/", L"joe_user", L"sekrit", 2002, 6, 1, 17, 15,
-       0},
+       "http://some.domain.com/", L"joe_user", L"sekrit", false, 2002, 6, 1, 17,
+       15, 0},
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
-       "http://some.domain.com/insecure.html", L"joe_user", L"sekrit", 1999, 12,
-       31, 23, 59, 59},
+       "http://some.domain.com/insecure.html", L"joe_user", L"sekrit", false,
+       1999, 12, 31, 23, 59, 59},
       {PasswordForm::SCHEME_HTML, "https://some.domain.com/",
-       "https://some.domain.com/secure.html", L"secure_user", L"password", 2010,
-       9, 8, 7, 6, 5},
+       "https://some.domain.com/secure.html", L"secure_user", L"password", true,
+       2010, 9, 8, 7, 6, 5},
       {PasswordForm::SCHEME_HTML, "http://dont.remember.com/",
-       "http://dont.remember.com/", NULL, NULL, 2000, 1, 1, 0, 0, 0},
+       "http://dont.remember.com/", NULL, NULL, false, 2000, 1, 1, 0, 0, 0},
       {PasswordForm::SCHEME_HTML, "http://dont.remember.com/",
-       "http://dont.remember.com/", NULL, NULL, 2000, 1, 1, 0, 0, 0},
+       "http://dont.remember.com/", NULL, NULL, false, 2000, 1, 1, 0, 0, 0},
       {PasswordForm::SCHEME_HTML, "https://dont.remember.com/",
-       "https://dont.remember.com/", NULL, NULL, 2000, 1, 1, 0, 0, 0},
+       "https://dont.remember.com/", NULL, NULL, true, 2000, 1, 1, 0, 0, 0},
       {PasswordForm::SCHEME_BASIC, "http://some.domain.com:4567/low_security",
        "http://some.domain.com:4567/insecure.html", L"basic_auth_user",
-       L"basic", 1998, 03, 30, 10, 00, 00},
+       L"basic", false, 1998, 03, 30, 10, 00, 00},
       {PasswordForm::SCHEME_DIGEST, "https://some.domain.com/high_security",
-       "https://some.domain.com/", L"digest_auth_user", L"digest", 1998, 3, 30,
-       10, 0, 0},
+       "https://some.domain.com/", L"digest_auth_user", L"digest", true, 1998,
+       3, 30, 10, 0, 0},
       // This one gives us an invalid date, which we will treat as a "NULL" date
       // which is 1601.
       {PasswordForm::SCHEME_OTHER, "http://a.server.com/",
-       "http://a.server.com/", L"abc", L"123", 1601, 1, 1, 0, 0, 0},
+       "http://a.server.com/", L"abc", L"123", false, 1601, 1, 1, 0, 0, 0},
       {PasswordForm::SCHEME_HTML, "android://hash@com.domain.some/", "",
-       L"joe_user", L"secret", 2015, 5, 15, 14, 13, 12},
+       L"joe_user", L"secret", true, 2015, 5, 15, 14, 13, 12},
   };
 
   for (unsigned int i = 0; i < arraysize(expected); ++i) {
@@ -385,6 +387,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainToFormTranslation) {
 
     EXPECT_EQ(expected[i].scheme, form.scheme);
     EXPECT_EQ(GURL(expected[i].origin), form.origin);
+    EXPECT_EQ(expected[i].ssl_valid, form.ssl_valid);
     EXPECT_EQ(std::string(expected[i].signon_realm), form.signon_realm);
     if (expected[i].username) {
       EXPECT_EQ(WideToUTF16(expected[i].username), form.username_value);
@@ -423,51 +426,55 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainSearch) {
   TestDataAndExpectation test_data[] = {
       // An HTML form we've seen.
       {{PasswordForm::SCHEME_HTML, "http://some.domain.com/", NULL, NULL, NULL,
-        NULL, NULL, L"joe_user", NULL, false, 0},
+        NULL, NULL, L"joe_user", NULL, false, false, 0},
        2,
        2},
       {{PasswordForm::SCHEME_HTML, "http://some.domain.com/", NULL, NULL, NULL,
-        NULL, NULL, L"wrong_user", NULL, false, 0},
+        NULL, NULL, L"wrong_user", NULL, false, false, 0},
        2,
        0},
       // An HTML form we haven't seen
       {{PasswordForm::SCHEME_HTML, "http://www.unseendomain.com/", NULL, NULL,
-        NULL, NULL, NULL, L"joe_user", NULL, false, 0},
+        NULL, NULL, NULL, L"joe_user", NULL, false, false, 0},
        0,
        0},
       // Basic auth that should match.
       {{PasswordForm::SCHEME_BASIC, "http://some.domain.com:4567/low_security",
-        NULL, NULL, NULL, NULL, NULL, L"basic_auth_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, NULL, L"basic_auth_user", NULL, false, false,
+        0},
        1,
        1},
       // Basic auth with the wrong port.
       {{PasswordForm::SCHEME_BASIC, "http://some.domain.com:1111/low_security",
-        NULL, NULL, NULL, NULL, NULL, L"basic_auth_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, NULL, L"basic_auth_user", NULL, false, false,
+        0},
        0,
        0},
       // Digest auth we've saved under https, visited with http.
       {{PasswordForm::SCHEME_DIGEST, "http://some.domain.com/high_security",
-        NULL, NULL, NULL, NULL, NULL, L"digest_auth_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, NULL, L"digest_auth_user", NULL, false, false,
+        0},
        0,
        0},
       // Digest auth that should match.
       {{PasswordForm::SCHEME_DIGEST, "https://some.domain.com/high_security",
-        NULL, NULL, NULL, NULL, NULL, L"wrong_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, NULL, L"wrong_user", NULL, false, true, 0},
        1,
        0},
       // Digest auth with the wrong domain.
       {{PasswordForm::SCHEME_DIGEST, "https://some.domain.com/other_domain",
-        NULL, NULL, NULL, NULL, NULL, L"digest_auth_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, NULL, L"digest_auth_user", NULL, false, true,
+        0},
        0,
        0},
       // Android credentials (both legacy ones with origin, and without).
       {{PasswordForm::SCHEME_HTML, "android://hash@com.domain.some/",
         "android://hash@com.domain.some/", NULL, NULL, NULL, NULL, L"joe_user",
-        NULL, false, 0},
+        NULL, false, true, 0},
        1,
        1},
       {{PasswordForm::SCHEME_HTML, "android://hash@com.domain.some/", NULL,
-        NULL, NULL, NULL, NULL, L"joe_user", NULL, false, 0},
+        NULL, NULL, NULL, NULL, L"joe_user", NULL, false, true, 0},
        1,
        1},
       // Federated logins do not have a corresponding Keychain entry, and should
@@ -477,12 +484,12 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainSearch) {
       // that it is a federated login.
       {{PasswordForm::SCHEME_HTML, "android://hash@com.domain.some/", NULL,
         NULL, NULL, NULL, NULL, L"joe_user",
-        password_manager::kTestingFederatedLoginMarker, false, 0},
+        password_manager::kTestingFederatedLoginMarker, false, true, 0},
        1,
        0},
       /// Garbage forms should have no matches.
       {{PasswordForm::SCHEME_HTML, "foo/bar/baz", NULL, NULL, NULL, NULL, NULL,
-        NULL, NULL, false, 0},
+        NULL, NULL, false, false, 0},
        0,
        0},
   };
@@ -559,13 +566,13 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainExactSearch) {
   PasswordFormData base_form_data[] = {
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
        "http://some.domain.com/insecure.html", NULL, NULL, NULL, NULL,
-       L"joe_user", NULL, true, 0},
+       L"joe_user", NULL, true, false, 0},
       {PasswordForm::SCHEME_BASIC, "http://some.domain.com:4567/low_security",
        "http://some.domain.com:4567/insecure.html", NULL, NULL, NULL, NULL,
-       L"basic_auth_user", NULL, true, 0},
+       L"basic_auth_user", NULL, true, false, 0},
       {PasswordForm::SCHEME_DIGEST, "https://some.domain.com/high_security",
        "https://some.domain.com", NULL, NULL, NULL, NULL, L"digest_auth_user",
-       NULL, true, 0},
+       NULL, true, true, 0},
   };
 
   for (unsigned int i = 0; i < arraysize(base_form_data); ++i) {
@@ -618,40 +625,40 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainAdd) {
       // Test a variety of scheme/port/protocol/path variations.
       {{PasswordForm::SCHEME_HTML, "http://web.site.com/",
         "http://web.site.com/path/to/page.html", NULL, NULL, NULL, NULL,
-        L"anonymous", L"knock-knock", false, 0},
+        L"anonymous", L"knock-knock", false, false, 0},
        true},
       {{PasswordForm::SCHEME_HTML, "https://web.site.com/",
         "https://web.site.com/", NULL, NULL, NULL, NULL, L"admin", L"p4ssw0rd",
-        false, 0},
+        false, false, 0},
        true},
       {{PasswordForm::SCHEME_BASIC, "http://a.site.com:2222/therealm",
         "http://a.site.com:2222/", NULL, NULL, NULL, NULL, L"username",
-        L"password", false, 0},
+        L"password", false, false, 0},
        true},
       {{PasswordForm::SCHEME_DIGEST, "https://digest.site.com/differentrealm",
         "https://digest.site.com/secure.html", NULL, NULL, NULL, NULL,
-        L"testname", L"testpass", false, 0},
+        L"testname", L"testpass", false, false, 0},
        true},
       // Test that Android credentials can be stored. Also check the legacy form
       // when |origin| was still filled with the Android URI (and not left
       // empty).
       {{PasswordForm::SCHEME_HTML, "android://hash@com.example.alpha/", "",
-        NULL, NULL, NULL, NULL, L"joe_user", L"password", false, 0},
+        NULL, NULL, NULL, NULL, L"joe_user", L"password", false, true, 0},
        true},
       {{PasswordForm::SCHEME_HTML, "android://hash@com.example.beta/",
         "android://hash@com.example.beta/", NULL, NULL, NULL, NULL,
-        L"jane_user", L"password2", false, 0},
+        L"jane_user", L"password2", false, true, 0},
        true},
       // Make sure that garbage forms are rejected.
       {{PasswordForm::SCHEME_HTML, "gobbledygook", "gobbledygook", NULL, NULL,
-        NULL, NULL, L"anonymous", L"knock-knock", false, 0},
+        NULL, NULL, L"anonymous", L"knock-knock", false, false, 0},
        false},
       // Test that failing to update a duplicate (forced using the magic failure
       // password; see MockAppleKeychain::ItemModifyAttributesAndData) is
       // reported.
       {{PasswordForm::SCHEME_HTML, "http://some.domain.com",
         "http://some.domain.com/insecure.html", NULL, NULL, NULL, NULL,
-        L"joe_user", L"fail_me", false, 0},
+        L"joe_user", L"fail_me", false, false, 0},
        false},
   };
 
@@ -685,6 +692,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainAdd) {
                              L"joe_user",
                              L"updated_password",
                              false,
+                             false,
                              0};
     std::unique_ptr<PasswordForm> update_form =
         CreatePasswordFormFromDataForTesting(data);
@@ -707,22 +715,23 @@ TEST_F(PasswordStoreMacInternalsTest, TestKeychainRemove) {
       // Test deletion of an item that we add.
       {{PasswordForm::SCHEME_HTML, "http://web.site.com/",
         "http://web.site.com/path/to/page.html", NULL, NULL, NULL, NULL,
-        L"anonymous", L"knock-knock", false, 0},
+        L"anonymous", L"knock-knock", false, false, 0},
        true},
       // Test that Android credentials can be removed. Also check the legacy
-      // case when |origin| was still filled with the Android URI (and not left
+      // case
+      // when |origin| was still filled with the Android URI (and not left
       // empty).
       {{PasswordForm::SCHEME_HTML, "android://hash@com.example.alpha/", "",
-        NULL, NULL, NULL, NULL, L"joe_user", L"secret", false, 0},
+        NULL, NULL, NULL, NULL, L"joe_user", L"secret", false, true, 0},
        true},
       {{PasswordForm::SCHEME_HTML, "android://hash@com.example.beta/",
         "android://hash@com.example.beta/", NULL, NULL, NULL, NULL,
-        L"jane_user", L"secret", false, 0},
+        L"jane_user", L"secret", false, true, 0},
        true},
       // Make sure we don't delete items we don't own.
       {{PasswordForm::SCHEME_HTML, "http://some.domain.com/",
         "http://some.domain.com/insecure.html", NULL, NULL, NULL, NULL,
-        L"joe_user", NULL, true, 0},
+        L"joe_user", NULL, true, false, 0},
        false},
   };
 
@@ -762,6 +771,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMatch) {
     different_form.username_element = ASCIIToUTF16("password");
     different_form.password_value = ASCIIToUTF16("sekrit");
     different_form.action = GURL("http://some.domain.com/action.cgi");
+    different_form.ssl_valid = true;
     different_form.preferred = true;
     different_form.date_created = base::Time::Now();
     EXPECT_TRUE(
@@ -831,6 +841,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                       L"joe_user",
                                       L"sekrit",
                                       false,
+                                      false,
                                       1010101010};
   PasswordFormData keychain_user_1_with_path = {
       PasswordForm::SCHEME_HTML,
@@ -843,6 +854,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"joe_user",
       L"otherpassword",
       false,
+      false,
       1010101010};
   PasswordFormData keychain_user_2 = {PasswordForm::SCHEME_HTML,
                                       "http://some.domain.com/",
@@ -854,6 +866,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                       L"john.doe",
                                       L"sesame",
                                       false,
+                                      false,
                                       958739876};
   PasswordFormData keychain_blacklist = {PasswordForm::SCHEME_HTML,
                                          "http://some.domain.com/",
@@ -865,6 +878,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                          NULL,
                                          NULL,
                                          false,
+                                         false,
                                          1010101010};
   PasswordFormData keychain_android = {PasswordForm::SCHEME_HTML,
                                        "android://hash@com.domain.some/",
@@ -876,6 +890,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                        L"joe_user",
                                        L"secret",
                                        false,
+                                       true,
                                        1234567890};
 
   PasswordFormData db_user_1 = {PasswordForm::SCHEME_HTML,
@@ -888,6 +903,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                 L"joe_user",
                                 L"",
                                 true,
+                                false,
                                 1212121212};
   PasswordFormData db_user_1_with_path = {
       PasswordForm::SCHEME_HTML,
@@ -900,6 +916,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"joe_user",
       L"",
       true,
+      false,
       1234567890};
   PasswordFormData db_user_3_with_path = {
       PasswordForm::SCHEME_HTML,
@@ -912,6 +929,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"second-account",
       L"",
       true,
+      false,
       1240000000};
   PasswordFormData database_blacklist_with_path = {
       PasswordForm::SCHEME_HTML,
@@ -924,6 +942,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       NULL,
       NULL,
       true,
+      false,
       1212121212};
   PasswordFormData db_android = {PasswordForm::SCHEME_HTML,
                                  "android://hash@com.domain.some/",
@@ -935,6 +954,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                  L"joe_user",
                                  L"",
                                  false,
+                                 true,
                                  1234567890};
   PasswordFormData db_federated = {
       PasswordForm::SCHEME_HTML,
@@ -947,6 +967,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"joe_user",
       password_manager::kTestingFederatedLoginMarker,
       false,
+      true,
       3434343434};
 
   PasswordFormData merged_user_1 = {PasswordForm::SCHEME_HTML,
@@ -959,6 +980,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                     L"joe_user",
                                     L"sekrit",
                                     true,
+                                    false,
                                     1212121212};
   PasswordFormData merged_user_1_with_db_path = {
       PasswordForm::SCHEME_HTML,
@@ -971,6 +993,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"joe_user",
       L"sekrit",
       true,
+      false,
       1234567890};
   PasswordFormData merged_user_1_with_both_paths = {
       PasswordForm::SCHEME_HTML,
@@ -983,6 +1006,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
       L"joe_user",
       L"otherpassword",
       true,
+      false,
       1234567890};
   PasswordFormData merged_android = {PasswordForm::SCHEME_HTML,
                                      "android://hash@com.domain.some/",
@@ -994,6 +1018,7 @@ TEST_F(PasswordStoreMacInternalsTest, TestFormMerge) {
                                      L"joe_user",
                                      L"secret",
                                      false,
+                                     true,
                                      1234567890};
 
   // Build up the big multi-dimensional array of data sets that will actually
@@ -1102,21 +1127,24 @@ TEST_F(PasswordStoreMacInternalsTest, TestPasswordBulkLookup) {
   PasswordFormData db_data[] = {
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
        "http://some.domain.com/", "http://some.domain.com/action.cgi",
-       L"submit", L"username", L"password", L"joe_user", L"", true, 1212121212},
+       L"submit", L"username", L"password", L"joe_user", L"", true, false,
+       1212121212},
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
        "http://some.domain.com/page.html",
        "http://some.domain.com/handlepage.cgi", L"submit", L"username",
-       L"password", L"joe_user", L"", true, 1234567890},
+       L"password", L"joe_user", L"", true, false, 1234567890},
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
        "http://some.domain.com/page.html",
        "http://some.domain.com/handlepage.cgi", L"submit", L"username",
-       L"password", L"second-account", L"", true, 1240000000},
+       L"password", L"second-account", L"", true, false, 1240000000},
       {PasswordForm::SCHEME_HTML, "http://dont.remember.com/",
        "http://dont.remember.com/", "http://dont.remember.com/handlepage.cgi",
-       L"submit", L"username", L"password", L"joe_user", L"", true, 1240000000},
+       L"submit", L"username", L"password", L"joe_user", L"", true, false,
+       1240000000},
       {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
        "http://some.domain.com/path.html", "http://some.domain.com/action.cgi",
-       L"submit", L"username", L"password", NULL, NULL, true, 1212121212},
+       L"submit", L"username", L"password", NULL, NULL, true, false,
+       1212121212},
   };
   ScopedVector<autofill::PasswordForm> database_forms;
   for (unsigned int i = 0; i < arraysize(db_data); ++i) {
@@ -1138,12 +1166,12 @@ TEST_F(PasswordStoreMacInternalsTest, TestBlacklistedFiltering) {
       {PasswordForm::SCHEME_HTML, "http://dont.remember.com/",
        "http://dont.remember.com/", "http://dont.remember.com/handlepage.cgi",
        L"submit", L"username", L"password", L"joe_user", L"non_empty_password",
-       true, 1240000000},
+       true, false, 1240000000},
       {PasswordForm::SCHEME_HTML, "https://dont.remember.com/",
        "https://dont.remember.com/",
        "https://dont.remember.com/handlepage_secure.cgi", L"submit",
        L"username", L"password", L"joe_user", L"non_empty_password", true,
-       1240000000},
+       false, 1240000000},
   };
   ScopedVector<autofill::PasswordForm> database_forms;
   for (unsigned int i = 0; i < arraysize(db_data); ++i) {
@@ -1229,13 +1257,13 @@ TEST_F(PasswordStoreMacInternalsTest, TestPasswordGetAll) {
   PasswordFormData owned_password_data[] = {
       {PasswordForm::SCHEME_HTML, "http://web.site.com/",
        "http://web.site.com/path/to/page.html", NULL, NULL, NULL, NULL,
-       L"anonymous", L"knock-knock", false, 0},
+       L"anonymous", L"knock-knock", false, false, 0},
       {PasswordForm::SCHEME_BASIC, "http://a.site.com:2222/therealm",
        "http://a.site.com:2222/", NULL, NULL, NULL, NULL, L"username",
-       L"password", false, 0},
+       L"password", false, false, 0},
       {PasswordForm::SCHEME_DIGEST, "https://digest.site.com/differentrealm",
        "https://digest.site.com/secure.html", NULL, NULL, NULL, NULL,
-       L"testname", L"testpass", false, 0},
+       L"testname", L"testpass", false, false, 0},
   };
   for (unsigned int i = 0; i < arraysize(owned_password_data); ++i) {
     std::unique_ptr<PasswordForm> form =
@@ -1416,6 +1444,7 @@ TEST_F(PasswordStoreMacTest, TestStoreUpdate) {
                                  L"joe_user",
                                  L"sekrit",
                                  true,
+                                 false,
                                  1};
   std::unique_ptr<PasswordForm> joint_form =
       CreatePasswordFormFromDataForTesting(joint_data);
@@ -1458,7 +1487,7 @@ TEST_F(PasswordStoreMacTest, TestStoreUpdate) {
       {
           {PasswordForm::SCHEME_HTML, "http://some.domain.com/",
            "http://some.domain.com/insecure.html", "login.cgi", L"username",
-           L"password", L"submit", L"joe_user", L"53krit", true, 2},
+           L"password", L"submit", L"joe_user", L"53krit", true, false, 2},
           "53krit",
       },
       // Update the keychain-only password; this simulates the initial use of a
@@ -1466,7 +1495,7 @@ TEST_F(PasswordStoreMacTest, TestStoreUpdate) {
       {
           {PasswordForm::SCHEME_HTML, "http://keychain.only.com/",
            "http://keychain.only.com/login.html", "login.cgi", L"username",
-           L"password", L"submit", L"keychain", L"only", true, 2},
+           L"password", L"submit", L"keychain", L"only", true, false, 2},
           "only",
       },
       // Update a password that doesn't exist in either location. This tests the
@@ -1475,7 +1504,7 @@ TEST_F(PasswordStoreMacTest, TestStoreUpdate) {
       {
           {PasswordForm::SCHEME_HTML, "http://different.com/",
            "http://different.com/index.html", "login.cgi", L"username",
-           L"password", L"submit", L"abc", L"123", true, 2},
+           L"password", L"submit", L"abc", L"123", true, false, 2},
           NULL,
       },
   };
@@ -1538,6 +1567,7 @@ TEST_F(PasswordStoreMacTest, TestDBKeychainAssociation) {
                                     L"joe_user",
                                     L"sekrit",
                                     true,
+                                    false,
                                     1};
   std::unique_ptr<PasswordForm> www_form =
       CreatePasswordFormFromDataForTesting(www_form_data);
@@ -1630,6 +1660,7 @@ void CheckRemoveLoginsBetween(PasswordStoreMacTest* test, bool check_created) {
       L"joe_user",
       L"sekrit",
       true,
+      false,
       0};
   // The old form doesn't have elements names.
   PasswordFormData www_form_data_facebook_old = {
@@ -1643,6 +1674,7 @@ void CheckRemoveLoginsBetween(PasswordStoreMacTest* test, bool check_created) {
       L"joe_user",
       L"oldsekrit",
       true,
+      false,
       0};
   PasswordFormData www_form_data_other = {PasswordForm::SCHEME_HTML,
                                           "http://different.com/",
@@ -1654,6 +1686,7 @@ void CheckRemoveLoginsBetween(PasswordStoreMacTest* test, bool check_created) {
                                           L"different_joe_user",
                                           L"sekrit",
                                           true,
+                                          false,
                                           0};
   std::unique_ptr<PasswordForm> form_facebook =
       CreatePasswordFormFromDataForTesting(www_form_data_facebook);
@@ -1757,6 +1790,7 @@ TEST_F(PasswordStoreMacTest, TestDisableAutoSignInForOrigins) {
       L"joe_user",
       L"sekrit",
       true,
+      false,
       0};
   std::unique_ptr<PasswordForm> form_facebook =
       CreatePasswordFormFromDataForTesting(www_form_data_facebook);
@@ -1773,6 +1807,7 @@ TEST_F(PasswordStoreMacTest, TestDisableAutoSignInForOrigins) {
       L"joe_user",
       L"sekrit",
       true,
+      false,
       0};
   std::unique_ptr<PasswordForm> form_google =
       CreatePasswordFormFromDataForTesting(www_form_data_google);
@@ -1834,6 +1869,7 @@ TEST_F(PasswordStoreMacTest, TestRemoveLoginsMultiProfile) {
                                      L"joe_user",
                                      L"sekrit",
                                      true,
+                                     false,
                                      1};
   std::unique_ptr<PasswordForm> www_form =
       CreatePasswordFormFromDataForTesting(www_form_data1);
@@ -1850,6 +1886,7 @@ TEST_F(PasswordStoreMacTest, TestRemoveLoginsMultiProfile) {
                                      L"not_joe_user",
                                      L"12345",
                                      true,
+                                     false,
                                      1};
   www_form = CreatePasswordFormFromDataForTesting(www_form_data2);
   store_->AddLogin(*www_form);
@@ -1899,6 +1936,7 @@ TEST_F(PasswordStoreMacTest, SilentlyRemoveOrphanedForm) {
                                     L"joe_user",
                                     L"",
                                     true,
+                                    false,
                                     1};
   std::unique_ptr<PasswordForm> www_form(
       CreatePasswordFormFromDataForTesting(www_form_data));
diff --git a/chrome/browser/password_manager/password_store_proxy_mac_unittest.cc b/chrome/browser/password_manager/password_store_proxy_mac_unittest.cc
index 8837d06..ee1bac1 100644
--- a/chrome/browser/password_manager/password_store_proxy_mac_unittest.cc
+++ b/chrome/browser/password_manager/password_store_proxy_mac_unittest.cc
@@ -359,6 +359,7 @@ TEST_P(PasswordStoreProxyMacTest, OperationsOnABadDatabaseSilentlyFail) {
       L"not_joe_user",
       L"12345",
       true,
+      false,
       1};
   std::unique_ptr<PasswordForm> form =
       CreatePasswordFormFromDataForTesting(www_form_data);
diff --git a/chrome/browser/password_manager/password_store_win.cc b/chrome/browser/password_manager/password_store_win.cc
index a19dbf9..277fa66 100644
--- a/chrome/browser/password_manager/password_store_win.cc
+++ b/chrome/browser/password_manager/password_store_win.cc
@@ -129,6 +129,7 @@ ScopedVector<autofill::PasswordForm> PasswordStoreWin::DBHandler::GetIE7Results(
         autofill->signon_realm = form.signon_realm;
         autofill->origin = form.origin;
         autofill->preferred = true;
+        autofill->ssl_valid = form.origin.SchemeIsCryptographic();
         autofill->date_created = info.date_created;
 
         matched_forms.push_back(autofill);
diff --git a/chrome/browser/password_manager/password_store_win_unittest.cc b/chrome/browser/password_manager/password_store_win_unittest.cc
index 4978184..2185a5e 100644
--- a/chrome/browser/password_manager/password_store_win_unittest.cc
+++ b/chrome/browser/password_manager/password_store_win_unittest.cc
@@ -244,6 +244,7 @@ TEST_F(PasswordStoreWinTest, DISABLED_ConvertIE7Login) {
       L"",
       L"",
       true,
+      false,
       1,
   };
   std::unique_ptr<PasswordForm> form =
@@ -262,6 +263,7 @@ TEST_F(PasswordStoreWinTest, DISABLED_ConvertIE7Login) {
       L"abcdefgh",
       L"abcdefghijkl",
       true,
+      false,
       1,
   };
   ScopedVector<autofill::PasswordForm> expected_forms;
@@ -292,6 +294,7 @@ TEST_F(PasswordStoreWinTest, OutstandingWDSQueries) {
       L"",
       L"",
       true,
+      false,
       1,
   };
   std::unique_ptr<PasswordForm> form =
@@ -347,6 +350,7 @@ TEST_F(PasswordStoreWinTest, DISABLED_MultipleWDSQueriesOnDifferentThreads) {
       L"",
       L"",
       true,
+      false,
       1,
   };
   std::unique_ptr<PasswordForm> form =
@@ -363,6 +367,7 @@ TEST_F(PasswordStoreWinTest, DISABLED_MultipleWDSQueriesOnDifferentThreads) {
       L"abcdefgh",
       L"abcdefghijkl",
       true,
+      false,
       1,
   };
   ScopedVector<autofill::PasswordForm> expected_forms;
@@ -405,6 +410,7 @@ TEST_F(PasswordStoreWinTest, EmptyLogins) {
       L"",
       L"",
       true,
+      false,
       1,
   };
   std::unique_ptr<PasswordForm> form =
diff --git a/chrome/browser/password_manager/password_store_x_unittest.cc b/chrome/browser/password_manager/password_store_x_unittest.cc
index 56382b8..2f26468 100644
--- a/chrome/browser/password_manager/password_store_x_unittest.cc
+++ b/chrome/browser/password_manager/password_store_x_unittest.cc
@@ -277,6 +277,7 @@ void InitExpectedForms(bool autofillable,
         autofillable ? L"username_value" : nullptr,
         autofillable ? L"password_value" : nullptr,
         autofillable,
+        false,
         static_cast<double>(i + 1)};
     forms->push_back(CreatePasswordFormFromDataForTesting(data));
   }
@@ -411,17 +412,12 @@ TEST_P(PasswordStoreXTest, Notifications) {
   store->Init(syncer::SyncableService::StartSyncFlare());
 
   password_manager::PasswordFormData form_data = {
-      PasswordForm::SCHEME_HTML,
-      "http://bar.example.com",
-      "http://bar.example.com/origin",
-      "http://bar.example.com/action",
-      L"submit_element",
-      L"username_element",
-      L"password_element",
-      L"username_value",
-      L"password_value",
-      true,
-      1};
+      PasswordForm::SCHEME_HTML,       "http://bar.example.com",
+      "http://bar.example.com/origin", "http://bar.example.com/action",
+      L"submit_element",               L"username_element",
+      L"password_element",             L"username_value",
+      L"password_value",               true,
+      false,                           1};
   std::unique_ptr<PasswordForm> form =
       CreatePasswordFormFromDataForTesting(form_data);
 
diff --git a/chrome/browser/password_manager/save_password_infobar_delegate_android_unittest.cc b/chrome/browser/password_manager/save_password_infobar_delegate_android_unittest.cc
index d724e74..ad2e76f 100644
--- a/chrome/browser/password_manager/save_password_infobar_delegate_android_unittest.cc
+++ b/chrome/browser/password_manager/save_password_infobar_delegate_android_unittest.cc
@@ -40,6 +40,7 @@ class MockPasswordFormManager : public password_manager::PasswordFormManager {
             client,
             driver,
             form,
+            false,
             base::WrapUnique(new password_manager::StubFormSaver)) {}
 
   ~MockPasswordFormManager() override {}
diff --git a/chrome/browser/permissions/permission_bubble_request_impl.cc b/chrome/browser/permissions/permission_bubble_request_impl.cc
index 2001775..e2389b1 100644
--- a/chrome/browser/permissions/permission_bubble_request_impl.cc
+++ b/chrome/browser/permissions/permission_bubble_request_impl.cc
@@ -29,7 +29,9 @@ PermissionBubbleRequestImpl::PermissionBubbleRequestImpl(
 PermissionBubbleRequestImpl::~PermissionBubbleRequestImpl() {
   DCHECK(is_finished_);
   if (!action_taken_)
-    PermissionUmaUtil::PermissionIgnored(permission_type_, request_origin_);
+    // TODO(stefanocs): Pass in a non null profile.
+    PermissionUmaUtil::PermissionIgnored(permission_type_, request_origin_,
+                                         nullptr);
 }
 
 gfx::VectorIconId PermissionBubbleRequestImpl::GetVectorIconId() const {
diff --git a/chrome/browser/permissions/permission_context_base.cc b/chrome/browser/permissions/permission_context_base.cc
index 5b8d602..802cb50 100644
--- a/chrome/browser/permissions/permission_context_base.cc
+++ b/chrome/browser/permissions/permission_context_base.cc
@@ -216,12 +216,15 @@ void PermissionContextBase::PermissionDecided(
     DCHECK(content_setting == CONTENT_SETTING_ALLOW ||
            content_setting == CONTENT_SETTING_BLOCK);
     if (content_setting == CONTENT_SETTING_ALLOW)
-      PermissionUmaUtil::PermissionGranted(permission_type_, requesting_origin);
+      PermissionUmaUtil::PermissionGranted(permission_type_, requesting_origin,
+                                           profile_);
     else
-      PermissionUmaUtil::PermissionDenied(permission_type_, requesting_origin);
+      PermissionUmaUtil::PermissionDenied(permission_type_, requesting_origin,
+                                          profile_);
   } else {
     DCHECK_EQ(content_setting, CONTENT_SETTING_DEFAULT);
-    PermissionUmaUtil::PermissionDismissed(permission_type_, requesting_origin);
+    PermissionUmaUtil::PermissionDismissed(permission_type_, requesting_origin,
+                                           profile_);
   }
 #endif
 
diff --git a/chrome/browser/permissions/permission_infobar_delegate.cc b/chrome/browser/permissions/permission_infobar_delegate.cc
index 14a9f5d..32cea3d 100644
--- a/chrome/browser/permissions/permission_infobar_delegate.cc
+++ b/chrome/browser/permissions/permission_infobar_delegate.cc
@@ -12,7 +12,9 @@
 
 PermissionInfobarDelegate::~PermissionInfobarDelegate() {
   if (!action_taken_)
-    PermissionUmaUtil::PermissionIgnored(permission_type_, requesting_origin_);
+    // TODO(stefanocs): Pass in a non null profile.
+    PermissionUmaUtil::PermissionIgnored(permission_type_, requesting_origin_,
+                                         nullptr);
 }
 
 PermissionInfobarDelegate::PermissionInfobarDelegate(
diff --git a/chrome/browser/permissions/permission_queue_controller.cc b/chrome/browser/permissions/permission_queue_controller.cc
index 76e1a6d..5f6bbfc 100644
--- a/chrome/browser/permissions/permission_queue_controller.cc
+++ b/chrome/browser/permissions/permission_queue_controller.cc
@@ -205,11 +205,14 @@ void PermissionQueueController::OnPermissionSet(
   if (update_content_setting) {
     UpdateContentSetting(requesting_frame, embedder, allowed);
     if (allowed)
-      PermissionUmaUtil::PermissionGranted(permission_type_, requesting_frame);
+      PermissionUmaUtil::PermissionGranted(permission_type_, requesting_frame,
+                                           profile_);
     else
-      PermissionUmaUtil::PermissionDenied(permission_type_, requesting_frame);
+      PermissionUmaUtil::PermissionDenied(permission_type_, requesting_frame,
+                                          profile_);
   } else {
-    PermissionUmaUtil::PermissionDismissed(permission_type_, requesting_frame);
+    PermissionUmaUtil::PermissionDismissed(permission_type_, requesting_frame,
+                                           profile_);
   }
 
   // Cancel this request first, then notify listeners.  TODO(pkasting): Why
diff --git a/chrome/browser/permissions/permission_uma_util.cc b/chrome/browser/permissions/permission_uma_util.cc
index efbdf5f..70324dd 100644
--- a/chrome/browser/permissions/permission_uma_util.cc
+++ b/chrome/browser/permissions/permission_uma_util.cc
@@ -6,13 +6,21 @@
 
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/stringprintf.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/permissions/permission_manager.h"
 #include "chrome/browser/permissions/permission_util.h"
 #include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/safe_browsing/safe_browsing_service.h"
+#include "chrome/browser/safe_browsing/ui_manager.h"
+#include "chrome/browser/sync/profile_sync_service_factory.h"
 #include "chrome/browser/ui/website_settings/permission_bubble_request.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "components/browser_sync/browser/profile_sync_service.h"
+#include "components/prefs/pref_service.h"
 #include "components/rappor/rappor_service.h"
 #include "components/rappor/rappor_utils.h"
 #include "content/public/browser/permission_type.h"
@@ -74,99 +82,6 @@ const std::string GetRapporMetric(PermissionType permission,
                             permission_str.c_str(), action_str.c_str());
 }
 
-void RecordPermissionAction(PermissionType permission,
-                            PermissionAction action,
-                            const GURL& requesting_origin) {
-  bool secure_origin = content::IsOriginSecure(requesting_origin);
-
-  switch (permission) {
-    case PermissionType::GEOLOCATION:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.Geolocation",
-            "Permissions.Action.SecureOrigin.Geolocation",
-            "Permissions.Action.InsecureOrigin.Geolocation",
-            action);
-        break;
-    case PermissionType::NOTIFICATIONS:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.Notifications",
-            "Permissions.Action.SecureOrigin.Notifications",
-            "Permissions.Action.InsecureOrigin.Notifications",
-            action);
-        break;
-    case PermissionType::MIDI_SYSEX:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.MidiSysEx",
-            "Permissions.Action.SecureOrigin.MidiSysEx",
-            "Permissions.Action.InsecureOrigin.MidiSysEx",
-            action);
-        break;
-    case PermissionType::PUSH_MESSAGING:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.PushMessaging",
-            "Permissions.Action.SecureOrigin.PushMessaging",
-            "Permissions.Action.InsecureOrigin.PushMessaging",
-            action);
-        break;
-    case PermissionType::PROTECTED_MEDIA_IDENTIFIER:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.ProtectedMedia",
-            "Permissions.Action.SecureOrigin.ProtectedMedia",
-            "Permissions.Action.InsecureOrigin.ProtectedMedia",
-            action);
-        break;
-    case PermissionType::DURABLE_STORAGE:
-        PERMISSION_ACTION_UMA(
-            secure_origin,
-            "Permissions.Action.DurableStorage",
-            "Permissions.Action.SecureOrigin.DurableStorage",
-            "Permissions.Action.InsecureOrigin.DurableStorage",
-            action);
-        break;
-    case PermissionType::AUDIO_CAPTURE:
-        // Media permissions are disabled on insecure origins, so there's no
-        // need to record metrics for secure/insecue.
-        UMA_HISTOGRAM_ENUMERATION("Permissions.Action.AudioCapture", action,
-                                  PERMISSION_ACTION_NUM);
-        break;
-    case PermissionType::VIDEO_CAPTURE:
-        UMA_HISTOGRAM_ENUMERATION("Permissions.Action.VideoCapture", action,
-                                  PERMISSION_ACTION_NUM);
-        break;
-    // The user is not prompted for these permissions, thus there is no
-    // permission action recorded for them.
-    case PermissionType::MIDI:
-    case PermissionType::BACKGROUND_SYNC:
-    case PermissionType::NUM:
-      NOTREACHED() << "PERMISSION "
-                   << PermissionUtil::GetPermissionString(permission)
-                   << " not accounted for";
-  }
-
-  // Retrieve the name of the RAPPOR metric. Currently, the new metric name is
-  // the deprecated name with "2" on the end, e.g.
-  // ContentSettings.PermissionActions_Geolocation.Granted.Url2. For simplicity,
-  // we retrieve the deprecated name and append the "2" for the new name.
-  // TODO(dominickn): remove the deprecated metric and replace it solely with
-  // the new one in GetRapporMetric - crbug.com/605836.
-  const std::string deprecated_metric = GetRapporMetric(permission, action);
-  rappor::RapporService* rappor_service = g_browser_process->rappor_service();
-  if (!deprecated_metric.empty() && rappor_service) {
-    rappor::SampleDomainAndRegistryFromGURL(rappor_service, deprecated_metric,
-                                            requesting_origin);
-
-    std::string rappor_metric = deprecated_metric + "2";
-    rappor_service->RecordSample(
-        rappor_metric, rappor::LOW_FREQUENCY_ETLD_PLUS_ONE_RAPPOR_TYPE,
-        rappor::GetDomainAndRegistrySampleFromGURL(requesting_origin));
-  }
-}
-
 void RecordPermissionRequest(PermissionType permission,
                              const GURL& requesting_origin,
                              const GURL& embedding_origin,
@@ -280,34 +195,39 @@ void PermissionUmaUtil::PermissionRequested(PermissionType permission,
 }
 
 void PermissionUmaUtil::PermissionGranted(PermissionType permission,
-                                          const GURL& requesting_origin) {
-  RecordPermissionAction(permission, GRANTED, requesting_origin);
+                                          const GURL& requesting_origin,
+                                          Profile* profile) {
+  RecordPermissionAction(permission, GRANTED, requesting_origin, profile);
 }
 
 void PermissionUmaUtil::PermissionDenied(PermissionType permission,
-                                         const GURL& requesting_origin) {
-  RecordPermissionAction(permission, DENIED, requesting_origin);
+                                         const GURL& requesting_origin,
+                                         Profile* profile) {
+  RecordPermissionAction(permission, DENIED, requesting_origin, profile);
 }
 
 void PermissionUmaUtil::PermissionDismissed(PermissionType permission,
-                                            const GURL& requesting_origin) {
-  RecordPermissionAction(permission, DISMISSED, requesting_origin);
+                                            const GURL& requesting_origin,
+                                            Profile* profile) {
+  RecordPermissionAction(permission, DISMISSED, requesting_origin, profile);
 }
 
 void PermissionUmaUtil::PermissionIgnored(PermissionType permission,
-                                          const GURL& requesting_origin) {
-  RecordPermissionAction(permission, IGNORED, requesting_origin);
+                                          const GURL& requesting_origin,
+                                          Profile* profile) {
+  RecordPermissionAction(permission, IGNORED, requesting_origin, profile);
 }
 
 void PermissionUmaUtil::PermissionRevoked(PermissionType permission,
-                                          const GURL& revoked_origin) {
+                                          const GURL& revoked_origin,
+                                          Profile* profile) {
   // TODO(tsergeant): Expand metrics definitions for revocation to include all
   // permissions.
   if (permission == PermissionType::NOTIFICATIONS ||
       permission == PermissionType::GEOLOCATION ||
       permission == PermissionType::AUDIO_CAPTURE ||
       permission == PermissionType::VIDEO_CAPTURE) {
-    RecordPermissionAction(permission, REVOKED, revoked_origin);
+    RecordPermissionAction(permission, REVOKED, revoked_origin, profile);
   }
 }
 
@@ -374,3 +294,127 @@ void PermissionUmaUtil::PermissionPromptDenied(
   PERMISSION_BUBBLE_TYPE_UMA(kPermissionsPromptDenied,
                              requests[0]->GetPermissionBubbleType());
 }
+
+bool PermissionUmaUtil::IsOptedIntoPermissionActionReporting(Profile* profile) {
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnablePermissionActionReporting))
+    return false;
+  // TODO(stefanocs): Remove this check once all callsites have been updated
+  // to not pass a nullptr.
+  if (!profile)
+    return false;
+  if (profile->GetProfileType() == Profile::INCOGNITO_PROFILE)
+    return false;
+  if (!profile->GetPrefs()->GetBoolean(prefs::kSafeBrowsingEnabled))
+    return false;
+
+  ProfileSyncService* profile_sync_service =
+      ProfileSyncServiceFactory::GetForProfile(profile);
+
+  // Do not report if profile can't get a profile sync service due to disable
+  // sync flag.
+  if (!profile_sync_service)
+    return false;
+
+  if (!profile_sync_service->CanSyncStart())
+    return false;
+
+  syncer::ModelTypeSet preferred_data_types =
+      profile_sync_service->GetPreferredDataTypes();
+  if (!preferred_data_types.Has(syncer::PROXY_TABS))
+    return false;
+  if (!preferred_data_types.Has(syncer::PRIORITY_PREFERENCES))
+    return false;
+
+  return true;
+}
+
+void PermissionUmaUtil::RecordPermissionAction(PermissionType permission,
+                                               PermissionAction action,
+                                               const GURL& requesting_origin,
+                                               Profile* profile) {
+  if (IsOptedIntoPermissionActionReporting(profile)) {
+    // TODO(stefanocs): Add browsertests to make sure the reports are being
+    // sent.
+    g_browser_process->safe_browsing_service()
+        ->ui_manager()
+        ->ReportPermissionAction(requesting_origin, permission, action);
+  }
+
+  bool secure_origin = content::IsOriginSecure(requesting_origin);
+
+  switch (permission) {
+    case PermissionType::GEOLOCATION:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.Geolocation",
+                            "Permissions.Action.SecureOrigin.Geolocation",
+                            "Permissions.Action.InsecureOrigin.Geolocation",
+                            action);
+      break;
+    case PermissionType::NOTIFICATIONS:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.Notifications",
+                            "Permissions.Action.SecureOrigin.Notifications",
+                            "Permissions.Action.InsecureOrigin.Notifications",
+                            action);
+      break;
+    case PermissionType::MIDI_SYSEX:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.MidiSysEx",
+                            "Permissions.Action.SecureOrigin.MidiSysEx",
+                            "Permissions.Action.InsecureOrigin.MidiSysEx",
+                            action);
+      break;
+    case PermissionType::PUSH_MESSAGING:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.PushMessaging",
+                            "Permissions.Action.SecureOrigin.PushMessaging",
+                            "Permissions.Action.InsecureOrigin.PushMessaging",
+                            action);
+      break;
+    case PermissionType::PROTECTED_MEDIA_IDENTIFIER:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.ProtectedMedia",
+                            "Permissions.Action.SecureOrigin.ProtectedMedia",
+                            "Permissions.Action.InsecureOrigin.ProtectedMedia",
+                            action);
+      break;
+    case PermissionType::DURABLE_STORAGE:
+      PERMISSION_ACTION_UMA(secure_origin, "Permissions.Action.DurableStorage",
+                            "Permissions.Action.SecureOrigin.DurableStorage",
+                            "Permissions.Action.InsecureOrigin.DurableStorage",
+                            action);
+      break;
+    case PermissionType::AUDIO_CAPTURE:
+      // Media permissions are disabled on insecure origins, so there's no
+      // need to record metrics for secure/insecue.
+      UMA_HISTOGRAM_ENUMERATION("Permissions.Action.AudioCapture", action,
+                                PERMISSION_ACTION_NUM);
+      break;
+    case PermissionType::VIDEO_CAPTURE:
+      UMA_HISTOGRAM_ENUMERATION("Permissions.Action.VideoCapture", action,
+                                PERMISSION_ACTION_NUM);
+      break;
+    // The user is not prompted for these permissions, thus there is no
+    // permission action recorded for them.
+    case PermissionType::MIDI:
+    case PermissionType::BACKGROUND_SYNC:
+    case PermissionType::NUM:
+      NOTREACHED() << "PERMISSION "
+                   << PermissionUtil::GetPermissionString(permission)
+                   << " not accounted for";
+  }
+
+  // Retrieve the name of the RAPPOR metric. Currently, the new metric name is
+  // the deprecated name with "2" on the end, e.g.
+  // ContentSettings.PermissionActions_Geolocation.Granted.Url2. For simplicity,
+  // we retrieve the deprecated name and append the "2" for the new name.
+  // TODO(dominickn): remove the deprecated metric and replace it solely with
+  // the new one in GetRapporMetric - crbug.com/605836.
+  const std::string deprecated_metric = GetRapporMetric(permission, action);
+  rappor::RapporService* rappor_service = g_browser_process->rappor_service();
+  if (!deprecated_metric.empty() && rappor_service) {
+    rappor::SampleDomainAndRegistryFromGURL(rappor_service, deprecated_metric,
+                                            requesting_origin);
+
+    std::string rappor_metric = deprecated_metric + "2";
+    rappor_service->RecordSample(
+        rappor_metric, rappor::LOW_FREQUENCY_ETLD_PLUS_ONE_RAPPOR_TYPE,
+        rappor::GetDomainAndRegistrySampleFromGURL(requesting_origin));
+  }
+}
diff --git a/chrome/browser/permissions/permission_uma_util.h b/chrome/browser/permissions/permission_uma_util.h
index f163617..0d7c771 100644
--- a/chrome/browser/permissions/permission_uma_util.h
+++ b/chrome/browser/permissions/permission_uma_util.h
@@ -51,15 +51,20 @@ class PermissionUmaUtil {
                                   const GURL& embedding_origin,
                                   Profile* profile);
   static void PermissionGranted(content::PermissionType permission,
-                                const GURL& requesting_origin);
+                                const GURL& requesting_origin,
+                                Profile* profile);
   static void PermissionDenied(content::PermissionType permission,
-                               const GURL& requesting_origin);
+                               const GURL& requesting_origin,
+                               Profile* profile);
   static void PermissionDismissed(content::PermissionType permission,
-                                  const GURL& requesting_origin);
+                                  const GURL& requesting_origin,
+                                  Profile* profile);
   static void PermissionIgnored(content::PermissionType permission,
-                                const GURL& requesting_origin);
+                                const GURL& requesting_origin,
+                                Profile* profile);
   static void PermissionRevoked(content::PermissionType permission,
-                                const GURL& revoked_origin);
+                                const GURL& revoked_origin,
+                                Profile* profile);
 
   // UMA specifically for when permission prompts are shown. This should be
   // roughly equivalent to the metrics above, however it is
@@ -86,7 +91,16 @@ class PermissionUmaUtil {
       const std::vector<PermissionBubbleRequest*>& requests);
 
  private:
+  friend class PermissionUmaUtilTest;
+
   DISALLOW_IMPLICIT_CONSTRUCTORS(PermissionUmaUtil);
+
+  static bool IsOptedIntoPermissionActionReporting(Profile* profile);
+
+  static void RecordPermissionAction(content::PermissionType permission,
+                                     PermissionAction action,
+                                     const GURL& requesting_origin,
+                                     Profile* profile);
 };
 
 #endif  // CHROME_BROWSER_PERMISSIONS_PERMISSION_UMA_UTIL_H_
diff --git a/chrome/browser/permissions/permission_uma_util_unittest.cc b/chrome/browser/permissions/permission_uma_util_unittest.cc
new file mode 100644
index 0000000..4921fce
--- /dev/null
+++ b/chrome/browser/permissions/permission_uma_util_unittest.cc
@@ -0,0 +1,161 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/permissions/permission_uma_util.h"
+
+#include "base/command_line.h"
+#include "chrome/browser/signin/fake_signin_manager_builder.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/sync/profile_sync_service_factory.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/test/base/testing_profile.h"
+#include "components/browser_sync/browser/profile_sync_service.h"
+#include "components/browser_sync/common/browser_sync_switches.h"
+#include "components/prefs/pref_service.h"
+#include "components/sync_driver/glue/sync_backend_host_mock.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "sync/internal_api/public/base/model_type.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace {
+const char* kTestingGaiaId = "gaia_id";
+const char* kTestingUsername = "fake_username";
+}  // namespace
+
+class PermissionUmaUtilTest : public testing::Test {
+ protected:
+  PermissionUmaUtilTest() : profile_(new TestingProfile()) {}
+
+  static bool IsOptedIntoPermissionActionReporting(Profile* profile) {
+    return PermissionUmaUtil::IsOptedIntoPermissionActionReporting(profile);
+  }
+
+  void SetUp() override {
+    profile_.reset(new TestingProfile());
+    ResetCommandLine();
+  }
+
+  void FakeSignIn() {
+    SigninManagerBase* signin_manager =
+        static_cast<FakeSigninManagerForTesting*>(
+            SigninManagerFactory::GetForProfile(profile()));
+    signin_manager->SetAuthenticatedAccountInfo(kTestingGaiaId,
+                                                kTestingUsername);
+    // Attach a sync backend to the profile sync service.
+    GetProfileSyncService()->backend_.reset(
+        new browser_sync::SyncBackendHostMock());
+    GetProfileSyncService()->backend_initialized_ = true;
+  }
+
+  void ResetCommandLine() {
+    base::CommandLine::Reset();
+    base::CommandLine::Init(0, NULL);
+  }
+
+  void SetKeepEverythingSynced(bool flag) {
+    GetProfileSyncService()->sync_prefs_.SetKeepEverythingSynced(flag);
+  }
+
+  void SetSafeBrowsing(bool enabled) {
+    PrefService* preferences = profile_->GetPrefs();
+    preferences->SetBoolean(prefs::kSafeBrowsingEnabled, enabled);
+  }
+
+  ProfileSyncService* GetProfileSyncService() {
+    return ProfileSyncServiceFactory::GetForProfile(profile());
+  }
+
+  Profile* profile() { return profile_.get(); }
+
+ private:
+  content::TestBrowserThreadBundle thread_bundle_;
+  std::unique_ptr<Profile> profile_;
+};
+
+// Test that PermissionUmaUtil::IsOptedIntoPermissionActionReporting returns
+// true if Safe Browsing is enabled, Permission Action Reporting flag is
+// enabled, not in incognito mode and signed in with default sync preferences.
+TEST_F(PermissionUmaUtilTest, IsOptedIntoPermissionActionReportingSignInCheck) {
+  SetSafeBrowsing(true);
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kEnablePermissionActionReporting);
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+
+  FakeSignIn();
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(
+      profile()->GetOffTheRecordProfile()));
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+}
+
+// Test that PermissionUmaUtil::IsOptedIntoPermissionActionReporting returns
+// false if Permission Action Reporting is not enabled.
+TEST_F(PermissionUmaUtilTest, IsOptedIntoPermissionActionReportingFlagCheck) {
+  SetSafeBrowsing(true);
+  FakeSignIn();
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kEnablePermissionActionReporting);
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+
+  ResetCommandLine();
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kDisablePermissionActionReporting);
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+}
+
+// Test that PermissionUmaUtil::IsOptedIntoPermissionActionReporting returns
+// false if Safe Browsing is disabled.
+TEST_F(PermissionUmaUtilTest,
+       IsOptedIntoPermissionActionReportingSafeBrowsingCheck) {
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kEnablePermissionActionReporting);
+  FakeSignIn();
+  SetSafeBrowsing(true);
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+
+  SetSafeBrowsing(false);
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+}
+
+// Test that PermissionUmaUtil::IsOptedIntoPermissionActionReporting returns
+// false if Sync is disabled.
+TEST_F(PermissionUmaUtilTest,
+       IsOptedIntoPermissionActionReportingProfileSyncServiceCheck) {
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kEnablePermissionActionReporting);
+  SetSafeBrowsing(true);
+  FakeSignIn();
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(switches::kDisableSync);
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+}
+
+// Test that PermissionUmaUtil::IsOptedIntoPermissionActionReporting returns
+// false if Tab Sync and Pref Sync are not both enabled.
+TEST_F(PermissionUmaUtilTest,
+       IsOptedIntoPermissionActionReportingSyncPreferenceCheck) {
+  base::CommandLine::ForCurrentProcess()->AppendSwitch(
+      switches::kEnablePermissionActionReporting);
+  SetSafeBrowsing(true);
+  FakeSignIn();
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+
+  SetKeepEverythingSynced(false);
+  GetProfileSyncService()->ChangePreferredDataTypes(
+      syncer::ModelTypeSet(syncer::PROXY_TABS));
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+
+  SetKeepEverythingSynced(false);
+  GetProfileSyncService()->ChangePreferredDataTypes(
+      syncer::ModelTypeSet(syncer::PRIORITY_PREFERENCES));
+  EXPECT_FALSE(IsOptedIntoPermissionActionReporting(profile()));
+
+  SetKeepEverythingSynced(true);
+  GetProfileSyncService()->ChangePreferredDataTypes(
+      syncer::ModelTypeSet(syncer::PROXY_TABS, syncer::PREFERENCES));
+  EXPECT_TRUE(IsOptedIntoPermissionActionReporting(profile()));
+}
diff --git a/chrome/browser/permissions/permission_util.cc b/chrome/browser/permissions/permission_util.cc
index 8749ac4..78271a2 100644
--- a/chrome/browser/permissions/permission_util.cc
+++ b/chrome/browser/permissions/permission_util.cc
@@ -100,7 +100,8 @@ void PermissionUtil::SetContentSettingAndRecordRevocation(
       final_value != CONTENT_SETTING_ALLOW) {
     PermissionType permission_type;
     if (PermissionUtil::GetPermissionType(content_type, &permission_type)) {
-      PermissionUmaUtil::PermissionRevoked(permission_type, primary_url);
+      PermissionUmaUtil::PermissionRevoked(permission_type, primary_url,
+                                           profile);
     }
   }
 }
diff --git a/chrome/browser/profiles/profile_manager_browsertest.cc b/chrome/browser/profiles/profile_manager_browsertest.cc
index c21fc6b..06f06dc 100644
--- a/chrome/browser/profiles/profile_manager_browsertest.cc
+++ b/chrome/browser/profiles/profile_manager_browsertest.cc
@@ -427,6 +427,7 @@ IN_PROC_BROWSER_TEST_F(ProfileManagerBrowserTest, DeletePasswords) {
   form.signon_realm = "http://accounts.google.com/";
   form.username_value = base::ASCIIToUTF16("my_username");
   form.password_value = base::ASCIIToUTF16("my_password");
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = false;
 
diff --git a/chrome/browser/push_messaging/push_messaging_permission_context.cc b/chrome/browser/push_messaging/push_messaging_permission_context.cc
index a7a786f..c7ae175 100644
--- a/chrome/browser/push_messaging/push_messaging_permission_context.cc
+++ b/chrome/browser/push_messaging/push_messaging_permission_context.cc
@@ -118,7 +118,8 @@ void PushMessagingPermissionContext::DecidePushPermission(
 
   if (push_content_setting == CONTENT_SETTING_BLOCK) {
     DVLOG(1) << "Push permission was explicitly blocked.";
-    PermissionUmaUtil::PermissionDenied(permission_type(), requesting_origin);
+    PermissionUmaUtil::PermissionDenied(permission_type(), requesting_origin,
+                                        profile_);
     NotifyPermissionSet(id, requesting_origin, embedding_origin, callback,
                         true /* persist */, CONTENT_SETTING_BLOCK);
     return;
@@ -131,7 +132,8 @@ void PushMessagingPermissionContext::DecidePushPermission(
     return;
   }
 
-  PermissionUmaUtil::PermissionGranted(permission_type(), requesting_origin);
+  PermissionUmaUtil::PermissionGranted(permission_type(), requesting_origin,
+                                       profile_);
   NotifyPermissionSet(id, requesting_origin, embedding_origin, callback,
                       true /* persist */, CONTENT_SETTING_ALLOW);
 }
diff --git a/chrome/browser/safe_browsing/ping_manager.cc b/chrome/browser/safe_browsing/ping_manager.cc
index 7c2ebb3..f75ed23 100644
--- a/chrome/browser/safe_browsing/ping_manager.cc
+++ b/chrome/browser/safe_browsing/ping_manager.cc
@@ -11,6 +11,7 @@
 #include "base/stl_util.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
+#include "chrome/browser/safe_browsing/permission_reporter.h"
 #include "components/certificate_reporting/error_reporter.h"
 #include "content/public/browser/browser_thread.h"
 #include "google_apis/google_api_keys.h"
@@ -64,6 +65,9 @@ SafeBrowsingPingManager::SafeBrowsingPingManager(
     certificate_error_reporter_.reset(new certificate_reporting::ErrorReporter(
         request_context_getter->GetURLRequestContext(), certificate_upload_url,
         cookies_preference));
+
+    permission_reporter_.reset(
+        new PermissionReporter(request_context_getter->GetURLRequestContext()));
   }
 
   version_ = SafeBrowsingProtocolManagerHelper::Version();
@@ -131,6 +135,13 @@ void SafeBrowsingPingManager::SetCertificateErrorReporterForTesting(
   certificate_error_reporter_ = std::move(certificate_error_reporter);
 }
 
+void SafeBrowsingPingManager::ReportPermissionAction(
+    const GURL& origin,
+    content::PermissionType permission,
+    PermissionAction action) {
+  permission_reporter_->SendReport(origin, permission, action);
+}
+
 GURL SafeBrowsingPingManager::SafeBrowsingHitUrl(
     const safe_browsing::HitReport& hit_report) const {
   DCHECK(hit_report.threat_type == SB_THREAT_TYPE_URL_MALWARE ||
diff --git a/chrome/browser/safe_browsing/ping_manager.h b/chrome/browser/safe_browsing/ping_manager.h
index 057f848..f07252c 100644
--- a/chrome/browser/safe_browsing/ping_manager.h
+++ b/chrome/browser/safe_browsing/ping_manager.h
@@ -14,9 +14,11 @@
 
 #include "base/gtest_prod_util.h"
 #include "base/macros.h"
+#include "chrome/browser/permissions/permission_uma_util.h"
 #include "chrome/browser/safe_browsing/protocol_manager_helper.h"
 #include "components/safe_browsing_db/hit_report.h"
 #include "components/safe_browsing_db/util.h"
+#include "content/public/browser/permission_type.h"
 #include "net/url_request/url_fetcher_delegate.h"
 #include "url/gurl.h"
 
@@ -31,6 +33,8 @@ class URLRequestContextGetter;
 
 namespace safe_browsing {
 
+class PermissionReporter;
+
 class SafeBrowsingPingManager : public net::URLFetcherDelegate {
  public:
   ~SafeBrowsingPingManager() override;
@@ -60,6 +64,11 @@ class SafeBrowsingPingManager : public net::URLFetcherDelegate {
       std::unique_ptr<certificate_reporting::ErrorReporter>
           certificate_error_reporter);
 
+  // Report permission action to SafeBrowsing servers.
+  void ReportPermissionAction(const GURL& origin,
+                              content::PermissionType permission,
+                              PermissionAction action);
+
  private:
   FRIEND_TEST_ALL_PREFIXES(SafeBrowsingPingManagerTest,
                            TestSafeBrowsingHitUrl);
@@ -100,6 +109,9 @@ class SafeBrowsingPingManager : public net::URLFetcherDelegate {
   std::unique_ptr<certificate_reporting::ErrorReporter>
       certificate_error_reporter_;
 
+  // Sends reports of permission actions.
+  std::unique_ptr<PermissionReporter> permission_reporter_;
+
   DISALLOW_COPY_AND_ASSIGN(SafeBrowsingPingManager);
 };
 
diff --git a/chrome/browser/safe_browsing/ui_manager.cc b/chrome/browser/safe_browsing/ui_manager.cc
index 8543c38..ab4769e 100644
--- a/chrome/browser/safe_browsing/ui_manager.cc
+++ b/chrome/browser/safe_browsing/ui_manager.cc
@@ -280,6 +280,17 @@ void SafeBrowsingUIManager::ReportInvalidCertificateChain(
       callback);
 }
 
+void SafeBrowsingUIManager::ReportPermissionAction(
+    const GURL& origin,
+    content::PermissionType permission,
+    PermissionAction action) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&SafeBrowsingUIManager::ReportPermissionActionOnIOThread, this,
+                 origin, permission, action));
+}
+
 void SafeBrowsingUIManager::AddObserver(Observer* observer) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   observer_list_.AddObserver(observer);
@@ -302,6 +313,21 @@ void SafeBrowsingUIManager::ReportInvalidCertificateChainOnIOThread(
   sb_service_->ping_manager()->ReportInvalidCertificateChain(serialized_report);
 }
 
+void SafeBrowsingUIManager::ReportPermissionActionOnIOThread(
+    const GURL& origin,
+    content::PermissionType permission,
+    PermissionAction action) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  // The service may delete the ping manager (i.e. when user disabling service,
+  // etc). This happens on the IO thread.
+  if (!sb_service_ || !sb_service_->ping_manager())
+    return;
+
+  sb_service_->ping_manager()->ReportPermissionAction(origin, permission,
+                                                      action);
+}
+
 // If the user had opted-in to send ThreatDetails, this gets called
 // when the report is ready.
 void SafeBrowsingUIManager::SendSerializedThreatDetails(
diff --git a/chrome/browser/safe_browsing/ui_manager.h b/chrome/browser/safe_browsing/ui_manager.h
index b9b7e52..4b39b65 100644
--- a/chrome/browser/safe_browsing/ui_manager.h
+++ b/chrome/browser/safe_browsing/ui_manager.h
@@ -16,9 +16,11 @@
 #include "base/memory/ref_counted.h"
 #include "base/observer_list.h"
 #include "base/time/time.h"
+#include "chrome/browser/permissions/permission_uma_util.h"
 #include "components/safe_browsing_db/hit_report.h"
 #include "components/safe_browsing_db/util.h"
 #include "content/public/browser/browser_thread.h"
+#include "content/public/browser/permission_type.h"
 #include "url/gurl.h"
 
 namespace base {
@@ -148,6 +150,12 @@ class SafeBrowsingUIManager
   void ReportInvalidCertificateChain(const std::string& serialized_report,
                                      const base::Closure& callback);
 
+  // Report permission action to SafeBrowsing servers. Can only be called on UI
+  // thread.
+  void ReportPermissionAction(const GURL& origin,
+                              content::PermissionType permission,
+                              PermissionAction action);
+
   // Add and remove observers.  These methods must be invoked on the UI thread.
   void AddObserver(Observer* observer);
   void RemoveObserver(Observer* remove);
@@ -168,6 +176,11 @@ class SafeBrowsingUIManager
   void ReportInvalidCertificateChainOnIOThread(
       const std::string& serialized_report);
 
+  // Report permission action to SafeBrowsing servers.
+  void ReportPermissionActionOnIOThread(const GURL& origin,
+                                        content::PermissionType permission,
+                                        PermissionAction action);
+
   // Updates the whitelist state.  Called on the UI thread.
   void AddToWhitelist(const UnsafeResource& resource);
 
diff --git a/chrome/browser/search/instant_service.cc b/chrome/browser/search/instant_service.cc
index 0b6676d..8c66c42 100644
--- a/chrome/browser/search/instant_service.cc
+++ b/chrome/browser/search/instant_service.cc
@@ -19,6 +19,7 @@
 #include "chrome/browser/search/instant_service_observer.h"
 #include "chrome/browser/search/most_visited_iframe_source.h"
 #include "chrome/browser/search/search.h"
+#include "chrome/browser/search/suggestions/suggestions_service_factory.h"
 #include "chrome/browser/search/thumbnail_source.h"
 #include "chrome/browser/search_engines/template_url_service_factory.h"
 #include "chrome/browser/search_engines/ui_thread_search_terms_data.h"
@@ -59,9 +60,23 @@
 #include "chrome/browser/themes/theme_service_factory.h"
 #endif  // defined(ENABLE_THEMES)
 
+namespace {
+
+const char kLocalNTPSuggestionService[] = "LocalNTPSuggestionsService";
+const char kLocalNTPSuggestionServiceEnabled[] = "Enabled";
+
+bool IsLocalNTPSuggestionServiceEnabled() {
+  return base::StartsWith(
+      base::FieldTrialList::FindFullName(kLocalNTPSuggestionService),
+      kLocalNTPSuggestionServiceEnabled, base::CompareCase::INSENSITIVE_ASCII);
+}
+
+}  // namespace
+
 InstantService::InstantService(Profile* profile)
     : profile_(profile),
       template_url_service_(TemplateURLServiceFactory::GetForProfile(profile_)),
+      suggestions_service_(NULL),
       weak_ptr_factory_(this) {
   // The initialization below depends on a typical set of browser threads. Skip
   // it if we are running in a unit test without the full suite.
@@ -141,6 +156,19 @@ InstantService::InstantService(Profile* profile)
   content::URLDataSource::Add(
       profile_, new LargeIconSource(fallback_icon_service, large_icon_service));
   content::URLDataSource::Add(profile_, new MostVisitedIframeSource());
+
+  if (IsLocalNTPSuggestionServiceEnabled()) {
+    suggestions_service_ =
+        suggestions::SuggestionsServiceFactory::GetForProfile(profile_);
+  }
+
+  if (suggestions_service_) {
+    suggestions_subscription_ = suggestions_service_->AddCallback(
+        base::Bind(&InstantService::OnSuggestionsAvailable,
+                   base::Unretained(this)));
+    suggestions_service_->FetchSuggestionsData();
+    // TODO(treib): Also re-fetch suggestions on local NTP loads.
+  }
 }
 
 InstantService::~InstantService() {
@@ -176,6 +204,9 @@ void InstantService::DeleteMostVisitedItem(const GURL& url) {
       TopSitesFactory::GetForProfile(profile_);
   if (top_sites)
     top_sites->AddBlacklistedURL(url);
+
+  if (suggestions_service_)
+    suggestions_service_->BlacklistURL(url);
 }
 
 void InstantService::UndoMostVisitedDeletion(const GURL& url) {
@@ -183,6 +214,9 @@ void InstantService::UndoMostVisitedDeletion(const GURL& url) {
       TopSitesFactory::GetForProfile(profile_);
   if (top_sites)
     top_sites->RemoveBlacklistedURL(url);
+
+  if (suggestions_service_)
+    suggestions_service_->UndoBlacklistURL(url);
 }
 
 void InstantService::UndoAllMostVisitedDeletions() {
@@ -190,6 +224,9 @@ void InstantService::UndoAllMostVisitedDeletions() {
       TopSitesFactory::GetForProfile(profile_);
   if (top_sites)
     top_sites->ClearBlacklistedURLs();
+
+  if (suggestions_service_)
+    suggestions_service_->ClearBlacklist();
 }
 
 void InstantService::UpdateThemeInfo() {
@@ -265,23 +302,59 @@ void InstantService::OnRendererProcessTerminated(int process_id) {
   }
 }
 
+void InstantService::OnSuggestionsAvailable(
+    const suggestions::SuggestionsProfile& profile) {
+  std::vector<InstantMostVisitedItem> new_suggestions_items;
+  for (int i = 0; i < profile.suggestions_size(); ++i) {
+    const suggestions::ChromeSuggestion& suggestion = profile.suggestions(i);
+
+    InstantMostVisitedItem item;
+    item.url = GURL(suggestion.url());
+    item.title = base::UTF8ToUTF16(suggestion.title());
+    if (suggestion.has_thumbnail()) {
+      item.thumbnail = GURL(suggestion.thumbnail());
+    }
+    if (suggestion.has_favicon_url()) {
+      item.favicon = GURL(suggestion.favicon_url());
+    }
+    if (suggestion.has_impression_url()) {
+      item.impression_url = GURL(suggestion.impression_url());
+    }
+    if (suggestion.has_click_url()) {
+      item.click_url = GURL(suggestion.click_url());
+    }
+    item.is_server_side_suggestion = true;
+    new_suggestions_items.push_back(item);
+  }
+  suggestions_items_ = new_suggestions_items;
+  NotifyAboutMostVisitedItems();
+}
+
 void InstantService::OnMostVisitedItemsReceived(
     const history::MostVisitedURLList& data) {
-  most_visited_items_.clear();
-  for (const history::MostVisitedURL& mv_url : data) {
+  history::MostVisitedURLList reordered_data(data);
+  std::vector<InstantMostVisitedItem> new_most_visited_items;
+  for (size_t i = 0; i < reordered_data.size(); i++) {
+    const history::MostVisitedURL& url = reordered_data[i];
     InstantMostVisitedItem item;
-    item.url = mv_url.url;
-    item.title = mv_url.title;
+    item.url = url.url;
+    item.title = url.title;
     item.is_server_side_suggestion = false;
-    most_visited_items_.push_back(item);
+    new_most_visited_items.push_back(item);
   }
 
+  most_visited_items_ = new_most_visited_items;
   NotifyAboutMostVisitedItems();
 }
 
 void InstantService::NotifyAboutMostVisitedItems() {
-  FOR_EACH_OBSERVER(InstantServiceObserver, observers_,
-                    MostVisitedItemsChanged(most_visited_items_));
+  if (suggestions_service_ && !suggestions_items_.empty()) {
+    FOR_EACH_OBSERVER(InstantServiceObserver, observers_,
+                      MostVisitedItemsChanged(suggestions_items_));
+  } else {
+    FOR_EACH_OBSERVER(InstantServiceObserver, observers_,
+                      MostVisitedItemsChanged(most_visited_items_));
+  }
 }
 
 #if defined(ENABLE_THEMES)
diff --git a/chrome/browser/search/instant_service.h b/chrome/browser/search/instant_service.h
index 23f4aa3..020e327 100644
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -17,6 +17,8 @@
 #include "components/history/core/browser/top_sites_observer.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/search_engines/template_url_service_observer.h"
+#include "components/suggestions/proto/suggestions.pb.h"
+#include "components/suggestions/suggestions_service.h"
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
 #include "url/gurl.h"
@@ -126,9 +128,12 @@ class InstantService : public KeyedService,
   // Called when a renderer process is terminated.
   void OnRendererProcessTerminated(int process_id);
 
+  // Called when SuggestionsService has a new suggestions profile available.
+  void OnSuggestionsAvailable(const suggestions::SuggestionsProfile& profile);
+
   // Called when we get new most visited items from TopSites, registered as an
   // async callback. Parses them and sends them to the renderer via
-  // NotifyAboutMostVisitedItems.
+  // SendMostVisitedItems.
   void OnMostVisitedItemsReceived(const history::MostVisitedURLList& data);
 
   // Notifies the observer about the last known most visited items.
@@ -153,6 +158,9 @@ class InstantService : public KeyedService,
   // InstantMostVisitedItems from TopSites.
   std::vector<InstantMostVisitedItem> most_visited_items_;
 
+  // InstantMostVisitedItems from SuggestionService.
+  std::vector<InstantMostVisitedItem> suggestions_items_;
+
   // Theme-related data for NTP overlay to adopt themes.
   std::unique_ptr<ThemeBackgroundInfo> theme_info_;
 
@@ -170,6 +178,14 @@ class InstantService : public KeyedService,
   std::unique_ptr<TemplateURLData> previous_default_search_provider_;
   GURL previous_google_base_url_;
 
+  // Suggestions Service to fetch server suggestions.
+  suggestions::SuggestionsService* suggestions_service_;
+
+  // Subscription to the SuggestionsService.
+  std::unique_ptr<
+      suggestions::SuggestionsService::ResponseCallbackList::Subscription>
+      suggestions_subscription_;
+
   // Used for Top Sites async retrieval.
   base::WeakPtrFactory<InstantService> weak_ptr_factory_;
 
diff --git a/chrome/browser/search/instant_service_unittest.cc b/chrome/browser/search/instant_service_unittest.cc
index bab485b..e24ab1a 100644
--- a/chrome/browser/search/instant_service_unittest.cc
+++ b/chrome/browser/search/instant_service_unittest.cc
@@ -55,6 +55,10 @@ class InstantServiceTest : public InstantUnitTestBase {
     return instant_service_->most_visited_items_;
   }
 
+  std::vector<InstantMostVisitedItem>& suggestions_items() {
+    return instant_service_->suggestions_items_;
+  }
+
   std::unique_ptr<MockInstantServiceObserver> instant_service_observer_;
 };
 
@@ -159,6 +163,17 @@ TEST_F(InstantServiceEnabledTest,
   EXPECT_NE(old_prerenderer, GetInstantSearchPrerenderer());
 }
 
+TEST_F(InstantServiceTest, GetSuggestionFromServiceSide) {
+  auto profile = suggestions::SuggestionsProfile();
+  profile.add_suggestions();
+
+  instant_service_->OnSuggestionsAvailable(profile);
+
+  auto items = instant_service_->suggestions_items_;
+  ASSERT_EQ(1, (int)items.size());
+  ASSERT_TRUE(items[0].is_server_side_suggestion);
+}
+
 TEST_F(InstantServiceTest, GetSuggestionFromClientSide) {
   history::MostVisitedURLList url_list;
   url_list.push_back(history::MostVisitedURL());
diff --git a/chrome/browser/search/search.cc b/chrome/browser/search/search.cc
index 376764c..c2ac4fe 100644
--- a/chrome/browser/search/search.cc
+++ b/chrome/browser/search/search.cc
@@ -507,6 +507,8 @@ GURL GetEffectiveURLForInstant(const GURL& url, Profile* profile) {
   if (url.SchemeIs(chrome::kChromeSearchScheme))
     return url;
 
+  GURL effective_url(url);
+
   // Replace the scheme with "chrome-search:", and clear the port, since
   // chrome-search is a scheme without port.
   url::Replacements<char> replacements;
@@ -525,7 +527,8 @@ GURL GetEffectiveURLForInstant(const GURL& url, Profile* profile) {
                          url::Component(0, remote_ntp_host.length()));
   }
 
-  return url.ReplaceComponents(replacements);
+  effective_url = effective_url.ReplaceComponents(replacements);
+  return effective_url;
 }
 
 bool HandleNewTabURLRewrite(GURL* url,
diff --git a/chrome/browser/search/search.h b/chrome/browser/search/search.h
index 14a7982..4466ef2 100644
--- a/chrome/browser/search/search.h
+++ b/chrome/browser/search/search.h
@@ -36,6 +36,16 @@ enum CacheableNTPLoad {
   CACHEABLE_NTP_LOAD_MAX = 2
 };
 
+enum OptInState {
+  // The user has not manually opted in/out of InstantExtended.
+  INSTANT_EXTENDED_NOT_SET,
+  // The user has opted-in to InstantExtended.
+  INSTANT_EXTENDED_OPT_IN,
+  // The user has opted-out of InstantExtended.
+  INSTANT_EXTENDED_OPT_OUT,
+  INSTANT_EXTENDED_OPT_IN_STATE_ENUM_COUNT,
+};
+
 // Returns whether the suggest is enabled for the given |profile|.
 bool IsSuggestPrefEnabled(Profile* profile);
 
@@ -124,10 +134,9 @@ GURL GetSearchResultPrefetchBaseURL(Profile* profile);
 // focused.
 bool ShouldPrerenderInstantUrlOnOmniboxFocus();
 
-// Transforms the input |url| into its "effective URL". |url| must be an
-// Instant URL, i.e. ShouldAssignURLToInstantRenderer must return true. The
-// returned URL facilitates grouping process-per-site. The |url| is transformed,
-// for example, from
+// Transforms the input |url| into its "effective URL". The returned URL
+// facilitates grouping process-per-site. The |url| is transformed, for
+// example, from
 //
 //   https://www.google.com/search?espv=1&q=tractors
 //
@@ -139,15 +148,16 @@ bool ShouldPrerenderInstantUrlOnOmniboxFocus();
 //
 // If the input is already a privileged URL then that same URL is returned.
 //
-// If |url| is that of the online NTP, its host is replaced with "remote-ntp".
+// If |url| is that of the online NTP, its host is replaced with "online-ntp".
 // This forces the NTP and search results pages to have different SiteIntances,
 // and hence different processes.
 GURL GetEffectiveURLForInstant(const GURL& url, Profile* profile);
 
-// Rewrites |url| to the actual NTP URL to use if
-//   1. |url| is "chrome://newtab",
+// Rewrites |url| if
+//   1. |url| is kChromeUINewTabURL,
 //   2. InstantExtended is enabled, and
-//   3. |browser_context| doesn't correspond to an incognito profile.
+//   3. The --instant-new-tab-url switch is set to a valid URL.
+// |url| is rewritten to the value of --instant-new-tab-url.
 bool HandleNewTabURLRewrite(GURL* url,
                             content::BrowserContext* browser_context);
 // Reverses the operation from HandleNewTabURLRewrite.
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc
index 452ce24..f6862a3 100644
--- a/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc
@@ -177,8 +177,11 @@ void WebContentsEntry::DidNavigateMainFrame(
     const content::LoadCommittedDetails& details,
     const content::FrameNavigateParams& params) {
   auto itr = tasks_by_frames_.find(web_contents()->GetMainFrame());
-  if (itr == tasks_by_frames_.end())
+  if (itr == tasks_by_frames_.end()) {
+    // TODO(afakhry): Validate whether this actually happens in practice.
+    NOTREACHED();
     return;
+  }
 
   // Listening to WebContentsObserver::TitleWasSet() only is not enough in
   // some cases when the the webpage doesn't have a title. That's why we update
@@ -196,8 +199,11 @@ void WebContentsEntry::DidNavigateMainFrame(
 void WebContentsEntry::TitleWasSet(content::NavigationEntry* entry,
                                    bool explicit_set) {
   auto itr = tasks_by_frames_.find(web_contents()->GetMainFrame());
-  if (itr == tasks_by_frames_.end())
+  if (itr == tasks_by_frames_.end()) {
+    // TODO(afakhry): Validate whether this actually happens in practice.
+    NOTREACHED();
     return;
+  }
 
   itr->second->UpdateTitle();
 }
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index 8a77489..d355815 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1200,8 +1200,7 @@ void ViewSource(Browser* browser,
   last_committed_entry->SetPageState(page_state.RemoveScrollOffset());
 
   // Do not restore title, derive it from the url.
-  view_source_contents->UpdateTitleForEntry(last_committed_entry,
-                                            base::string16());
+  last_committed_entry->SetTitle(base::string16());
 
   // Now show view-source entry.
   if (browser->CanSupportWindowFeature(Browser::FEATURE_TABSTRIP)) {
diff --git a/chrome/browser/ui/passwords/manage_passwords_state_unittest.cc b/chrome/browser/ui/passwords/manage_passwords_state_unittest.cc
index 4d76648..e774420 100644
--- a/chrome/browser/ui/passwords/manage_passwords_state_unittest.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_state_unittest.cc
@@ -119,7 +119,7 @@ ManagePasswordsStateTest::CreateFormManagerInternal(bool include_federated) {
   std::unique_ptr<password_manager::PasswordFormManager> test_form_manager(
       new password_manager::PasswordFormManager(
           &password_manager_, &stub_client_, driver_.AsWeakPtr(),
-          test_local_form(),
+          test_local_form(), false,
           base::WrapUnique(new password_manager::StubFormSaver)));
   test_form_manager->SimulateFetchMatchingLoginsFromPasswordStore();
   if (include_federated) {
diff --git a/chrome/browser/ui/passwords/manage_passwords_test.cc b/chrome/browser/ui/passwords/manage_passwords_test.cc
index fac73b9..e48aea5 100644
--- a/chrome/browser/ui/passwords/manage_passwords_test.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_test.cc
@@ -63,7 +63,7 @@ void ManagePasswordsTest::SetupPendingPassword() {
 
   std::unique_ptr<password_manager::PasswordFormManager> test_form_manager(
       new password_manager::PasswordFormManager(
-          nullptr, &client, driver.AsWeakPtr(), *test_form(),
+          nullptr, &client, driver.AsWeakPtr(), *test_form(), false,
           base::WrapUnique(new password_manager::StubFormSaver)));
   test_form_manager->SimulateFetchMatchingLoginsFromPasswordStore();
   ScopedVector<autofill::PasswordForm> best_matches;
@@ -78,7 +78,7 @@ void ManagePasswordsTest::SetupAutomaticPassword() {
 
   std::unique_ptr<password_manager::PasswordFormManager> test_form_manager(
       new password_manager::PasswordFormManager(
-          nullptr, &client, driver.AsWeakPtr(), *test_form(),
+          nullptr, &client, driver.AsWeakPtr(), *test_form(), false,
           base::WrapUnique(new password_manager::StubFormSaver)));
   GetController()->OnAutomaticPasswordSave(std::move(test_form_manager));
 }
diff --git a/chrome/browser/ui/passwords/manage_passwords_ui_controller_unittest.cc b/chrome/browser/ui/passwords/manage_passwords_ui_controller_unittest.cc
index d5c7178..aabd135 100644
--- a/chrome/browser/ui/passwords/manage_passwords_ui_controller_unittest.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_ui_controller_unittest.cc
@@ -236,7 +236,7 @@ ManagePasswordsUIControllerTest::CreateFormManagerWithBestMatches(
   std::unique_ptr<password_manager::PasswordFormManager> test_form_manager(
       new password_manager::PasswordFormManager(
           &password_manager_, &client_, driver_.AsWeakPtr(), observed_form,
-          base::WrapUnique(new password_manager::StubFormSaver)));
+          true, base::WrapUnique(new password_manager::StubFormSaver)));
   test_form_manager->SimulateFetchMatchingLoginsFromPasswordStore();
   test_form_manager->OnGetPasswordStoreResults(std::move(best_matches));
   return test_form_manager;
diff --git a/chrome/browser/ui/search/search_tab_helper.cc b/chrome/browser/ui/search/search_tab_helper.cc
index 01e6a7e..3ff3225 100644
--- a/chrome/browser/ui/search/search_tab_helper.cc
+++ b/chrome/browser/ui/search/search_tab_helper.cc
@@ -171,11 +171,15 @@ SearchTabHelper::~SearchTabHelper() {
     instant_service_->RemoveObserver(this);
 }
 
+void SearchTabHelper::InitForPreloadedNTP() {
+  UpdateMode(true, true);
+}
+
 void SearchTabHelper::OmniboxInputStateChanged() {
   if (!is_search_enabled_)
     return;
 
-  UpdateMode(false);
+  UpdateMode(false, false);
 }
 
 void SearchTabHelper::OmniboxFocusChanged(OmniboxFocusState state,
@@ -215,7 +219,25 @@ void SearchTabHelper::NavigationEntryUpdated() {
   if (!is_search_enabled_)
     return;
 
-  UpdateMode(false);
+  UpdateMode(false, false);
+}
+
+void SearchTabHelper::InstantSupportChanged(bool instant_support) {
+  if (!is_search_enabled_)
+    return;
+
+  InstantSupportState new_state = instant_support ? INSTANT_SUPPORT_YES :
+      INSTANT_SUPPORT_NO;
+
+  model_.SetInstantSupportState(new_state);
+
+  content::NavigationEntry* entry =
+      web_contents_->GetController().GetLastCommittedEntry();
+  if (entry) {
+    search::SetInstantSupportStateInNavigationEntry(new_state, entry);
+    if (delegate_ && !instant_support)
+      delegate_->OnWebContentsInstantSupportDisabled(web_contents_);
+  }
 }
 
 bool SearchTabHelper::SupportsInstant() const {
@@ -235,14 +257,6 @@ void SearchTabHelper::Submit(const base::string16& text,
 void SearchTabHelper::OnTabActivated() {
   ipc_router_.OnTabActivated();
 
-  if (search::IsInstantNTP(web_contents_)) {
-    // Force creation of NTPUserDataLogger, if we loaded an NTP. The
-    // NTPUserDataLogger tries to detect whether the NTP is being created at
-    // startup or from the user opening a new tab, and if we wait until later,
-    // it won't correctly detect this case.
-    NTPUserDataLogger::GetOrCreateFromWebContents(web_contents_);
-  }
-
   OmniboxView* omnibox_view = GetOmniboxView();
   if (search::ShouldPrerenderInstantUrlOnOmniboxFocus() &&
       omnibox_has_focus_fn_(omnibox_view)) {
@@ -277,10 +291,8 @@ void SearchTabHelper::DidStartNavigationToPendingEntry(
     // prevents any flickering of the tab title.
     content::NavigationEntry* entry =
         web_contents_->GetController().GetPendingEntry();
-    if (entry) {
-      web_contents_->UpdateTitleForEntry(
-          entry, l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));
-    }
+    if (entry)
+      entry->SetTitle(l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));
   }
 }
 
@@ -308,8 +320,7 @@ void SearchTabHelper::DidNavigateMainFrame(
   if (entry && entry->GetTitle().empty() &&
       (entry->GetVirtualURL() == GURL(chrome::kChromeUINewTabURL) ||
        search::NavEntryIsInstantNTP(web_contents_, entry))) {
-    web_contents_->UpdateTitleForEntry(
-        entry, l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));
+    entry->SetTitle(l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));
   }
 }
 
@@ -335,7 +346,7 @@ void SearchTabHelper::NavigationEntryCommitted(
                                                profile()))
     ipc_router_.SetDisplayInstantResults();
 
-  UpdateMode(true);
+  UpdateMode(true, false);
 
   content::NavigationEntry* entry =
       web_contents_->GetController().GetVisibleEntry();
@@ -504,28 +515,10 @@ void SearchTabHelper::OnHistorySyncCheck() {
   ipc_router_.SendHistorySyncCheckResult(IsHistorySyncEnabled(profile()));
 }
 
-void SearchTabHelper::InstantSupportChanged(bool instant_support) {
-  if (!is_search_enabled_)
-    return;
-
-  InstantSupportState new_state = instant_support ? INSTANT_SUPPORT_YES :
-      INSTANT_SUPPORT_NO;
-
-  model_.SetInstantSupportState(new_state);
-
-  content::NavigationEntry* entry =
-      web_contents_->GetController().GetLastCommittedEntry();
-  if (entry) {
-    search::SetInstantSupportStateInNavigationEntry(new_state, entry);
-    if (delegate_ && !instant_support)
-      delegate_->OnWebContentsInstantSupportDisabled(web_contents_);
-  }
-}
-
-void SearchTabHelper::UpdateMode(bool update_origin) {
+void SearchTabHelper::UpdateMode(bool update_origin, bool is_preloaded_ntp) {
   SearchMode::Type type = SearchMode::MODE_DEFAULT;
   SearchMode::Origin origin = SearchMode::ORIGIN_DEFAULT;
-  if (IsNTP(web_contents_)) {
+  if (IsNTP(web_contents_) || is_preloaded_ntp) {
     type = SearchMode::MODE_NTP;
     origin = SearchMode::ORIGIN_NTP;
   } else if (IsSearchResults(web_contents_)) {
diff --git a/chrome/browser/ui/search/search_tab_helper.h b/chrome/browser/ui/search/search_tab_helper.h
index 164bd76..bc1188e 100644
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -52,6 +52,9 @@ class SearchTabHelper : public content::WebContentsObserver,
     return &model_;
   }
 
+  // Sets up the initial state correctly for a preloaded NTP.
+  void InitForPreloadedNTP();
+
   // Invoked when the omnibox input state is changed in some way that might
   // affect the search mode.
   void OmniboxInputStateChanged();
@@ -67,6 +70,9 @@ class SearchTabHelper : public content::WebContentsObserver,
   // the notification system and shouldn't call this method.
   void NavigationEntryUpdated();
 
+  // Invoked to update the instant support state.
+  void InstantSupportChanged(bool supports_instant);
+
   // Returns true if the page supports instant. If the instant support state is
   // not determined or if the page does not support instant returns false.
   bool SupportsInstant() const;
@@ -171,13 +177,12 @@ class SearchTabHelper : public content::WebContentsObserver,
   void MostVisitedItemsChanged(
       const std::vector<InstantMostVisitedItem>& items) override;
 
-  // Invoked to update the instant support state.
-  void InstantSupportChanged(bool supports_instant);
-
   // Sets the mode of the model based on the current URL of web_contents().
   // Only updates the origin part of the mode if |update_origin| is true,
-  // otherwise keeps the current origin.
-  void UpdateMode(bool update_origin);
+  // otherwise keeps the current origin. If |is_preloaded_ntp| is true, the mode
+  // is set to NTP regardless of the current URL; this is used to ensure that
+  // InstantController can bind InstantTab to new tab pages immediately.
+  void UpdateMode(bool update_origin, bool is_preloaded_ntp);
 
   // Tells the renderer to determine if the page supports the Instant API, which
   // results in a call to OnInstantSupportDetermined() when the reply is
diff --git a/chrome/browser/ui/toolbar/back_forward_menu_model_unittest.cc b/chrome/browser/ui/toolbar/back_forward_menu_model_unittest.cc
index 5d66a18..03492e2 100644
--- a/chrome/browser/ui/toolbar/back_forward_menu_model_unittest.cc
+++ b/chrome/browser/ui/toolbar/back_forward_menu_model_unittest.cc
@@ -79,8 +79,7 @@ class BackFwdMenuModelTest : public ChromeRenderViewHostTestHarness {
 
   void LoadURLAndUpdateState(const char* url, const char* title) {
     NavigateAndCommit(GURL(url));
-    web_contents()->UpdateTitleForEntry(
-        controller().GetLastCommittedEntry(), base::UTF8ToUTF16(title));
+    controller().GetLastCommittedEntry()->SetTitle(base::UTF8ToUTF16(title));
   }
 
   // Navigate back or forward the given amount and commits the entry (which
diff --git a/chrome/browser/ui/website_settings/website_settings.cc b/chrome/browser/ui/website_settings/website_settings.cc
index eb8ff4b..b6d3012 100644
--- a/chrome/browser/ui/website_settings/website_settings.cc
+++ b/chrome/browser/ui/website_settings/website_settings.cc
@@ -293,8 +293,8 @@ void WebsiteSettings::OnSitePermissionChanged(ContentSettingsType type,
     // in the permissions layer. See crbug.com/469221.
     content::PermissionType permission_type;
     if (PermissionUtil::GetPermissionType(type, &permission_type)) {
-      PermissionUmaUtil::PermissionRevoked(permission_type,
-                                           this->site_url_);
+      PermissionUmaUtil::PermissionRevoked(permission_type, this->site_url_,
+                                           this->profile_);
     }
   }
 
diff --git a/chrome/chrome_tests_unit.gypi b/chrome/chrome_tests_unit.gypi
index 4d414c1..100ed0f 100644
--- a/chrome/chrome_tests_unit.gypi
+++ b/chrome/chrome_tests_unit.gypi
@@ -175,6 +175,7 @@
       'browser/permissions/delegation_tracker_unittest.cc',
       'browser/permissions/permission_context_base_unittest.cc',
       'browser/permissions/permission_manager_unittest.cc',
+      'browser/permissions/permission_uma_util_unittest.cc',
       'browser/permissions/permission_util_unittest.cc',
       'browser/policy/cloud/cloud_policy_invalidator_unittest.cc',
       'browser/policy/cloud/remote_commands_invalidator_unittest.cc',
diff --git a/chrome/test/base/browser_with_test_window_test.cc b/chrome/test/base/browser_with_test_window_test.cc
index cfb71ad..b2dda01 100644
--- a/chrome/test/base/browser_with_test_window_test.cc
+++ b/chrome/test/base/browser_with_test_window_test.cc
@@ -183,11 +183,10 @@ void BrowserWithTestWindowTest::NavigateAndCommitActiveTabWithTitle(
     Browser* navigating_browser,
     const GURL& url,
     const base::string16& title) {
-  WebContents* contents =
-      navigating_browser->tab_strip_model()->GetActiveWebContents();
-  NavigationController* controller = &contents->GetController();
+  NavigationController* controller = &navigating_browser->tab_strip_model()->
+      GetActiveWebContents()->GetController();
   NavigateAndCommit(controller, url);
-  contents->UpdateTitleForEntry(controller->GetActiveEntry(), title);
+  controller->GetActiveEntry()->SetTitle(title);
 }
 
 void BrowserWithTestWindowTest::DestroyBrowserAndProfile() {
diff --git a/chrome/utility/importer/ie_importer_win.cc b/chrome/utility/importer/ie_importer_win.cc
index 7e06583..aadfd5b 100644
--- a/chrome/utility/importer/ie_importer_win.cc
+++ b/chrome/utility/importer/ie_importer_win.cc
@@ -662,6 +662,13 @@ void IEImporter::ImportPasswordsIE6() {
     form.password_value = ac_list[i].data[1];
     form.signon_realm = url.GetOrigin().spec();
 
+    // This is not precise, because a scheme of https does not imply a valid
+    // certificate was presented; however we assign it this way so that if we
+    // import a password from IE whose scheme is https, we give it the benefit
+    // of the doubt and DON'T auto-fill it unless the form appears under
+    // valid TLS conditions.
+    form.ssl_valid = url.SchemeIsCryptographic();
+
     // Goes through the list to find out the username field
     // of the web page.
     size_t list_it, item_it;
diff --git a/chrome/utility/importer/nss_decryptor.cc b/chrome/utility/importer/nss_decryptor.cc
index 1698420..be88f05 100644
--- a/chrome/utility/importer/nss_decryptor.cc
+++ b/chrome/utility/importer/nss_decryptor.cc
@@ -371,6 +371,7 @@ bool NSSDecryptor::CreatePasswordFormFromRawInfo(
     // digest_auth entry, so let's assume basic_auth.
     form->scheme = autofill::PasswordForm::SCHEME_BASIC;
   }
+  form->ssl_valid = form->origin.SchemeIsCryptographic();
   form->username_element = raw_password_info.username_element;
   form->username_value = Decrypt(raw_password_info.encrypted_username);
   form->password_element = raw_password_info.password_element;
diff --git a/chromeos/CHROMEOS_LKGM b/chromeos/CHROMEOS_LKGM
index 9346351..98dac5d 100644
--- a/chromeos/CHROMEOS_LKGM
+++ b/chromeos/CHROMEOS_LKGM
@@ -1 +1 @@
-8584.0.0
\ No newline at end of file
+8580.0.0
\ No newline at end of file
diff --git a/components/autofill/content/common/OWNERS b/components/autofill/content/common/OWNERS
index 25497bf..9fbdf6f 100644
--- a/components/autofill/content/common/OWNERS
+++ b/components/autofill/content/common/OWNERS
@@ -2,5 +2,3 @@
 # new sandbox escapes.
 per-file *_messages*.h=set noparent
 per-file *_messages*.h=file://ipc/SECURITY_OWNERS
-per-file *_param_traits*.*=set noparent
-per-file *_param_traits*.*=file://ipc/SECURITY_OWNERS
diff --git a/components/autofill/content/common/autofill_param_traits_macros.h b/components/autofill/content/common/autofill_param_traits_macros.h
index b20ff68..ed94ab8 100644
--- a/components/autofill/content/common/autofill_param_traits_macros.h
+++ b/components/autofill/content/common/autofill_param_traits_macros.h
@@ -43,6 +43,7 @@ IPC_STRUCT_TRAITS_BEGIN(autofill::PasswordForm)
   IPC_STRUCT_TRAITS_MEMBER(password_value)
   IPC_STRUCT_TRAITS_MEMBER(new_password_element)
   IPC_STRUCT_TRAITS_MEMBER(new_password_value)
+  IPC_STRUCT_TRAITS_MEMBER(ssl_valid)
   IPC_STRUCT_TRAITS_MEMBER(preferred)
   IPC_STRUCT_TRAITS_MEMBER(blacklisted_by_user)
   IPC_STRUCT_TRAITS_MEMBER(type)
diff --git a/components/autofill/content/public/cpp/autofill_types_struct_traits.cc b/components/autofill/content/public/cpp/autofill_types_struct_traits.cc
index 83fe681..3c53888 100644
--- a/components/autofill/content/public/cpp/autofill_types_struct_traits.cc
+++ b/components/autofill/content/public/cpp/autofill_types_struct_traits.cc
@@ -496,6 +496,7 @@ bool StructTraits<mojom::PasswordForm, PasswordForm>::Read(
 
   out->new_password_value_is_default = data.new_password_value_is_default();
   out->new_password_marked_by_site = data.new_password_marked_by_site();
+  out->ssl_valid = data.ssl_valid();
   out->preferred = data.preferred();
 
   if (!data.ReadDateCreated(&out->date_created) ||
diff --git a/components/autofill/content/public/cpp/autofill_types_struct_traits.h b/components/autofill/content/public/cpp/autofill_types_struct_traits.h
index 34aa1f9..538a7be 100644
--- a/components/autofill/content/public/cpp/autofill_types_struct_traits.h
+++ b/components/autofill/content/public/cpp/autofill_types_struct_traits.h
@@ -441,6 +441,8 @@ struct StructTraits<autofill::mojom::PasswordForm, autofill::PasswordForm> {
     return r.new_password_marked_by_site;
   }
 
+  static bool ssl_valid(const autofill::PasswordForm& r) { return r.ssl_valid; }
+
   static bool preferred(const autofill::PasswordForm& r) { return r.preferred; }
 
   static const base::Time& date_created(const autofill::PasswordForm& r) {
diff --git a/components/autofill/content/public/cpp/autofill_types_struct_traits_unittest.cc b/components/autofill/content/public/cpp/autofill_types_struct_traits_unittest.cc
index ed26640..0416fd8 100644
--- a/components/autofill/content/public/cpp/autofill_types_struct_traits_unittest.cc
+++ b/components/autofill/content/public/cpp/autofill_types_struct_traits_unittest.cc
@@ -91,6 +91,7 @@ void CreateTestPasswordForm(PasswordForm* form) {
   form->new_password_value = base::ASCIIToUTF16("new_password_value");
   form->new_password_value_is_default = false;
   form->new_password_marked_by_site = false;
+  form->ssl_valid = true;
   form->preferred = false;
   form->date_created = base::Time::Now();
   form->date_synced = base::Time::Now();
diff --git a/components/autofill/content/public/interfaces/autofill_types.mojom b/components/autofill/content/public/interfaces/autofill_types.mojom
index 0c33455..8fab0aa 100644
--- a/components/autofill/content/public/interfaces/autofill_types.mojom
+++ b/components/autofill/content/public/interfaces/autofill_types.mojom
@@ -153,6 +153,7 @@ struct PasswordForm {
   string new_password_value;
   bool new_password_value_is_default;
   bool new_password_marked_by_site;
+  bool ssl_valid;
   bool preferred;
   mojo.common.mojom.Time date_created;
   mojo.common.mojom.Time date_synced;
diff --git a/components/autofill/content/renderer/password_form_conversion_utils.cc b/components/autofill/content/renderer/password_form_conversion_utils.cc
index 4c2437f..4780a84 100644
--- a/components/autofill/content/renderer/password_form_conversion_utils.cc
+++ b/components/autofill/content/renderer/password_form_conversion_utils.cc
@@ -594,6 +594,7 @@ bool GetPasswordForm(const SyntheticForm& form,
   }
 
   password_form->scheme = PasswordForm::SCHEME_HTML;
+  password_form->ssl_valid = false;
   password_form->preferred = false;
   password_form->blacklisted_by_user = false;
   password_form->type = PasswordForm::TYPE_MANUAL;
diff --git a/components/autofill/content/renderer/password_form_conversion_utils_browsertest.cc b/components/autofill/content/renderer/password_form_conversion_utils_browsertest.cc
index 81f436e..dc790c1 100644
--- a/components/autofill/content/renderer/password_form_conversion_utils_browsertest.cc
+++ b/components/autofill/content/renderer/password_form_conversion_utils_browsertest.cc
@@ -260,6 +260,7 @@ TEST_F(MAYBE_PasswordFormConversionUtilsTest, BasicFormAttributes) {
   EXPECT_EQ(base::UTF8ToUTF16("password"), password_form->password_element);
   EXPECT_EQ(base::UTF8ToUTF16("secret"), password_form->password_value);
   EXPECT_EQ(PasswordForm::SCHEME_HTML, password_form->scheme);
+  EXPECT_FALSE(password_form->ssl_valid);
   EXPECT_FALSE(password_form->preferred);
   EXPECT_FALSE(password_form->blacklisted_by_user);
   EXPECT_EQ(PasswordForm::TYPE_MANUAL, password_form->type);
diff --git a/components/autofill/core/common/password_form.cc b/components/autofill/core/common/password_form.cc
index 706cfb8..c4bcc58 100644
--- a/components/autofill/core/common/password_form.cc
+++ b/components/autofill/core/common/password_form.cc
@@ -45,6 +45,7 @@ void PasswordFormToJSON(const PasswordForm& form,
                                      base::ASCIIToUTF16("|")));
   target->SetBoolean("blacklisted", form.blacklisted_by_user);
   target->SetBoolean("preferred", form.preferred);
+  target->SetBoolean("ssl_valid", form.ssl_valid);
   target->SetDouble("date_created", form.date_created.ToDoubleT());
   target->SetDouble("date_synced", form.date_synced.ToDoubleT());
   target->SetInteger("type", form.type);
@@ -75,6 +76,7 @@ PasswordForm::PasswordForm()
       password_value_is_default(false),
       new_password_value_is_default(false),
       new_password_marked_by_site(false),
+      ssl_valid(false),
       preferred(false),
       blacklisted_by_user(false),
       type(TYPE_MANUAL),
@@ -114,8 +116,8 @@ bool PasswordForm::operator==(const PasswordForm& form) const {
          new_password_element == form.new_password_element &&
          new_password_marked_by_site == form.new_password_marked_by_site &&
          new_password_value == form.new_password_value &&
-         preferred == form.preferred && date_created == form.date_created &&
-         date_synced == form.date_synced &&
+         ssl_valid == form.ssl_valid && preferred == form.preferred &&
+         date_created == form.date_created && date_synced == form.date_synced &&
          blacklisted_by_user == form.blacklisted_by_user && type == form.type &&
          times_used == form.times_used &&
          form_data.SameFormAs(form.form_data) &&
diff --git a/components/autofill/core/common/password_form.h b/components/autofill/core/common/password_form.h
index a32e530..41dcef4 100644
--- a/components/autofill/core/common/password_form.h
+++ b/components/autofill/core/common/password_form.h
@@ -176,6 +176,15 @@ struct PasswordForm {
   // attribute. This is only used in parsed HTML forms.
   bool new_password_marked_by_site;
 
+  // Whether or not this login was saved under an HTTPS session with a valid
+  // SSL cert. We will never match or autofill a PasswordForm where
+  // ssl_valid == true with a PasswordForm where ssl_valid == false. This means
+  // passwords saved under HTTPS will never get autofilled onto an HTTP page.
+  // When importing, this should be set to true if the page URL is HTTPS, thus
+  // giving it "the benefit of the doubt" that the SSL cert was valid when it
+  // was saved. Default to false.
+  bool ssl_valid;
+
   // True if this PasswordForm represents the last username/password login the
   // user selected to log in to the site. If there is only one saved entry for
   // the site, this will always be true, but when there are multiple entries
diff --git a/components/autofill/core/common/password_form_fill_data_unittest.cc b/components/autofill/core/common/password_form_fill_data_unittest.cc
index 3a8954d..e4734cc 100644
--- a/components/autofill/core/common/password_form_fill_data_unittest.cc
+++ b/components/autofill/core/common/password_form_fill_data_unittest.cc
@@ -29,6 +29,7 @@ TEST(PasswordFormFillDataTest, TestSinglePreferredMatch) {
   form_on_page.password_value = ASCIIToUTF16("test");
   form_on_page.submit_element = ASCIIToUTF16("");
   form_on_page.signon_realm = "https://foo.com/";
+  form_on_page.ssl_valid = true;
   form_on_page.preferred = false;
   form_on_page.scheme = PasswordForm::SCHEME_HTML;
 
@@ -42,6 +43,7 @@ TEST(PasswordFormFillDataTest, TestSinglePreferredMatch) {
   preferred_match.password_value = ASCIIToUTF16("test");
   preferred_match.submit_element = ASCIIToUTF16("");
   preferred_match.signon_realm = "https://foo.com/";
+  preferred_match.ssl_valid = true;
   preferred_match.preferred = true;
   preferred_match.scheme = PasswordForm::SCHEME_HTML;
 
@@ -90,6 +92,7 @@ TEST(PasswordFormFillDataTest, TestPublicSuffixDomainMatching) {
   form_on_page.password_value = ASCIIToUTF16("test");
   form_on_page.submit_element = ASCIIToUTF16("");
   form_on_page.signon_realm = "https://foo.com/";
+  form_on_page.ssl_valid = true;
   form_on_page.preferred = false;
   form_on_page.scheme = PasswordForm::SCHEME_HTML;
 
@@ -104,6 +107,7 @@ TEST(PasswordFormFillDataTest, TestPublicSuffixDomainMatching) {
   preferred_match.submit_element = ASCIIToUTF16("");
   preferred_match.signon_realm = "https://foo.com/";
   preferred_match.is_public_suffix_match = true;
+  preferred_match.ssl_valid = true;
   preferred_match.preferred = true;
   preferred_match.scheme = PasswordForm::SCHEME_HTML;
 
@@ -119,6 +123,7 @@ TEST(PasswordFormFillDataTest, TestPublicSuffixDomainMatching) {
   exact_match.password_value = ASCIIToUTF16("test");
   exact_match.submit_element = ASCIIToUTF16("");
   exact_match.signon_realm = "https://foo.com/";
+  exact_match.ssl_valid = true;
   exact_match.preferred = false;
   exact_match.scheme = PasswordForm::SCHEME_HTML;
 
@@ -135,6 +140,7 @@ TEST(PasswordFormFillDataTest, TestPublicSuffixDomainMatching) {
   public_suffix_match.submit_element = ASCIIToUTF16("");
   public_suffix_match.is_public_suffix_match = true;
   public_suffix_match.signon_realm = "https://foo.com/";
+  public_suffix_match.ssl_valid = true;
   public_suffix_match.preferred = false;
   public_suffix_match.scheme = PasswordForm::SCHEME_HTML;
 
@@ -183,6 +189,7 @@ TEST(PasswordFormFillDataTest, TestAffiliationMatch) {
   form_on_page.password_value = ASCIIToUTF16("test");
   form_on_page.submit_element = ASCIIToUTF16("");
   form_on_page.signon_realm = "https://foo.com/";
+  form_on_page.ssl_valid = true;
   form_on_page.preferred = false;
   form_on_page.scheme = PasswordForm::SCHEME_HTML;
 
@@ -193,6 +200,7 @@ TEST(PasswordFormFillDataTest, TestAffiliationMatch) {
   preferred_match.password_value = ASCIIToUTF16("test");
   preferred_match.signon_realm = "android://hash@foo.com/";
   preferred_match.is_affiliation_based_match = true;
+  preferred_match.ssl_valid = true;
   preferred_match.preferred = true;
 
   // Create a match that matches exactly, so |is_affiliation_based_match| has a
@@ -207,6 +215,7 @@ TEST(PasswordFormFillDataTest, TestAffiliationMatch) {
   exact_match.password_value = ASCIIToUTF16("test");
   exact_match.submit_element = ASCIIToUTF16("");
   exact_match.signon_realm = "https://foo.com/";
+  exact_match.ssl_valid = true;
   exact_match.preferred = false;
   exact_match.scheme = PasswordForm::SCHEME_HTML;
 
@@ -219,6 +228,7 @@ TEST(PasswordFormFillDataTest, TestAffiliationMatch) {
   affiliated_match.password_value = ASCIIToUTF16("test");
   affiliated_match.is_affiliation_based_match = true;
   affiliated_match.signon_realm = "https://foo1.com/";
+  affiliated_match.ssl_valid = true;
   affiliated_match.preferred = false;
   affiliated_match.scheme = PasswordForm::SCHEME_HTML;
 
diff --git a/components/autofill/core/common/save_password_progress_logger.cc b/components/autofill/core/common/save_password_progress_logger.cc
index 05e8e32..1c13e46 100644
--- a/components/autofill/core/common/save_password_progress_logger.cc
+++ b/components/autofill/core/common/save_password_progress_logger.cc
@@ -90,6 +90,7 @@ void SavePasswordProgressLogger::LogPasswordForm(
                 ScrubElementID(form.password_element));
   log.SetString(GetStringFromID(STRING_NEW_PASSWORD_ELEMENT),
                 ScrubElementID(form.new_password_element));
+  log.SetBoolean(GetStringFromID(STRING_SSL_VALID), form.ssl_valid);
   log.SetBoolean(GetStringFromID(STRING_PASSWORD_GENERATED),
                  form.type == PasswordForm::TYPE_GENERATED);
   log.SetInteger(GetStringFromID(STRING_TIMES_USED), form.times_used);
@@ -196,6 +197,8 @@ std::string SavePasswordProgressLogger::GetStringFromID(
       return "Password element";
     case SavePasswordProgressLogger::STRING_NEW_PASSWORD_ELEMENT:
       return "New password element";
+    case SavePasswordProgressLogger::STRING_SSL_VALID:
+      return "SSL valid";
     case SavePasswordProgressLogger::STRING_PASSWORD_GENERATED:
       return "Password generated";
     case SavePasswordProgressLogger::STRING_TIMES_USED:
diff --git a/components/autofill/core/common/save_password_progress_logger.h b/components/autofill/core/common/save_password_progress_logger.h
index 339735f..4407c11 100644
--- a/components/autofill/core/common/save_password_progress_logger.h
+++ b/components/autofill/core/common/save_password_progress_logger.h
@@ -53,6 +53,7 @@ class SavePasswordProgressLogger {
     STRING_USERNAME_ELEMENT,
     STRING_PASSWORD_ELEMENT,
     STRING_NEW_PASSWORD_ELEMENT,
+    STRING_SSL_VALID,
     STRING_PASSWORD_GENERATED,
     STRING_TIMES_USED,
     STRING_PSL_MATCH,
diff --git a/components/browser_sync/browser/profile_sync_service.h b/components/browser_sync/browser/profile_sync_service.h
index 201e303..0e37bcf 100644
--- a/components/browser_sync/browser/profile_sync_service.h
+++ b/components/browser_sync/browser/profile_sync_service.h
@@ -669,6 +669,7 @@ class ProfileSyncService : public sync_driver::SyncService,
     SYNC_INITIAL_STATE_LIMIT
   };
 
+  friend class PermissionUmaUtilTest;
   friend class ProfileSyncServicePasswordTest;
   friend class SyncTest;
   friend class TestProfileSyncService;
diff --git a/components/components_tests.gyp b/components/components_tests.gyp
index b2f8779..de97a09 100644
--- a/components/components_tests.gyp
+++ b/components/components_tests.gyp
@@ -874,7 +874,6 @@
       'tracing/common/graphics_memory_dump_provider_android_unittest.cc',
       'tracing/common/process_metrics_memory_dump_provider_unittest.cc',
       'tracing/core/proto_utils_unittest.cc',
-      'tracing/core/proto_zero_message_unittest.cc',
       'tracing/core/trace_ring_buffer_unittest.cc',
       'tracing/core/scattered_stream_writer_unittest.cc',
       'tracing/test/fake_scattered_buffer.cc',
diff --git a/components/memory_coordinator.gypi b/components/memory_coordinator.gypi
index bb848e1..d7002f3 100644
--- a/components/memory_coordinator.gypi
+++ b/components/memory_coordinator.gypi
@@ -10,18 +10,22 @@
       'type': 'static_library',
       'sources': [
         'memory_coordinator/public/interfaces/child_memory_coordinator.mojom',
+        'memory_coordinator/public/interfaces/memory_coordinator.mojom',
       ],
       'includes': [ '../mojo/mojom_bindings_generator.gypi' ],
     },
     {
       # GN version: //components/memory_coordinator/common
       'target_name': 'memory_coordinator_common',
-      'type': 'none',
+      'type': 'static_library',
       'dependencies': [
+        '<(DEPTH)/base/base.gyp:base',
         'memory_coordinator_mojo_bindings',
       ],
       'sources': [
         'memory_coordinator/common/memory_coordinator_client.h',
+        'memory_coordinator/common/memory_coordinator_features.cc',
+        'memory_coordinator/common/memory_coordinator_features.h',
       ],
     },
     {
@@ -38,5 +42,19 @@
         'memory_coordinator/child/child_memory_coordinator_impl.h',
       ],
     },
+    {
+      # GN version: //components/memory_coordinator/browser
+      'target_name': 'memory_coordinator_browser',
+      'type': 'static_library',
+      'dependencies': [
+        '<(DEPTH)/base/base.gyp:base',
+        'memory_coordinator_common',
+        'memory_coordinator_mojo_bindings',
+      ],
+      'sources': [
+        'memory_coordinator/browser/memory_coordinator.cc',
+        'memory_coordinator/browser/memory_coordinator.h',
+      ],
+    },
   ],
 }
diff --git a/components/memory_coordinator/DEPS b/components/memory_coordinator/DEPS
index ef8ad28..1cd1e07 100644
--- a/components/memory_coordinator/DEPS
+++ b/components/memory_coordinator/DEPS
@@ -1,3 +1,4 @@
 include_rules = [
   "+mojo/public",
+  "+services/shell",
 ]
diff --git a/components/memory_coordinator/browser/BUILD.gn b/components/memory_coordinator/browser/BUILD.gn
new file mode 100644
index 0000000..ac0869a
--- /dev/null
+++ b/components/memory_coordinator/browser/BUILD.gn
@@ -0,0 +1,19 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+source_set("browser") {
+  sources = [
+    "memory_coordinator.cc",
+    "memory_coordinator.h",
+  ]
+
+  deps = [
+    "//base",
+    "//components/memory_coordinator/public/interfaces",
+  ]
+
+  public_deps = [
+    "//components/memory_coordinator/common",
+  ]
+}
diff --git a/components/memory_coordinator/browser/memory_coordinator.cc b/components/memory_coordinator/browser/memory_coordinator.cc
new file mode 100644
index 0000000..101426f
--- /dev/null
+++ b/components/memory_coordinator/browser/memory_coordinator.cc
@@ -0,0 +1,56 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/memory_coordinator/browser/memory_coordinator.h"
+
+namespace memory_coordinator {
+
+// The implementation of MemoryCoordinatorHandle. See memory_coordinator.mojom
+// for the role of this class.
+class MemoryCoordinatorHandleImpl : public mojom::MemoryCoordinatorHandle {
+ public:
+  MemoryCoordinatorHandleImpl(mojom::MemoryCoordinatorHandleRequest request)
+      : binding_(this, std::move(request)) {
+  }
+
+  // mojom::MemoryCoordinatorHandle implementations:
+
+  void AddChild(mojom::ChildMemoryCoordinatorPtr child) override {
+    DCHECK(!child_.is_bound());
+    child_ = std::move(child);
+  }
+
+  mojom::ChildMemoryCoordinatorPtr& child() { return child_; }
+  mojo::Binding<mojom::MemoryCoordinatorHandle>& binding() { return binding_; }
+
+ private:
+  mojom::ChildMemoryCoordinatorPtr child_;
+  mojo::Binding<mojom::MemoryCoordinatorHandle> binding_;
+
+  DISALLOW_COPY_AND_ASSIGN(MemoryCoordinatorHandleImpl);
+};
+
+MemoryCoordinator::MemoryCoordinator() {}
+
+MemoryCoordinator::~MemoryCoordinator() {}
+
+void MemoryCoordinator::CreateHandle(
+    int render_process_id,
+    mojom::MemoryCoordinatorHandleRequest request) {
+  auto handle = new MemoryCoordinatorHandleImpl(std::move(request));
+  handle->binding().set_connection_error_handler(
+      base::Bind(&MemoryCoordinator::OnConnectionError, base::Unretained(this),
+                 render_process_id));
+  children_[render_process_id].reset(handle);
+}
+
+size_t MemoryCoordinator::NumChildrenForTesting() {
+  return children_.size();
+}
+
+void MemoryCoordinator::OnConnectionError(int render_process_id) {
+  children_.erase(render_process_id);
+}
+
+}  // namespace memory_coordinator
diff --git a/components/memory_coordinator/browser/memory_coordinator.h b/components/memory_coordinator/browser/memory_coordinator.h
new file mode 100644
index 0000000..8ae02eb
--- /dev/null
+++ b/components/memory_coordinator/browser/memory_coordinator.h
@@ -0,0 +1,42 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_MEMORY_COORDINATOR_BROWSER_MEMORY_COORDINATOR_H_
+#define COMPONENTS_MEMORY_COORDINATOR_BROWSER_MEMORY_COORDINATOR_H_
+
+#include "components/memory_coordinator/public/interfaces/memory_coordinator.mojom.h"
+#include "mojo/public/cpp/bindings/binding.h"
+
+namespace memory_coordinator {
+
+class MemoryCoordinatorHandleImpl;
+
+// MemoryCoordinator is responsible for the whole memory management accross the
+// browser and child proceeses. It will dispatch memory events to its clients
+// and child processes based on its best knowledge of the memory usage.
+class MemoryCoordinator {
+ public:
+  MemoryCoordinator();
+  ~MemoryCoordinator();
+
+  void CreateHandle(int render_process_id,
+                    mojom::MemoryCoordinatorHandleRequest request);
+
+  // Returns number of children. Only used for testing.
+  size_t NumChildrenForTesting();
+
+ private:
+  void OnConnectionError(int render_process_id);
+
+  // Mappings of RenderProcessHost::GetID() -> MemoryCoordinatorHandleImpl.
+  // A mapping is added when a renderer connects to MemoryCoordinator and
+  // removed automatically when a underlying binding is disconnected.
+  std::map<int, std::unique_ptr<MemoryCoordinatorHandleImpl>> children_;
+
+  DISALLOW_COPY_AND_ASSIGN(MemoryCoordinator);
+};
+
+}  // memory_coordinator
+
+#endif  // COMPONENTS_MEMORY_COORDINATOR_BROWSER_MEMORY_COORDINATOR_H_
diff --git a/components/memory_coordinator/child/BUILD.gn b/components/memory_coordinator/child/BUILD.gn
index db58c2d..47eecb1 100644
--- a/components/memory_coordinator/child/BUILD.gn
+++ b/components/memory_coordinator/child/BUILD.gn
@@ -10,8 +10,12 @@ source_set("child") {
 
   deps = [
     "//base",
-    "//components/memory_coordinator/common",
     "//components/memory_coordinator/public/interfaces",
+    "//services/shell/public/cpp",
+  ]
+
+  public_deps = [
+    "//components/memory_coordinator/common",
   ]
 }
 
diff --git a/components/memory_coordinator/child/child_memory_coordinator_impl.cc b/components/memory_coordinator/child/child_memory_coordinator_impl.cc
index 75889ed..d1f9f6c 100644
--- a/components/memory_coordinator/child/child_memory_coordinator_impl.cc
+++ b/components/memory_coordinator/child/child_memory_coordinator_impl.cc
@@ -7,12 +7,26 @@
 namespace memory_coordinator {
 
 ChildMemoryCoordinatorImpl::ChildMemoryCoordinatorImpl(
-      mojo::InterfaceRequest<mojom::ChildMemoryCoordinator> request,
-      scoped_refptr<ClientList> clients)
-    : binding_(this, std::move(request)),
-      clients_(clients) {}
+    shell::InterfaceProvider* remote_interfaces)
+    : binding_(this), clients_(new ClientList) {
+  if (remote_interfaces) {
+    remote_interfaces->GetInterface(mojo::GetProxy(&parent_));
+    parent_->AddChild(binding_.CreateInterfacePtrAndBind());
+  }
+}
+
+ChildMemoryCoordinatorImpl::~ChildMemoryCoordinatorImpl() {
+}
 
-ChildMemoryCoordinatorImpl::~ChildMemoryCoordinatorImpl() {}
+void ChildMemoryCoordinatorImpl::RegisterClient(
+    MemoryCoordinatorClient* client) {
+  clients_->AddObserver(client);
+}
+
+void ChildMemoryCoordinatorImpl::UnregisterClient(
+    MemoryCoordinatorClient* client) {
+  clients_->RemoveObserver(client);
+}
 
 void ChildMemoryCoordinatorImpl::OnStateChange(mojom::MemoryState state) {
   clients_->Notify(FROM_HERE, &MemoryCoordinatorClient::OnMemoryStateChange,
diff --git a/components/memory_coordinator/child/child_memory_coordinator_impl.h b/components/memory_coordinator/child/child_memory_coordinator_impl.h
index bdb6376..7471c53 100644
--- a/components/memory_coordinator/child/child_memory_coordinator_impl.h
+++ b/components/memory_coordinator/child/child_memory_coordinator_impl.h
@@ -8,8 +8,11 @@
 #include "base/compiler_specific.h"
 #include "base/observer_list_threadsafe.h"
 #include "components/memory_coordinator/common/memory_coordinator_client.h"
+#include "components/memory_coordinator/common/memory_coordinator_features.h"
 #include "components/memory_coordinator/public/interfaces/child_memory_coordinator.mojom.h"
-#include "mojo/public/cpp/bindings/strong_binding.h"
+#include "components/memory_coordinator/public/interfaces/memory_coordinator.mojom.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "services/shell/public/cpp/interface_provider.h"
 
 namespace memory_coordinator {
 
@@ -19,18 +22,23 @@ namespace memory_coordinator {
 class ChildMemoryCoordinatorImpl
     : NON_EXPORTED_BASE(public mojom::ChildMemoryCoordinator) {
  public:
-  using ClientList = base::ObserverListThreadSafe<MemoryCoordinatorClient>;
-  ChildMemoryCoordinatorImpl(
-      mojo::InterfaceRequest<mojom::ChildMemoryCoordinator> request,
-      scoped_refptr<ClientList> clients);
+  ChildMemoryCoordinatorImpl(shell::InterfaceProvider* remote_interfaces);
   ~ChildMemoryCoordinatorImpl() override;
 
+  // Registers/unregisters a client. Does not take ownership of client.
+  void RegisterClient(MemoryCoordinatorClient* client);
+  void UnregisterClient(MemoryCoordinatorClient* client);
+
   // mojom::ChildMemoryCoordinator implementations:
   void OnStateChange(mojom::MemoryState state) override;
 
  private:
-  mojo::StrongBinding<mojom::ChildMemoryCoordinator> binding_;
+  friend class ChildMemoryCoordinatorImplTest;
+
+  mojo::Binding<mojom::ChildMemoryCoordinator> binding_;
+  using ClientList = base::ObserverListThreadSafe<MemoryCoordinatorClient>;
   scoped_refptr<ClientList> clients_;
+  mojom::MemoryCoordinatorHandlePtr parent_;
 
   DISALLOW_COPY_AND_ASSIGN(ChildMemoryCoordinatorImpl);
 };
diff --git a/components/memory_coordinator/child/child_memory_coordinator_impl_unittest.cc b/components/memory_coordinator/child/child_memory_coordinator_impl_unittest.cc
index 3b7db40..7486d86 100644
--- a/components/memory_coordinator/child/child_memory_coordinator_impl_unittest.cc
+++ b/components/memory_coordinator/child/child_memory_coordinator_impl_unittest.cc
@@ -13,21 +13,20 @@
 
 namespace memory_coordinator {
 
-namespace {
-
 class ChildMemoryCoordinatorImplTest : public testing::Test {
  public:
   ChildMemoryCoordinatorImplTest()
-      : clients_(new ChildMemoryCoordinatorImpl::ClientList),
-        message_loop_(new base::MessageLoop),
-        coordinator_impl_(mojo::GetProxy(&coordinator_), clients_) {}
+      : message_loop_(new base::MessageLoop),
+        coordinator_impl_(nullptr) {
+    coordinator_ = coordinator_impl_.binding_.CreateInterfacePtrAndBind();
+  }
 
   void RegisterClient(MemoryCoordinatorClient* client) {
-    clients_->AddObserver(client);
+    coordinator_impl_.RegisterClient(client);
   }
 
   void UnregisterClient(MemoryCoordinatorClient* client) {
-    clients_->RemoveObserver(client);
+    coordinator_impl_.UnregisterClient(client);
   }
 
   mojom::ChildMemoryCoordinatorPtr& coordinator() { return coordinator_; }
@@ -39,17 +38,16 @@ class ChildMemoryCoordinatorImplTest : public testing::Test {
     loop.RunUntilIdle();
   }
 
- protected:
-  scoped_refptr<ChildMemoryCoordinatorImpl::ClientList> clients_;
-
  private:
   std::unique_ptr<base::MessageLoop> message_loop_;
-  mojom::ChildMemoryCoordinatorPtr coordinator_ = nullptr;
   ChildMemoryCoordinatorImpl coordinator_impl_;
+  mojom::ChildMemoryCoordinatorPtr coordinator_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(ChildMemoryCoordinatorImplTest);
 };
 
+namespace {
+
 class MockMemoryCoordinatorClient final : public MemoryCoordinatorClient {
 public:
   void OnMemoryStateChange(mojom::MemoryState state) override {
@@ -67,12 +65,12 @@ class MemoryCoordinatorTestThread : public base::Thread,
  public:
   MemoryCoordinatorTestThread(
       const std::string& name,
-      scoped_refptr<ChildMemoryCoordinatorImpl::ClientList> clients)
-      : Thread(name), clients_(clients) {}
+      ChildMemoryCoordinatorImpl& coordinator)
+      : Thread(name), coordinator_(coordinator) {}
   ~MemoryCoordinatorTestThread() override { Stop(); }
 
   void Init() override {
-    clients_->AddObserver(this);
+    coordinator_.RegisterClient(this);
   }
 
   void OnMemoryStateChange(mojom::MemoryState state) override {
@@ -94,7 +92,7 @@ class MemoryCoordinatorTestThread : public base::Thread,
     EXPECT_EQ(state, last_state_);
   }
 
-  scoped_refptr<ChildMemoryCoordinatorImpl::ClientList> clients_;
+  ChildMemoryCoordinatorImpl& coordinator_;
   mojom::MemoryState last_state_ = mojom::MemoryState::UNKNOWN;
 };
 
@@ -114,8 +112,8 @@ TEST_F(ChildMemoryCoordinatorImplTest, SingleClient) {
 }
 
 TEST_F(ChildMemoryCoordinatorImplTest, MultipleClients) {
-  MemoryCoordinatorTestThread t1("thread 1", clients_);
-  MemoryCoordinatorTestThread t2("thread 2", clients_);
+  MemoryCoordinatorTestThread t1("thread 1", coordinator_impl());
+  MemoryCoordinatorTestThread t2("thread 2", coordinator_impl());
 
   t1.StartAndWaitForTesting();
   t2.StartAndWaitForTesting();
diff --git a/components/memory_coordinator/common/BUILD.gn b/components/memory_coordinator/common/BUILD.gn
index 950b137..a2c0f5e 100644
--- a/components/memory_coordinator/common/BUILD.gn
+++ b/components/memory_coordinator/common/BUILD.gn
@@ -5,6 +5,12 @@
 source_set("common") {
   sources = [
     "memory_coordinator_client.h",
+    "memory_coordinator_features.cc",
+    "memory_coordinator_features.h",
+  ]
+
+  deps = [
+    "//base",
   ]
 
   public_deps = [
diff --git a/components/memory_coordinator/common/memory_coordinator_features.cc b/components/memory_coordinator/common/memory_coordinator_features.cc
new file mode 100644
index 0000000..a5e892f
--- /dev/null
+++ b/components/memory_coordinator/common/memory_coordinator_features.cc
@@ -0,0 +1,24 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/feature_list.h"
+
+namespace memory_coordinator {
+
+const base::Feature kMemoryCoordinator {
+  "MemoryCoordinator", base::FEATURE_DISABLED_BY_DEFAULT
+};
+
+bool IsEnabled() {
+  return base::FeatureList::IsEnabled(kMemoryCoordinator);
+}
+
+void EnableForTesting() {
+  base::FeatureList::ClearInstanceForTesting();
+  std::unique_ptr<base::FeatureList> feature_list(new base::FeatureList);
+  feature_list->InitializeFromCommandLine(kMemoryCoordinator.name, "");
+  base::FeatureList::SetInstance(std::move(feature_list));
+}
+
+}  // namespace memory_coordinator
diff --git a/components/memory_coordinator/common/memory_coordinator_features.h b/components/memory_coordinator/common/memory_coordinator_features.h
new file mode 100644
index 0000000..8b0518a
--- /dev/null
+++ b/components/memory_coordinator/common/memory_coordinator_features.h
@@ -0,0 +1,24 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_MEMORY_COORDINATOR_COMMON_MEMORY_COORDINATOR_FEATURES_H_
+#define COMPONENTS_MEMORY_COORDINATOR_COMMON_MEMORY_COORDINATOR_FEATURES_H_
+
+#include "base/feature_list.h"
+
+// WARNING:
+// The memory coordinator is not ready for use and enabling this may cause
+// unexpected memory regression at this point. Please do not enable this.
+
+namespace memory_coordinator {
+
+// Returns true when the memory coordinator is enabled.
+bool IsEnabled();
+
+// Enables the memory coordinator for testing.
+void EnableForTesting();
+
+}  // memory_coordinator
+
+#endif  // COMPONENTS_MEMORY_COORDINATOR_COMMON_MEMORY_COORDINATOR_FEATURES_H_
diff --git a/components/memory_coordinator/public/interfaces/BUILD.gn b/components/memory_coordinator/public/interfaces/BUILD.gn
index 770bc29..95c1c6f 100644
--- a/components/memory_coordinator/public/interfaces/BUILD.gn
+++ b/components/memory_coordinator/public/interfaces/BUILD.gn
@@ -7,5 +7,6 @@ import("//mojo/public/tools/bindings/mojom.gni")
 mojom("interfaces") {
   sources = [
     "child_memory_coordinator.mojom",
+    "memory_coordinator.mojom",
   ]
 }
diff --git a/components/memory_coordinator/public/interfaces/memory_coordinator.mojom b/components/memory_coordinator/public/interfaces/memory_coordinator.mojom
new file mode 100644
index 0000000..f56250a
--- /dev/null
+++ b/components/memory_coordinator/public/interfaces/memory_coordinator.mojom
@@ -0,0 +1,14 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+module memory_coordinator.mojom;
+
+import "components/memory_coordinator/public/interfaces/child_memory_coordinator.mojom";
+
+// An interface to access the central memory coordinator from a child process.
+// The browser process creates a handle for each child process.
+interface MemoryCoordinatorHandle {
+  // A child process calls this method when ChildMemoryCoordinator is created.
+  AddChild(ChildMemoryCoordinator child);
+};
diff --git a/components/ntp_tiles/most_visited_sites.cc b/components/ntp_tiles/most_visited_sites.cc
index 236ad77..47cb499 100644
--- a/components/ntp_tiles/most_visited_sites.cc
+++ b/components/ntp_tiles/most_visited_sites.cc
@@ -6,7 +6,6 @@
 
 #include <algorithm>
 #include <set>
-#include <string>
 #include <utility>
 
 #include "base/callback.h"
@@ -26,6 +25,7 @@
 #include "components/ntp_tiles/switches.h"
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_service.h"
+#include "url/gurl.h"
 
 using history::TopSites;
 using suggestions::ChromeSuggestion;
@@ -67,9 +67,9 @@ bool ShouldShowPopularSites() {
   const std::string group_name =
       base::FieldTrialList::FindFullName(kPopularSitesFieldTrialName);
   base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
-  if (cmd_line->HasSwitch(switches::kDisableNTPPopularSites))
+  if (cmd_line->HasSwitch(ntp_tiles::switches::kDisableNTPPopularSites))
     return false;
-  if (cmd_line->HasSwitch(switches::kEnableNTPPopularSites))
+  if (cmd_line->HasSwitch(ntp_tiles::switches::kEnableNTPPopularSites))
     return true;
   return base::StartsWith(group_name, "Enabled",
                           base::CompareCase::INSENSITIVE_ASCII);
@@ -83,7 +83,7 @@ bool NeedPopularSites(const PrefService* prefs, int num_tiles) {
 
   // TODO(treib): Remove after M55.
   const base::ListValue* source_list =
-      prefs->GetList(prefs::kDeprecatedNTPSuggestionsIsPersonal);
+      prefs->GetList(ntp_tiles::prefs::kDeprecatedNTPSuggestionsIsPersonal);
   // If there aren't enough previous suggestions to fill the grid, we need
   // popular suggestions.
   if (static_cast<int>(source_list->GetSize()) < num_tiles)
@@ -119,9 +119,16 @@ std::string GetSourceHistogramName(int source) {
   return std::string();
 }
 
+void AppendSuggestions(MostVisitedSites::SuggestionsVector src,
+                       MostVisitedSites::SuggestionsVector* dst) {
+  dst->insert(dst->end(),
+              std::make_move_iterator(src.begin()),
+              std::make_move_iterator(src.end()));
+}
+
 }  // namespace
 
-MostVisitedSites::Suggestion::Suggestion() : source(TOP_SITES) {}
+MostVisitedSites::Suggestion::Suggestion() {}
 
 MostVisitedSites::Suggestion::~Suggestion() {}
 
@@ -172,7 +179,8 @@ void MostVisitedSites::SetMostVisitedURLsObserver(Observer* observer,
   observer_ = observer;
   num_sites_ = num_sites;
 
-  if (ShouldShowPopularSites() && NeedPopularSites(prefs_, num_sites_)) {
+  if (ShouldShowPopularSites() &&
+      NeedPopularSites(prefs_, num_sites_)) {
     popular_sites_.reset(new PopularSites(
         blocking_pool_, prefs_, template_url_service_, variations_service_,
         download_context_, popular_sites_directory_, false,
@@ -343,18 +351,18 @@ void MostVisitedSites::OnSuggestionsProfileAvailable(
 
   SuggestionsVector suggestions;
   for (int i = 0; i < num_tiles; ++i) {
-    const ChromeSuggestion& suggestion_pb = suggestions_profile.suggestions(i);
-    GURL url(suggestion_pb.url());
-    if (supervisor_->IsBlocked(url))
+    const ChromeSuggestion& suggestion = suggestions_profile.suggestions(i);
+    if (supervisor_->IsBlocked(GURL(suggestion.url())))
       continue;
 
-    Suggestion suggestion;
-    suggestion.title = base::UTF8ToUTF16(suggestion_pb.title());
-    suggestion.url = url;
-    suggestion.source = SUGGESTIONS_SERVICE;
-    suggestion.whitelist_icon_path = GetWhitelistLargeIconPath(url);
+    Suggestion generated_suggestion;
+    generated_suggestion.title = base::UTF8ToUTF16(suggestion.title());
+    generated_suggestion.url = GURL(suggestion.url());
+    generated_suggestion.source = SUGGESTIONS_SERVICE;
+    generated_suggestion.whitelist_icon_path =
+        GetWhitelistLargeIconPath(GURL(suggestion.url()));
 
-    suggestions.push_back(std::move(suggestion));
+    suggestions.push_back(std::move(generated_suggestion));
   }
 
   received_most_visited_sites_ = true;
@@ -484,12 +492,9 @@ MostVisitedSites::SuggestionsVector MostVisitedSites::MergeSuggestions(
     SuggestionsVector whitelist_suggestions,
     SuggestionsVector popular_suggestions) {
   SuggestionsVector merged_suggestions;
-  std::move(personal_suggestions.begin(), personal_suggestions.end(),
-            std::back_inserter(merged_suggestions));
-  std::move(whitelist_suggestions.begin(), whitelist_suggestions.end(),
-            std::back_inserter(merged_suggestions));
-  std::move(popular_suggestions.begin(), popular_suggestions.end(),
-            std::back_inserter(merged_suggestions));
+  AppendSuggestions(std::move(personal_suggestions), &merged_suggestions);
+  AppendSuggestions(std::move(whitelist_suggestions), &merged_suggestions);
+  AppendSuggestions(std::move(popular_suggestions), &merged_suggestions);
   return merged_suggestions;
 }
 
diff --git a/components/ntp_tiles/most_visited_sites.h b/components/ntp_tiles/most_visited_sites.h
index 2d77e18..236f19e 100644
--- a/components/ntp_tiles/most_visited_sites.h
+++ b/components/ntp_tiles/most_visited_sites.h
@@ -8,6 +8,7 @@
 #include <stddef.h>
 
 #include <memory>
+#include <string>
 #include <vector>
 
 #include "base/compiler_specific.h"
@@ -15,7 +16,6 @@
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/scoped_observer.h"
-#include "base/strings/string16.h"
 #include "components/history/core/browser/history_types.h"
 #include "components/history/core/browser/top_sites_observer.h"
 #include "components/ntp_tiles/popular_sites.h"
@@ -27,6 +27,10 @@ namespace history {
 class TopSites;
 }
 
+namespace suggestions {
+class SuggestionsService;
+}
+
 namespace user_prefs {
 class PrefRegistrySyncable;
 }
diff --git a/components/password_manager/content/browser/credential_manager_impl.cc b/components/password_manager/content/browser/credential_manager_impl.cc
index b303a71..ba0cf7d 100644
--- a/components/password_manager/content/browser/credential_manager_impl.cc
+++ b/components/password_manager/content/browser/credential_manager_impl.cc
@@ -264,6 +264,8 @@ autofill::PasswordForm CredentialManagerImpl::GetSynthesizedFormForOrigin()
   synthetic_form.origin = web_contents()->GetLastCommittedURL().GetOrigin();
   synthetic_form.signon_realm = synthetic_form.origin.spec();
   synthetic_form.scheme = autofill::PasswordForm::SCHEME_HTML;
+  synthetic_form.ssl_valid = synthetic_form.origin.SchemeIsCryptographic() &&
+                             !client_->DidLastPageLoadEncounterSSLErrors();
   return synthetic_form;
 }
 
diff --git a/components/password_manager/content/browser/credential_manager_impl_unittest.cc b/components/password_manager/content/browser/credential_manager_impl_unittest.cc
index 9628dba..60448a4 100644
--- a/components/password_manager/content/browser/credential_manager_impl_unittest.cc
+++ b/components/password_manager/content/browser/credential_manager_impl_unittest.cc
@@ -224,6 +224,7 @@ class CredentialManagerImplTest : public content::RenderViewHostTestHarness {
     form_.signon_realm = form_.origin.spec();
     form_.scheme = autofill::PasswordForm::SCHEME_HTML;
     form_.skip_zero_click = false;
+    form_.ssl_valid = true;
 
     affiliated_form1_.username_value = base::ASCIIToUTF16("Affiliated 1");
     affiliated_form1_.display_name = base::ASCIIToUTF16("Display Name");
@@ -232,6 +233,7 @@ class CredentialManagerImplTest : public content::RenderViewHostTestHarness {
     affiliated_form1_.signon_realm = kTestAndroidRealm1;
     affiliated_form1_.scheme = autofill::PasswordForm::SCHEME_HTML;
     affiliated_form1_.skip_zero_click = false;
+    affiliated_form1_.ssl_valid = true;
 
     affiliated_form2_.username_value = base::ASCIIToUTF16("Affiliated 2");
     affiliated_form2_.display_name = base::ASCIIToUTF16("Display Name");
@@ -240,6 +242,7 @@ class CredentialManagerImplTest : public content::RenderViewHostTestHarness {
     affiliated_form2_.signon_realm = kTestAndroidRealm2;
     affiliated_form2_.scheme = autofill::PasswordForm::SCHEME_HTML;
     affiliated_form2_.skip_zero_click = false;
+    affiliated_form2_.ssl_valid = true;
 
     origin_path_form_.username_value = base::ASCIIToUTF16("Username 2");
     origin_path_form_.display_name = base::ASCIIToUTF16("Display Name 2");
@@ -1221,6 +1224,7 @@ TEST_F(CredentialManagerImplTest, GetSynthesizedFormForOrigin) {
   EXPECT_EQ(kTestWebOrigin, synthesized.origin.spec());
   EXPECT_EQ(kTestWebOrigin, synthesized.signon_realm);
   EXPECT_EQ(autofill::PasswordForm::SCHEME_HTML, synthesized.scheme);
+  EXPECT_TRUE(synthesized.ssl_valid);
 }
 
 TEST_F(CredentialManagerImplTest, BlacklistPasswordCredential) {
@@ -1245,6 +1249,7 @@ TEST_F(CredentialManagerImplTest, BlacklistPasswordCredential) {
   blacklisted.origin = form_.origin;
   blacklisted.signon_realm = form_.signon_realm;
   blacklisted.type = autofill::PasswordForm::TYPE_API;
+  blacklisted.ssl_valid = true;
   blacklisted.date_created = passwords[form_.signon_realm][0].date_created;
   EXPECT_THAT(passwords[form_.signon_realm], testing::ElementsAre(blacklisted));
 }
@@ -1275,6 +1280,7 @@ TEST_F(CredentialManagerImplTest, BlacklistFederatedCredential) {
   blacklisted.origin = form_.origin;
   blacklisted.signon_realm = blacklisted.origin.spec();
   blacklisted.type = autofill::PasswordForm::TYPE_API;
+  blacklisted.ssl_valid = true;
   blacklisted.date_created =
       passwords[blacklisted.signon_realm][0].date_created;
   EXPECT_THAT(passwords[blacklisted.signon_realm],
@@ -1286,6 +1292,7 @@ TEST_F(CredentialManagerImplTest, RespectBlacklistingPasswordCredential) {
   blacklisted.blacklisted_by_user = true;
   blacklisted.origin = form_.origin;
   blacklisted.signon_realm = blacklisted.origin.spec();
+  blacklisted.ssl_valid = true;
   store_->AddLogin(blacklisted);
 
   CredentialInfo info(form_, CredentialType::CREDENTIAL_TYPE_PASSWORD);
@@ -1305,6 +1312,7 @@ TEST_F(CredentialManagerImplTest, RespectBlacklistingFederatedCredential) {
   blacklisted.blacklisted_by_user = true;
   blacklisted.origin = form_.origin;
   blacklisted.signon_realm = blacklisted.origin.spec();
+  blacklisted.ssl_valid = true;
   store_->AddLogin(blacklisted);
 
   form_.federation_origin = url::Origin(GURL("https://example.com/"));
diff --git a/components/password_manager/core/browser/BUILD.gn b/components/password_manager/core/browser/BUILD.gn
index 2c1152c..e4c2541 100644
--- a/components/password_manager/core/browser/BUILD.gn
+++ b/components/password_manager/core/browser/BUILD.gn
@@ -216,7 +216,6 @@ bundle_data("unit_tests_bundle_data") {
     "//components/test/data/password_manager/login_db_v15.sql",
     "//components/test/data/password_manager/login_db_v16.sql",
     "//components/test/data/password_manager/login_db_v17.sql",
-    "//components/test/data/password_manager/login_db_v18.sql",
     "//components/test/data/password_manager/login_db_v1_broken.sql",
     "//components/test/data/password_manager/login_db_v2.sql",
     "//components/test/data/password_manager/login_db_v2_broken.sql",
diff --git a/components/password_manager/core/browser/affiliated_match_helper.cc b/components/password_manager/core/browser/affiliated_match_helper.cc
index ee18665..dc56945 100644
--- a/components/password_manager/core/browser/affiliated_match_helper.cc
+++ b/components/password_manager/core/browser/affiliated_match_helper.cc
@@ -140,7 +140,7 @@ bool AffiliatedMatchHelper::IsValidAndroidCredential(
 bool AffiliatedMatchHelper::IsValidWebCredential(
     const autofill::PasswordForm& form) {
   FacetURI facet_uri(FacetURI::FromPotentiallyInvalidSpec(form.signon_realm));
-  return form.scheme == autofill::PasswordForm::SCHEME_HTML &&
+  return form.scheme == autofill::PasswordForm::SCHEME_HTML && form.ssl_valid &&
          facet_uri.IsValidWebFacetURI();
 }
 
diff --git a/components/password_manager/core/browser/affiliated_match_helper_unittest.cc b/components/password_manager/core/browser/affiliated_match_helper_unittest.cc
index a8b8c94..79694ff 100644
--- a/components/password_manager/core/browser/affiliated_match_helper_unittest.cc
+++ b/components/password_manager/core/browser/affiliated_match_helper_unittest.cc
@@ -144,6 +144,7 @@ autofill::PasswordForm GetTestAndroidCredentials(const char* signon_realm) {
   form.signon_realm = signon_realm;
   form.username_value = base::ASCIIToUTF16(kTestUsername);
   form.password_value = base::ASCIIToUTF16(kTestPassword);
+  form.ssl_valid = true;
   return form;
 }
 
@@ -161,6 +162,7 @@ autofill::PasswordForm GetTestObservedWebForm(const char* signon_realm,
   form.signon_realm = signon_realm;
   if (origin)
     form.origin = GURL(origin);
+  form.ssl_valid = true;
   return form;
 }
 
@@ -378,6 +380,15 @@ TEST_F(AffiliatedMatchHelperTest,
 }
 
 TEST_F(AffiliatedMatchHelperTest,
+       GetAffiliatedAndroidRealmsYieldsEmptyResultsForInsecureForms) {
+  autofill::PasswordForm insecure_observed_form(
+      GetTestObservedWebForm(kTestWebRealmAlpha1, nullptr));
+  insecure_observed_form.ssl_valid = false;
+  EXPECT_THAT(GetAffiliatedAndroidRealms(insecure_observed_form),
+              testing::IsEmpty());
+}
+
+TEST_F(AffiliatedMatchHelperTest,
        GetAffiliatedAndroidRealmsYieldsEmptyResultsForHTTPBasicAuthForms) {
   autofill::PasswordForm http_auth_observed_form(
       GetTestObservedWebForm(kTestWebRealmAlpha1, nullptr));
diff --git a/components/password_manager/core/browser/credential_manager_password_form_manager.cc b/components/password_manager/core/browser/credential_manager_password_form_manager.cc
index 91bdbdc..a23a38a 100644
--- a/components/password_manager/core/browser/credential_manager_password_form_manager.cc
+++ b/components/password_manager/core/browser/credential_manager_password_form_manager.cc
@@ -28,6 +28,7 @@ CredentialManagerPasswordFormManager::CredentialManagerPasswordFormManager(
           client,
           driver,
           observed_form,
+          true,
           base::WrapUnique(new FormSaverImpl(client->GetPasswordStore()))),
       delegate_(delegate),
       saved_form_(std::move(saved_form)) {
diff --git a/components/password_manager/core/browser/login_database.cc b/components/password_manager/core/browser/login_database.cc
index 3c227a2..a353245 100644
--- a/components/password_manager/core/browser/login_database.cc
+++ b/components/password_manager/core/browser/login_database.cc
@@ -42,10 +42,10 @@ using autofill::PasswordForm;
 namespace password_manager {
 
 // The current version number of the login database schema.
-const int kCurrentVersionNumber = 18;
+const int kCurrentVersionNumber = 17;
 // The oldest version of the schema such that a legacy Chrome client using that
 // version can still read/write the current database.
-const int kCompatibleVersionNumber = 18;
+const int kCompatibleVersionNumber = 14;
 
 base::Pickle SerializeVector(const std::vector<base::string16>& vec) {
   base::Pickle p;
@@ -78,6 +78,7 @@ enum LoginTableColumns {
   COLUMN_PASSWORD_VALUE,
   COLUMN_SUBMIT_ELEMENT,
   COLUMN_SIGNON_REALM,
+  COLUMN_SSL_VALID,
   COLUMN_PREFERRED,
   COLUMN_DATE_CREATED,
   COLUMN_BLACKLISTED_BY_USER,
@@ -124,6 +125,7 @@ void BindAddStatement(const PasswordForm& form,
               static_cast<int>(encrypted_password.length()));
   s->BindString16(COLUMN_SUBMIT_ELEMENT, form.submit_element);
   s->BindString(COLUMN_SIGNON_REALM, form.signon_realm);
+  s->BindInt(COLUMN_SSL_VALID, form.ssl_valid);
   s->BindInt(COLUMN_PREFERRED, form.preferred);
   s->BindInt64(COLUMN_DATE_CREATED, form.date_created.ToInternalValue());
   s->BindInt(COLUMN_BLACKLISTED_BY_USER, form.blacklisted_by_user);
@@ -424,11 +426,6 @@ void InitializeBuilder(SQLTableBuilder* builder) {
   version = builder->SealVersion();
   DCHECK_EQ(17u, version);
 
-  // Version 18.
-  builder->DropColumn("ssl_valid");
-  version = builder->SealVersion();
-  DCHECK_EQ(18u, version);
-
   DCHECK_EQ(static_cast<size_t>(COLUMN_NUM), builder->NumberOfColumns())
       << "Adjust LoginTableColumns if you change column definitions here.";
 }
@@ -731,7 +728,8 @@ void LoginDatabase::ReportMetrics(const std::string& sync_username,
   }
 
   sql::Statement logins_with_schemes_statement(db_.GetUniqueStatement(
-      "SELECT signon_realm, origin_url, blacklisted_by_user FROM logins;"));
+      "SELECT signon_realm, origin_url, ssl_valid, blacklisted_by_user "
+      "FROM logins;"));
 
   if (!logins_with_schemes_statement.is_valid())
     return;
@@ -745,7 +743,8 @@ void LoginDatabase::ReportMetrics(const std::string& sync_username,
   while (logins_with_schemes_statement.Step()) {
     std::string signon_realm = logins_with_schemes_statement.ColumnString(0);
     GURL origin_url = GURL(logins_with_schemes_statement.ColumnString(1));
-    bool blacklisted_by_user = !!logins_with_schemes_statement.ColumnInt(2);
+    bool ssl_valid = !!logins_with_schemes_statement.ColumnInt(2);
+    bool blacklisted_by_user = !!logins_with_schemes_statement.ColumnInt(3);
     if (blacklisted_by_user)
       continue;
 
@@ -753,6 +752,8 @@ void LoginDatabase::ReportMetrics(const std::string& sync_username,
       ++android_logins;
     } else if (origin_url.SchemeIs(url::kHttpsScheme)) {
       ++https_logins;
+      metrics_util::LogUMAHistogramBoolean(
+          "PasswordManager.UserStoredPasswordWithInvalidSSLCert", !ssl_valid);
     } else if (origin_url.SchemeIs(url::kHttpScheme)) {
       ++http_logins;
     } else if (origin_url.SchemeIs(url::kFtpScheme)) {
@@ -841,33 +842,34 @@ PasswordStoreChangeList LoginDatabase::UpdateLogin(const PasswordForm& form) {
   s.BindBlob(1, encrypted_password.data(),
              static_cast<int>(encrypted_password.length()));
   s.BindString16(2, form.submit_element);
-  s.BindInt(3, form.preferred);
-  s.BindInt64(4, form.date_created.ToInternalValue());
-  s.BindInt(5, form.blacklisted_by_user);
-  s.BindInt(6, form.scheme);
-  s.BindInt(7, form.type);
+  s.BindInt(3, form.ssl_valid);
+  s.BindInt(4, form.preferred);
+  s.BindInt64(5, form.date_created.ToInternalValue());
+  s.BindInt(6, form.blacklisted_by_user);
+  s.BindInt(7, form.scheme);
+  s.BindInt(8, form.type);
   base::Pickle pickle = SerializeVector(form.other_possible_usernames);
-  s.BindBlob(8, pickle.data(), pickle.size());
-  s.BindInt(9, form.times_used);
+  s.BindBlob(9, pickle.data(), pickle.size());
+  s.BindInt(10, form.times_used);
   base::Pickle form_data_pickle;
   autofill::SerializeFormData(form.form_data, &form_data_pickle);
-  s.BindBlob(10, form_data_pickle.data(), form_data_pickle.size());
-  s.BindInt64(11, form.date_synced.ToInternalValue());
-  s.BindString16(12, form.display_name);
-  s.BindString(13, form.icon_url.spec());
+  s.BindBlob(11, form_data_pickle.data(), form_data_pickle.size());
+  s.BindInt64(12, form.date_synced.ToInternalValue());
+  s.BindString16(13, form.display_name);
+  s.BindString(14, form.icon_url.spec());
   // An empty Origin serializes as "null" which would be strange to store here.
-  s.BindString(14, form.federation_origin.unique()
+  s.BindString(15, form.federation_origin.unique()
                        ? std::string()
                        : form.federation_origin.Serialize());
-  s.BindInt(15, form.skip_zero_click);
-  s.BindInt(16, form.generation_upload_status);
+  s.BindInt(16, form.skip_zero_click);
+  s.BindInt(17, form.generation_upload_status);
 
   // WHERE starts here.
-  s.BindString(17, form.origin.spec());
-  s.BindString16(18, form.username_element);
-  s.BindString16(19, form.username_value);
-  s.BindString16(20, form.password_element);
-  s.BindString(21, form.signon_realm);
+  s.BindString(18, form.origin.spec());
+  s.BindString16(19, form.username_element);
+  s.BindString16(20, form.username_value);
+  s.BindString16(21, form.password_element);
+  s.BindString(22, form.signon_realm);
 
   if (!s.Run())
     return PasswordStoreChangeList();
@@ -980,6 +982,7 @@ LoginDatabase::EncryptionResult LoginDatabase::InitPasswordFormFromStatement(
   form->submit_element = s.ColumnString16(COLUMN_SUBMIT_ELEMENT);
   tmp = s.ColumnString(COLUMN_SIGNON_REALM);
   form->signon_realm = tmp;
+  form->ssl_valid = (s.ColumnInt(COLUMN_SSL_VALID) > 0);
   form->preferred = (s.ColumnInt(COLUMN_PREFERRED) > 0);
   form->date_created =
       base::Time::FromInternalValue(s.ColumnInt64(COLUMN_DATE_CREATED));
diff --git a/components/password_manager/core/browser/login_database_unittest.cc b/components/password_manager/core/browser/login_database_unittest.cc
index b9c7983..73226b5 100644
--- a/components/password_manager/core/browser/login_database_unittest.cc
+++ b/components/password_manager/core/browser/login_database_unittest.cc
@@ -55,6 +55,7 @@ void GenerateExamplePasswordForm(PasswordForm* form) {
   form->password_value = ASCIIToUTF16("test");
   form->submit_element = ASCIIToUTF16("signIn");
   form->signon_realm = "http://www.google.com/";
+  form->ssl_valid = false;
   form->preferred = false;
   form->scheme = PasswordForm::SCHEME_HTML;
   form->times_used = 1;
@@ -255,6 +256,7 @@ TEST_F(LoginDatabaseTest, Logins) {
   // Imagine the site moves to a secure server for login.
   PasswordForm form4(form3);
   form4.signon_realm = "https://www.google.com/";
+  form4.ssl_valid = true;
 
   // We have only an http record, so no match for this.
   EXPECT_TRUE(db().GetLogins(form4, &result));
@@ -281,14 +283,24 @@ TEST_F(LoginDatabaseTest, Logins) {
   EXPECT_TRUE(db().GetLogins(form, &result));
   EXPECT_EQ(0U, result.size());
 
-  // User changes their password.
+  // The user's request for the HTTPS site is intercepted
+  // by an attacker who presents an invalid SSL cert.
   PasswordForm form5(form4);
-  form5.password_value = ASCIIToUTF16("test6");
-  form5.preferred = true;
+  form5.ssl_valid = 0;
+
+  // It will match in this case.
+  EXPECT_TRUE(db().GetLogins(form5, &result));
+  EXPECT_EQ(1U, result.size());
+  result.clear();
+
+  // User changes their password.
+  PasswordForm form6(form5);
+  form6.password_value = ASCIIToUTF16("test6");
+  form6.preferred = true;
 
   // We update, and check to make sure it matches the
   // old form, and there is only one record.
-  EXPECT_EQ(UpdateChangeForForm(form5), db().UpdateLogin(form5));
+  EXPECT_EQ(UpdateChangeForForm(form6), db().UpdateLogin(form6));
   // matches
   EXPECT_TRUE(db().GetLogins(form5, &result));
   EXPECT_EQ(1U, result.size());
@@ -297,9 +309,9 @@ TEST_F(LoginDatabaseTest, Logins) {
   EXPECT_TRUE(db().GetAutofillableLogins(&result));
   EXPECT_EQ(1U, result.size());
   // Password element was updated.
-  EXPECT_EQ(form5.password_value, result[0]->password_value);
+  EXPECT_EQ(form6.password_value, result[0]->password_value);
   // Preferred login.
-  EXPECT_TRUE(form5.preferred);
+  EXPECT_TRUE(form6.preferred);
   result.clear();
 
   // Make sure everything can disappear.
@@ -325,6 +337,7 @@ TEST_F(LoginDatabaseTest, TestPublicSuffixDomainMatching) {
   form.password_value = ASCIIToUTF16("test");
   form.submit_element = ASCIIToUTF16("");
   form.signon_realm = "https://foo.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -370,6 +383,7 @@ TEST_F(LoginDatabaseTest, TestFederatedMatching) {
   form.username_value = ASCIIToUTF16("test@gmail.com");
   form.password_value = ASCIIToUTF16("test");
   form.signon_realm = "https://foo.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -444,6 +458,7 @@ TEST_F(LoginDatabaseTest, TestPublicSuffixDomainMatchingShouldMatchingApply) {
   form.password_value = ASCIIToUTF16("test");
   form.submit_element = ASCIIToUTF16("");
   form.signon_realm = "https://accounts.google.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -483,6 +498,7 @@ TEST_F(LoginDatabaseTest, TestFederatedMatchingWithoutPSLMatching) {
   form.username_value = ASCIIToUTF16("test@gmail.com");
   form.password_value = ASCIIToUTF16("test");
   form.signon_realm = "https://accounts.google.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -539,6 +555,7 @@ TEST_F(LoginDatabaseTest, TestPublicSuffixDomainMatchingDifferentSites) {
   form.password_value = ASCIIToUTF16("test");
   form.submit_element = ASCIIToUTF16("");
   form.signon_realm = "https://foo.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -575,6 +592,7 @@ TEST_F(LoginDatabaseTest, TestPublicSuffixDomainMatchingDifferentSites) {
   form.password_value = ASCIIToUTF16("test");
   form.submit_element = ASCIIToUTF16("");
   form.signon_realm = "https://baz.com/";
+  form.ssl_valid = true;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -624,6 +642,7 @@ TEST_F(LoginDatabaseTest, TestPublicSuffixDomainMatchingRegexp) {
   form.password_value = ASCIIToUTF16("test");
   form.submit_element = ASCIIToUTF16("");
   form.signon_realm = "http://foo.com/";
+  form.ssl_valid = false;
   form.preferred = false;
   form.scheme = PasswordForm::SCHEME_HTML;
 
@@ -894,6 +913,7 @@ TEST_F(LoginDatabaseTest, BlacklistedLogins) {
   form.password_element = ASCIIToUTF16("Passwd");
   form.submit_element = ASCIIToUTF16("signIn");
   form.signon_realm = "http://www.google.com/";
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = true;
   form.scheme = PasswordForm::SCHEME_HTML;
@@ -953,6 +973,7 @@ TEST_F(LoginDatabaseTest, UpdateIncompleteCredentials) {
   incomplete_form.signon_realm = "http://accounts.google.com/";
   incomplete_form.username_value = ASCIIToUTF16("my_username");
   incomplete_form.password_value = ASCIIToUTF16("my_password");
+  incomplete_form.ssl_valid = false;
   incomplete_form.preferred = true;
   incomplete_form.blacklisted_by_user = false;
   incomplete_form.scheme = PasswordForm::SCHEME_HTML;
@@ -975,6 +996,7 @@ TEST_F(LoginDatabaseTest, UpdateIncompleteCredentials) {
   EXPECT_EQ(incomplete_form.username_value, result[0]->username_value);
   EXPECT_EQ(incomplete_form.password_value, result[0]->password_value);
   EXPECT_TRUE(result[0]->preferred);
+  EXPECT_FALSE(result[0]->ssl_valid);
 
   // We should return empty 'action', 'username_element', 'password_element'
   // and 'submit_element' as we can't be sure if the credentials were entered
@@ -1016,6 +1038,7 @@ TEST_F(LoginDatabaseTest, UpdateOverlappingCredentials) {
   incomplete_form.signon_realm = "http://accounts.google.com/";
   incomplete_form.username_value = ASCIIToUTF16("my_username");
   incomplete_form.password_value = ASCIIToUTF16("my_password");
+  incomplete_form.ssl_valid = false;
   incomplete_form.preferred = true;
   incomplete_form.blacklisted_by_user = false;
   incomplete_form.scheme = PasswordForm::SCHEME_HTML;
@@ -1062,6 +1085,7 @@ TEST_F(LoginDatabaseTest, DoubleAdd) {
   form.signon_realm = "http://accounts.google.com/";
   form.username_value = ASCIIToUTF16("my_username");
   form.password_value = ASCIIToUTF16("my_password");
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = false;
   form.scheme = PasswordForm::SCHEME_HTML;
@@ -1082,6 +1106,7 @@ TEST_F(LoginDatabaseTest, AddWrongForm) {
   form.signon_realm = "http://accounts.google.com/";
   form.username_value = ASCIIToUTF16("my_username");
   form.password_value = ASCIIToUTF16("my_password");
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = false;
   form.scheme = PasswordForm::SCHEME_HTML;
@@ -1099,6 +1124,7 @@ TEST_F(LoginDatabaseTest, UpdateLogin) {
   form.signon_realm = "http://accounts.google.com/";
   form.username_value = ASCIIToUTF16("my_username");
   form.password_value = ASCIIToUTF16("my_password");
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = false;
   form.scheme = PasswordForm::SCHEME_HTML;
@@ -1106,6 +1132,7 @@ TEST_F(LoginDatabaseTest, UpdateLogin) {
 
   form.action = GURL("http://accounts.google.com/login");
   form.password_value = ASCIIToUTF16("my_new_password");
+  form.ssl_valid = true;
   form.preferred = false;
   form.other_possible_usernames.push_back(ASCIIToUTF16("my_new_username"));
   form.times_used = 20;
@@ -1134,6 +1161,7 @@ TEST_F(LoginDatabaseTest, RemoveWrongForm) {
   form.signon_realm = "http://accounts.google.com/";
   form.username_value = ASCIIToUTF16("my_username");
   form.password_value = ASCIIToUTF16("my_password");
+  form.ssl_valid = false;
   form.preferred = true;
   form.blacklisted_by_user = false;
   form.scheme = PasswordForm::SCHEME_HTML;
diff --git a/components/password_manager/core/browser/password_form_manager.cc b/components/password_manager/core/browser/password_form_manager.cc
index c3f9e10..f018d34 100644
--- a/components/password_manager/core/browser/password_form_manager.cc
+++ b/components/password_manager/core/browser/password_form_manager.cc
@@ -52,6 +52,13 @@ namespace password_manager {
 
 namespace {
 
+PasswordForm CopyAndModifySSLValidity(const PasswordForm& orig,
+                                      bool ssl_valid) {
+  PasswordForm result(orig);
+  result.ssl_valid = ssl_valid;
+  return result;
+}
+
 // Returns true if user-typed username and password field values match with one
 // of the password form within |credentials| map; otherwise false.
 bool DoesUsenameAndPasswordMatchCredentials(
@@ -165,8 +172,9 @@ PasswordFormManager::PasswordFormManager(
     PasswordManagerClient* client,
     const base::WeakPtr<PasswordManagerDriver>& driver,
     const PasswordForm& observed_form,
+    bool ssl_valid,
     std::unique_ptr<FormSaver> form_saver)
-    : observed_form_(observed_form),
+    : observed_form_(CopyAndModifySSLValidity(observed_form, ssl_valid)),
       provisionally_saved_form_(nullptr),
       other_possible_username_action_(
           PasswordFormManager::IGNORE_OTHER_POSSIBLE_USERNAMES),
@@ -480,6 +488,12 @@ void PasswordFormManager::OnRequestDone(
   }
 
   // Remove credentials which need to be ignored from |logins_result|.
+  if (!observed_form_.ssl_valid) {
+    logins_result.erase(
+        std::partition(logins_result.begin(), logins_result.end(),
+                       [](PasswordForm* form) { return !form->ssl_valid; }),
+        logins_result.end());
+  }
   logins_result =
       client_->GetStoreResultFilter()->FilterResults(std::move(logins_result));
 
diff --git a/components/password_manager/core/browser/password_form_manager.h b/components/password_manager/core/browser/password_form_manager.h
index 10f6039..faaa9ce 100644
--- a/components/password_manager/core/browser/password_form_manager.h
+++ b/components/password_manager/core/browser/password_form_manager.h
@@ -35,10 +35,13 @@ class PasswordFormManager : public PasswordStoreConsumer {
  public:
   // |password_manager| owns this object
   // |form_on_page| is the form that may be submitted and could need login data.
+  // |ssl_valid| represents the security of the page containing observed_form,
+  //           used to filter login results from database.
   PasswordFormManager(PasswordManager* password_manager,
                       PasswordManagerClient* client,
                       const base::WeakPtr<PasswordManagerDriver>& driver,
                       const autofill::PasswordForm& observed_form,
+                      bool ssl_valid,
                       std::unique_ptr<FormSaver> form_saver);
   ~PasswordFormManager() override;
 
diff --git a/components/password_manager/core/browser/password_form_manager_unittest.cc b/components/password_manager/core/browser/password_form_manager_unittest.cc
index 56e79a1..e6c0b93 100644
--- a/components/password_manager/core/browser/password_form_manager_unittest.cc
+++ b/components/password_manager/core/browser/password_form_manager_unittest.cc
@@ -416,7 +416,7 @@ class PasswordFormManagerTest : public testing::Test {
     password_manager_.reset(new PasswordManager(client_.get()));
     form_manager_.reset(new PasswordFormManager(
         password_manager_.get(), client_.get(), client_.get()->driver(),
-        observed_form_, base::WrapUnique(new MockFormSaver())));
+        observed_form_, false, base::WrapUnique(new MockFormSaver())));
   }
 
   void TearDown() override {
@@ -458,7 +458,7 @@ class PasswordFormManagerTest : public testing::Test {
     form.form_data = observed_form_data;
 
     PasswordFormManager form_manager(password_manager(), client(),
-                                     client()->driver(), form,
+                                     client()->driver(), form, false,
                                      base::WrapUnique(new MockFormSaver()));
     ScopedVector<PasswordForm> result;
     result.push_back(CreateSavedMatch(false));
@@ -535,9 +535,9 @@ class PasswordFormManagerTest : public testing::Test {
     observed_form()->form_data.fields.push_back(field);
 
     client()->set_is_update_password_ui_enabled(true);
-    PasswordFormManager form_manager(password_manager(), client(),
-                                     client()->driver(), *observed_form(),
-                                     base::WrapUnique(new MockFormSaver()));
+    PasswordFormManager form_manager(
+        password_manager(), client(), client()->driver(), *observed_form(),
+        false, base::WrapUnique(new MockFormSaver()));
 
     SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
 
@@ -665,7 +665,7 @@ class PasswordFormManagerTest : public testing::Test {
     }
 
     PasswordFormManager form_manager(password_manager(), client(),
-                                     client()->driver(), form,
+                                     client()->driver(), form, false,
                                      base::WrapUnique(new MockFormSaver()));
 
     ScopedVector<PasswordForm> result;
@@ -852,7 +852,7 @@ TEST_F(PasswordFormManagerTest, TestBlacklistMatching) {
   observed_form()->action = GURL("http://accounts.google.com/a/Login");
   observed_form()->signon_realm = "http://accounts.google.com";
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   form_manager.SimulateFetchMatchingLoginsFromPasswordStore();
 
@@ -991,7 +991,7 @@ TEST_F(PasswordFormManagerTest, TestNewLoginFromNewPasswordElement) {
   observed_form()->username_marked_by_site = true;
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_NO_MATCH);
 
@@ -1072,7 +1072,7 @@ TEST_F(PasswordFormManagerTest, TestUpdatePasswordFromNewPasswordElement) {
   saved_match()->submit_element.clear();
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
 
@@ -1113,6 +1113,31 @@ TEST_F(PasswordFormManagerTest, TestUpdatePasswordFromNewPasswordElement) {
   EXPECT_EQ(saved_match()->submit_element, new_credentials.submit_element);
 }
 
+TEST_F(PasswordFormManagerTest, TestIgnoreResult_SSL) {
+  const bool kObservedFormSSLValid = false;
+  PasswordFormManager form_manager(
+      password_manager(), client(), client()->driver(), *observed_form(),
+      kObservedFormSSLValid, base::WrapUnique(new MockFormSaver()));
+
+  PasswordForm saved_form = *observed_form();
+  saved_form.ssl_valid = !kObservedFormSSLValid;
+  saved_form.username_value = ASCIIToUTF16("test1@gmail.com");
+  ScopedVector<PasswordForm> result;
+  result.push_back(new PasswordForm(saved_form));
+  saved_form.username_value = ASCIIToUTF16("test2@gmail.com");
+  result.push_back(new PasswordForm(saved_form));
+  saved_form.username_value = ASCIIToUTF16("test3@gmail.com");
+  saved_form.ssl_valid = kObservedFormSSLValid;
+  result.push_back(new PasswordForm(saved_form));
+  form_manager.SimulateFetchMatchingLoginsFromPasswordStore();
+  form_manager.OnGetPasswordStoreResults(std::move(result));
+
+  // Make sure we don't match a PasswordForm if it was originally saved on
+  // an SSL-valid page and we are now on a page with invalid certificate.
+  EXPECT_EQ(1u, form_manager.best_matches().count(saved_form.username_value));
+  EXPECT_EQ(1u, form_manager.best_matches().size());
+}
+
 TEST_F(PasswordFormManagerTest, TestIgnoreResult_Paths) {
   PasswordForm observed(*observed_form());
   observed.origin = GURL("https://accounts.google.com/a/LoginAuth");
@@ -1120,7 +1145,7 @@ TEST_F(PasswordFormManagerTest, TestIgnoreResult_Paths) {
   observed.signon_realm = "https://accounts.google.com";
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), observed,
+                                   client()->driver(), observed, false,
                                    base::WrapUnique(new MockFormSaver()));
 
   PasswordForm saved_form = observed;
@@ -1142,7 +1167,7 @@ TEST_F(PasswordFormManagerTest, TestIgnoreResult_IgnoredCredentials) {
   observed.signon_realm = "https://accounts.google.com";
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), observed,
+                                   client()->driver(), observed, false,
                                    base::WrapUnique(new MockFormSaver()));
   client()->FilterAllResults();
 
@@ -1309,7 +1334,7 @@ TEST_F(PasswordFormManagerTest,
   signup_form.new_password_element = base::ASCIIToUTF16("new_password_field");
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), signup_form,
+                                   client()->driver(), signup_form, false,
                                    base::WrapUnique(new MockFormSaver()));
   EXPECT_CALL(*(client()->mock_driver()), AllowPasswordGenerationForForm(_))
       .Times(1);
@@ -1477,7 +1502,7 @@ TEST_F(PasswordFormManagerTest, TestUpdateIncompleteCredentials) {
   EXPECT_CALL(*(client()->mock_driver()), AllowPasswordGenerationForForm(_));
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), encountered_form,
+                                   client()->driver(), encountered_form, false,
                                    base::WrapUnique(new MockFormSaver()));
 
   EXPECT_CALL(*mock_store(), GetLogins(encountered_form, &form_manager));
@@ -1490,6 +1515,7 @@ TEST_F(PasswordFormManagerTest, TestUpdateIncompleteCredentials) {
   incomplete_form->password_value = ASCIIToUTF16("my_password");
   incomplete_form->username_value = ASCIIToUTF16("my_username");
   incomplete_form->preferred = true;
+  incomplete_form->ssl_valid = false;
   incomplete_form->scheme = PasswordForm::SCHEME_HTML;
 
   // We expect to see this form eventually sent to the Password store. It
@@ -1664,9 +1690,9 @@ TEST_F(PasswordFormManagerTest, InvalidActionURLsDoNotMatch) {
                    PasswordFormManager::RESULT_ACTION_MATCH);
   // Then when the observed form has an invalid URL:
   PasswordForm valid_action_form(*observed_form());
-  PasswordFormManager invalid_manager(password_manager(), client(),
-                                      client()->driver(), invalid_action_form,
-                                      base::WrapUnique(new MockFormSaver()));
+  PasswordFormManager invalid_manager(
+      password_manager(), client(), client()->driver(), invalid_action_form,
+      false, base::WrapUnique(new MockFormSaver()));
   EXPECT_EQ(0,
             invalid_manager.DoesManage(valid_action_form) &
                 PasswordFormManager::RESULT_ACTION_MATCH);
@@ -1684,7 +1710,7 @@ TEST_F(PasswordFormManagerTest, EmptyActionURLsDoNotMatchNonEmpty) {
   PasswordForm valid_action_form(*observed_form());
   PasswordFormManager empty_action_manager(
       password_manager(), client(), client()->driver(), empty_action_form,
-      base::WrapUnique(new MockFormSaver()));
+      false, base::WrapUnique(new MockFormSaver()));
   EXPECT_EQ(0,
             empty_action_manager.DoesManage(valid_action_form) &
                 PasswordFormManager::RESULT_ACTION_MATCH);
@@ -1700,7 +1726,7 @@ TEST_F(PasswordFormManagerTest, NonHTMLFormsDoNotMatchHTMLForms) {
   // The other way round: observing a non-HTML form, don't match a HTML form.
   PasswordForm html_form(*observed_form());
   PasswordFormManager non_html_manager(password_manager(), client(), kNoDriver,
-                                       non_html_form,
+                                       non_html_form, false,
                                        base::WrapUnique(new MockFormSaver()));
   EXPECT_EQ(0, non_html_manager.DoesManage(html_form) &
                    PasswordFormManager::RESULT_HTML_ATTRIBUTES_MATCH);
@@ -1736,9 +1762,9 @@ TEST_F(PasswordFormManagerTest,
 
   PasswordForm secure_observed_form(*observed_form());
   secure_observed_form.origin = GURL("https://accounts.google.com/a/LoginAuth");
-  PasswordFormManager secure_manager(password_manager(), client(),
-                                     client()->driver(), secure_observed_form,
-                                     base::WrapUnique(new MockFormSaver()));
+  PasswordFormManager secure_manager(
+      password_manager(), client(), client()->driver(), secure_observed_form,
+      true, base::WrapUnique(new MockFormSaver()));
   // Also for HTTPS in the observed form, and HTTP in the compared form, an
   // exact path match is expected.
   EXPECT_EQ(0, secure_manager.DoesManage(form_longer_path) &
@@ -1814,7 +1840,7 @@ TEST_F(PasswordFormManagerTest, UploadFormData_NewPassword) {
   // For newly saved passwords, upload a password vote for autofill::PASSWORD.
   // Don't vote for the username field yet.
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *saved_match(),
+                                   client()->driver(), *saved_match(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_NO_MATCH);
 
@@ -1836,7 +1862,7 @@ TEST_F(PasswordFormManagerTest, UploadFormData_NewPassword) {
 
   // Do not upload a vote if the user is blacklisting the form.
   PasswordFormManager blacklist_form_manager(
-      password_manager(), client(), client()->driver(), *saved_match(),
+      password_manager(), client(), client()->driver(), *saved_match(), false,
       base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&blacklist_form_manager, RESULT_NO_MATCH);
 
@@ -1932,7 +1958,7 @@ TEST_F(PasswordFormManagerTest, DriverDeletedBeforeStoreDone) {
   form->submit_element = ASCIIToUTF16("s");
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *form,
+                                   client()->driver(), *form, false,
                                    base::WrapUnique(new MockFormSaver()));
 
   EXPECT_CALL(*mock_store(), GetLogins(*form, &form_manager));
@@ -1980,7 +2006,7 @@ TEST_F(PasswordFormManagerTest,
       base::ASCIIToUTF16("new_password_field");
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
 
@@ -2077,9 +2103,10 @@ TEST_F(PasswordFormManagerTest, TestSuggestingPasswordChangeForms) {
   PasswordForm observed_change_password_form = *observed_form();
   observed_change_password_form.new_password_element =
       base::ASCIIToUTF16("new_pwd");
-  PasswordFormManager manager_creds(
-      password_manager(), client(), client()->driver(),
-      observed_change_password_form, base::WrapUnique(new MockFormSaver()));
+  PasswordFormManager manager_creds(password_manager(), client(),
+                                    client()->driver(),
+                                    observed_change_password_form, false,
+                                    base::WrapUnique(new MockFormSaver()));
   manager_creds.SimulateFetchMatchingLoginsFromPasswordStore();
   ScopedVector<PasswordForm> simulated_results;
   simulated_results.push_back(CreateSavedMatch(false));
@@ -2115,7 +2142,7 @@ TEST_F(PasswordFormManagerTest, TestUpdateMethod) {
 
   client()->set_is_update_password_ui_enabled(true);
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
 
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
@@ -2178,7 +2205,7 @@ TEST_F(PasswordFormManagerTest, TestUpdateNoUsernameTextfieldPresent) {
 
   client()->set_is_update_password_ui_enabled(true);
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
 
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
@@ -2228,7 +2255,7 @@ TEST_F(PasswordFormManagerTest, WipeStoreCopyIfOutdated_BeforeStoreCallback) {
   ASSERT_FALSE(form.password_value.empty());
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), form,
+                                   client()->driver(), form, false,
                                    base::WrapUnique(new MockFormSaver()));
 
   // Do not notify the store observer after this GetLogins call.
@@ -2422,7 +2449,7 @@ TEST_F(PasswordFormManagerTest, UploadChangePasswordForm_NOT_NEW_PASSWORD) {
 
 TEST_F(PasswordFormManagerTest, TestUpdatePSLMatchedCredentials) {
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH | RESULT_PSL_MATCH);
 
@@ -2473,7 +2500,7 @@ TEST_F(PasswordFormManagerTest, TestUpdatePSLMatchedCredentials) {
 TEST_F(PasswordFormManagerTest,
        TestNotUpdatePSLMatchedCredentialsWithAnotherUsername) {
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   psl_saved_match()->username_value += ASCIIToUTF16("1");
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH | RESULT_PSL_MATCH);
@@ -2513,7 +2540,7 @@ TEST_F(PasswordFormManagerTest,
 TEST_F(PasswordFormManagerTest,
        TestNotUpdatePSLMatchedCredentialsWithAnotherPassword) {
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   psl_saved_match()->password_value += ASCIIToUTF16("1");
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH | RESULT_PSL_MATCH);
@@ -2552,7 +2579,7 @@ TEST_F(PasswordFormManagerTest,
 
 TEST_F(PasswordFormManagerTest, TestNotUpdateWhenOnlyPSLMatched) {
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_PSL_MATCH);
 
@@ -2737,7 +2764,7 @@ TEST_F(PasswordFormManagerTest,
 
   client()->set_is_update_password_ui_enabled(true);
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
 
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
@@ -2814,7 +2841,7 @@ TEST_F(PasswordFormManagerTest, FormClassifierVoteUpload) {
     submitted_form.password_value = saved_match()->password_value;
 
     PasswordFormManager form_manager(password_manager(), client(),
-                                     client()->driver(), form,
+                                     client()->driver(), form, false,
                                      base::WrapUnique(new MockFormSaver()));
     base::string16 generation_element = form.password_element;
     if (found_generation_element)
@@ -2848,7 +2875,7 @@ TEST_F(PasswordFormManagerTest, TestSavingAPIFormsWithSamePassword) {
   saved_match()->type = autofill::PasswordForm::TYPE_API;
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), *observed_form(),
+                                   client()->driver(), *observed_form(), false,
                                    base::WrapUnique(new MockFormSaver()));
   SimulateMatchingPhase(&form_manager, RESULT_SAVED_MATCH);
 
@@ -2905,7 +2932,7 @@ TEST_F(PasswordFormManagerTest, ProbablyAccountCreationUpload) {
   form.form_data = saved_match()->form_data;
 
   PasswordFormManager form_manager(password_manager(), client(),
-                                   client()->driver(), form,
+                                   client()->driver(), form, false,
                                    base::WrapUnique(new MockFormSaver()));
 
   PasswordForm form_to_save(form);
diff --git a/components/password_manager/core/browser/password_manager.cc b/components/password_manager/core/browser/password_manager.cc
index 17e8d65..3783547 100644
--- a/components/password_manager/core/browser/password_manager.cc
+++ b/components/password_manager/core/browser/password_manager.cc
@@ -229,8 +229,9 @@ void PasswordManager::SetGenerationElementAndReasonForForm(
   // If there is no corresponding PasswordFormManager, we create one. This is
   // not the common case, and should only happen when there is a bug in our
   // ability to detect forms.
+  bool ssl_valid = form.origin.SchemeIsCryptographic();
   PasswordFormManager* manager = new PasswordFormManager(
-      this, client_, driver->AsWeakPtr(), form,
+      this, client_, driver->AsWeakPtr(), form, ssl_valid,
       base::WrapUnique(new FormSaverImpl(client_->GetPasswordStore())));
   pending_login_managers_.push_back(manager);
   manager->FetchDataFromPasswordStore();
@@ -341,6 +342,9 @@ void PasswordManager::ProvisionallySavePassword(const PasswordForm& form) {
   }
 
   PasswordForm provisionally_saved_form(form);
+  provisionally_saved_form.ssl_valid =
+      form.origin.SchemeIsCryptographic() &&
+      !client_->DidLastPageLoadEncounterSSLErrors();
   provisionally_saved_form.preferred = true;
   if (logger) {
     logger->LogPasswordForm(Logger::STRING_PROVISIONALLY_SAVED_FORM,
@@ -526,10 +530,11 @@ void PasswordManager::CreatePendingLoginManagers(
 
     if (logger)
       logger->LogFormSignatures(Logger::STRING_ADDING_SIGNATURE, *iter);
+    bool ssl_valid = iter->origin.SchemeIsCryptographic();
     PasswordFormManager* manager = new PasswordFormManager(
         this, client_,
         (driver ? driver->AsWeakPtr() : base::WeakPtr<PasswordManagerDriver>()),
-        *iter,
+        *iter, ssl_valid,
         base::WrapUnique(new FormSaverImpl(client_->GetPasswordStore())));
     pending_login_managers_.push_back(manager);
 
diff --git a/components/password_manager/core/browser/password_manager_test_utils.cc b/components/password_manager/core/browser/password_manager_test_utils.cc
index 39eca2f..73f2857 100644
--- a/components/password_manager/core/browser/password_manager_test_utils.cc
+++ b/components/password_manager/core/browser/password_manager_test_utils.cc
@@ -38,6 +38,7 @@ std::unique_ptr<PasswordForm> CreatePasswordFormFromDataForTesting(
   std::unique_ptr<PasswordForm> form(new PasswordForm());
   form->scheme = form_data.scheme;
   form->preferred = form_data.preferred;
+  form->ssl_valid = form_data.ssl_valid;
   form->date_created = base::Time::FromDoubleT(form_data.creation_time);
   form->date_synced =
       form->date_created +
diff --git a/components/password_manager/core/browser/password_manager_test_utils.h b/components/password_manager/core/browser/password_manager_test_utils.h
index cb9a95f..9a75e12 100644
--- a/components/password_manager/core/browser/password_manager_test_utils.h
+++ b/components/password_manager/core/browser/password_manager_test_utils.h
@@ -52,6 +52,7 @@ struct PasswordFormData {
   const wchar_t* username_value;  // Set to NULL for a blacklist entry.
   const wchar_t* password_value;
   const bool preferred;
+  const bool ssl_valid;
   const double creation_time;
 };
 
diff --git a/components/password_manager/core/browser/password_manager_util_unittest.cc b/components/password_manager/core/browser/password_manager_util_unittest.cc
index 5bc606f..bb963cc 100644
--- a/components/password_manager/core/browser/password_manager_util_unittest.cc
+++ b/components/password_manager/core/browser/password_manager_util_unittest.cc
@@ -23,6 +23,7 @@ autofill::PasswordForm GetTestAndroidCredentials(const char* signon_realm) {
   form.signon_realm = signon_realm;
   form.username_value = base::ASCIIToUTF16(kTestUsername);
   form.password_value = base::ASCIIToUTF16(kTestPassword);
+  form.ssl_valid = true;
   return form;
 }
 
diff --git a/components/password_manager/core/browser/password_store_change.h b/components/password_manager/core/browser/password_store_change.h
index 18f103c..0d37f9d 100644
--- a/components/password_manager/core/browser/password_store_change.h
+++ b/components/password_manager/core/browser/password_store_change.h
@@ -39,6 +39,7 @@ class PasswordStoreChange {
            form().password_value == other.form().password_value &&
            form().new_password_element == other.form().new_password_element &&
            form().new_password_value == other.form().new_password_value &&
+           form().ssl_valid == other.form().ssl_valid &&
            form().preferred == other.form().preferred &&
            form().date_created == other.form().date_created &&
            form().blacklisted_by_user == other.form().blacklisted_by_user;
diff --git a/components/password_manager/core/browser/password_store_default_unittest.cc b/components/password_manager/core/browser/password_store_default_unittest.cc
index 9dffaa2..884adda 100644
--- a/components/password_manager/core/browser/password_store_default_unittest.cc
+++ b/components/password_manager/core/browser/password_store_default_unittest.cc
@@ -71,6 +71,7 @@ PasswordFormData CreateTestPasswordFormData() {
                            L"username_value",
                            L"password_value",
                            true,
+                           false,
                            1};
   return data;
 }
@@ -167,7 +168,8 @@ TEST(PasswordStoreDefaultTest, NonASCIIData) {
   static const PasswordFormData form_data[] = {
       {PasswordForm::SCHEME_HTML, "http://foo.example.com",
        "http://foo.example.com/origin", "http://foo.example.com/action",
-       L"", L"?", L"", L" ", L"", true, 1},
+       L"", L"?", L"", L" ", L"", true,
+       false, 1},
   };
 
   // Build the expected forms vector and add the forms to the store.
diff --git a/components/password_manager/core/browser/password_store_origin_unittest.h b/components/password_manager/core/browser/password_store_origin_unittest.h
index a5358d7..e8ff255 100644
--- a/components/password_manager/core/browser/password_store_origin_unittest.h
+++ b/components/password_manager/core/browser/password_store_origin_unittest.h
@@ -39,6 +39,7 @@ PasswordFormData CreateTestPasswordFormDataByOrigin(const char* origin_url) {
                            L"username_value",
                            L"password_value",
                            true,
+                           false,
                            1};
   return data;
 }
diff --git a/components/password_manager/core/browser/password_store_unittest.cc b/components/password_manager/core/browser/password_store_unittest.cc
index b559804..ac22a33 100644
--- a/components/password_manager/core/browser/password_store_unittest.cc
+++ b/components/password_manager/core/browser/password_store_unittest.cc
@@ -48,6 +48,8 @@ const char kTestWebRealm2[] = "https://two.example.com/";
 const char kTestWebOrigin2[] = "https://two.example.com/origin";
 const char kTestWebRealm3[] = "https://three.example.com/";
 const char kTestWebOrigin3[] = "https://three.example.com/origin";
+const char kTestWebRealm4[] = "https://four.example.com/";
+const char kTestWebOrigin4[] = "https://four.example.com/origin";
 const char kTestWebRealm5[] = "https://five.example.com/";
 const char kTestWebOrigin5[] = "https://five.example.com/origin";
 const char kTestPSLMatchingWebRealm[] = "https://psl.example.com/";
@@ -114,29 +116,29 @@ TEST_F(PasswordStoreTest, IgnoreOldWwwGoogleLogins) {
       {PasswordForm::SCHEME_HTML, "https://www.google.com",
        "https://www.google.com/origin", "https://www.google.com/action",
        L"submit_element", L"username_element", L"password_element",
-       L"username_value_1", L"", true, cutoff - 1},
+       L"username_value_1", L"", true, true, cutoff - 1},
       // A form on https://www.google.com/ older than the cutoff. Will be
       // ignored.
       {PasswordForm::SCHEME_HTML, "https://www.google.com",
        "https://www.google.com/origin", "https://www.google.com/action",
        L"submit_element", L"username_element", L"password_element",
-       L"username_value_2", L"", true, cutoff - 1},
+       L"username_value_2", L"", true, true, cutoff - 1},
       // A form on https://www.google.com/ newer than the cutoff.
       {PasswordForm::SCHEME_HTML, "https://www.google.com",
        "https://www.google.com/origin", "https://www.google.com/action",
        L"submit_element", L"username_element", L"password_element",
-       L"username_value_3", L"", true, cutoff + 1},
+       L"username_value_3", L"", true, true, cutoff + 1},
       // A form on https://accounts.google.com/ older than the cutoff.
       {PasswordForm::SCHEME_HTML, "https://accounts.google.com",
        "https://accounts.google.com/origin",
        "https://accounts.google.com/action", L"submit_element",
        L"username_element", L"password_element", L"username_value", L"", true,
-       cutoff - 1},
+       true, cutoff - 1},
       // A form on http://bar.example.com/ older than the cutoff.
       {PasswordForm::SCHEME_HTML, "http://bar.example.com",
        "http://bar.example.com/origin", "http://bar.example.com/action",
        L"submit_element", L"username_element", L"password_element",
-       L"username_value", L"", true, cutoff - 1},
+       L"username_value", L"", true, false, cutoff - 1},
   };
 
   // Build the forms vector and add the forms to the store.
@@ -224,7 +226,7 @@ TEST_F(PasswordStoreTest, GetLoginImpl) {
       kTestWebOrigin1,
       "", L"", L"username_element",  L"password_element",
       L"username_value",
-      L"", true, 1};
+      L"", true, true, 1};
   /* clang-format on */
 
   scoped_refptr<PasswordStoreDefault> store(new PasswordStoreDefault(
@@ -280,14 +282,14 @@ TEST_F(PasswordStoreTest, UpdateLoginPrimaryKeyFields) {
        kTestWebOrigin1,
        "", L"", L"username_element_1",  L"password_element_1",
        L"username_value_1",
-       L"", true, 1},
+       L"", true, true, 1},
       // The new credential with different values for all primary key fields.
       {PasswordForm::SCHEME_HTML,
        kTestWebRealm2,
        kTestWebOrigin2,
        "", L"", L"username_element_2",  L"password_element_2",
        L"username_value_2",
-       L"", true, 1}};
+       L"", true, true, 1}};
   /* clang-format on */
 
   scoped_refptr<PasswordStoreDefault> store(new PasswordStoreDefault(
@@ -340,7 +342,7 @@ TEST_F(PasswordStoreTest, RemoveLoginsCreatedBetweenCallbackIsCalled) {
        kTestWebOrigin1,
        "", L"", L"username_element_1",  L"password_element_1",
        L"username_value_1",
-       L"", true, 1};
+       L"", true, true, 1};
   /* clang-format on */
 
   scoped_refptr<PasswordStoreDefault> store(new PasswordStoreDefault(
@@ -380,20 +382,20 @@ TEST_F(PasswordStoreTest, GetLoginsWithoutAffiliations) {
        kTestWebOrigin1,
        "", L"", L"",  L"",
        L"username_value_1",
-       L"", true, 1},
+       L"", true, true, 1},
       // Credential that is a PSL match of the observed form.
       {PasswordForm::SCHEME_HTML,
        kTestPSLMatchingWebRealm,
        kTestPSLMatchingWebOrigin,
        "", L"", L"",  L"",
        L"username_value_2",
-       L"", true, 1},
+       L"", true, true, 1},
       // Credential for an unrelated Android application.
       {PasswordForm::SCHEME_HTML,
        kTestUnrelatedAndroidRealm,
        "", "", L"", L"", L"",
        L"username_value_3",
-       L"", true, 1}};
+       L"", true, true, 1}};
   /* clang-format on */
 
   scoped_refptr<PasswordStoreDefault> store(new PasswordStoreDefault(
@@ -415,6 +417,7 @@ TEST_F(PasswordStoreTest, GetLoginsWithoutAffiliations) {
   PasswordForm observed_form;
   observed_form.scheme = PasswordForm::SCHEME_HTML;
   observed_form.origin = GURL(kTestWebOrigin1);
+  observed_form.ssl_valid = true;
   observed_form.signon_realm = kTestWebRealm1;
 
   MockPasswordStoreConsumer mock_consumer;
@@ -452,53 +455,53 @@ TEST_F(PasswordStoreTest, GetLoginsWithAffiliations) {
        kTestWebOrigin1,
        "", L"", L"",  L"",
        L"username_value_1",
-       L"", true, 1},
+       L"", true, true, 1},
       // Credential that is a PSL match of the observed form.
       {PasswordForm::SCHEME_HTML,
        kTestPSLMatchingWebRealm,
        kTestPSLMatchingWebOrigin,
        "", L"", L"",  L"",
        L"username_value_2",
-       L"", true, 1},
+       L"", true, true, 1},
       // Credential for an Android application affiliated with the realm of the
       // observed from.
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm1,
        "", "", L"", L"", L"",
        L"username_value_3",
-       L"", true, 1},
+       L"", true, true, 1},
       // Second credential for the same Android application.
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm1,
        "", "", L"", L"", L"",
        L"username_value_3b",
-       L"", true, 1},
+       L"", true, true, 1},
       // Third credential for the same application which is username-only.
       {PasswordForm::SCHEME_USERNAME_ONLY,
        kTestAndroidRealm1,
        "", "", L"", L"", L"",
        L"username_value_3c",
-       L"", true, 1},
+       L"", true, true, 1},
       // Credential for another Android application affiliated with the realm
       // of the observed from.
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm2,
        "", "", L"", L"", L"",
        L"username_value_4",
-       L"", true, 1},
+       L"", true, true, 1},
       // Federated credential for this second Android application; this should
       // not be returned.
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm2,
        "", "", L"", L"", L"",
        L"username_value_4b",
-       kTestingFederatedLoginMarker, true, 1},
+       kTestingFederatedLoginMarker, true, true, 1},
       // Credential for an unrelated Android application.
       {PasswordForm::SCHEME_HTML,
        kTestUnrelatedAndroidRealm,
        "", "", L"", L"", L"",
        L"username_value_5",
-       L"", true, 1}
+       L"", true, true, 1}
        };
   /* clang-format on */
 
@@ -521,6 +524,7 @@ TEST_F(PasswordStoreTest, GetLoginsWithAffiliations) {
   PasswordForm observed_form;
   observed_form.scheme = PasswordForm::SCHEME_HTML;
   observed_form.origin = GURL(kTestWebOrigin1);
+  observed_form.ssl_valid = true;
   observed_form.signon_realm = kTestWebRealm1;
 
   MockPasswordStoreConsumer mock_consumer;
@@ -585,7 +589,7 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestAndroidRealm1,
        "", "", L"", L"", L"",
        kTestUsername,
-       kTestOldPassword, true, 2},
+       kTestOldPassword, true, true, 2},
 
       // --- Positive samples --- Credentials that the password update should be
       // automatically propagated to.
@@ -596,7 +600,7 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestWebOrigin1,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for another affiliated web site with the same username.
       // Although the password is different than the current/old password for
       // the Android application, it should be updated regardless.
@@ -605,7 +609,7 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestWebOrigin2,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestOtherPassword, true, 1},
+       kTestOtherPassword, true, true, 1},
 
       // --- Negative samples --- Credentials that the password update should
       // not be propagated to.
@@ -617,21 +621,29 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestWebOrigin3,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestNewPassword, true, 1},
+       kTestNewPassword, true, true, 1},
+      // Credential for another affiliated web site, but one that was saved
+      // under insecure conditions.
+      {PasswordForm::SCHEME_HTML,
+       kTestWebRealm4,
+       kTestWebOrigin4,
+       "", L"", L"",  L"",
+       kTestUsername,
+       kTestOldPassword, true, false, 1},
       // Credential for the HTTP version of an affiliated web site.
       {PasswordForm::SCHEME_HTML,
        kTestInsecureWebRealm,
        kTestInsecureWebOrigin,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, false, 1},
       // Credential for an affiliated web site, but with a different username.
       {PasswordForm::SCHEME_HTML,
        kTestWebRealm1,
        kTestWebOrigin1,
        "", L"", L"",  L"",
        kTestOtherUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for a web site that is a PSL match to a web sites affiliated
       // with the Android application.
       {PasswordForm::SCHEME_HTML,
@@ -639,26 +651,26 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestPSLMatchingWebOrigin,
        "poisoned", L"poisoned", L"",  L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for an unrelated web site.
       {PasswordForm::SCHEME_HTML,
        kTestUnrelatedWebRealm,
        kTestUnrelatedWebOrigin,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for an affiliated Android application.
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm2,
        "", "", L"", L"", L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for an unrelated Android application.
       {PasswordForm::SCHEME_HTML,
        kTestUnrelatedAndroidRealm,
        "", "", L"", L"", L"",
        kTestUsername,
-       kTestOldPassword, true, 1},
+       kTestOldPassword, true, true, 1},
       // Credential for an affiliated web site with the same username, but one
       // that was updated at the same time via Sync as the Android credential.
       {PasswordForm::SCHEME_HTML,
@@ -666,7 +678,7 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
        kTestWebOrigin5,
        "", L"", L"",  L"",
        kTestUsername,
-       kTestOtherPassword, true, 2}};
+       kTestOtherPassword, true, true, 2}};
   /* clang-format on */
 
   // The number of positive samples in |kTestCredentials|.
@@ -725,6 +737,7 @@ TEST_F(PasswordStoreTest, MAYBE_UpdatePasswordsStoredForAffiliatedWebsites) {
         affiliated_web_realms.push_back(kTestWebRealm1);
         affiliated_web_realms.push_back(kTestWebRealm2);
         affiliated_web_realms.push_back(kTestWebRealm3);
+        affiliated_web_realms.push_back(kTestWebRealm4);
         affiliated_web_realms.push_back(kTestWebRealm5);
         mock_helper->ExpectCallToGetAffiliatedWebRealms(
             *expected_credentials_after_update[0], affiliated_web_realms);
@@ -772,17 +785,17 @@ TEST_F(PasswordStoreTest, GetLoginsWithAffiliatedRealms) {
        kTestAndroidRealm1,
        "", "", L"", L"", L"",
        L"username_value_1",
-       L"", true, 1},
+       L"", true, true, 1},
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm2,
        "", "", L"", L"", L"",
        L"username_value_2",
-       L"", true, 1},
+       L"", true, true, 1},
       {PasswordForm::SCHEME_HTML,
        kTestAndroidRealm3,
        "", "", L"", L"", L"",
        L"username_value_3",
-       L"", true, 1}};
+       L"", true, true, 1}};
   /* clang-format on */
 
   const bool kFalseTrue[] = {false, true};
diff --git a/components/password_manager/core/browser/password_syncable_service.cc b/components/password_manager/core/browser/password_syncable_service.cc
index b7d214a..5eda943 100644
--- a/components/password_manager/core/browser/password_syncable_service.cc
+++ b/components/password_manager/core/browser/password_syncable_service.cc
@@ -50,6 +50,7 @@ bool AreLocalAndSyncPasswordsEqual(
               password_specifics.username_value() &&
           base::UTF16ToUTF8(password_form.password_value) ==
               password_specifics.password_value() &&
+          password_form.ssl_valid == password_specifics.ssl_valid() &&
           password_form.preferred == password_specifics.preferred() &&
           password_form.date_created.ToInternalValue() ==
               password_specifics.date_created() &&
@@ -453,6 +454,7 @@ syncer::SyncData SyncDataFromPassword(
   CopyStringField(password_element);
   CopyStringField(username_value);
   CopyStringField(password_value);
+  CopyField(ssl_valid);
   CopyField(preferred);
   password_specifics->set_date_created(
       password_form.date_created.ToInternalValue());
@@ -486,6 +488,7 @@ autofill::PasswordForm PasswordFromSpecifics(
       base::UTF8ToUTF16(password.password_element());
   new_password.username_value = base::UTF8ToUTF16(password.username_value());
   new_password.password_value = base::UTF8ToUTF16(password.password_value());
+  new_password.ssl_valid = password.ssl_valid();
   new_password.preferred = password.preferred();
   new_password.date_created =
       base::Time::FromInternalValue(password.date_created());
diff --git a/components/password_manager/core/browser/password_syncable_service_unittest.cc b/components/password_manager/core/browser/password_syncable_service_unittest.cc
index 15745fc..df7f280 100644
--- a/components/password_manager/core/browser/password_syncable_service_unittest.cc
+++ b/components/password_manager/core/browser/password_syncable_service_unittest.cc
@@ -88,6 +88,7 @@ MATCHER_P(PasswordIs, form, "") {
           actual_password.password_element() &&
       expected_password.username_value() == actual_password.username_value() &&
       expected_password.password_value() == actual_password.password_value() &&
+      expected_password.ssl_valid() == actual_password.ssl_valid() &&
       expected_password.preferred() == actual_password.preferred() &&
       expected_password.date_created() == actual_password.date_created() &&
       expected_password.blacklisted() == actual_password.blacklisted() &&
@@ -629,6 +630,8 @@ TEST_F(PasswordSyncableServiceTest, SerializeEmptyPasswordForm) {
   EXPECT_EQ("", specifics.password_element());
   EXPECT_TRUE(specifics.has_password_value());
   EXPECT_EQ("", specifics.password_value());
+  EXPECT_TRUE(specifics.has_ssl_valid());
+  EXPECT_FALSE(specifics.ssl_valid());
   EXPECT_TRUE(specifics.has_preferred());
   EXPECT_FALSE(specifics.preferred());
   EXPECT_TRUE(specifics.has_date_created());
@@ -659,6 +662,7 @@ TEST_F(PasswordSyncableServiceTest, SerializeNonEmptyPasswordForm) {
   form.username_value = base::ASCIIToUTF16("god@google.com");
   form.password_element = base::ASCIIToUTF16("password_element");
   form.password_value = base::ASCIIToUTF16("!@#$%^&*()");
+  form.ssl_valid = true;
   form.preferred = true;
   form.date_created = base::Time::FromInternalValue(100);
   form.blacklisted_by_user = true;
@@ -686,6 +690,8 @@ TEST_F(PasswordSyncableServiceTest, SerializeNonEmptyPasswordForm) {
   EXPECT_EQ("password_element", specifics.password_element());
   EXPECT_TRUE(specifics.has_password_value());
   EXPECT_EQ("!@#$%^&*()", specifics.password_value());
+  EXPECT_TRUE(specifics.has_ssl_valid());
+  EXPECT_TRUE(specifics.ssl_valid());
   EXPECT_TRUE(specifics.has_preferred());
   EXPECT_TRUE(specifics.preferred());
   EXPECT_TRUE(specifics.has_date_created());
diff --git a/components/policy/resources/policy_templates.json b/components/policy/resources/policy_templates.json
index 00cccee..177040f 100644
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -4859,13 +4859,13 @@
       },
       'example_value': False,
       'id': 293,
-      'caption': '''Send network packets to the management server to monitor online status''',
+      'caption': '''Send monitoring heartbeats to the management server''',
       'tags': ['admin-sharing'],
-      'desc': '''Send network packets to the management server to monitor online status, to allow
+      'desc': '''Send monitoring heartbeats to the management server, to allow
       the server to detect if the device is offline.
 
-      If this policy is set to true, monitoring network packets (so-called <ph name="HEARTBEATS_TERM">heartbeats</ph>) will be sent.
-      If set to false or unset, no packets will be sent.''',
+      If this policy is set to true, monitoring heartbeats will be sent. If set
+      to false or unset, then no heartbeats will be sent.''',
     },
     {
       'name': 'HeartbeatFrequency',
@@ -4878,9 +4878,9 @@
       },
       'example_value': 180000,
       'id': 294,
-      'caption': '''Frequency of monitoring network packets''',
+      'caption': '''Frequency of monitoring heartbeats''',
       'tags': [],
-      'desc': '''How frequently monitoring network packets are sent, in milliseconds.
+      'desc': '''How frequently monitoring heartbeats are sent, in milliseconds.
 
       If this policy is unset, the default frequency is 3 minutes. The minimum
       frequency is 30 seconds and the maximum frequency is 24 hours - values
diff --git a/components/test/data/password_manager/login_db_v18.sql b/components/test/data/password_manager/login_db_v18.sql
deleted file mode 100644
index 687fd39..0000000
--- a/components/test/data/password_manager/login_db_v18.sql
+++ /dev/null
@@ -1,86 +0,0 @@
-PRAGMA foreign_keys=OFF;
-BEGIN TRANSACTION;
-CREATE TABLE meta(key LONGVARCHAR NOT NULL UNIQUE PRIMARY KEY, value LONGVARCHAR);
-INSERT INTO "meta" VALUES('last_compatible_version','18');
-INSERT INTO "meta" VALUES('version','18');
-CREATE TABLE logins (
-origin_url VARCHAR NOT NULL,
-action_url VARCHAR,
-username_element VARCHAR,
-username_value VARCHAR,
-password_element VARCHAR,
-password_value BLOB,
-submit_element VARCHAR,
-signon_realm VARCHAR NOT NULL,
-preferred INTEGER NOT NULL,
-date_created INTEGER NOT NULL,
-blacklisted_by_user INTEGER NOT NULL,
-scheme INTEGER NOT NULL,
-password_type INTEGER,
-possible_usernames BLOB,
-times_used INTEGER,
-form_data BLOB,
-date_synced INTEGER,
-display_name VARCHAR,
-icon_url VARCHAR,
-federation_url VARCHAR,
-skip_zero_click INTEGER,
-generation_upload_status INTEGER,
-UNIQUE (origin_url, username_element, username_value, password_element, signon_realm));
-INSERT INTO "logins" VALUES(
-'https://accounts.google.com/ServiceLogin', /* origin_url */
-'https://accounts.google.com/ServiceLoginAuth', /* action_url */
-'Email', /* username_element */
-'theerikchen', /* username_value */
-'Passwd', /* password_element */
-X'', /* password_value */
-'', /* submit_element */
-'https://accounts.google.com/', /* signon_realm */
-1, /* preferred */
-13047429345000000, /* date_created */
-0, /* blacklisted_by_user */
-0, /* scheme */
-0, /* password_type */
-X'00000000', /* possible_usernames */
-1, /* times_used */
-X'18000000020000000000000000000000000000000000000000000000', /* form_data */
-0, /* date_synced */
-'', /* display_name */
-'', /* icon_url */
-'', /* federation_url */
-1,  /* skip_zero_click */
-0  /* generation_upload_status */
-);
-INSERT INTO "logins" VALUES(
-'https://accounts.google.com/ServiceLogin', /* origin_url */
-'https://accounts.google.com/ServiceLoginAuth', /* action_url */
-'Email', /* username_element */
-'theerikchen2', /* username_value */
-'Passwd', /* password_element */
-X'', /* password_value */
-'non-empty', /* submit_element */
-'https://accounts.google.com/', /* signon_realm */
-1, /* preferred */
-13047423600000000, /* date_created */
-0, /* blacklisted_by_user */
-0, /* scheme */
-0, /* password_type */
-X'00000000', /* possible_usernames */
-1, /* times_used */
-X'18000000020000000000000000000000000000000000000000000000', /* form_data */
-0, /* date_synced */
-'', /* display_name */
-'https://www.google.com/icon', /* icon_url */
-'', /* federation_url */
-1,  /* skip_zero_click */
-0  /* generation_upload_status */
-);
-CREATE INDEX logins_signon ON logins (signon_realm);
-CREATE TABLE stats (
-origin_domain VARCHAR NOT NULL,
-username_value VARCHAR,
-dismissal_count INTEGER,
-update_time INTEGER NOT NULL,
-UNIQUE(origin_domain, username_value));
-CREATE INDEX stats_origin ON stats(origin_domain);
-COMMIT;
diff --git a/components/tracing.gyp b/components/tracing.gyp
index b118b87..f742bac 100644
--- a/components/tracing.gyp
+++ b/components/tracing.gyp
@@ -43,8 +43,6 @@
         'tracing/common/tracing_switches.cc',
         'tracing/common/tracing_switches.h',
         'tracing/core/proto_utils.h',
-        'tracing/core/proto_zero_message.cc',
-        'tracing/core/proto_zero_message.h',
         'tracing/core/scattered_stream_writer.cc',
         'tracing/core/scattered_stream_writer.h',
         'tracing/core/trace_ring_buffer.cc',
diff --git a/components/tracing/BUILD.gn b/components/tracing/BUILD.gn
index a466421..8f066a5 100644
--- a/components/tracing/BUILD.gn
+++ b/components/tracing/BUILD.gn
@@ -17,8 +17,6 @@ component("tracing") {
     "common/tracing_messages.cc",
     "common/tracing_messages.h",
     "core/proto_utils.h",
-    "core/proto_zero_message.cc",
-    "core/proto_zero_message.h",
     "core/scattered_stream_writer.cc",
     "core/scattered_stream_writer.h",
     "core/trace_ring_buffer.cc",
@@ -96,7 +94,6 @@ source_set("unit_tests") {
     "common/graphics_memory_dump_provider_android_unittest.cc",
     "common/process_metrics_memory_dump_provider_unittest.cc",
     "core/proto_utils_unittest.cc",
-    "core/proto_zero_message_unittest.cc",
     "core/scattered_stream_writer_unittest.cc",
     "core/trace_ring_buffer_unittest.cc",
     "test/fake_scattered_buffer.cc",
diff --git a/components/tracing/core/proto_utils.h b/components/tracing/core/proto_utils.h
index 6859919..59b147d 100644
--- a/components/tracing/core/proto_utils.h
+++ b/components/tracing/core/proto_utils.h
@@ -26,10 +26,6 @@ enum : uint32_t {
   kFieldTypeFixed32 = 5,
 };
 
-// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
-constexpr size_t kMessageLengthFieldSize = 4;
-constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;
-
 // Returns the number of bytes sufficient to encode the largest
 // |int_size_in_bits|-bits integer using a non-redundant varint encoding.
 template <typename T>
diff --git a/components/tracing/core/proto_zero_message.cc b/components/tracing/core/proto_zero_message.cc
deleted file mode 100644
index b715230..0000000
--- a/components/tracing/core/proto_zero_message.cc
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "components/tracing/core/proto_zero_message.h"
-
-#include <string.h>
-
-#include "components/tracing/core/proto_utils.h"
-
-#if !defined(ARCH_CPU_LITTLE_ENDIAN)
-// The memcpy() for float and double below needs to be adjusted if we want to
-// support big endian CPUs. There doesn't seem to be a compelling need today.
-#error big-endian CPUs not supported by this translation unit.
-#endif
-
-namespace tracing {
-namespace v2 {
-
-ProtoZeroMessage::ProtoZeroMessage() {
-  // Do NOT add any code here, use the Reset() method below instead.
-  // Ctor and Dtor of ProtoZeroMessage are never called, with the exeception
-  // of root (non-nested) messages. Nested messages are allocated in the
-  // |nested_messages_arena_| and implictly destroyed when the arena of the
-  // root message goes away. This is fine as long as all the fields are PODs,
-  // hence the static_assert below.
-  static_assert(base::is_trivially_destructible<ProtoZeroMessage>::value,
-                "ProtoZeroMessage must be trivially destructible");
-
-  static_assert(
-      sizeof(ProtoZeroMessage::nested_messages_arena_) >=
-          kMaxNestingDepth * (sizeof(ProtoZeroMessage) -
-                              sizeof(ProtoZeroMessage::nested_messages_arena_)),
-      "ProtoZeroMessage::nested_messages_arena_ is too small");
-}
-
-// This method is called to initialize both root and nested messages.
-void ProtoZeroMessage::Reset(ScatteredStreamWriter* stream_writer) {
-  stream_writer_ = stream_writer;
-  size_ = 0;
-  size_field_.reset();
-  size_already_written_ = 0;
-  nested_message_ = nullptr;
-  nesting_depth_ = 0;
-#if DCHECK_IS_ON()
-  sealed_ = false;
-#endif
-}
-
-void ProtoZeroMessage::AppendVarIntU64(uint32_t field_id, uint64_t value) {
-  if (nested_message_)
-    EndNestedMessage();
-
-  uint8_t data[proto::GetMaxVarIntEncodedSize<uint32_t>() +
-               proto::GetMaxVarIntEncodedSize<uint64_t>()];
-  uint8_t* data_end;
-  data_end = proto::WriteVarIntU32(proto::MakeTagVarInt(field_id), data);
-  data_end = proto::WriteVarIntU64(value, data_end);
-  WriteToStream(data, data_end);
-}
-
-void ProtoZeroMessage::AppendVarIntU32(uint32_t field_id, uint32_t value) {
-  // TODO(kraynov): this could be perf-optimized. See http://crbug.com/624311 .
-  AppendVarIntU64(field_id, value);
-}
-
-void ProtoZeroMessage::AppendFloat(uint32_t field_id, float value) {
-  if (nested_message_)
-    EndNestedMessage();
-
-  uint8_t data[proto::GetMaxVarIntEncodedSize<uint32_t>() + sizeof(value)];
-  uint8_t* data_end;
-  data_end = proto::WriteVarIntU32(proto::MakeTagFixed32(field_id), data);
-  memcpy(data_end, &value, sizeof(value));
-  data_end += sizeof(value);
-  WriteToStream(data, data_end);
-}
-
-void ProtoZeroMessage::AppendDouble(uint32_t field_id, double value) {
-  if (nested_message_)
-    EndNestedMessage();
-
-  uint8_t data[proto::GetMaxVarIntEncodedSize<uint32_t>() + sizeof(value)];
-  uint8_t* data_end;
-  data_end = proto::WriteVarIntU32(proto::MakeTagFixed64(field_id), data);
-  memcpy(data_end, &value, sizeof(value));
-  data_end += sizeof(value);
-  WriteToStream(data, data_end);
-}
-
-void ProtoZeroMessage::AppendString(uint32_t field_id, const char* str) {
-  AppendBytes(field_id, str, strlen(str));
-}
-
-void ProtoZeroMessage::AppendBytes(uint32_t field_id,
-                                   const void* src,
-                                   size_t size) {
-  if (nested_message_)
-    EndNestedMessage();
-
-  // Write the proto preamble (field id, type and length of the buffer).
-  uint8_t data[2 * proto::GetMaxVarIntEncodedSize<uint32_t>()];
-  uint8_t* data_end =
-      proto::WriteVarIntU32(proto::MakeTagLengthDelimited(field_id), data);
-  data_end = proto::WriteVarIntU32(static_cast<uint32_t>(size), data_end);
-  WriteToStream(data, data_end);
-  const uint8_t* src_u8 = reinterpret_cast<const uint8_t*>(src);
-  WriteToStream(src_u8, src_u8 + size);
-}
-
-size_t ProtoZeroMessage::Finalize() {
-  if (nested_message_)
-    EndNestedMessage();
-
-  if (size_field_.is_valid()) {
-// Write the length of the nested message a posteriori, using a leading-zero
-// redundant varint encoding.
-#if DCHECK_IS_ON()
-    DCHECK(!sealed_);
-#endif
-    DCHECK_LT(size_, proto::kMaxMessageLength);
-    DCHECK_EQ(proto::kMessageLengthFieldSize, size_field_.size());
-    proto::WriteRedundantVarIntU32<proto::kMessageLengthFieldSize>(
-        static_cast<uint32_t>(size_ - size_already_written_),
-        size_field_.begin);
-    size_field_.reset();
-  }
-
-#if DCHECK_IS_ON()
-  sealed_ = true;
-#endif
-
-  return size_;
-}
-
-void ProtoZeroMessage::BeginNestedMessageInternal(uint32_t field_id,
-                                                  ProtoZeroMessage* message) {
-  if (nested_message_)
-    EndNestedMessage();
-
-  // Write the proto preamble for the nested message.
-  uint8_t data[proto::GetMaxVarIntEncodedSize<uint32_t>()];
-  uint8_t* data_end =
-      proto::WriteVarIntU32(proto::MakeTagLengthDelimited(field_id), data);
-  WriteToStream(data, data_end);
-
-  message->Reset(stream_writer_);
-  CHECK_LT(nesting_depth_, kMaxNestingDepth);
-  message->nesting_depth_ = nesting_depth_ + 1;
-
-  // The length of the nested message cannot be known upfront. So right now
-  // just reserve the bytes to encode the size after the nested message is done.
-  message->set_size_field(
-      stream_writer_->ReserveBytes(proto::kMessageLengthFieldSize));
-  size_ += proto::kMessageLengthFieldSize;
-  nested_message_ = message;
-}
-
-void ProtoZeroMessage::EndNestedMessage() {
-  size_ += nested_message_->Finalize();
-  nested_message_ = nullptr;
-}
-
-}  // namespace v2
-}  // namespace tracing
diff --git a/components/tracing/core/proto_zero_message.h b/components/tracing/core/proto_zero_message.h
deleted file mode 100644
index 7f65093..0000000
--- a/components/tracing/core/proto_zero_message.h
+++ /dev/null
@@ -1,155 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef COMPONENTS_TRACING_CORE_PROTO_ZERO_MESSAGE_H_
-#define COMPONENTS_TRACING_CORE_PROTO_ZERO_MESSAGE_H_
-
-#include <stdint.h>
-
-#include <type_traits>
-
-#include "base/compiler_specific.h"
-#include "base/gtest_prod_util.h"
-#include "base/logging.h"
-#include "base/macros.h"
-#include "base/template_util.h"
-#include "build/build_config.h"
-#include "components/tracing/core/scattered_stream_writer.h"
-#include "components/tracing/tracing_export.h"
-
-namespace tracing {
-namespace v2 {
-
-// Base class extended by the proto C++ stubs generated by the ProtoZero
-// compiler (see //components/tracing/tools/). This class provides the minimal
-// runtime required to support append-only operations and is desiged for
-// performance. None of the methods require any dynamic memory allocation.
-class TRACING_EXPORT ProtoZeroMessage {
- public:
-  // Commits all the changes to the buffer (backfills the size field of this and
-  // all nested messages) and seals the message. Returns the size of the message
-  // (and all nested sub-messages), without taking into account any chunking.
-  // Finalize is idempotent and can be called several times w/o side effects.
-  size_t Finalize();
-
-  // Optional. If is_valid() == true, the corresponding memory region (its
-  // length == proto::kMessageLengthFieldSize) is backfilled with the size of
-  // this message (minus |size_already_written| below) when the message is
-  // finalized. This is the mechanism used by messages to backfill their
-  // corresponding size field in the parent message.
-  ContiguousMemoryRange size_field() const { return size_field_; }
-  void set_size_field(const ContiguousMemoryRange& reserved_range) {
-    size_field_ = reserved_range;
-  }
-
-  // This is to deal with case of backfilling the size of a root (non-nested)
-  // message which is split into multiple chunks. Upon finalization only the
-  // partial size that lies in the last chunk has to be backfilled.
-  void inc_size_already_written(size_t size) { size_already_written_ += size; }
-
- protected:
-  ProtoZeroMessage();
-
-  // Clears up the state, allowing the message to be reused as a fresh one.
-  void Reset(ScatteredStreamWriter*);
-
-  void AppendVarIntU64(uint32_t field_id, uint64_t value);
-  void AppendVarIntU32(uint32_t field_id, uint32_t value);
-  void AppendFloat(uint32_t field_id, float value);
-  void AppendDouble(uint32_t field_id, double value);
-  void AppendString(uint32_t field_id, const char* str);
-  void AppendBytes(uint32_t field_id, const void* value, size_t size);
-  // TODO(kraynov): implement AppendVarIntS32/64(...) w/ zig-zag encoding.
-
-  // Begins a nested message, using the static storage provided by the parent
-  // class (see comment in |nested_messages_arena_|). The nested message ends
-  // either when Finalize() is called or when any other Append* method is called
-  // in the parent class.
-  // The template argument T is supposed to be a stub class auto generated from
-  // a .proto, hence a subclass of ProtoZeroMessage.
-  template <class T>
-  T* BeginNestedMessage(uint32_t field_id) {
-    // This is to prevent subclasses (which should be autogenerated, though), to
-    // introduce extra state fields (which wouldn't be initialized by Reset()).
-    static_assert(std::is_base_of<ProtoZeroMessage, T>::value,
-                  "T must be a subclass of ProtoZeroMessage");
-    static_assert(sizeof(T) == sizeof(ProtoZeroMessage),
-                  "ProtoZeroMessage subclasses cannot introduce extra state.");
-    T* message = reinterpret_cast<T*>(nested_messages_arena_);
-    BeginNestedMessageInternal(field_id, message);
-    return message;
-  }
-
- private:
-  friend class ProtoZeroMessageTest;
-  FRIEND_TEST_ALL_PREFIXES(ProtoZeroMessageTest, BasicTypesNoNesting);
-  FRIEND_TEST_ALL_PREFIXES(ProtoZeroMessageTest, BackfillSizeOnFinalization);
-  FRIEND_TEST_ALL_PREFIXES(ProtoZeroMessageTest, NestedMessagesSimple);
-  FRIEND_TEST_ALL_PREFIXES(ProtoZeroMessageTest, StressTest);
-
-  enum : uint32_t { kMaxNestingDepth = 8 };
-
-  void BeginNestedMessageInternal(uint32_t field_id, ProtoZeroMessage*);
-
-  // Called by Finalize and Append* methods.
-  void EndNestedMessage();
-
-  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
-#if DCHECK_IS_ON()
-    DCHECK(!sealed_);
-#endif
-    DCHECK(src_begin < src_end);
-    const size_t size = static_cast<size_t>(src_end - src_begin);
-    stream_writer_->WriteBytes(src_begin, size);
-    size_ += size;
-  }
-
-  // Only POD fields are allowed. This class's dtor is never called.
-  // See the comment on the static_assert in the the corresponding .cc file.
-
-  // The stream writer interface used for the serialization.
-  ScatteredStreamWriter* stream_writer_;
-
-  // Keeps track of the size of the current message.
-  size_t size_;
-
-  ContiguousMemoryRange size_field_;
-  size_t size_already_written_;
-
-  // Used to detect attemps to create messages with a nesting level >
-  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
-  uint32_t nesting_depth_;
-
-#if DCHECK_IS_ON()
-  // When true, no more changes to the message are allowed. This is to DCHECK
-  // attempts of writing to a message which has been Finalize()-d.
-  bool sealed_;
-#endif
-
-  // Pointer to the last child message created through BeginNestedMessage(), if
-  // any. nullptr otherwise. There is no need to keep track of more than one
-  // message per nesting level as the proto-zero API contract mandates that
-  // nested fields can be filled only in a stacked fashion. In other words,
-  // nested messages are finalized and sealed when any other field is set in the
-  // parent message (or the parent message itself is finalized) and cannot be
-  // accessed anymore afterwards.
-  ProtoZeroMessage* nested_message_;
-
-  // The root message owns the storage for all its nested messages, up to a max
-  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
-  // the arena are meaningful only for the root message. The static_assert in
-  // the .cc file guarantees that the sizeof(nested_messages_arena_) is enough
-  // to contain up to kMaxNestingDepth messages.
-  ALIGNAS(sizeof(void*)) uint8_t nested_messages_arena_[512];
-
-  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
-  // nested messages would overflow the storage allocated by the root message.
-
-  DISALLOW_COPY_AND_ASSIGN(ProtoZeroMessage);
-};
-
-}  // namespace v2
-}  // namespace tracing
-
-#endif  // COMPONENTS_TRACING_CORE_PROTO_ZERO_MESSAGE_H_
diff --git a/components/tracing/core/proto_zero_message_unittest.cc b/components/tracing/core/proto_zero_message_unittest.cc
deleted file mode 100644
index e95db77..0000000
--- a/components/tracing/core/proto_zero_message_unittest.cc
+++ /dev/null
@@ -1,230 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "components/tracing/core/proto_zero_message.h"
-
-#include <limits>
-#include <memory>
-#include <vector>
-
-#include "base/hash.h"
-#include "components/tracing/core/proto_utils.h"
-#include "components/tracing/test/fake_scattered_buffer.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace tracing {
-namespace v2 {
-
-const size_t kChunkSize = 16;
-const uint8_t kTestBytes[] = {0, 0, 0, 0, 0x42, 1, 0x42, 0xff, 0x42, 0};
-const char kStartWatermark[] = {'a', 'b', 'c', 'd', '1', '2', '3', '\0'};
-const char kEndWatermark[] = {'9', '8', '7', '6', 'z', 'w', 'y', '\0'};
-
-class FakeMessage : public ProtoZeroMessage {
- public:
-};
-
-class ProtoZeroMessageTest : public ::testing::Test {
- public:
-  void SetUp() override {
-    buffer_.reset(new FakeScatteredBuffer(kChunkSize));
-    stream_writer_.reset(new ScatteredStreamWriter(buffer_.get()));
-    readback_pos_ = 0;
-  }
-
-  void TearDown() override {
-    // Check that none of the messages created by the text fixtures below did
-    // under/overflow their heap boundaries.
-    for (std::unique_ptr<uint8_t[]>& mem : messages_) {
-      EXPECT_STREQ(kStartWatermark, reinterpret_cast<char*>(mem.get()));
-      EXPECT_STREQ(kEndWatermark,
-                   reinterpret_cast<char*>(mem.get() + sizeof(kStartWatermark) +
-                                           sizeof(ProtoZeroMessage)));
-      mem.reset();
-    }
-    messages_.clear();
-    stream_writer_.reset();
-    buffer_.reset();
-  }
-
-  ProtoZeroMessage* NewMessage() {
-    std::unique_ptr<uint8_t[]> mem(
-        new uint8_t[sizeof(kStartWatermark) + sizeof(ProtoZeroMessage) +
-                    sizeof(kEndWatermark)]);
-    uint8_t* msg_start = mem.get() + sizeof(kStartWatermark);
-    memcpy(mem.get(), kStartWatermark, sizeof(kStartWatermark));
-    memset(msg_start, 0, sizeof(ProtoZeroMessage));
-    memcpy(msg_start + sizeof(ProtoZeroMessage), kEndWatermark,
-           sizeof(kEndWatermark));
-    messages_.push_back(std::move(mem));
-    ProtoZeroMessage* msg = reinterpret_cast<ProtoZeroMessage*>(msg_start);
-    msg->Reset(stream_writer_.get());
-    return msg;
-  }
-
-  size_t GetNumSerializedBytes() {
-    if (buffer_->chunks().empty())
-      return 0;
-    return buffer_->chunks().size() * kChunkSize -
-           stream_writer_->bytes_available();
-  }
-
-  std::string GetNextSerializedBytes(size_t num_bytes) {
-    size_t old_readback_pos = readback_pos_;
-    readback_pos_ += num_bytes;
-    return buffer_->GetBytesAsString(old_readback_pos, num_bytes);
-  }
-
-  static void BuildNestedMessages(uint32_t depth, ProtoZeroMessage* msg) {
-    for (uint32_t i = 1; i <= 128; ++i)
-      msg->AppendBytes(i, kTestBytes, sizeof(kTestBytes));
-
-    if (depth < ProtoZeroMessage::kMaxNestingDepth) {
-      auto* child_msg = msg->BeginNestedMessage<FakeMessage>(1 + depth * 10);
-      BuildNestedMessages(depth + 1, child_msg);
-    }
-
-    for (uint32_t i = 129; i <= 256; ++i)
-      msg->AppendVarIntU32(i, 42);
-
-    if ((depth & 2) == 0)
-      msg->Finalize();
-  }
-
- private:
-  std::unique_ptr<FakeScatteredBuffer> buffer_;
-  std::unique_ptr<ScatteredStreamWriter> stream_writer_;
-  std::vector<std::unique_ptr<uint8_t[]>> messages_;
-  size_t readback_pos_;
-};
-
-TEST_F(ProtoZeroMessageTest, BasicTypesNoNesting) {
-  ProtoZeroMessage* msg = NewMessage();
-  msg->AppendVarIntU32(1 /* field_id */, 0);
-  msg->AppendVarIntU32(2 /* field_id */, std::numeric_limits<uint32_t>::max());
-  msg->AppendVarIntU64(3 /* field_id */, 42);
-  msg->AppendVarIntU64(4 /* field_id */, std::numeric_limits<uint64_t>::max());
-  msg->AppendFloat(5 /* field_id */, 3.1415f);
-  msg->AppendDouble(6 /* field_id */, 3.14159265358979323846);
-  msg->AppendBytes(7 /* field_id */, kTestBytes, sizeof(kTestBytes));
-
-  // Field ids > 16 are expected to be varint encoded (preamble > 1 byte)
-  msg->AppendString(257 /* field_id */, "0123456789abcdefABCDEF");
-
-  EXPECT_EQ(72u, msg->Finalize());
-  EXPECT_EQ(72u, GetNumSerializedBytes());
-
-  // These lines match the serialization of the Append* calls above.
-  ASSERT_EQ("0800", GetNextSerializedBytes(2));
-  ASSERT_EQ("10FFFFFFFF0F", GetNextSerializedBytes(6));
-  ASSERT_EQ("182A", GetNextSerializedBytes(2));
-  ASSERT_EQ("20FFFFFFFFFFFFFFFFFF01", GetNextSerializedBytes(11));
-  ASSERT_EQ("2D560E4940", GetNextSerializedBytes(5));
-  ASSERT_EQ("31182D4454FB210940", GetNextSerializedBytes(9));
-  ASSERT_EQ("3A0A00000000420142FF4200", GetNextSerializedBytes(12));
-  ASSERT_EQ("8A101630313233343536373839616263646566414243444546",
-            GetNextSerializedBytes(25));
-}
-
-TEST_F(ProtoZeroMessageTest, NestedMessagesSimple) {
-  ProtoZeroMessage* root_msg = NewMessage();
-  root_msg->AppendVarIntU32(1 /* field_id */, 1);
-
-  FakeMessage* nested_msg =
-      root_msg->BeginNestedMessage<FakeMessage>(128 /* field_id */);
-  ASSERT_EQ(0u, reinterpret_cast<uintptr_t>(nested_msg) % sizeof(void*));
-  nested_msg->AppendVarIntU32(2 /* field_id */, 2);
-
-  nested_msg = root_msg->BeginNestedMessage<FakeMessage>(129 /* field_id */);
-  nested_msg->AppendVarIntU32(4 /* field_id */, 2);
-
-  root_msg->AppendVarIntU32(5 /* field_id */, 3);
-
-  // The expected size of the root message is supposed to be 20 bytes:
-  //   2 bytes for the varint field (id: 1) (1 for preamble and one for payload)
-  //   6 bytes for the preamble of the 1st nested message (2 for id, 4 for size)
-  //   2 bytes for the varint field (id: 2) of the 1st nested message
-  //   6 bytes for the premable of the 2nd nested message
-  //   2 bytes for the varint field (id: 4) of the 2nd nested message.
-  //   2 bytes for the last varint (id : 5) field of the root message.
-  // Test also that finalization is idempontent and Finalize() can be safely
-  // called more than once without side effects.
-  for (int i = 0; i < 3; ++i) {
-    EXPECT_EQ(20u, root_msg->Finalize());
-    EXPECT_EQ(20u, GetNumSerializedBytes());
-  }
-
-  ASSERT_EQ("0801", GetNextSerializedBytes(2));
-
-  ASSERT_EQ("820882808000", GetNextSerializedBytes(6));
-  ASSERT_EQ("1002", GetNextSerializedBytes(2));
-
-  ASSERT_EQ("8A0882808000", GetNextSerializedBytes(6));
-  ASSERT_EQ("2002", GetNextSerializedBytes(2));
-
-  ASSERT_EQ("2803", GetNextSerializedBytes(2));
-}
-
-// Checks that the size field of root and nested messages is properly written
-// on finalization.
-TEST_F(ProtoZeroMessageTest, BackfillSizeOnFinalization) {
-  ProtoZeroMessage* root_msg = NewMessage();
-  uint8_t root_msg_size[proto::kMessageLengthFieldSize];
-  root_msg->set_size_field(
-      {&root_msg_size[0], &root_msg_size[proto::kMessageLengthFieldSize]});
-  root_msg->AppendVarIntU32(1, 0x42);
-
-  FakeMessage* nested_msg_1 = root_msg->BeginNestedMessage<FakeMessage>(2);
-  nested_msg_1->AppendVarIntU32(3, 0x43);
-
-  FakeMessage* nested_msg_2 = nested_msg_1->BeginNestedMessage<FakeMessage>(4);
-  uint8_t buf200[200];
-  memset(buf200, 0x42, sizeof(buf200));
-  nested_msg_2->AppendBytes(5, buf200, sizeof(buf200));
-
-  root_msg->inc_size_already_written(6);
-
-  // The value returned by Finalize() should be == the full size of |root_msg|.
-  EXPECT_EQ(217u, root_msg->Finalize());
-  EXPECT_EQ(217u, GetNumSerializedBytes());
-
-  // However the size written in the size field should take into account the
-  // inc_size_already_written() call and be equal to 118 - 6 = 112, encoded
-  // in a rendundant varint encoding of kMessageLengthFieldSize bytes.
-  EXPECT_STREQ("\xD3\x81\x80\x00", reinterpret_cast<char*>(root_msg_size));
-
-  // Skip 2 bytes for the 0x42 varint + 1 byte for the |nested_msg_1| preamble.
-  GetNextSerializedBytes(3);
-
-  // Check that the size of |nested_msg_1| was backfilled. Its size is:
-  // 203 bytes for |nest_mesg_2| (see below) + 5 bytes for its preamble +
-  // 2 bytes for the 0x43 varint = 210 bytes.
-  EXPECT_EQ("D2818000", GetNextSerializedBytes(4));
-
-  // Skip 2 bytes for the 0x43 varint + 1 byte for the |nested_msg_2| preamble.
-  GetNextSerializedBytes(3);
-
-  // Check that the size of |nested_msg_2| was backfilled. Its size is:
-  // 200 bytes (for |buf200|) + 3 bytes for its preamble = 203 bytes.
-  EXPECT_EQ("CB818000", GetNextSerializedBytes(4));
-}
-
-TEST_F(ProtoZeroMessageTest, StressTest) {
-  std::vector<ProtoZeroMessage*> nested_msgs;
-
-  ProtoZeroMessage* root_msg = NewMessage();
-  BuildNestedMessages(0, root_msg);
-  root_msg->Finalize();
-
-  // The main point of this test is to stress the code paths and test for
-  // unexpected crashes of the production code. The actual serialization is
-  // already covered in the other text fixtures. Keeping just a final smoke test
-  // here on the full buffer hash.
-  std::string full_buf = GetNextSerializedBytes(GetNumSerializedBytes());
-  uint32_t buf_hash = base::SuperFastHash(full_buf.data(), full_buf.size());
-  EXPECT_EQ(0x14BC1BA3u, buf_hash);
-}
-
-}  // namespace v2
-}  // namespace tracing
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 46d37b5..4143cc1 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -37,6 +37,7 @@ source_set("browser") {
     "//components/filesystem:lib",
     "//components/leveldb:lib",
     "//components/link_header_util",
+    "//components/memory_coordinator/browser",
     "//components/mime_util",
     "//components/scheduler:common",
     "//components/tracing",
diff --git a/content/browser/DEPS b/content/browser/DEPS
index 5cd8d76..96021ad 100644
--- a/content/browser/DEPS
+++ b/content/browser/DEPS
@@ -4,6 +4,8 @@ include_rules = [
   "+components/filesystem",
   "+components/leveldb",
   "+components/link_header_util",
+  "+components/memory_coordinator/browser",
+  "+components/memory_coordinator/common",
   "+components/mime_util",
   "+components/network_session_configurator/switches.h",
   "+components/profile_service",
diff --git a/content/browser/android/content_view_core_impl.cc b/content/browser/android/content_view_core_impl.cc
index e486341..b3bbe94 100644
--- a/content/browser/android/content_view_core_impl.cc
+++ b/content/browser/android/content_view_core_impl.cc
@@ -1007,6 +1007,10 @@ jboolean ContentViewCoreImpl::OnTouchEvent(
                                : rwhv->OnTouchEvent(event);
 }
 
+float ContentViewCoreImpl::GetDpiScale() const {
+  return dpi_scale_;
+}
+
 jboolean ContentViewCoreImpl::SendMouseMoveEvent(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
diff --git a/content/browser/android/content_view_core_impl.h b/content/browser/android/content_view_core_impl.h
index ae645d3..28ac05f 100644
--- a/content/browser/android/content_view_core_impl.h
+++ b/content/browser/android/content_view_core_impl.h
@@ -65,6 +65,7 @@ class ContentViewCoreImpl : public ContentViewCore,
       const override;
   cc::Layer* GetLayer() const override;
   bool ShowPastePopup(int x, int y) override;
+  float GetDpiScale() const override;
   void PauseOrResumeGeolocation(bool should_pause) override;
   void RequestTextSurroundingSelection(
       int max_length,
diff --git a/content/browser/android/overscroll_controller_android.cc b/content/browser/android/overscroll_controller_android.cc
index 5e89172..8feda1c 100644
--- a/content/browser/android/overscroll_controller_android.cc
+++ b/content/browser/android/overscroll_controller_android.cc
@@ -97,10 +97,9 @@ std::unique_ptr<OverscrollRefresh> CreateRefreshEffect(
 }  // namespace
 
 OverscrollControllerAndroid::OverscrollControllerAndroid(
-    ContentViewCoreImpl* content_view_core,
-    float dpi_scale)
+    ContentViewCoreImpl* content_view_core)
     : compositor_(content_view_core->GetWindowAndroid()->GetCompositor()),
-      dpi_scale_(dpi_scale),
+      dpi_scale_(content_view_core->GetDpiScale()),
       enabled_(true),
       glow_effect_(CreateGlowEffect(this, dpi_scale_)),
       refresh_effect_(CreateRefreshEffect(content_view_core)) {
diff --git a/content/browser/android/overscroll_controller_android.h b/content/browser/android/overscroll_controller_android.h
index 7db37c9..564754e 100644
--- a/content/browser/android/overscroll_controller_android.h
+++ b/content/browser/android/overscroll_controller_android.h
@@ -37,8 +37,7 @@ struct DidOverscrollParams;
 // Note that all input coordinates (both for events and overscroll) are in DIPs.
 class OverscrollControllerAndroid : public ui::OverscrollGlowClient {
  public:
-  explicit OverscrollControllerAndroid(ContentViewCoreImpl* content_view_core,
-                                       float dpi_scale);
+  explicit OverscrollControllerAndroid(ContentViewCoreImpl* content_view_core);
   ~OverscrollControllerAndroid() override;
 
   // Returns true if |event| is consumed by an overscroll effect, in which
diff --git a/content/browser/android/popup_touch_handle_drawable.cc b/content/browser/android/popup_touch_handle_drawable.cc
index 14b1230..e5cce03 100644
--- a/content/browser/android/popup_touch_handle_drawable.cc
+++ b/content/browser/android/popup_touch_handle_drawable.cc
@@ -11,8 +11,7 @@ namespace content {
 
 // static
 std::unique_ptr<PopupTouchHandleDrawable> PopupTouchHandleDrawable::Create(
-    ContentViewCore* content_view_core,
-    float dpi_scale) {
+    ContentViewCore* content_view_core) {
   DCHECK(content_view_core);
   base::android::ScopedJavaLocalRef<jobject> content_view_core_obj =
       content_view_core->GetJavaObject();
@@ -21,8 +20,8 @@ std::unique_ptr<PopupTouchHandleDrawable> PopupTouchHandleDrawable::Create(
   JNIEnv* env = base::android::AttachCurrentThread();
   base::android::ScopedJavaLocalRef<jobject> drawable_obj(
       Java_PopupTouchHandleDrawable_create(env, content_view_core_obj.obj()));
-  return std::unique_ptr<PopupTouchHandleDrawable>(
-      new PopupTouchHandleDrawable(env, drawable_obj.obj(), dpi_scale));
+  return std::unique_ptr<PopupTouchHandleDrawable>(new PopupTouchHandleDrawable(
+      env, drawable_obj.obj(), content_view_core->GetDpiScale()));
 }
 
 PopupTouchHandleDrawable::PopupTouchHandleDrawable(JNIEnv* env,
diff --git a/content/browser/android/popup_touch_handle_drawable.h b/content/browser/android/popup_touch_handle_drawable.h
index f64a61a..9ba4093 100644
--- a/content/browser/android/popup_touch_handle_drawable.h
+++ b/content/browser/android/popup_touch_handle_drawable.h
@@ -21,8 +21,7 @@ class ContentViewCore;
 class PopupTouchHandleDrawable : public ui::TouchHandleDrawable {
  public:
   static std::unique_ptr<PopupTouchHandleDrawable> Create(
-      ContentViewCore* content_view_core,
-      float dpi_scale);
+      ContentViewCore* content_view_core);
   ~PopupTouchHandleDrawable() override;
 
   // ui::TouchHandleDrawable implementation.
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 2368fbd..dd8a090 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -36,6 +36,8 @@
 #include "base/trace_event/memory_dump_manager.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "components/memory_coordinator/browser/memory_coordinator.h"
+#include "components/memory_coordinator/common/memory_coordinator_features.h"
 #include "components/tracing/browser/trace_config_file.h"
 #include "components/tracing/common/process_metrics_memory_dump_provider.h"
 #include "components/tracing/common/trace_to_console.h"
@@ -721,6 +723,10 @@ int BrowserMainLoop::PreCreateThreads() {
       parsed_command_line_));
 #endif
 
+  if (memory_coordinator::IsEnabled()) {
+    memory_coordinator_.reset(new memory_coordinator::MemoryCoordinator);
+  }
+
 #if defined(ENABLE_PLUGINS)
   // Prior to any processing happening on the IO thread, we create the
   // plugin service as it is predominantly used from the IO thread,
@@ -997,6 +1003,7 @@ void BrowserMainLoop::ShutdownThreadsAndCleanUp() {
   }
 
   memory_pressure_monitor_.reset();
+  memory_coordinator_.reset();
 
 #if defined(OS_MACOSX)
   BrowserCompositorMac::DisableRecyclingForShutdown();
diff --git a/content/browser/browser_main_loop.h b/content/browser/browser_main_loop.h
index 62ba7ac..d05d176 100644
--- a/content/browser/browser_main_loop.h
+++ b/content/browser/browser_main_loop.h
@@ -50,6 +50,10 @@ class MidiManager;
 }  // namespace midi
 }  // namespace media
 
+namespace memory_coordinator {
+class MemoryCoordinator;
+}  // namespace memory_coordinator
+
 namespace mojo {
 namespace edk {
 class ScopedIPCSupport;
@@ -143,6 +147,10 @@ class CONTENT_EXPORT BrowserMainLoop {
 
   void StopStartupTracingTimer();
 
+  memory_coordinator::MemoryCoordinator* memory_coordinator() const {
+    return memory_coordinator_.get();
+  }
+
 #if defined(OS_MACOSX) && !defined(OS_IOS)
   media::DeviceMonitorMac* device_monitor_mac() const {
     return device_monitor_mac_.get();
@@ -249,6 +257,7 @@ class CONTENT_EXPORT BrowserMainLoop {
   // Members initialized in |PreCreateThreads()| -------------------------------
   // Torn down in ShutdownThreadsAndCleanUp.
   std::unique_ptr<base::MemoryPressureMonitor> memory_pressure_monitor_;
+  std::unique_ptr<memory_coordinator::MemoryCoordinator> memory_coordinator_;
 
   // Members initialized in |CreateThreads()| ----------------------------------
   std::unique_ptr<BrowserProcessSubThread> db_thread_;
diff --git a/content/browser/frame_host/interstitial_page_impl.cc b/content/browser/frame_host/interstitial_page_impl.cc
index be08682..47e0c48 100644
--- a/content/browser/frame_host/interstitial_page_impl.cc
+++ b/content/browser/frame_host/interstitial_page_impl.cc
@@ -298,8 +298,11 @@ void InterstitialPageImpl::Hide() {
   controller_->delegate()->DetachInterstitialPage();
   // Let's revert to the original title if necessary.
   NavigationEntry* entry = controller_->GetVisibleEntry();
-  if (entry && !new_navigation_ && should_revert_web_contents_title_)
-    web_contents_->UpdateTitleForEntry(entry, original_web_contents_title_);
+  if (entry && !new_navigation_ && should_revert_web_contents_title_) {
+    entry->SetTitle(original_web_contents_title_);
+    controller_->delegate()->NotifyNavigationStateChanged(
+        INVALIDATE_TYPE_TITLE);
+  }
 
   static_cast<WebContentsImpl*>(web_contents_)->DidChangeVisibleSSLState();
 
@@ -408,7 +411,8 @@ void InterstitialPageImpl::UpdateTitle(
   }
   // TODO(evan): make use of title_direction.
   // http://code.google.com/p/chromium/issues/detail?id=27094
-  web_contents_->UpdateTitleForEntry(entry, title);
+  entry->SetTitle(title);
+  controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_TITLE);
 }
 
 InterstitialPage* InterstitialPageImpl::GetAsInterstitialPage() {
@@ -665,7 +669,7 @@ void InterstitialPageImpl::DontProceed() {
 
   if (should_discard_pending_nav_entry_) {
     // Since no navigation happens we have to discard the transient entry
-    // explicitly.  Note that by calling DiscardNonCommittedEntries() we also
+    // explicitely.  Note that by calling DiscardNonCommittedEntries() we also
     // discard the pending entry, which is what we want, since the navigation is
     // cancelled.
     controller_->DiscardNonCommittedEntries();
diff --git a/content/browser/frame_host/interstitial_page_impl_browsertest.cc b/content/browser/frame_host/interstitial_page_impl_browsertest.cc
index ab7203d..2fbdda3 100644
--- a/content/browser/frame_host/interstitial_page_impl_browsertest.cc
+++ b/content/browser/frame_host/interstitial_page_impl_browsertest.cc
@@ -64,6 +64,61 @@ class TestInterstitialPageDelegate : public InterstitialPageDelegate {
   }
 };
 
+// A title watcher for interstitial pages. The existing TitleWatcher does not
+// work for interstitial pages. Note that this title watcher waits for the
+// title update IPC message not the actual title update. So, the new title is
+// probably not propagated completely, yet.
+class InterstitialTitleUpdateWatcher : public BrowserMessageFilter {
+ public:
+  explicit InterstitialTitleUpdateWatcher(InterstitialPage* interstitial)
+      : BrowserMessageFilter(FrameMsgStart) {
+    interstitial->GetMainFrame()->GetProcess()->AddFilter(this);
+  }
+
+  void InitWait(const std::string& expected_title) {
+    DCHECK(!run_loop_);
+    expected_title_ = base::UTF8ToUTF16(expected_title);
+    run_loop_.reset(new base::RunLoop());
+  }
+
+  void Wait() {
+    DCHECK(run_loop_);
+    run_loop_->Run();
+    run_loop_.reset();
+  }
+
+ private:
+  ~InterstitialTitleUpdateWatcher() override {}
+
+  void OnTitleUpdateReceived(const base::string16& title) {
+    DCHECK(run_loop_);
+    if (title == expected_title_)
+      run_loop_->Quit();
+  }
+
+  // BrowserMessageFilter:
+  bool OnMessageReceived(const IPC::Message& message) override {
+    if (!run_loop_)
+      return false;
+
+    if (message.type() == FrameHostMsg_UpdateTitle::ID) {
+      FrameHostMsg_UpdateTitle::Param params;
+      if (FrameHostMsg_UpdateTitle::Read(&message, &params)) {
+        BrowserThread::PostTask(
+            BrowserThread::UI, FROM_HERE,
+            base::Bind(&InterstitialTitleUpdateWatcher::OnTitleUpdateReceived,
+                       this, std::get<0>(params)));
+      }
+    }
+    return false;
+  }
+
+  base::string16 expected_title_;
+  std::unique_ptr<base::RunLoop> run_loop_;
+
+  DISALLOW_COPY_AND_ASSIGN(InterstitialTitleUpdateWatcher);
+};
+
 // A message filter that watches for WriteText and CommitWrite clipboard IPC
 // messages to make sure cut/copy is working properly. It will mark these events
 // as handled to prevent modification of the actual clipboard.
@@ -197,6 +252,8 @@ class InterstitialPageImplTest : public ContentBrowserTest {
 
     clipboard_message_watcher_ =
         new ClipboardMessageWatcher(interstitial_.get());
+    title_update_watcher_ =
+        new InterstitialTitleUpdateWatcher(interstitial_.get());
 
     // Wait until page loads completely.
     ASSERT_TRUE(WaitForRenderFrameReady(interstitial_->GetMainFrame()));
@@ -235,14 +292,12 @@ class InterstitialPageImplTest : public ContentBrowserTest {
 
   std::string PerformCut() {
     clipboard_message_watcher_->InitWait();
-    const base::string16 expected_title = base::UTF8ToUTF16("TEXT_CHANGED");
-    content::TitleWatcher title_watcher(shell()->web_contents(),
-                                        expected_title);
+    title_update_watcher_->InitWait("TEXT_CHANGED");
     RenderFrameHostImpl* rfh =
         static_cast<RenderFrameHostImpl*>(interstitial_->GetMainFrame());
     rfh->GetRenderWidgetHost()->delegate()->Cut();
     clipboard_message_watcher_->WaitForWriteCommit();
-    EXPECT_EQ(expected_title, title_watcher.WaitAndGetTitle());
+    title_update_watcher_->Wait();
     return clipboard_message_watcher_->last_text();
   }
 
@@ -256,24 +311,19 @@ class InterstitialPageImplTest : public ContentBrowserTest {
   }
 
   void PerformPaste() {
-    const base::string16 expected_title = base::UTF8ToUTF16("TEXT_CHANGED");
-    content::TitleWatcher title_watcher(shell()->web_contents(),
-                                        expected_title);
+    title_update_watcher_->InitWait("TEXT_CHANGED");
     RenderFrameHostImpl* rfh =
         static_cast<RenderFrameHostImpl*>(interstitial_->GetMainFrame());
     rfh->GetRenderWidgetHost()->delegate()->Paste();
-    EXPECT_EQ(expected_title, title_watcher.WaitAndGetTitle());
+    title_update_watcher_->Wait();
   }
 
   void PerformSelectAll() {
-    const base::string16 expected_title =
-        base::UTF8ToUTF16("SELECTION_CHANGED");
-    content::TitleWatcher title_watcher(shell()->web_contents(),
-                                        expected_title);
+    title_update_watcher_->InitWait("SELECTION_CHANGED");
     RenderFrameHostImpl* rfh =
         static_cast<RenderFrameHostImpl*>(interstitial_->GetMainFrame());
     rfh->GetRenderWidgetHost()->delegate()->SelectAll();
-    EXPECT_EQ(expected_title, title_watcher.WaitAndGetTitle());
+    title_update_watcher_->Wait();
   }
 
  private:
@@ -294,6 +344,7 @@ class InterstitialPageImplTest : public ContentBrowserTest {
 
   std::unique_ptr<InterstitialPageImpl> interstitial_;
   scoped_refptr<ClipboardMessageWatcher> clipboard_message_watcher_;
+  scoped_refptr<InterstitialTitleUpdateWatcher> title_update_watcher_;
 
   DISALLOW_COPY_AND_ASSIGN(InterstitialPageImplTest);
 };
diff --git a/content/browser/frame_host/navigation_controller_impl_unittest.cc b/content/browser/frame_host/navigation_controller_impl_unittest.cc
index 1655c5f..a2c74bd 100644
--- a/content/browser/frame_host/navigation_controller_impl_unittest.cc
+++ b/content/browser/frame_host/navigation_controller_impl_unittest.cc
@@ -5039,8 +5039,7 @@ TEST_F(NavigationControllerTest, PushStateUpdatesTitleAndFavicon) {
   FaviconStatus favicon;
   favicon.valid = true;
   favicon.url = GURL("http://foo/favicon.ico");
-  contents()->UpdateTitleForEntry(
-      controller().GetLastCommittedEntry(), title);
+  controller().GetLastCommittedEntry()->SetTitle(title);
   controller().GetLastCommittedEntry()->GetFavicon() = favicon;
 
   // history.pushState() is called.
diff --git a/content/browser/loader/resource_dispatcher_host_browsertest.cc b/content/browser/loader/resource_dispatcher_host_browsertest.cc
index b96cc73..1261484 100644
--- a/content/browser/loader/resource_dispatcher_host_browsertest.cc
+++ b/content/browser/loader/resource_dispatcher_host_browsertest.cc
@@ -818,56 +818,18 @@ class RequestDataResourceDispatcherHostBrowserTest : public ContentBrowserTest {
 };
 
 IN_PROC_BROWSER_TEST_F(RequestDataResourceDispatcherHostBrowserTest, Basic) {
-  GURL top_url(embedded_test_server()->GetURL("/page_with_subresources.html"));
+  GURL top_url(embedded_test_server()->GetURL("/simple_page.html"));
   url::Origin top_origin(top_url);
 
   NavigateToURLBlockUntilNavigationsComplete(shell(), top_url, 1);
 
-  EXPECT_EQ(8u, delegate_->data().size());
-
-  // All resources loaded directly by the top-level document (including the
-  // top-level document itself) should have a |first_party| and |initiator|
-  // that match the URL of the top-level document.
-  for (const auto& request : delegate_->data()) {
-    SCOPED_TRACE(request->url);
-    EXPECT_EQ(top_url, request->first_party);
-    EXPECT_EQ(top_origin, request->initiator);
-  }
-}
-
-IN_PROC_BROWSER_TEST_F(RequestDataResourceDispatcherHostBrowserTest,
-                       BasicCrossSite) {
-  host_resolver()->AddRule("*", "127.0.0.1");
-  GURL top_url(embedded_test_server()->GetURL(
-      "a.com", "/nested_page_with_subresources.html"));
-  GURL nested_url(embedded_test_server()->GetURL(
-      "not-a.com", "/page_with_subresources.html"));
-  url::Origin top_origin(top_url);
-  url::Origin nested_origin(nested_url);
-
-  NavigateToURLBlockUntilNavigationsComplete(shell(), top_url, 1);
-
-  EXPECT_EQ(9u, delegate_->data().size());
+  EXPECT_EQ(1u, delegate_->data().size());
 
-  // The first items loaded are the top-level and nested documents. These should
-  // both have a |first_party| and |initiator| that match the URL of the
-  // top-level document:
+  // User-initiated top-level navigations have a first-party and initiator that
+  // matches the URL to which they navigate.
   EXPECT_EQ(top_url, delegate_->data()[0]->url);
   EXPECT_EQ(top_url, delegate_->data()[0]->first_party);
   EXPECT_EQ(top_origin, delegate_->data()[0]->initiator);
-
-  EXPECT_EQ(nested_url, delegate_->data()[1]->url);
-  EXPECT_EQ(top_url, delegate_->data()[1]->first_party);
-  EXPECT_EQ(top_origin, delegate_->data()[1]->initiator);
-
-  // The remaining items are loaded as subresources in the nested document, and
-  // should have a unique first-party, and an initiator that matches the
-  // document in which they're embedded.
-  for (size_t i = 2; i < delegate_->data().size(); i++) {
-    SCOPED_TRACE(delegate_->data()[i]->url);
-    EXPECT_EQ(kURLWithUniqueOrigin, delegate_->data()[i]->first_party);
-    EXPECT_EQ(nested_origin, delegate_->data()[i]->initiator);
-  }
 }
 
 IN_PROC_BROWSER_TEST_F(RequestDataResourceDispatcherHostBrowserTest,
diff --git a/content/browser/memory/memory_coordinator_browsertest.cc b/content/browser/memory/memory_coordinator_browsertest.cc
new file mode 100644
index 0000000..6000ce9
--- /dev/null
+++ b/content/browser/memory/memory_coordinator_browsertest.cc
@@ -0,0 +1,36 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/memory_coordinator/browser/memory_coordinator.h"
+#include "components/memory_coordinator/common/memory_coordinator_features.h"
+#include "content/browser/browser_main_loop.h"
+#include "content/public/test/content_browser_test.h"
+#include "content/public/test/content_browser_test_utils.h"
+
+namespace content {
+
+class MemoryCoordinatorTest : public ContentBrowserTest {
+ public:
+  MemoryCoordinatorTest() {}
+
+  void SetUp() override {
+    memory_coordinator::EnableForTesting();
+    ContentBrowserTest::SetUp();
+  }
+
+ protected:
+  memory_coordinator::MemoryCoordinator* memory_coordinator() {
+    return BrowserMainLoop::GetInstance()->memory_coordinator();
+  }
+
+  DISALLOW_COPY_AND_ASSIGN(MemoryCoordinatorTest);
+};
+
+IN_PROC_BROWSER_TEST_F(MemoryCoordinatorTest, HandleAdded) {
+  GURL url = GetTestUrl("", "simple_page.html");
+  NavigateToURL(shell(), url);
+  EXPECT_EQ(1u, memory_coordinator()->NumChildrenForTesting());
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 1aaee15..c0d9d72 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -44,6 +44,8 @@
 #include "base/tracked_objects.h"
 #include "build/build_config.h"
 #include "cc/base/switches.h"
+#include "components/memory_coordinator/browser/memory_coordinator.h"
+#include "components/memory_coordinator/common/memory_coordinator_features.h"
 #include "components/scheduler/common/scheduler_switches.h"
 #include "components/tracing/common/tracing_switches.h"
 #include "components/webmessaging/broadcast_channel_provider.h"
@@ -450,6 +452,13 @@ std::string UintVectorToString(const std::vector<unsigned>& vector) {
   return str;
 }
 
+void CreateMemoryCoordinatorHandle(
+    int render_process_id,
+    memory_coordinator::mojom::MemoryCoordinatorHandleRequest request) {
+  BrowserMainLoop::GetInstance()->memory_coordinator()->CreateHandle(
+      render_process_id, std::move(request));
+}
+
 }  // namespace
 
 RendererMainThreadFactoryFunction g_renderer_main_thread_factory = NULL;
@@ -1099,6 +1108,11 @@ void RenderProcessHostImpl::RegisterMojoInterfaces() {
   GetInterfaceRegistry()->AddInterface(
       base::Bind(&DeviceOrientationAbsoluteHost::Create), io_task_runner);
 
+  if (memory_coordinator::IsEnabled()) {
+    GetInterfaceRegistry()->AddInterface(
+        base::Bind(&CreateMemoryCoordinatorHandle, GetID()));
+  }
+
 #if defined(OS_ANDROID)
   ServiceRegistrarAndroid::RegisterProcessHostServices(
       mojo_child_connection_->service_registry_android());
diff --git a/content/browser/renderer_host/render_widget_host_view_android.cc b/content/browser/renderer_host/render_widget_host_view_android.cc
index 5916807..a196842 100644
--- a/content/browser/renderer_host/render_widget_host_view_android.cc
+++ b/content/browser/renderer_host/render_widget_host_view_android.cc
@@ -79,7 +79,6 @@
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "ui/android/window_android.h"
 #include "ui/android/window_android_compositor.h"
-#include "ui/base/layout.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/events/blink/blink_event_util.h"
@@ -271,10 +270,8 @@ std::unique_ptr<ui::TouchSelectionController> CreateSelectionController(
 }
 
 std::unique_ptr<OverscrollControllerAndroid> CreateOverscrollController(
-    ContentViewCoreImpl* content_view_core,
-    float dpi_scale) {
-  return base::WrapUnique(
-      new OverscrollControllerAndroid(content_view_core, dpi_scale));
+    ContentViewCoreImpl* content_view_core) {
+  return base::WrapUnique(new OverscrollControllerAndroid(content_view_core));
 }
 
 gfx::RectF GetSelectionRect(const ui::TouchSelectionController& controller) {
@@ -1187,13 +1184,11 @@ std::unique_ptr<ui::TouchHandleDrawable>
 RenderWidgetHostViewAndroid::CreateDrawable() {
   DCHECK(content_view_core_);
   if (!using_browser_compositor_)
-    return PopupTouchHandleDrawable::Create(
-        content_view_core_, ui::GetScaleFactorForNativeView(GetNativeView()));
+    return PopupTouchHandleDrawable::Create(content_view_core_);
 
   return std::unique_ptr<
       ui::TouchHandleDrawable>(new CompositedTouchHandleDrawable(
-      content_view_core_->GetLayer(),
-      ui::GetScaleFactorForNativeView(GetNativeView()),
+      content_view_core_->GetLayer(), content_view_core_->GetDpiScale(),
       // Use the activity context (instead of the application context) to ensure
       // proper handle theming.
       content_view_core_->GetContext().obj()));
@@ -1740,8 +1735,7 @@ void RenderWidgetHostViewAndroid::SetContentViewCore(
 
   if (!overscroll_controller_ &&
       content_view_core_->GetWindowAndroid()->GetCompositor()) {
-    overscroll_controller_ = CreateOverscrollController(
-        content_view_core_, ui::GetScaleFactorForNativeView(GetNativeView()));
+    overscroll_controller_ = CreateOverscrollController(content_view_core_);
   }
 
   if (!sync_compositor_) {
@@ -1813,8 +1807,7 @@ void RenderWidgetHostViewAndroid::OnDetachedFromWindow() {
 void RenderWidgetHostViewAndroid::OnAttachCompositor() {
   DCHECK(content_view_core_);
   if (!overscroll_controller_)
-    overscroll_controller_ = CreateOverscrollController(
-        content_view_core_, ui::GetScaleFactorForNativeView(GetNativeView()));
+    overscroll_controller_ = CreateOverscrollController(content_view_core_);
 }
 
 void RenderWidgetHostViewAndroid::OnDetachCompositor() {
diff --git a/content/browser/service_worker/embedded_worker_registry.cc b/content/browser/service_worker/embedded_worker_registry.cc
index f0031c5..70f2d9e 100644
--- a/content/browser/service_worker/embedded_worker_registry.cc
+++ b/content/browser/service_worker/embedded_worker_registry.cc
@@ -61,14 +61,7 @@ bool EmbeddedWorkerRegistry::OnMessageReceived(const IPC::Message& message,
     // purposely handling the message as no-op.
     return true;
   }
-  bool handled = worker->OnMessageReceived(message);
-
-  // Assume an unhandled message for a stopping worker is because the message
-  // was timed out and its handler removed prior to stopping.
-  // We might be more precise and record timed out request ids, but some
-  // cumbersome bookkeeping is needed and the IPC messaging will soon migrate
-  // to Mojo anyway.
-  return handled || worker->status() == EmbeddedWorkerStatus::STOPPING;
+  return worker->OnMessageReceived(message);
 }
 
 void EmbeddedWorkerRegistry::Shutdown() {
diff --git a/content/browser/service_worker/service_worker_dispatcher_host_unittest.cc b/content/browser/service_worker/service_worker_dispatcher_host_unittest.cc
index 1880575..1dc9254 100644
--- a/content/browser/service_worker/service_worker_dispatcher_host_unittest.cc
+++ b/content/browser/service_worker/service_worker_dispatcher_host_unittest.cc
@@ -23,7 +23,6 @@
 #include "content/browser/service_worker/service_worker_handle.h"
 #include "content/common/service_worker/embedded_worker_messages.h"
 #include "content/common/service_worker/service_worker_messages.h"
-#include "content/common/service_worker/service_worker_utils.h"
 #include "content/public/common/content_switches.h"
 #include "content/public/test/mock_resource_context.h"
 #include "content/public/test/test_browser_thread_bundle.h"
@@ -770,30 +769,4 @@ TEST_F(ServiceWorkerDispatcherHostTest, OnSetHostedVersionId) {
       ServiceWorkerMsg_AssociateRegistration::ID));
 }
 
-TEST_F(ServiceWorkerDispatcherHostTest, ReceivedTimedOutRequestResponse) {
-  GURL pattern = GURL("https://www.example.com/");
-  GURL script_url = GURL("https://www.example.com/service_worker.js");
-
-  SendProviderCreated(SERVICE_WORKER_PROVIDER_FOR_WINDOW, pattern);
-  SetUpRegistration(pattern, script_url);
-
-  version_->StartWorker(ServiceWorkerMetrics::EventType::UNKNOWN,
-                        base::Bind(&ServiceWorkerUtils::NoOpStatusCallback));
-  base::RunLoop().RunUntilIdle();
-
-  // Set the worker status to STOPPING.
-  version_->embedded_worker()->Stop();
-  EXPECT_EQ(EmbeddedWorkerStatus::STOPPING, version_->running_status());
-
-  // Receive a response for a timed out request. The bad message count should
-  // not increase.
-  const int kRequestId = 91;  // Dummy value
-  dispatcher_host_->OnMessageReceived(ServiceWorkerHostMsg_FetchEventResponse(
-      version_->embedded_worker()->embedded_worker_id(), kRequestId,
-      SERVICE_WORKER_FETCH_EVENT_RESULT_FALLBACK, ServiceWorkerResponse()));
-
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(0, dispatcher_host_->bad_messages_received_count_);
-}
-
 }  // namespace content
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 8facc1c..9b445c8 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -3893,7 +3893,7 @@ void WebContentsImpl::UpdateMaxPageIDIfNecessary(RenderViewHost* rvh) {
                                    max_restored_page_id);
 }
 
-void WebContentsImpl::UpdateTitleForEntry(NavigationEntry* entry,
+bool WebContentsImpl::UpdateTitleForEntry(NavigationEntryImpl* entry,
                                           const base::string16& title) {
   // For file URLs without a title, use the pathname instead. In the case of a
   // synthesized title, we don't want the update to count toward the "one set
@@ -3913,12 +3913,12 @@ void WebContentsImpl::UpdateTitleForEntry(NavigationEntry* entry,
   // |page_title_when_no_navigation_entry_| will be used for page title.
   if (entry) {
     if (final_title == entry->GetTitle())
-      return;  // Nothing changed, don't bother.
+      return false;  // Nothing changed, don't bother.
 
     entry->SetTitle(final_title);
   } else {
     if (page_title_when_no_navigation_entry_ == final_title)
-      return;  // Nothing changed, don't bother.
+      return false;  // Nothing changed, don't bother.
 
     page_title_when_no_navigation_entry_ = final_title;
   }
@@ -3929,9 +3929,7 @@ void WebContentsImpl::UpdateTitleForEntry(NavigationEntry* entry,
   FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                     TitleWasSet(entry, explicit_set));
 
-  // Broadcast notifications when the UI should be updated.
-  if (entry == controller_.GetEntryAtOffset(0))
-    NotifyNavigationStateChanged(INVALIDATE_TYPE_TITLE);
+  return true;
 }
 
 void WebContentsImpl::SendChangeLoadProgress() {
@@ -4537,7 +4535,12 @@ void WebContentsImpl::UpdateTitle(RenderFrameHost* render_frame_host,
 
   // TODO(evan): make use of title_direction.
   // http://code.google.com/p/chromium/issues/detail?id=27094
-  UpdateTitleForEntry(entry, title);
+  if (!UpdateTitleForEntry(entry, title))
+    return;
+
+  // Broadcast notifications when the UI should be updated.
+  if (entry == controller_.GetEntryAtOffset(0))
+    NotifyNavigationStateChanged(INVALIDATE_TYPE_TITLE);
 }
 
 void WebContentsImpl::UpdateEncoding(RenderFrameHost* render_frame_host,
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index c99ec23..dca061e 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -278,8 +278,6 @@ class CONTENT_EXPORT WebContentsImpl
   bool IsFullAccessibilityModeForTesting() const override;
   const PageImportanceSignals& GetPageImportanceSignals() const override;
   const base::string16& GetTitle() const override;
-  void UpdateTitleForEntry(NavigationEntry* entry,
-                           const base::string16& title) override;
   int32_t GetMaxPageID() override;
   int32_t GetMaxPageIDForSiteInstance(SiteInstance* site_instance) override;
   SiteInstanceImpl* GetSiteInstance() const override;
@@ -805,6 +803,9 @@ class CONTENT_EXPORT WebContentsImpl
   // So |find_request_manager_| can be accessed for testing.
   friend class FindRequestManagerTest;
 
+  // So InterstitialPageImpl can access SetIsLoading.
+  friend class InterstitialPageImpl;
+
   // TODO(brettw) TestWebContents shouldn't exist!
   friend class TestWebContents;
 
@@ -996,6 +997,17 @@ class CONTENT_EXPORT WebContentsImpl
   // have begun, to prevent any races in updating RenderView::next_page_id.
   void UpdateMaxPageIDIfNecessary(RenderViewHost* rvh);
 
+  // Saves the given title to the navigation entry and does associated work. It
+  // will update history and the view for the new title, and also synthesize
+  // titles for file URLs that have none (so we require that the URL of the
+  // entry already be set).
+  //
+  // This is used as the backend for state updates, which include a new title,
+  // or the dedicated set title message. It returns true if the new title is
+  // different and was therefore updated.
+  bool UpdateTitleForEntry(NavigationEntryImpl* entry,
+                           const base::string16& title);
+
   // Helper for CreateNewWidget/CreateNewFullscreenWidget.
   void CreateNewWidget(int32_t render_process_id,
                        int32_t route_id,
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index 90749ef..47c31c8 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -27,7 +27,6 @@ source_set("common") {
     "//content:content_implementation",
     "//build/config:precompiled_headers",
     "//build/config/compiler:no_size_t_to_int_warning",
-    "//media/gpu:gpu_config",
   ]
 
   public_deps = [
diff --git a/content/common/sandbox_linux/bpf_gpu_policy_linux.cc b/content/common/sandbox_linux/bpf_gpu_policy_linux.cc
index 7dc9fa7..d356897 100644
--- a/content/common/sandbox_linux/bpf_gpu_policy_linux.cc
+++ b/content/common/sandbox_linux/bpf_gpu_policy_linux.cc
@@ -78,8 +78,8 @@ inline bool IsArchitectureArm() {
 #endif
 }
 
-inline bool UseV4L2Codec() {
-#if defined(USE_V4L2_CODEC)
+inline bool IsOzone() {
+#if defined(USE_OZONE)
   return true;
 #else
   return false;
@@ -343,7 +343,7 @@ void GpuProcessPolicy::InitGpuBrokerProcess(
   if (!IsChromeOS()) {
     permissions.push_back(
         BrokerFilePermission::ReadWriteCreateUnlinkRecursive(kDevShm));
-  } else if (UseV4L2Codec()){
+  } else if (IsArchitectureArm() || IsOzone()){
     AddV4L2GpuWhitelist(&permissions);
     if (UseLibV4L2()) {
       dlopen("/usr/lib/libv4l2.so", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
diff --git a/content/content_browser.gypi b/content/content_browser.gypi
index 38034e3..7a768ad 100644
--- a/content/content_browser.gypi
+++ b/content/content_browser.gypi
@@ -8,6 +8,7 @@
     '../cc/cc.gyp:cc',
     '../cc/cc.gyp:cc_surfaces',
     '../components/components.gyp:display_compositor',
+    '../components/components.gyp:memory_coordinator_browser',
     '../components/leveldb/leveldb.gyp:leveldb_lib',
     '../components/link_header_util/link_header_util.gyp:link_header_util',
     '../components/mime_util/mime_util.gyp:mime_util',
diff --git a/content/content_renderer.gypi b/content/content_renderer.gypi
index d56e782..a7467f4 100644
--- a/content/content_renderer.gypi
+++ b/content/content_renderer.gypi
@@ -9,6 +9,7 @@
     '../cc/cc.gyp:cc',
     '../cc/cc.gyp:cc_proto',
     '../cc/blink/cc_blink.gyp:cc_blink',
+    '../components/components.gyp:memory_coordinator_child',
     '../components/scheduler/scheduler.gyp:scheduler',
     '../components/url_formatter/url_formatter.gyp:url_formatter',
     '../device/battery/battery.gyp:device_battery',
diff --git a/content/content_tests.gypi b/content/content_tests.gypi
index cc4fc9e..26f3343 100644
--- a/content/content_tests.gypi
+++ b/content/content_tests.gypi
@@ -254,6 +254,7 @@
       'browser/media/session/media_session_visibility_browsertest.cc',
       'browser/media/session/mock_media_session_observer.cc',
       'browser/media/session/mock_media_session_observer.h',
+      'browser/memory/memory_coordinator_browsertest.cc',
       'browser/memory/memory_pressure_controller_impl_browsertest.cc',
       'browser/message_port_provider_browsertest.cc',
       'browser/net_info_browsertest.cc',
@@ -1396,6 +1397,7 @@
         'test_support_content',
         'web_ui_test_mojo_bindings',
         '../base/base.gyp:test_support_base',
+        '../components/components.gyp:memory_coordinator_common',
         '../device/battery/battery.gyp:device_battery',
         '../device/battery/battery.gyp:device_battery_mojo_bindings',
         '../device/power_save_blocker/power_save_blocker.gyp:device_power_save_blocker',
diff --git a/content/public/browser/android/content_view_core.h b/content/public/browser/android/content_view_core.h
index 63921ec..44a2e3f 100644
--- a/content/public/browser/android/content_view_core.h
+++ b/content/public/browser/android/content_view_core.h
@@ -46,6 +46,7 @@ class CONTENT_EXPORT ContentViewCore {
   virtual base::android::ScopedJavaLocalRef<jobject> GetJavaObject() = 0;
   virtual bool ShowPastePopup(int x, int y) = 0;
 
+  virtual float GetDpiScale() const = 0;
   virtual void PauseOrResumeGeolocation(bool should_pause) = 0;
 
   // Text surrounding selection.
diff --git a/content/public/browser/navigation_entry.h b/content/public/browser/navigation_entry.h
index 87c17cd..92f020f 100644
--- a/content/public/browser/navigation_entry.h
+++ b/content/public/browser/navigation_entry.h
@@ -87,10 +87,6 @@ class NavigationEntry {
   // The caller is responsible for detecting when there is no title and
   // displaying the appropriate "Untitled" label if this is being displayed to
   // the user.
-  // Use WebContents::UpdateTitleForEntry() in most cases, since that notifies
-  // observers when the visible title changes. Only call
-  // NavigationEntry::SetTitle() below directly when this entry is known not to
-  // be visible.
   virtual void SetTitle(const base::string16& title) = 0;
   virtual const base::string16& GetTitle() const = 0;
 
diff --git a/content/public/browser/web_contents.h b/content/public/browser/web_contents.h
index 65de3da..36996f0 100644
--- a/content/public/browser/web_contents.h
+++ b/content/public/browser/web_contents.h
@@ -317,12 +317,6 @@ class WebContents : public PageNavigator,
   // download, in which case the URL would revert to what it was previously).
   virtual const base::string16& GetTitle() const = 0;
 
-  // Saves the given title to the navigation entry and does associated work. It
-  // will update history and the view with the new title, and also synthesize
-  // titles for file URLs that have none. Thus |entry| must have a URL set.
-  virtual void UpdateTitleForEntry(NavigationEntry* entry,
-                                   const base::string16& title) = 0;
-
   // The max page ID for any page that the current SiteInstance has loaded in
   // this WebContents.  Page IDs are specific to a given SiteInstance and
   // WebContents, corresponding to a specific RenderView in the renderer.
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index de54cbc..973f1f8 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -37,6 +37,7 @@ source_set("renderer") {
     "//cc/proto",
     "//cc/surfaces",
     "//cc/surfaces:surface_id",
+    "//components/memory_coordinator/child",
     "//components/scheduler:scheduler",
     "//components/url_formatter",
     "//content:resources",
diff --git a/content/renderer/DEPS b/content/renderer/DEPS
index 2a875c3..f728e88 100644
--- a/content/renderer/DEPS
+++ b/content/renderer/DEPS
@@ -1,6 +1,7 @@
 include_rules = [
   # Allow inclusion of specific components that we depend on.
   # See comment in content/DEPS for which components are allowed.
+  "+components/memory_coordinator/child",
   "+components/scheduler",
   "+components/url_formatter",
 
diff --git a/content/renderer/mus/BUILD.gn b/content/renderer/mus/BUILD.gn
index 7ce0718..1935f4e 100644
--- a/content/renderer/mus/BUILD.gn
+++ b/content/renderer/mus/BUILD.gn
@@ -21,7 +21,6 @@ source_set("mus") {
     "//base",
     "//cc",
     "//content/common",
-    "//content/public/child:child_sources",
     "//content/public/common:common_sources",
     "//mojo/common",
     "//mojo/converters/blink",
diff --git a/content/renderer/mus/render_widget_mus_connection.cc b/content/renderer/mus/render_widget_mus_connection.cc
index ad7233c..925cf8a 100644
--- a/content/renderer/mus/render_widget_mus_connection.cc
+++ b/content/renderer/mus/render_widget_mus_connection.cc
@@ -47,7 +47,7 @@ RenderWidgetMusConnection::CreateOutputSurface() {
   DCHECK(thread_checker_.CalledOnValidThread());
   DCHECK(!window_surface_binding_);
   scoped_refptr<cc::ContextProvider> context_provider(new ui::ContextProvider(
-      ChildThread::Get()->GetMojoShellConnection()->GetConnector()));
+      MojoShellConnection::GetForProcess()->GetConnector()));
 
   std::unique_ptr<cc::OutputSurface> surface(new ui::OutputSurface(
       context_provider, ui::WindowSurface::Create(&window_surface_binding_)));
diff --git a/content/renderer/mus/render_widget_window_tree_client_factory.cc b/content/renderer/mus/render_widget_window_tree_client_factory.cc
index 5abfc23..ef56edd 100644
--- a/content/renderer/mus/render_widget_window_tree_client_factory.cc
+++ b/content/renderer/mus/render_widget_window_tree_client_factory.cc
@@ -10,7 +10,6 @@
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "content/common/render_widget_window_tree_client_factory.mojom.h"
-#include "content/public/child/child_thread.h"
 #include "content/public/common/mojo_shell_connection.h"
 #include "content/renderer/mus/render_widget_mus_connection.h"
 #include "mojo/public/cpp/bindings/binding_set.h"
@@ -33,7 +32,7 @@ class RenderWidgetWindowTreeClientFactoryImpl
       public mojom::RenderWidgetWindowTreeClientFactory {
  public:
   RenderWidgetWindowTreeClientFactoryImpl() {
-    DCHECK(ChildThread::Get()->GetMojoShellConnection());
+    DCHECK(MojoShellConnection::GetForProcess());
   }
 
   ~RenderWidgetWindowTreeClientFactoryImpl() override {}
@@ -69,7 +68,7 @@ class RenderWidgetWindowTreeClientFactoryImpl
 }  // namespace
 
 void CreateRenderWidgetWindowTreeClientFactory() {
-  ChildThread::Get()->GetMojoShellConnection()->MergeService(
+  MojoShellConnection::GetForProcess()->MergeService(
       base::WrapUnique(new RenderWidgetWindowTreeClientFactoryImpl));
 }
 
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 1ababbb..495de97 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -3940,7 +3940,7 @@ void RenderFrameImpl::willSendRequest(
   //
   // TODO(mkwst): It would be cleaner to adjust blink::ResourceRequest to
   // initialize itself with a `nullptr` initiator so that this can be a simple
-  // `isNull()` check. https://crbug.com/625969
+  // `isNull()` check.
   if (request.requestorOrigin().isUnique() &&
       !frame->document().getSecurityOrigin().isUnique()) {
     request.setRequestorOrigin(frame->document().getSecurityOrigin());
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
index 0ca1197..1a4a026 100644
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -46,6 +46,7 @@
 #include "cc/raster/task_graph_runner.h"
 #include "cc/trees/layer_tree_host_common.h"
 #include "cc/trees/layer_tree_settings.h"
+#include "components/memory_coordinator/child/child_memory_coordinator_impl.h"
 #include "components/scheduler/child/compositor_worker_scheduler.h"
 #include "components/scheduler/child/webthread_base.h"
 #include "components/scheduler/child/webthread_impl_for_worker_scheduler.h"
@@ -823,6 +824,15 @@ void RenderThreadImpl::Init(
       base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,
                  base::Unretained(this))));
 
+  if (memory_coordinator::IsEnabled()) {
+    // TODO(bashi): Revisit how to manage the lifetime of
+    // ChildMemoryCoordinatorImpl.
+    // https://codereview.chromium.org/2094583002/#msg52
+    memory_coordinator_.reset(
+        new memory_coordinator::ChildMemoryCoordinatorImpl(
+            GetRemoteInterfaces()));
+  }
+
   int num_raster_threads = 0;
   std::string string_value =
       command_line.GetSwitchValueASCII(switches::kNumRasterThreads);
@@ -852,7 +862,7 @@ void RenderThreadImpl::Init(
 #if defined(MOJO_SHELL_CLIENT) && defined(USE_AURA)
   // We may not have a MojoShellConnection object in tests that directly
   // instantiate a RenderThreadImpl.
-  if (ChildThread::Get()->GetMojoShellConnection() &&
+  if (MojoShellConnection::GetForProcess() &&
       base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kUseMusInRenderer))
     CreateRenderWidgetWindowTreeClientFactory();
@@ -1837,7 +1847,8 @@ RenderThreadImpl::CreateCompositorOutputSurface(
     use_software = true;
 
 #if defined(MOJO_SHELL_CLIENT) && defined(USE_AURA)
-  if (ChildThread::Get()->GetMojoShellConnection() && !use_software &&
+  auto* shell_connection = MojoShellConnection::GetForProcess();
+  if (shell_connection && !use_software &&
       command_line.HasSwitch(switches::kUseMusInRenderer)) {
     RenderWidgetMusConnection* connection =
         RenderWidgetMusConnection::GetOrCreate(routing_id);
diff --git a/content/renderer/render_thread_impl.h b/content/renderer/render_thread_impl.h
index 9a3795f..b7ad13a 100644
--- a/content/renderer/render_thread_impl.h
+++ b/content/renderer/render_thread_impl.h
@@ -79,6 +79,10 @@ class AudioHardwareConfig;
 class GpuVideoAcceleratorFactories;
 }
 
+namespace memory_coordinator {
+class ChildMemoryCoordinatorImpl;
+}
+
 namespace scheduler {
 class WebThreadBase;
 }
@@ -643,6 +647,8 @@ class CONTENT_EXPORT RenderThreadImpl
   std::unique_ptr<base::MemoryPressureListener> memory_pressure_listener_;
 
   std::unique_ptr<MemoryObserver> memory_observer_;
+  std::unique_ptr<memory_coordinator::ChildMemoryCoordinatorImpl>
+      memory_coordinator_;
 
   scoped_refptr<base::SingleThreadTaskRunner>
       main_thread_compositor_task_runner_;
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index bab905c..83a74d0 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -449,6 +449,7 @@ test("content_browsertests") {
     ":content_test_mojo_bindings",
     ":web_ui_test_mojo_bindings",
     "//base/test:test_support",
+    "//components/memory_coordinator/browser",
     "//components/scheduler",
     "//content:resources",
     "//content/app:both_for_content_tests",
diff --git a/content/test/data/nested_page_with_subresources.html b/content/test/data/nested_page_with_subresources.html
deleted file mode 100644
index e6c2c98..0000000
--- a/content/test/data/nested_page_with_subresources.html
+++ /dev/null
@@ -1,8 +0,0 @@
-<!DOCTYPE html>
-<body>
-<script>
-  var i = document.createElement("iframe");
-  i.src = location.protocol + "//not-" + location.hostname + (location.port ? (":" + location.port) : "") + "/page_with_subresources.html";
-  document.body.appendChild(i);
-</script>
-</body>
diff --git a/content/test/data/page_with_subresources.html b/content/test/data/page_with_subresources.html
deleted file mode 100644
index 314cdba..0000000
--- a/content/test/data/page_with_subresources.html
+++ /dev/null
@@ -1,26 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-  <link rel="stylesheet" href="style"></link>
-  <link rel="prefetch" href="prefetch"></link>
-</head>
-<body>
-  <img src="image-inline">
-  <a href="javascript:" ping="ping">link</a>
-
-  <!-- All script-based loading at the bottom to avoid duplicating requests
-       due to the preload scanner -->
-  <script src="script"></script>
-  <script>
-    // <img>
-    var i = document.createElement('img');
-    i.src = "image-script";
-
-    // <a ping>
-    document.querySelector('a').click();
-
-    // Beacon
-    navigator.sendBeacon("/beacon", "foo");
-  </script>
-</body>
-</html>
diff --git a/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc b/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc
index a58e021..13f7dc3 100644
--- a/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc
+++ b/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc
@@ -182,8 +182,7 @@ void MimeHandlerViewGuest::NavigationStateChanged(
   content::NavigationEntry* last_committed_entry =
       embedder_web_contents()->GetController().GetLastCommittedEntry();
   if (last_committed_entry) {
-    embedder_web_contents()->UpdateTitleForEntry(last_committed_entry,
-                                                 source->GetTitle());
+    last_committed_entry->SetTitle(source->GetTitle());
     embedder_web_contents()->GetDelegate()->NavigationStateChanged(
         embedder_web_contents(), changed_flags);
   }
diff --git a/ios/chrome/BUILD.gn b/ios/chrome/BUILD.gn
index 01a2f17..0d2daa3 100644
--- a/ios/chrome/BUILD.gn
+++ b/ios/chrome/BUILD.gn
@@ -43,12 +43,7 @@ test("ios_chrome_unittests") {
     "browser/net/image_fetcher_unittest.mm",
     "browser/net/metrics_network_client_unittest.mm",
     "browser/net/retryable_url_fetcher_unittest.mm",
-    "browser/passwords/credential_manager_js_unittest.mm",
-    "browser/passwords/credential_manager_unittest.mm",
-    "browser/passwords/password_controller_js_unittest.mm",
-    "browser/passwords/password_controller_off_the_record_unittest.mm",
     "browser/passwords/password_controller_unittest.mm",
-    "browser/passwords/password_generation_agent_unittest.mm",
     "browser/reading_list/reading_list_entry_unittest.cc",
     "browser/reading_list/reading_list_model_unittest.cc",
     "browser/signin/chrome_identity_service_observer_bridge_unittest.mm",
@@ -77,8 +72,6 @@ test("ios_chrome_unittests") {
     ":native_content_controller_test_xib",
     "//base",
     "//base/test:test_support",
-    "//components/autofill/core/common:common",
-    "//components/autofill/ios/browser:browser",
     "//components/bookmarks/test",
     "//components/favicon_base",
     "//components/metrics",
@@ -102,7 +95,6 @@ test("ios_chrome_unittests") {
     "//ios/chrome/test:run_all_unittests",
     "//ios/public/provider/chrome/browser",
     "//ios/public/provider/chrome/browser:test_support",
-    "//ios/testing:ocmock_support",
     "//ios/web",
     "//ios/web:test_support",
     "//net:test_support",
diff --git a/ios/chrome/browser/DEPS b/ios/chrome/browser/DEPS
index 3ce842d..e334443 100644
--- a/ios/chrome/browser/DEPS
+++ b/ios/chrome/browser/DEPS
@@ -96,7 +96,6 @@ include_rules = [
   # For tests.
   "+ios/chrome/test",
   "+ios/public/test",
-  "+ios/testing",
 
   # Only parts of skia are compiled on iOS, so we explicitly list the
   # files that can be included to avoid bringing in more code.
diff --git a/ios/chrome/browser/passwords/credential_manager.mm b/ios/chrome/browser/passwords/credential_manager.mm
index 8c8779f..3ad9eb2 100644
--- a/ios/chrome/browser/passwords/credential_manager.mm
+++ b/ios/chrome/browser/passwords/credential_manager.mm
@@ -317,6 +317,8 @@ autofill::PasswordForm CredentialManager::GetSynthesizedFormForOrigin() const {
   synthetic_form.origin = web_state()->GetLastCommittedURL().GetOrigin();
   synthetic_form.signon_realm = synthetic_form.origin.spec();
   synthetic_form.scheme = autofill::PasswordForm::SCHEME_HTML;
+  synthetic_form.ssl_valid = synthetic_form.origin.SchemeIsCryptographic() &&
+                             !client_->DidLastPageLoadEncounterSSLErrors();
   return synthetic_form;
 }
 
diff --git a/ios/chrome/browser/passwords/credential_manager_js_unittest.mm b/ios/chrome/browser/passwords/credential_manager_js_unittest.mm
deleted file mode 100644
index 42382ba..0000000
--- a/ios/chrome/browser/passwords/credential_manager_js_unittest.mm
+++ /dev/null
@@ -1,510 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <memory>
-
-#include "base/mac/foundation_util.h"
-#import "base/mac/scoped_nsobject.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
-#import "ios/chrome/browser/passwords/js_credential_manager.h"
-#include "ios/web/public/web_state/credential.h"
-#import "ios/web/public/web_state/js/crw_js_injection_receiver.h"
-#import "ios/web/public/web_state/web_state.h"
-#include "ios/web/public/web_state/web_state_observer.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "testing/gtest_mac.h"
-#include "url/gurl.h"
-
-namespace {
-
-using ::testing::_;
-
-// Matcher to match web::Credential.
-MATCHER_P(IsEqualTo, value, "") {
-  return arg.type == value.type && arg.id == value.id &&
-         arg.name == value.name && arg.avatar_url == value.avatar_url &&
-         arg.password == value.password &&
-         arg.federation_origin.Serialize() ==
-             value.federation_origin.Serialize();
-}
-
-// A mock WebStateObserver for testing the Credential Manager API.
-class MockWebStateObserver : public web::WebStateObserver {
- public:
-  explicit MockWebStateObserver(web::WebState* web_state)
-      : web::WebStateObserver(web_state) {}
-  ~MockWebStateObserver() override {}
-
-  MOCK_METHOD5(
-      CredentialsRequested,
-      void(int, const GURL&, bool, const std::vector<std::string>&, bool));
-  MOCK_METHOD3(SignedIn, void(int, const GURL&, const web::Credential&));
-  MOCK_METHOD2(SignedIn, void(int, const GURL&));
-  MOCK_METHOD2(SignedOut, void(int, const GURL&));
-  MOCK_METHOD3(SignInFailed, void(int, const GURL&, const web::Credential&));
-  MOCK_METHOD2(SignInFailed, void(int, const GURL&));
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(MockWebStateObserver);
-};
-
-// Unit tests for the Credential Manager JavaScript and associated plumbing.
-class CredentialManagerJsTest : public web::WebTestWithWebState {
- public:
-  CredentialManagerJsTest() {}
-
-  void SetUp() override {
-    web::WebTestWithWebState::SetUp();
-    js_credential_manager_.reset(base::mac::ObjCCastStrict<JSCredentialManager>(
-        [[web_state()->GetJSInjectionReceiver()
-            instanceOfClass:[JSCredentialManager class]] retain]));
-    observer_.reset(new MockWebStateObserver(web_state()));
-  }
-
-  // Sets up a web page and injects the JSCredentialManager. Must be called
-  // before any interaction with the page.
-  void Inject() {
-    LoadHtml(@"");
-    [js_credential_manager_ inject];
-  }
-
-  // Returns the mock observer.
-  MockWebStateObserver& observer() { return *observer_; }
-
-  // Returns a string that creates a Credential object for JavaScript testing.
-  NSString* test_credential_js() {
-    return @"new PasswordCredential('bob', 'bobiscool', 'Bob Boblaw',"
-           @"'https://bobboblawslawblog.com/bob.jpg')";
-  }
-
-  // Returns a Credential to match the one returned by |test_credential_js()|.
-  web::Credential test_credential() {
-    web::Credential test_credential;
-    test_credential.type = web::CredentialType::CREDENTIAL_TYPE_PASSWORD;
-    test_credential.id = base::ASCIIToUTF16("bob");
-    test_credential.password = base::ASCIIToUTF16("bobiscool");
-    test_credential.name = base::ASCIIToUTF16("Bob Boblaw");
-    test_credential.avatar_url = GURL("https://bobboblawslawblog.com/bob.jpg");
-    return test_credential;
-  }
-
-  // Adds handlers for resolving and rejecting the promise returned by
-  // executing the code in |promise|.
-  void PrepareResolverAndRejecter(NSString* promise) {
-    EvaluateJavaScriptAsString(
-        [NSString stringWithFormat:@"var resolved = false;             "
-                                   @"var rejected = false;             "
-                                   @"var resolvedCredential = null;    "
-                                   @"var rejectedError = null;         "
-                                   @"function resolve(credential) {    "
-                                   @"  resolved = true;                "
-                                   @"  resolvedCredential = credential;"
-                                   @"}                                 "
-                                   @"function reject(error) {          "
-                                   @"  rejected = true;                "
-                                   @"  rejectedError = error;          "
-                                   @"}                                 "
-                                   @"%@.then(resolve, reject);         ",
-                                   promise]);
-    // Wait until the promise executor has executed.
-    WaitForCondition(^bool {
-      return [EvaluateJavaScriptAsString(
-          @"Object.keys(__gCrWeb.credentialManager.resolvers_).length > 0")
-          isEqualToString:@"true"];
-    });
-  }
-
-  // Checks that the Credential returned to the resolve handler in JavaScript
-  // matches the structure of |test_credential()|.
-  void CheckResolvedCredentialMatchesTestCredential() {
-    EXPECT_NSEQ(@"true", EvaluateJavaScriptAsString(@"resolved"));
-    EXPECT_NSEQ(
-        @"PasswordCredential",
-        EvaluateJavaScriptAsString(@"resolvedCredential.constructor.name"));
-    EXPECT_NSEQ(@"bob", EvaluateJavaScriptAsString(@"resolvedCredential.id"));
-    EXPECT_NSEQ(@"bobiscool",
-                EvaluateJavaScriptAsString(@"resolvedCredential.password_"));
-    EXPECT_NSEQ(@"Bob Boblaw",
-                EvaluateJavaScriptAsString(@"resolvedCredential.name"));
-    EXPECT_NSEQ(@"https://bobboblawslawblog.com/bob.jpg",
-                EvaluateJavaScriptAsString(@"resolvedCredential.avatarURL"));
-  }
-
-  // Checks that the promise set up by |PrepareResolverAndRejecter| was resolved
-  // without a credential.
-  void CheckResolvedWithoutCredential() {
-    EXPECT_NSEQ(@"true", EvaluateJavaScriptAsString(@"resolved"));
-    EXPECT_NSEQ(@"false", EvaluateJavaScriptAsString(@"!!resolvedCredential"));
-  }
-
-  // Checks that the promise set up by |PrepareResolverAndRejecter| was rejected
-  // with an error with name |error_name| and |message|.
-  void CheckRejected(NSString* error_name, NSString* message) {
-    EXPECT_NSEQ(@"true", EvaluateJavaScriptAsString(@"rejected"));
-    EXPECT_NSEQ(error_name, EvaluateJavaScriptAsString(@"rejectedError.name"));
-    EXPECT_NSEQ(message, EvaluateJavaScriptAsString(@"rejectedError.message"));
-  }
-
-  // Waits until the promise set up by |PrepareResolverAndRejecter| has been
-  // either resolved or rejected.
-  void WaitUntilPromiseResolvedOrRejected() {
-    WaitForCondition(^bool {
-      return [EvaluateJavaScriptAsString(@"resolved || rejected")
-          isEqualToString:@"true"];
-    });
-  }
-
-  // Resolves the promise set up by |PrepareResolverAndRejecter| and associated
-  // with |request_id| with |test_credential()|.
-  void ResolvePromiseWithTestCredential(int request_id) {
-    __block bool finished = false;
-    [js_credential_manager() resolvePromiseWithRequestID:request_id
-                                              credential:test_credential()
-                                       completionHandler:^(BOOL success) {
-                                         EXPECT_TRUE(success);
-                                         finished = true;
-                                       }];
-    WaitForCondition(^bool {
-      return finished;
-    });
-    WaitUntilPromiseResolvedOrRejected();
-  }
-
-  // Resolves the promise set up by |PrepareResolverAndRejecter| and associated
-  // with |request_id| without a credential.
-  void ResolvePromiseWithoutCredential(int request_id) {
-    __block bool finished = false;
-    [js_credential_manager() resolvePromiseWithRequestID:request_id
-                                       completionHandler:^(BOOL success) {
-                                         EXPECT_TRUE(success);
-                                         finished = true;
-                                       }];
-    WaitForCondition(^bool {
-      return finished;
-    });
-    WaitUntilPromiseResolvedOrRejected();
-  }
-
-  // Rejects the promise set up by |PrepareResolverAndRejecter| and associated
-  // with |request_id| with an error of type |error_type| and |message|.
-  void RejectPromise(int request_id, NSString* error_type, NSString* message) {
-    __block bool finished = false;
-    [js_credential_manager() rejectPromiseWithRequestID:request_id
-                                              errorType:error_type
-                                                message:message
-                                      completionHandler:^(BOOL success) {
-                                        EXPECT_TRUE(success);
-                                        finished = true;
-                                      }];
-    WaitForCondition(^bool {
-      return finished;
-    });
-    WaitUntilPromiseResolvedOrRejected();
-  }
-
-  // Tests that the promise set up by |PrepareResolverAndRejecter| wasn't
-  // rejected.
-  void CheckNeverRejected() {
-    EXPECT_NSEQ(@"false", EvaluateJavaScriptAsString(@"rejected"));
-  }
-
-  // Tests that the promise set up by |PrepareResolverAndRejecter| wasn't
-  // resolved.
-  void CheckNeverResolved() {
-    EXPECT_NSEQ(@"false", EvaluateJavaScriptAsString(@"resolved"));
-  }
-
-  // Returns the JSCredentialManager for testing.
-  JSCredentialManager* js_credential_manager() {
-    return js_credential_manager_;
-  }
-
-  // Tests that resolving the promise returned by |promise| and associated with
-  // |request_id| with |test_credential()| correctly forwards that credential
-  // to the client.
-  void TestPromiseResolutionWithCredential(int request_id, NSString* promise) {
-    PrepareResolverAndRejecter(promise);
-    ResolvePromiseWithTestCredential(request_id);
-    CheckResolvedCredentialMatchesTestCredential();
-    CheckNeverRejected();
-  }
-
-  // Tests that resolving the promise returned by |promise| and associated with
-  // |request_id| without a credential correctly invokes the client.
-  void TestPromiseResolutionWithoutCredential(int request_id,
-                                              NSString* promise) {
-    PrepareResolverAndRejecter(promise);
-    ResolvePromiseWithoutCredential(request_id);
-    CheckResolvedWithoutCredential();
-    CheckNeverRejected();
-  }
-
-  // Tests that rejecting the promise returned by |promise| and associated with
-  // |request_id| with an error of type |error| and message |message| correctly
-  // forwards that error to the client.
-  void TestPromiseRejection(int request_id,
-                            NSString* error,
-                            NSString* message,
-                            NSString* promise) {
-    PrepareResolverAndRejecter(promise);
-    RejectPromise(request_id, error, message);
-    CheckRejected(error, message);
-    CheckNeverResolved();
-  }
-
- private:
-  // Manager for injected credential manager JavaScript.
-  base::scoped_nsobject<JSCredentialManager> js_credential_manager_;
-
-  // Mock observer for testing.
-  std::unique_ptr<MockWebStateObserver> observer_;
-
-  DISALLOW_COPY_AND_ASSIGN(CredentialManagerJsTest);
-};
-
-// Tests that navigator.credentials calls use distinct request identifiers.
-TEST_F(CredentialManagerJsTest, RequestIdentifiersDiffer) {
-  Inject();
-  EXPECT_CALL(observer(), CredentialsRequested(0, _, _, _, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.request()");
-  EXPECT_CALL(observer(), SignInFailed(1, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifyFailedSignIn()");
-  EXPECT_CALL(observer(), SignInFailed(2, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifyFailedSignIn()");
-  EXPECT_CALL(observer(), SignedIn(3, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifySignedIn()");
-  EXPECT_CALL(observer(), SignedOut(4, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifySignedOut()");
-  EXPECT_CALL(observer(), CredentialsRequested(5, _, _, _, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.request()");
-}
-
-// Tests that navigator.credentials.request() creates and forwards the right
-// arguments to the app side.
-// TODO(rohitrao): Fails after merge r376674.  https://crbug.com/588706.
-TEST_F(CredentialManagerJsTest, DISABLED_RequestToApp) {
-  Inject();
-  std::vector<std::string> empty_federations;
-  std::vector<std::string> nonempty_federations;
-  nonempty_federations.push_back("foo");
-  nonempty_federations.push_back("bar");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(0, _, false, empty_federations, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.request()");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(1, _, false, empty_federations, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.request({})");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(2, _, true, empty_federations, _));
-  EvaluateJavaScriptAsString(
-      @"navigator.credentials.request({suppressUI: true})");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(3, _, false, nonempty_federations, _));
-  EvaluateJavaScriptAsString(
-      @"navigator.credentials.request({federations: ['foo', 'bar']})");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(4, _, true, nonempty_federations, _));
-  EvaluateJavaScriptAsString(
-      @"navigator.credentials.request("
-      @"    { suppressUI: true, federations: ['foo', 'bar'] })");
-
-  EXPECT_CALL(observer(),
-              CredentialsRequested(5, _, false, empty_federations, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.request("
-                             @"    { suppressUI: false, federations: [] })");
-}
-
-// Tests that navigator.credentials.notifySignedIn() creates and forwards the
-// right arguments to the app side.
-TEST_F(CredentialManagerJsTest, NotifySignedInToApp) {
-  Inject();
-  EXPECT_CALL(observer(), SignedIn(0, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifySignedIn()");
-
-  EXPECT_CALL(observer(), SignedIn(1, _, IsEqualTo(test_credential())));
-  EvaluateJavaScriptAsString(
-      [NSString stringWithFormat:@"navigator.credentials.notifySignedIn(%@)",
-                                 test_credential_js()]);
-}
-
-// Tests that navigator.credentials.notifySignedOut() creates and forwards the
-// right arguments to the app side.
-TEST_F(CredentialManagerJsTest, NotifySignedOutToApp) {
-  Inject();
-  EXPECT_CALL(observer(), SignedOut(0, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifySignedOut()");
-}
-
-// Tests that navigator.credentials.notifyFailedSignIn() creates and forwards
-// the right arguments to the app side.
-TEST_F(CredentialManagerJsTest, NotifyFailedSignInToApp) {
-  Inject();
-  EXPECT_CALL(observer(), SignInFailed(0, _));
-  EvaluateJavaScriptAsString(@"navigator.credentials.notifyFailedSignIn()");
-
-  EXPECT_CALL(observer(), SignInFailed(1, _, IsEqualTo(test_credential())));
-  EvaluateJavaScriptAsString([NSString
-      stringWithFormat:@"navigator.credentials.notifyFailedSignIn(%@)",
-                       test_credential_js()]);
-}
-
-// Tests that resolving the promise returned by a call to
-// navigator.credentials.request() with a credential correctly forwards that
-// credential to the client.
-TEST_F(CredentialManagerJsTest, ResolveRequestPromiseWithCredential) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), CredentialsRequested(request_id, _, _, _, _));
-  TestPromiseResolutionWithCredential(request_id,
-                                      @"navigator.credentials.request()");
-}
-
-// Tests that resolving the promise returned by a call to
-// navigator.credentials.request() without a credential correctly invokes the
-// client handler.
-TEST_F(CredentialManagerJsTest, ResolveRequestPromiseWithoutCredential) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), CredentialsRequested(request_id, _, _, _, _));
-  TestPromiseResolutionWithoutCredential(request_id,
-                                         @"navigator.credentials.request()");
-}
-
-// Tests that resolving the promise returned by a call to
-// navigator.credentials.notifySignedIn() without a credential correctly invokes
-// the client handler.
-TEST_F(CredentialManagerJsTest, ResolveNotifySignedInPromiseWithoutCredential) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedIn(request_id, _));
-  TestPromiseResolutionWithoutCredential(
-      request_id, @"navigator.credentials.notifySignedIn()");
-}
-
-// Tests that resolving the promise returned by a call to
-// navigator.credentials.notifyFailedSignIn() without a credential correctly
-// invokes the client handler.
-TEST_F(CredentialManagerJsTest,
-       ResolveNotifyFailedSignInPromiseWithoutCredential) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignInFailed(request_id, _));
-  TestPromiseResolutionWithoutCredential(
-      request_id, @"navigator.credentials.notifyFailedSignIn()");
-}
-
-// Tests that resolving the promise returned by a call to
-// navigator.credentials.notifyFailedSignIn() without a credential correctly
-// invokes the client handler.
-TEST_F(CredentialManagerJsTest,
-       ResolveNotifySignedOutPromiseWithoutCredential) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedOut(request_id, _));
-  TestPromiseResolutionWithoutCredential(
-      request_id, @"navigator.credentials.notifySignedOut()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.request() with a InvalidStateError correctly forwards
-// that error to the client.
-TEST_F(CredentialManagerJsTest, RejectRequestPromiseWithInvalidStateError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), CredentialsRequested(request_id, _, _, _, _));
-  TestPromiseRejection(request_id, @"InvalidStateError", @"foo",
-                       @"navigator.credentials.request()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifySignedIn() with a InvalidStateError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest,
-       RejectNotifySignedInPromiseWithInvalidStateError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedIn(request_id, _));
-  TestPromiseRejection(request_id, @"InvalidStateError", @"foo",
-                       @"navigator.credentials.notifySignedIn()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifyFailedSignIn() with a InvalidStateError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest,
-       RejectNotifyFailedSignInPromiseWithInvalidStateError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignInFailed(request_id, _));
-  TestPromiseRejection(request_id, @"InvalidStateError", @"foo",
-                       @"navigator.credentials.notifyFailedSignIn()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifySignedOut() with a InvalidStateError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest,
-       RejectNotifySignedOutPromiseWithInvalidStateError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedOut(request_id, _));
-  TestPromiseRejection(request_id, @"InvalidStateError", @"foo",
-                       @"navigator.credentials.notifySignedOut()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.request() with a SecurityError correctly forwards that
-// error to the client.
-TEST_F(CredentialManagerJsTest, RejectRequestPromiseWithSecurityError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), CredentialsRequested(request_id, _, _, _, _));
-  TestPromiseRejection(request_id, @"SecurityError", @"foo",
-                       @"navigator.credentials.request()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifySignedIn() with a SecurityError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest, RejectNotifySignedInPromiseWithSecurityError) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedIn(request_id, _));
-  TestPromiseRejection(request_id, @"SecurityError", @"foo",
-                       @"navigator.credentials.notifySignedIn()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifyFailedSignIn() with a SecurityError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest,
-       RejectPromiseWithSecurityError_notifyFailedSignIn) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignInFailed(request_id, _));
-  TestPromiseRejection(request_id, @"SecurityError", @"foo",
-                       @"navigator.credentials.notifyFailedSignIn()");
-}
-
-// Tests that rejecting the promise returned by a call to
-// navigator.credentials.notifySignedOut() with a SecurityError correctly
-// forwards that error to the client.
-TEST_F(CredentialManagerJsTest,
-       RejectPromiseWithSecurityError_notifySignedOut) {
-  Inject();
-  const int request_id = 0;
-  EXPECT_CALL(observer(), SignedOut(request_id, _));
-  TestPromiseRejection(request_id, @"SecurityError", @"foo",
-                       @"navigator.credentials.notifySignedOut()");
-}
-
-}  // namespace
diff --git a/ios/chrome/browser/passwords/credential_manager_unittest.mm b/ios/chrome/browser/passwords/credential_manager_unittest.mm
deleted file mode 100644
index 342b7c9..0000000
--- a/ios/chrome/browser/passwords/credential_manager_unittest.mm
+++ /dev/null
@@ -1,608 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "ios/chrome/browser/passwords/credential_manager.h"
-
-#include <memory>
-#include <utility>
-
-#include "base/mac/bind_objc_block.h"
-#include "base/memory/ref_counted.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
-#include "components/password_manager/core/browser/password_bubble_experiment.h"
-#include "components/password_manager/core/browser/stub_password_manager_client.h"
-#include "components/password_manager/core/browser/stub_password_manager_driver.h"
-#include "components/password_manager/core/browser/test_password_store.h"
-#include "components/password_manager/core/common/credential_manager_types.h"
-#include "components/password_manager/core/common/password_manager_pref_names.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "components/prefs/testing_pref_service.h"
-#import "ios/web/public/web_state/web_state.h"
-#import "ios/chrome/browser/passwords/js_credential_manager.h"
-#import "ios/testing/ocmock_complex_type_helper.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "testing/gtest_mac.h"
-#include "third_party/ocmock/OCMock/OCMock.h"
-#include "third_party/ocmock/gtest_support.h"
-#include "url/gurl.h"
-
-using testing::Return;
-
-namespace {
-// Type of a function invoked when a promise is resolved.
-typedef void (^ResolvePromiseBlock)(NSInteger request_id,
-                                    const web::Credential& credential);
-}  // namespace
-
-// A helper to mock methods that have C++ object parameters.
-@interface MockJSCredentialManager : OCMockComplexTypeHelper
-@end
-
-@implementation MockJSCredentialManager
-- (void)resolvePromiseWithRequestID:(NSInteger)requestID
-                         credential:(const web::Credential&)credential
-                  completionHandler:(void (^)(BOOL))completionHandler {
-  static_cast<ResolvePromiseBlock>([self blockForSelector:_cmd])(requestID,
-                                                                 credential);
-  completionHandler(YES);
-}
-@end
-
-namespace {
-
-// Returns a test credential.
-autofill::PasswordForm GetTestPasswordForm1(bool zero_click_allowed) {
-  autofill::PasswordForm form;
-  form.username_value = base::ASCIIToUTF16("foo");
-  form.password_value = base::ASCIIToUTF16("bar");
-  form.skip_zero_click = !zero_click_allowed;
-  form.type = autofill::PasswordForm::Type::TYPE_API;
-  return form;
-}
-
-// Returns a test credential matching |GetTestPasswordForm1()|.
-web::Credential GetTestWebCredential1(bool zero_click_allowed) {
-  web::Credential credential;
-  autofill::PasswordForm form(GetTestPasswordForm1(zero_click_allowed));
-  credential.type = web::CredentialType::CREDENTIAL_TYPE_PASSWORD;
-  credential.id = form.username_value;
-  credential.password = form.password_value;
-  return credential;
-}
-
-// Returns a different test credential.
-autofill::PasswordForm GetTestPasswordForm2(bool zero_click_allowed) {
-  autofill::PasswordForm form;
-  form.username_value = base::ASCIIToUTF16("baz");
-  form.password_value = base::ASCIIToUTF16("bah");
-  form.skip_zero_click = !zero_click_allowed;
-  return form;
-}
-
-// Returns a test credential matching |GetTestPasswordForm2()|.
-web::Credential GetTestWebCredential2(bool zero_click_allowed) {
-  web::Credential credential;
-  autofill::PasswordForm form(GetTestPasswordForm2(zero_click_allowed));
-  credential.type = web::CredentialType::CREDENTIAL_TYPE_PASSWORD;
-  credential.id = form.username_value;
-  credential.password = form.password_value;
-  return credential;
-}
-
-typedef BOOL (^StringPredicate)(NSString*);
-
-// Returns a block that takes a string argument and returns whether it is equal
-// to |string|.
-StringPredicate EqualsString(const char* string) {
-  return [[^BOOL(NSString* other) {
-    return [base::SysUTF8ToNSString(string) isEqualToString:other];
-  } copy] autorelease];
-}
-
-// A stub PasswordManagerClient for testing.
-class StubPasswordManagerClient
-    : public password_manager::StubPasswordManagerClient {
- public:
-  StubPasswordManagerClient()
-      : password_manager::StubPasswordManagerClient(),
-        password_store_(nullptr) {
-    prefs_.registry()->RegisterBooleanPref(
-        password_manager::prefs::kCredentialsEnableAutosignin, false);
-    password_bubble_experiment::RegisterPrefs(prefs_.registry());
-  }
-
-  ~StubPasswordManagerClient() override {
-    if (password_store_)
-      password_store_->ShutdownOnUIThread();
-  }
-
-  MOCK_CONST_METHOD0(IsSavingAndFillingEnabledForCurrentPage, bool());
-
-  void SetPasswordStore(
-      scoped_refptr<password_manager::PasswordStore> password_store) {
-    password_store_ = password_store;
-  }
-
-  password_manager::PasswordStore* GetPasswordStore() const override {
-    return password_store_.get();
-  }
-
-  void SetUserChosenCredential(
-      const password_manager::CredentialInfo& credential) {
-    user_chosen_credential_ = credential;
-  }
-
-  bool PromptUserToChooseCredentials(
-      ScopedVector<autofill::PasswordForm> local_forms,
-      ScopedVector<autofill::PasswordForm> federated_forms,
-      const GURL& origin,
-      const CredentialsCallback& callback) override {
-    return false;
-  }
-
-  bool PromptUserToSaveOrUpdatePassword(
-      std::unique_ptr<password_manager::PasswordFormManager> form_to_save,
-      password_manager::CredentialSourceType type,
-      bool update_password) override {
-    if (!update_password)
-      saved_form_ = std::move(form_to_save);
-    return true;
-  }
-
-  PrefService* GetPrefs() override { return &prefs_; }
-
-  password_manager::PasswordFormManager* saved_form() {
-    return saved_form_.get();
-  }
-
- private:
-  // PrefService for testing.
-  TestingPrefServiceSimple prefs_;
-
-  // PasswordStore for testing.
-  scoped_refptr<password_manager::PasswordStore> password_store_;
-
-  // The password form shown to the user for saving.
-  std::unique_ptr<password_manager::PasswordFormManager> saved_form_;
-
-  // The credential to be returned to callers of PromptUserToChooseCredentials.
-  password_manager::CredentialInfo user_chosen_credential_;
-
-  DISALLOW_COPY_AND_ASSIGN(StubPasswordManagerClient);
-};
-
-// Tests for CredentialManager.
-class CredentialManagerTest : public web::WebTestWithWebState {
- public:
-  CredentialManagerTest() {}
-  ~CredentialManagerTest() override {}
-
-  void SetUp() override {
-    web::WebTestWithWebState::SetUp();
-    id originalMock =
-        [OCMockObject niceMockForClass:[JSCredentialManager class]];
-    mock_js_credential_manager_.reset([[MockJSCredentialManager alloc]
-        initWithRepresentedObject:originalMock]);
-    credential_manager_.reset(new CredentialManager(
-        web_state(), &stub_client_, &stub_driver_,
-        static_cast<id>(mock_js_credential_manager_.get())));
-  }
-
-  // Sets up an expectation that the promise identified by |request_id| will be
-  // resolved with |credential|. |verified| must point to a variable that will
-  // be checked by the caller to ensure that the expectations were run. (This
-  // is necessary because OCMock doesn't handle methods with C++ object
-  // parameters.)
-  void ExpectPromiseResolved(bool* verified,
-                             int request_id,
-                             const web::Credential& credential) {
-    SEL selector =
-        @selector(resolvePromiseWithRequestID:credential:completionHandler:);
-    web::Credential strong_credential(credential);
-    [mock_js_credential_manager_
-                  onSelector:selector
-        callBlockExpectation:^(NSInteger block_request_id,
-                               const web::Credential& block_credential) {
-          EXPECT_EQ(request_id, block_request_id);
-          EXPECT_TRUE(CredentialsEqual(strong_credential, block_credential));
-          *verified = true;
-        }];
-  }
-
-  // Same as |ExpectPromiseResolved(bool*, int, const web::Credential&)| but
-  // does not expect a credential to be passed.
-  void ExpectPromiseResolved(int request_id) {
-    [[[mock_js_credential_manager_ representedObject] expect]
-        resolvePromiseWithRequestID:request_id
-                  completionHandler:nil];
-  }
-
-  // Clears the expectations set up by |ExpectPromiseResolved()|.
-  void ClearPromiseResolutionExpectations() {
-    SEL selector =
-        @selector(resolvePromiseWithRequestID:credential:completionHandler:);
-    [mock_js_credential_manager_ removeBlockExpectationOnSelector:selector];
-  }
-
-  // Sets up an expectation that the promise identified by |request_id| will be
-  // rejected with the given |error_type| and |message|. The caller should use
-  // EXPECT_OCMOCK_VERIFY to verify that the expectations were run.
-  void ExpectPromiseRejected(int request_id,
-                             const char* error_type,
-                             const char* message) {
-    [[[mock_js_credential_manager_ representedObject] expect]
-        rejectPromiseWithRequestID:request_id
-                         errorType:[OCMArg
-                                       checkWithBlock:EqualsString(error_type)]
-                           message:[OCMArg checkWithBlock:EqualsString(message)]
-                 completionHandler:[OCMArg any]];
-  }
-
- protected:
-  // Mock for PasswordManagerClient.
-  StubPasswordManagerClient stub_client_;
-
-  // Stub for PasswordManagerDriver.
-  password_manager::StubPasswordManagerDriver stub_driver_;
-
-  // Mock for JSCredentialManager.
-  base::scoped_nsobject<MockJSCredentialManager> mock_js_credential_manager_;
-
-  // CredentialManager for testing.
-  std::unique_ptr<CredentialManager> credential_manager_;
-
- private:
-  explicit CredentialManagerTest(const CredentialManagerTest&) = delete;
-  CredentialManagerTest& operator=(const CredentialManagerTest&) = delete;
-};
-
-// Tests that a credential request is rejected properly when the PasswordStore
-// is unavailable.
-TEST_F(CredentialManagerTest, RequestRejectedWhenPasswordStoreUnavailable) {
-  // Clear the password store.
-  stub_client_.SetPasswordStore(nullptr);
-
-  // Requesting a credential should reject the request with an error.
-  const int request_id = 0;
-  ExpectPromiseRejected(request_id,
-                        kCredentialsPasswordStoreUnavailableErrorType,
-                        kCredentialsPasswordStoreUnavailableErrorMessage);
-  credential_manager_->CredentialsRequested(request_id,
-                                            GURL("http://foo.com/login"), false,
-                                            std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_OCMOCK_VERIFY([mock_js_credential_manager_ representedObject]);
-}
-
-// Tests that a credential request is rejected when another request is pending.
-TEST_F(CredentialManagerTest, RequestRejectedWhenExistingRequestIsPending) {
-  // Set a password store, but prevent requests from completing.
-  stub_client_.SetPasswordStore(new password_manager::TestPasswordStore);
-
-  // Make an initial request. Don't pump the message loop, so that the task
-  // doesn't complete. Expect the request to resolve with an empty credential
-  // after the message loop is pumped.
-  const int first_request_id = 0;
-  bool first_verified = false;
-  ExpectPromiseResolved(&first_verified, first_request_id, web::Credential());
-  credential_manager_->CredentialsRequested(first_request_id,
-                                            GURL("http://foo.com/login"), false,
-                                            std::vector<std::string>(), true);
-
-  // Making a second request and then pumping the message loop should reject the
-  // request with an error.
-  const int second_request_id = 0;
-  ExpectPromiseRejected(second_request_id, kCredentialsPendingRequestErrorType,
-                        kCredentialsPendingRequestErrorMessage);
-  credential_manager_->CredentialsRequested(second_request_id,
-                                            GURL("http://foo.com/login"), false,
-                                            std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(first_verified);
-  EXPECT_OCMOCK_VERIFY([mock_js_credential_manager_ representedObject]);
-}
-
-// Tests that a zero-click credential request is resolved properly with an empty
-// credential when zero-click sign-in is disabled.
-TEST_F(CredentialManagerTest,
-       ZeroClickRequestResolvedWithEmptyCredentialWhenZeroClickSignInDisabled) {
-  // Set a password store, but request a zero-click credential with zero-click
-  // disabled.
-  stub_client_.SetPasswordStore(new password_manager::TestPasswordStore);
-  const bool zero_click = true;
-  static_cast<TestingPrefServiceSimple*>(stub_client_.GetPrefs())
-      ->SetUserPref(password_manager::prefs::kCredentialsEnableAutosignin,
-                    new base::FundamentalValue(!zero_click));
-
-  // Requesting a zero-click credential should immediately resolve the request
-  // with an empty credential.
-  const int request_id = 0;
-  bool verified = false;
-  ExpectPromiseResolved(&verified, request_id, web::Credential());
-  credential_manager_->CredentialsRequested(
-      request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(verified);
-}
-
-// Tests that a credential request is properly resolved with an empty credential
-// when no credentials are available.
-TEST_F(CredentialManagerTest,
-       RequestResolvedWithEmptyCredentialWhenNoneAvailable) {
-  // Set a password store with no credentials, enable zero-click, and request a
-  // zero-click credential.
-  stub_client_.SetPasswordStore(new password_manager::TestPasswordStore);
-  const bool zero_click = true;
-  static_cast<TestingPrefServiceSimple*>(stub_client_.GetPrefs())
-      ->SetUserPref(password_manager::prefs::kCredentialsEnableAutosignin,
-                    new base::FundamentalValue(zero_click));
-
-  // Requesting a zero-click credential should try to retrieve PasswordForms
-  // from the PasswordStore and resolve the request with an empty Credential
-  // when none are found.
-  const int request_id = 0;
-  bool verified = false;
-  ExpectPromiseResolved(&verified, request_id, web::Credential());
-  credential_manager_->CredentialsRequested(
-      request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(verified);
-}
-
-// Tests that a zero-click credential request properly resolves.
-TEST_F(CredentialManagerTest, ZeroClickRequestResolved) {
-  // Set a password store with a credential, enable zero-click, and request a
-  // zero-click credential.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  const bool zero_click = true;
-  store->AddLogin(GetTestPasswordForm1(zero_click));
-  stub_client_.SetPasswordStore(store);
-  static_cast<TestingPrefServiceSimple*>(stub_client_.GetPrefs())
-      ->SetUserPref(password_manager::prefs::kCredentialsEnableAutosignin,
-                    new base::FundamentalValue(zero_click));
-  // Without the first run experience, the zero-click credentials won't be
-  // passed to the site.
-  static_cast<TestingPrefServiceSimple*>(stub_client_.GetPrefs())
-      ->SetUserPref(
-          password_manager::prefs::kWasAutoSignInFirstRunExperienceShown,
-          new base::FundamentalValue(true));
-  WaitForBackgroundTasks();
-
-  // Requesting a zero-click credential should retrieve a PasswordForm from the
-  // PasswordStore and resolve the request with a corresponding Credential.
-  const int request_id = 0;
-  bool verified = false;
-  ExpectPromiseResolved(&verified, request_id,
-                        GetTestWebCredential1(zero_click));
-  credential_manager_->CredentialsRequested(
-      request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(verified);
-}
-
-// Tests that a credential request properly resolves.
-// TODO(crbug.com/598851): Reenabled this test.
-TEST_F(CredentialManagerTest, DISABLED_RequestResolved) {
-  // Set a password store with two credentials and set a credential to be
-  // returned by the PasswordManagerClient as if chosen by the user.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  const bool zero_click = false;
-  store->AddLogin(GetTestPasswordForm1(zero_click));
-  store->AddLogin(GetTestPasswordForm2(zero_click));
-  stub_client_.SetPasswordStore(store);
-  stub_client_.SetUserChosenCredential(password_manager::CredentialInfo(
-      GetTestPasswordForm2(zero_click),
-      password_manager::CredentialType::CREDENTIAL_TYPE_PASSWORD));
-  WaitForBackgroundTasks();
-
-  // Request a credential. The request should be resolved with the credential
-  // set on the stub client.
-  const int request_id = 0;
-  bool verified = false;
-  ExpectPromiseResolved(&verified, request_id,
-                        GetTestWebCredential2(zero_click));
-  credential_manager_->CredentialsRequested(
-      request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(verified);
-}
-
-// Tests that two requests back-to-back succeed when they wait to be resolved.
-// TODO(crbug.com/598851): Reenable this test.
-TEST_F(CredentialManagerTest, DISABLED_ConsecutiveRequestsResolve) {
-  // Set a password store with two credentials and set a credential to be
-  // returned by the PasswordManagerClient as if chosen by the user.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  const bool zero_click = false;
-  store->AddLogin(GetTestPasswordForm1(zero_click));
-  stub_client_.SetPasswordStore(store);
-  stub_client_.SetUserChosenCredential(password_manager::CredentialInfo(
-      GetTestPasswordForm1(zero_click),
-      password_manager::CredentialType::CREDENTIAL_TYPE_PASSWORD));
-  WaitForBackgroundTasks();
-
-  // Request a credential. The request should be resolved with the credential
-  // set on the stub client.
-  const int first_request_id = 0;
-  bool first_verified = false;
-  ExpectPromiseResolved(&first_verified, first_request_id,
-                        GetTestWebCredential1(zero_click));
-  credential_manager_->CredentialsRequested(
-      first_request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(first_verified);
-
-  ClearPromiseResolutionExpectations();
-
-  // Make a second request. It should be resolved again.
-  const int second_request_id = 1;
-  bool second_verified = false;
-  ExpectPromiseResolved(&second_verified, second_request_id,
-                        GetTestWebCredential1(zero_click));
-  credential_manager_->CredentialsRequested(
-      second_request_id, GURL("http://foo.com/login"), zero_click,
-      std::vector<std::string>(), true);
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  EXPECT_TRUE(second_verified);
-}
-
-// Tests that notifySignedIn prompts the user to save a password.
-TEST_F(CredentialManagerTest,
-       SignInResolvesAndPromptsUserWhenSavingEnabledAndNotBlacklisted) {
-  // Set a password store so the PasswordFormManager can retrieve credentials.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  stub_client_.SetPasswordStore(store);
-  const bool saving_enabled = true;
-  EXPECT_CALL(stub_client_, IsSavingAndFillingEnabledForCurrentPage())
-      .WillOnce(Return(saving_enabled))
-      .WillOnce(Return(saving_enabled));
-
-  // Notify the browser that the user signed in.
-  const int request_id = 0;
-  ExpectPromiseResolved(request_id);
-  const bool zero_click = false;
-  credential_manager_->SignedIn(request_id, GURL("http://foo.com/login"),
-                                GetTestWebCredential1(zero_click));
-
-  // Pump the message loop and verify.
-  WaitForBackgroundTasks();
-  autofill::PasswordForm expected_observed_form(
-      GetTestPasswordForm1(zero_click));
-  expected_observed_form.username_value.clear();
-  expected_observed_form.password_value.clear();
-  EXPECT_EQ(expected_observed_form, stub_client_.saved_form()->observed_form());
-}
-
-// Tests that notifySignedIn doesn't prompt the user to save a password when the
-// password manager is disabled for the current page.
-TEST_F(CredentialManagerTest,
-       SignInResolvesAndDoesNotPromptsUserWhenSavingDisabledAndNotBlacklisted) {
-  // Disable saving.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  stub_client_.SetPasswordStore(store);
-  const bool saving_enabled = false;
-  EXPECT_CALL(stub_client_, IsSavingAndFillingEnabledForCurrentPage())
-      .WillOnce(Return(saving_enabled));
-
-  // Notify the browser that the user signed in.
-  const int request_id = 0;
-  ExpectPromiseResolved(request_id);
-  const bool zero_click = false;
-  credential_manager_->SignedIn(request_id, GURL("http://foo.com/login"),
-                                GetTestWebCredential1(zero_click));
-
-  // Pump the message loop and verify that no form was saved.
-  WaitForBackgroundTasks();
-  EXPECT_FALSE(stub_client_.saved_form());
-}
-
-// Tests that notifySignedIn doesn't prompt the user to save a password when the
-// submitted form is blacklisted by the password manager.
-TEST_F(CredentialManagerTest,
-       SignInResolvesAndDoesNotPromptUserWhenSavingEnabledAndBlacklisted) {
-  // Disable saving.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  stub_client_.SetPasswordStore(store);
-  const bool saving_enabled = true;
-  EXPECT_CALL(stub_client_, IsSavingAndFillingEnabledForCurrentPage())
-      .WillOnce(Return(saving_enabled))
-      .WillOnce(Return(saving_enabled));
-
-  // Save the credential that will be signed in and mark it blacklisted.
-  const bool zero_click = false;
-  autofill::PasswordForm blacklisted_form(GetTestPasswordForm1(zero_click));
-  blacklisted_form.blacklisted_by_user = true;
-  store->AddLogin(blacklisted_form);
-  WaitForBackgroundTasks();
-
-  // Notify the browser that the user signed in.
-  const int request_id = 0;
-  ExpectPromiseResolved(request_id);
-  credential_manager_->SignedIn(request_id, GURL("http://foo.com/login"),
-                                GetTestWebCredential1(zero_click));
-
-  // Pump the message loop and verify that no form was saved.
-  WaitForBackgroundTasks();
-  EXPECT_FALSE(stub_client_.saved_form());
-}
-
-// Tests that notifySignedOut marks credentials as non-zero-click.
-TEST_F(CredentialManagerTest, SignOutResolvesAndMarksFormsNonZeroClick) {
-  // Create two zero-click credentials for the current page.
-  std::string current_origin(credential_manager_->GetOrigin().spec());
-  autofill::PasswordForm form1(GetTestPasswordForm1(true));
-  form1.signon_realm = current_origin;
-  autofill::PasswordForm form2(GetTestPasswordForm2(true));
-  form2.signon_realm = current_origin;
-
-  // Add both credentials to the store.
-  scoped_refptr<password_manager::TestPasswordStore> store(
-      new password_manager::TestPasswordStore);
-  stub_client_.SetPasswordStore(store);
-  store->AddLogin(form1);
-  store->AddLogin(form2);
-  WaitForBackgroundTasks();
-
-  // Check that both credentials in the store are zero-click.
-  EXPECT_EQ(1U, store->stored_passwords().size());
-  const std::vector<autofill::PasswordForm>& passwords_before_signout =
-      store->stored_passwords().find(current_origin)->second;
-  EXPECT_EQ(2U, passwords_before_signout.size());
-  for (const autofill::PasswordForm& form : passwords_before_signout)
-    EXPECT_FALSE(form.skip_zero_click);
-
-  // Sign out the current origin, which has credentials, and a second origin,
-  // which doesnt.
-  const int first_request_id = 0;
-  ExpectPromiseResolved(first_request_id);
-  credential_manager_->SignedOut(first_request_id,
-                                 credential_manager_->GetOrigin());
-  const int second_request_id = 1;
-  ExpectPromiseResolved(second_request_id);
-  credential_manager_->SignedOut(second_request_id, GURL("https://foo.com"));
-
-  // Pump the message loop to let the promises resolve. Check that the
-  // credentials in the store are now non-zero-click and that signing out an
-  // origin with no credentials had no effect.
-  WaitForBackgroundTasks();
-  EXPECT_EQ(1U, store->stored_passwords().size());
-  const std::vector<autofill::PasswordForm>& passwords_after_signout =
-      store->stored_passwords().find(current_origin)->second;
-  EXPECT_EQ(2U, passwords_after_signout.size());
-  for (const autofill::PasswordForm& form : passwords_after_signout)
-    EXPECT_TRUE(form.skip_zero_click);
-}
-
-}  // namespace
diff --git a/ios/chrome/browser/passwords/password_controller_js_unittest.mm b/ios/chrome/browser/passwords/password_controller_js_unittest.mm
deleted file mode 100644
index 966edc5..0000000
--- a/ios/chrome/browser/passwords/password_controller_js_unittest.mm
+++ /dev/null
@@ -1,300 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#import <Foundation/Foundation.h>
-
-#import "ios/chrome/browser/passwords/js_password_manager.h"
-#import "ios/web/public/test/web_js_test.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "testing/gtest_mac.h"
-
-// Unit tests for ios/chrome/browser/web/resources/password_controller.js
-namespace {
-
-// Text fixture to test password controller.
-class PasswordControllerJsTest
-    : public web::WebJsTest<web::WebTestWithWebState> {
- public:
-  PasswordControllerJsTest()
-      : web::WebJsTest<web::WebTestWithWebState>(@[ @"password_controller" ]) {}
-};
-
-// IDs used in the Username and Password <input> elements.
-NSString* const kEmailInputID = @"Email";
-NSString* const kPasswordInputID = @"Passwd";
-
-// Returns an autoreleased string of an HTML form that is similar to the
-// Google Accounts sign in form. |email| may be nil if the form does not
-// need to be pre-filled with the username. Use |isReadOnly| flag to indicate
-// if the email field should be read-only.
-NSString* GAIASignInForm(NSString* formAction,
-                         NSString* email,
-                         BOOL isReadOnly) {
-  return [NSString
-      stringWithFormat:
-          @"<html><body>"
-           "<form novalidate method=\"post\" action=\"%@\" "
-           "id=\"gaia_loginform\">"
-           "  <input name=\"GALX\" type=\"hidden\" value=\"abcdefghij\">"
-           "  <input name=\"service\" type=\"hidden\" value=\"mail\">"
-           "  <input id=\"%@\" name=\"Email\" type=\"email\" value=\"%@\" %@>"
-           "  <input id=\"%@\" name=\"Passwd\" type=\"password\" "
-           "    placeholder=\"Password\">"
-           "</form></body></html>",
-          formAction, kEmailInputID, email ? email : @"",
-          isReadOnly ? @"readonly" : @"", kPasswordInputID];
-}
-
-// Returns an autoreleased string of JSON for a parsed form.
-NSString* GAIASignInFormData(NSString* formAction) {
-  return [NSString stringWithFormat:@"{"
-                                     "  \"action\":\"%@\","
-                                     "  \"origin\":\"%@\","
-                                     "  \"fields\":["
-                                     "    {\"name\":\"%@\", \"value\":\"\"},"
-                                     "    {\"name\":\"%@\",\"value\":\"\"}"
-                                     "  ]"
-                                     "}",
-                                    formAction, formAction, kEmailInputID,
-                                    kPasswordInputID];
-}
-
-// Loads a page with a password form containing a username value already.
-// Checks that an attempt to fill in credentials with the same username
-// succeeds.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithPrefilledUsername_SucceedsWhenUsernameMatches) {
-  NSString* const formAction = @"https://accounts.google.com/ServiceLoginAuth";
-  NSString* const username = @"john.doe@gmail.com";
-  NSString* const password = @"super!secret";
-  LoadHtmlAndInject(GAIASignInForm(formAction, username, YES));
-  EXPECT_NSEQ(@"true", EvaluateJavaScriptWithFormat(
-                           @"__gCrWeb.fillPasswordForm(%@, '%@', '%@', '%@')",
-                           GAIASignInFormData(formAction), username, password,
-                           formAction));
-  // Verifies that the sign-in form has been filled with username/password.
-  EvaluateJavaScriptOnElementsAndCheck(@"document.getElementById('%@').value",
-                                       @[ kEmailInputID, kPasswordInputID ],
-                                       @[ username, password ]);
-}
-
-// Loads a page with a password form containing a username value already.
-// Checks that an attempt to fill in credentials with a different username
-// fails, as long as the field is read-only.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithPrefilledUsername_FailsWhenUsernameMismatched) {
-  NSString* const formAction = @"https://accounts.google.com/ServiceLoginAuth";
-  NSString* const username1 = @"john.doe@gmail.com";
-  NSString* const username2 = @"jean.dubois@gmail.com";
-  NSString* const password = @"super!secret";
-  LoadHtmlAndInject(GAIASignInForm(formAction, username1, YES));
-  EXPECT_NSEQ(@"false", EvaluateJavaScriptWithFormat(
-                            @"__gCrWeb.fillPasswordForm(%@, '%@', '%@', '%@')",
-                            GAIASignInFormData(formAction), username2, password,
-                            formAction));
-  // Verifies that the sign-in form has not been filled.
-  EvaluateJavaScriptOnElementsAndCheck(@"document.getElementById('%@').value",
-                                       @[ kEmailInputID, kPasswordInputID ],
-                                       @[ username1, @"" ]);
-}
-
-// Loads a page with a password form containing a username value already.
-// Checks that an attempt to fill in credentials with a different username
-// succeeds, as long as the field is writeable.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithPrefilledUsername_SucceedsByOverridingUsername) {
-  NSString* const formAction = @"https://accounts.google.com/ServiceLoginAuth";
-  NSString* const username1 = @"john.doe@gmail.com";
-  NSString* const username2 = @"jane.doe@gmail.com";
-  NSString* const password = @"super!secret";
-  LoadHtmlAndInject(GAIASignInForm(formAction, username1, NO));
-  EXPECT_NSEQ(@"true", EvaluateJavaScriptWithFormat(
-                           @"__gCrWeb.fillPasswordForm(%@, '%@', '%@', '%@')",
-                           GAIASignInFormData(formAction), username2, password,
-                           formAction));
-  // Verifies that the sign-in form has been filled with the new username
-  // and password.
-  EvaluateJavaScriptOnElementsAndCheck(@"document.getElementById('%@').value",
-                                       @[ kEmailInputID, kPasswordInputID ],
-                                       @[ username2, password ]);
-}
-
-// Check that when instructed to fill a form named "bar", a form named "foo"
-// is not filled with generated password.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithGeneratedPassword_FailsWhenFormNotFound) {
-  LoadHtmlAndInject(@"<html>"
-                     "  <body>"
-                     "    <form name=\"foo\">"
-                     "      <input type=\"password\" name=\"ps\">"
-                     "    </form>"
-                     "  </body"
-                     "</html>");
-  NSString* const formName = @"bar";
-  NSString* const password = @"abc";
-  EXPECT_NSEQ(@"false",
-              EvaluateJavaScriptWithFormat(
-                  @"__gCrWeb.fillPasswordFormWithGeneratedPassword('%@', '%@')",
-                  formName, password));
-}
-
-// Check that filling a form without password fields fails.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithGeneratedPassword_FailsWhenNoFieldsFilled) {
-  LoadHtmlAndInject(@"<html>"
-                     "  <body>"
-                     "    <form name=\"foo\">"
-                     "      <input type=\"text\" name=\"user\">"
-                     "      <input type=\"submit\" name=\"go\">"
-                     "    </form>"
-                     "  </body"
-                     "</html>");
-  NSString* const formName = @"foo";
-  NSString* const password = @"abc";
-  EXPECT_NSEQ(@"false",
-              EvaluateJavaScriptWithFormat(
-                  @"__gCrWeb.fillPasswordFormWithGeneratedPassword('%@', '%@')",
-                  formName, password));
-}
-
-// Check that a matching and complete password form is successfully filled
-// with the generated password.
-TEST_F(PasswordControllerJsTest,
-       FillPasswordFormWithGeneratedPassword_SucceedsWhenFieldsFilled) {
-  LoadHtmlAndInject(@"<html>"
-                     "  <body>"
-                     "    <form name=\"foo\">"
-                     "      <input type=\"text\" id=\"user\" name=\"user\">"
-                     "      <input type=\"password\" id=\"ps1\" name=\"ps1\">"
-                     "      <input type=\"password\" id=\"ps2\" name=\"ps2\">"
-                     "      <input type=\"submit\" name=\"go\">"
-                     "    </form>"
-                     "  </body"
-                     "</html>");
-  NSString* const formName = @"foo";
-  NSString* const password = @"abc";
-  EXPECT_NSEQ(@"true",
-              EvaluateJavaScriptWithFormat(
-                  @"__gCrWeb.fillPasswordFormWithGeneratedPassword('%@', '%@')",
-                  formName, password));
-  EXPECT_NSEQ(@"true",
-              EvaluateJavaScriptWithFormat(
-                  @"document.getElementById('ps1').value == '%@'", password));
-  EXPECT_NSEQ(@"true",
-              EvaluateJavaScriptWithFormat(
-                  @"document.getElementById('ps2').value == '%@'", password));
-  EXPECT_NSEQ(@"false",
-              EvaluateJavaScriptWithFormat(
-                  @"document.getElementById('user').value == '%@'", password));
-}
-
-// Check that one password form is identified and serialized correctly.
-TEST_F(PasswordControllerJsTest,
-       FindAndPreparePasswordFormsSingleFrameSingleForm) {
-  LoadHtmlAndInject(
-      @"<html><body>"
-       "<form action='/generic_submit' method='post' name='login_form'>"
-       "  Name: <input type='text' name='name'>"
-       "  Password: <input type='password' name='password'>"
-       "  <input type='submit' value='Submit'>"
-       "</form>"
-       "</body></html>");
-
-  const std::string base_url = BaseUrl();
-  NSString* result = [NSString
-      stringWithFormat:
-          @"[{\"action\":\"/generic_submit\","
-           "\"method\":\"post\","
-           "\"name\":\"login_form\","
-           "\"origin\":\"%s\","
-           "\"fields\":[{\"element\":\"name\",\"type\":\"text\"},"
-           "{\"element\":\"password\",\"type\":\"password\"},"
-           "{\"element\":\"\",\"type\":\"submit\"}],"
-           "\"usernameElement\":\"name\","
-           "\"usernameValue\":\"\","
-           "\"passwords\":[{\"element\":\"password\",\"value\":\"\"}]}]",
-          base_url.c_str()];
-  EXPECT_NSEQ(result,
-              EvaluateJavaScriptWithFormat(@"__gCrWeb.findPasswordForms()"));
-};
-
-// Check that multiple password forms are identified and serialized correctly.
-TEST_F(PasswordControllerJsTest,
-       FindAndPreparePasswordFormsSingleFrameMultipleForms) {
-  LoadHtmlAndInject(
-      @"<html><body>"
-       "<form action='/generic_submit' method='post' id='login_form1'>"
-       "  Name: <input type='text' name='name'>"
-       "  Password: <input type='password' name='password'>"
-       "  <input type='submit' value='Submit'>"
-       "</form>"
-       "<form action='/generic_s2' method='post' name='login_form2'>"
-       "  Name: <input type='text' name='name2'>"
-       "  Password: <input type='password' name='password2'>"
-       "  <input type='submit' value='Submit'>"
-       "</form>"
-       "</body></html>");
-
-  const std::string base_url = BaseUrl();
-  NSString* result = [NSString
-      stringWithFormat:
-          @"[{\"action\":\"/generic_submit\","
-           "\"method\":\"post\","
-           "\"name\":\"login_form1\","
-           "\"origin\":\"%s\","
-           "\"fields\":[{\"element\":\"name\",\"type\":\"text\"},"
-           "{\"element\":\"password\",\"type\":\"password\"},"
-           "{\"element\":\"\",\"type\":\"submit\"}],"
-           "\"usernameElement\":\"name\","
-           "\"usernameValue\":\"\","
-           "\"passwords\":[{\"element\":\"password\",\"value\":\"\"}]},"
-           "{\"action\":\"/generic_s2\","
-           "\"method\":\"post\","
-           "\"name\":\"login_form2\","
-           "\"origin\":\"%s\","
-           "\"fields\":[{\"element\":\"name2\",\"type\":\"text\"},"
-           "{\"element\":\"password2\",\"type\":\"password\"},"
-           "{\"element\":\"\",\"type\":\"submit\"}],"
-           "\"usernameElement\":\"name2\","
-           "\"usernameValue\":\"\","
-           "\"passwords\":[{\"element\":\"password2\",\"value\":\"\"}]}]",
-          base_url.c_str(), base_url.c_str()];
-  EXPECT_NSEQ(result,
-              EvaluateJavaScriptWithFormat(@"__gCrWeb.findPasswordForms()"));
-};
-
-// Test serializing of password forms.
-TEST_F(PasswordControllerJsTest, GetPasswordFormData) {
-  LoadHtmlAndInject(
-      @"<html><body>"
-       "<form name='np' id='np1' action='/generic_submit' method='post'>"
-       "  Name: <input type='text' name='name'>"
-       "  Password: <input type='password' name='password'>"
-       "  <input type='submit' value='Submit'>"
-       "</form>"
-       "</body></html>");
-
-  const std::string base_url = BaseUrl();
-  NSString* parameter = @"window.document.getElementsByTagName('form')[0]";
-  NSString* result = [NSString
-      stringWithFormat:
-          @"{\"action\":\"/generic_submit\","
-           "\"method\":\"post\","
-           "\"name\":\"np\","
-           "\"origin\":\"%s\","
-           "\"fields\":[{\"element\":\"name\",\"type\":\"text\"},"
-           "{\"element\":\"password\",\"type\":\"password\"},"
-           "{\"element\":\"\",\"type\":\"submit\"}],"
-           "\"usernameElement\":\"name\","
-           "\"usernameValue\":\"\","
-           "\"passwords\":[{\"element\":\"password\",\"value\":\"\"}]}",
-          base_url.c_str()];
-  EXPECT_NSEQ(
-      result,
-      EvaluateJavaScriptWithFormat(
-          @"__gCrWeb.stringify(__gCrWeb.getPasswordFormData(%@))", parameter));
-};
-
-}  // namespace
diff --git a/ios/chrome/browser/passwords/password_controller_off_the_record_unittest.mm b/ios/chrome/browser/passwords/password_controller_off_the_record_unittest.mm
deleted file mode 100644
index 2ce74f8..0000000
--- a/ios/chrome/browser/passwords/password_controller_off_the_record_unittest.mm
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <memory>
-
-#import "base/mac/scoped_nsobject.h"
-#include "base/memory/ptr_util.h"
-#include "components/password_manager/core/browser/stub_password_manager_client.h"
-#include "ios/chrome/browser/browser_state/test_chrome_browser_state.h"
-#import "ios/chrome/browser/passwords/password_controller.h"
-#import "ios/web/public/test/test_web_state.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace {
-
-class IncognitoPasswordManagerClient
-    : public password_manager::StubPasswordManagerClient {
- public:
-  bool IsOffTheRecord() const override { return true; }
-};
-
-}  // namespace
-
-class OffTheRecordWebState : public web::TestWebState {
- public:
-  OffTheRecordWebState() {
-    TestChromeBrowserState::Builder test_cbs_builder;
-    chrome_browser_state_ = test_cbs_builder.Build();
-  }
-
-  web::BrowserState* GetBrowserState() const override {
-    return chrome_browser_state_->GetOffTheRecordChromeBrowserState();
-  }
-
- private:
-  std::unique_ptr<TestChromeBrowserState> chrome_browser_state_;
-};
-
-class PasswordControllerOffTheRecordTest : public web::WebTestWithWebState {
- public:
-  void SetUp() override {
-    web::WebTestWithWebState::SetUp();
-    password_controller_.reset([[PasswordController alloc]
-           initWithWebState:&off_the_record_web_state_
-        passwordsUiDelegate:nil
-                     client:base::WrapUnique(
-                                new IncognitoPasswordManagerClient())]);
-  }
-
-  void TearDown() override {
-    [password_controller_ detach];
-    web::WebTestWithWebState::TearDown();
-  }
-
- protected:
-  OffTheRecordWebState off_the_record_web_state_;
-  base::scoped_nsobject<PasswordController> password_controller_;
-};
-
-// Check that if the PasswordController is told (by the PasswordManagerClient)
-// that this is Incognito, it won't enable password generation.
-TEST_F(PasswordControllerOffTheRecordTest, PasswordGenerationDisabled) {
-  EXPECT_FALSE([this->password_controller_ passwordGenerationManager]);
-}
diff --git a/ios/chrome/browser/passwords/password_controller_unittest.mm b/ios/chrome/browser/passwords/password_controller_unittest.mm
index 56148f2..7757fe2 100644
--- a/ios/chrome/browser/passwords/password_controller_unittest.mm
+++ b/ios/chrome/browser/passwords/password_controller_unittest.mm
@@ -1,50 +1,28 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
+// Copyright 2016 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 #import "ios/chrome/browser/passwords/password_controller.h"
 
-#import <Foundation/Foundation.h>
-
 #include <memory>
-#include <utility>
+#include <vector>
 
-#include "base/json/json_reader.h"
-#include "base/mac/bind_objc_block.h"
-#import "base/mac/scoped_nsobject.h"
+#include "base/mac/scoped_nsobject.h"
 #include "base/memory/ptr_util.h"
-#include "base/memory/ref_counted.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#import "base/test/ios/wait_util.h"
-#include "base/values.h"
-#include "components/autofill/core/common/password_form_fill_data.h"
 #include "components/password_manager/core/browser/log_manager.h"
-#include "components/password_manager/core/browser/mock_password_store.h"
+#include "components/password_manager/core/browser/password_form_manager.h"
 #include "components/password_manager/core/browser/stub_password_manager_client.h"
 #include "components/password_manager/core/common/password_manager_pref_names.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "components/prefs/testing_pref_service.h"
-#import "ios/chrome/browser/autofill/form_input_accessory_view_controller.h"
-#import "ios/chrome/browser/autofill/form_suggestion_controller.h"
+#include "components/syncable_prefs/testing_pref_service_syncable.h"
 #include "ios/chrome/browser/browser_state/test_chrome_browser_state.h"
-#import "ios/chrome/browser/passwords/js_password_manager.h"
-#import "ios/web/public/web_state/web_state.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
 #import "ios/web/public/test/test_web_state.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "testing/gtest_mac.h"
-#import "third_party/ocmock/OCMock/OCMock.h"
-#import "third_party/ocmock/OCMock/OCPartialMockObject.h"
 #include "url/gurl.h"
 
-using autofill::PasswordForm;
-using autofill::PasswordFormFillData;
+using testing::_;
 using testing::Return;
 
-namespace {
-
 class MockWebState : public web::TestWebState {
  public:
   MOCK_CONST_METHOD0(GetBrowserState, web::BrowserState*(void));
@@ -53,22 +31,21 @@ class MockWebState : public web::TestWebState {
 class MockPasswordManagerClient
     : public password_manager::StubPasswordManagerClient {
  public:
-  explicit MockPasswordManagerClient(password_manager::PasswordStore* store)
-      : store_(store) {}
-
-  ~MockPasswordManagerClient() override = default;
-
+  // |form_manager| stays owned by the mock.
+  MOCK_METHOD3(PromptUserToSaveOrUpdatePasswordPtr,
+               void(password_manager::PasswordFormManager* form_manager,
+                    password_manager::CredentialSourceType type,
+                    bool update_password));
   MOCK_CONST_METHOD0(GetLogManager, password_manager::LogManager*(void));
 
-  PrefService* GetPrefs() override { return &prefs_; }
-
-  password_manager::PasswordStore* GetPasswordStore() const override {
-    return store_;
+  // Workaround for std::unique_ptr<> lacking a copy constructor.
+  bool PromptUserToSaveOrUpdatePassword(
+      std::unique_ptr<password_manager::PasswordFormManager> manager,
+      password_manager::CredentialSourceType type,
+      bool update_password) override {
+    PromptUserToSaveOrUpdatePasswordPtr(manager.get(), type, update_password);
+    return false;
   }
-
- private:
-  TestingPrefServiceSimple prefs_;
-  password_manager::PasswordStore* const store_;
 };
 
 class MockLogManager : public password_manager::LogManager {
@@ -81,1202 +58,24 @@ class MockLogManager : public password_manager::LogManager {
   void SetSuspended(bool suspended) override {}
 };
 
-// Creates PasswordController with the given |web_state| and a mock client
-// using the given |store|. If not null, |weak_client| is filled with a
-// non-owning pointer to the created client. The created controller is
-// returned.
-base::scoped_nsobject<PasswordController> CreatePasswordController(
-    web::WebState* web_state,
-    password_manager::PasswordStore* store,
-    MockPasswordManagerClient** weak_client) {
-  auto client = base::WrapUnique(new MockPasswordManagerClient(store));
-  if (weak_client)
-    *weak_client = client.get();
-  return base::scoped_nsobject<PasswordController>([[PasswordController alloc]
-         initWithWebState:web_state
-      passwordsUiDelegate:nil
-                   client:std::move(client)]);
-}
-
-}  // namespace
-
-@interface PasswordController (
-    Testing)<CRWWebStateObserver, FormSuggestionProvider>
-
-- (void)findPasswordFormsWithCompletionHandler:
-    (void (^)(const std::vector<PasswordForm>&))completionHandler;
-
-- (void)extractSubmittedPasswordForm:(const std::string&)formName
-                   completionHandler:
-                       (void (^)(BOOL found,
-                                 const PasswordForm& form))completionHandler;
-
-- (void)fillPasswordForm:(const PasswordFormFillData&)formData
-       completionHandler:(void (^)(BOOL))completionHandler;
-
-- (BOOL)getPasswordForm:(PasswordForm*)form
-         fromDictionary:(const base::DictionaryValue*)dictionary
-                pageURL:(const GURL&)pageLocation;
-
-// Provides access to JavaScript Manager for testing with mocks.
-@property(readonly) JsPasswordManager* passwordJsManager;
-
-@end
-
-// Real FormSuggestionController is wrapped to register the addition of
-// suggestions.
-@interface PasswordsTestSuggestionController : FormSuggestionController
-
-@property(nonatomic, copy) NSArray* suggestions;
-
-- (void)dealloc;
-
-@end
-
-@implementation PasswordsTestSuggestionController
-
-@synthesize suggestions = _suggestions;
-
-- (void)updateKeyboardWithSuggestions:(NSArray*)suggestions {
-  self.suggestions = suggestions;
-}
-
-- (void)dealloc {
-  [_suggestions release];
-  [super dealloc];
-}
-
-@end
-
-class PasswordControllerTest : public web::WebTestWithWebState {
- public:
-  PasswordControllerTest()
-      : store_(new testing::NiceMock<password_manager::MockPasswordStore>()) {}
-
-  ~PasswordControllerTest() override { store_->ShutdownOnUIThread(); }
-
-  void SetUp() override {
-    web::WebTestWithWebState::SetUp();
-    passwordController_ =
-        CreatePasswordController(web_state(), store_.get(), nullptr);
-    @autoreleasepool {
-      // Make sure the temporary array is released after SetUp finishes,
-      // otherwise [passwordController_ suggestionProvider] will be retained
-      // until PlatformTest teardown, at which point all Chrome objects are
-      // already gone and teardown may access invalid memory.
-      suggestionController_.reset([[PasswordsTestSuggestionController alloc]
-          initWithWebState:web_state()
-                 providers:@[ [passwordController_ suggestionProvider] ]]);
-      accessoryViewController_.reset([[FormInputAccessoryViewController alloc]
-          initWithWebState:web_state()
-                 providers:@[ [suggestionController_ accessoryViewProvider] ]]);
-    }
-  }
-
- protected:
-  // Helper method for PasswordControllerTest.DontFillReadonly. Tries to load
-  // |html| and find and fill there a form with hard-coded form data. Returns
-  // YES on success, NO otherwise.
-  BOOL BasicFormFill(NSString* html);
-
-  // Retrieve the current suggestions from suggestionController_ sorted in
-  // alphabetical order according to their value properties.
-  NSArray* GetSortedSuggestionValues() {
-    NSMutableArray* suggestion_values = [NSMutableArray array];
-    for (FormSuggestion* suggestion in [suggestionController_ suggestions])
-      [suggestion_values addObject:suggestion.value];
-    return [suggestion_values
-        sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
-  }
-
-  // Returns an identifier for the |form_number|th form in the page.
-  std::string FormName(int form_number) {
-    NSString* kFormNamingScript =
-        @"__gCrWeb.common.getFormIdentifier("
-         "    document.querySelectorAll('form')[%d]);";
-    return base::SysNSStringToUTF8(EvaluateJavaScriptAsString(
-        [NSString stringWithFormat:kFormNamingScript, form_number]));
-  }
-
-  // Sets up a partial mock that intercepts calls to the selector
-  // -fillPasswordForm:withUsername:password:completionHandler: to the
-  // PasswordController's JavaScript manager. For the first
-  // |target_failure_count| calls, skips the invocation of the real JavaScript
-  // manager, giving the effect that password form fill failed. As soon as
-  // |failure_count| reaches |target_failure_count|, stop the partial mock
-  // and let the original JavaScript manager execute.
-  void SetFillPasswordFormFailureCount(int target_failure_count) {
-    id original_manager = [passwordController_ passwordJsManager];
-    OCPartialMockObject* failing_manager =
-        [OCMockObject partialMockForObject:original_manager];
-    __block int failure_count = 0;
-    void (^fail_invocation)(NSInvocation*) = ^(NSInvocation* invocation) {
-      if (failure_count >= target_failure_count) {
-        [failing_manager stop];
-        [invocation invokeWithTarget:original_manager];
-      } else {
-        ++failure_count;
-        // Fetches the completion handler from |invocation| and calls it with
-        // failure status.
-        void (^completionHandler)(BOOL);
-        const NSInteger kArgOffset = 1;
-        const NSInteger kCompletionHandlerArgIndex = 4;
-        [invocation getArgument:&completionHandler
-                        atIndex:(kCompletionHandlerArgIndex + kArgOffset)];
-        ASSERT_TRUE(completionHandler);
-        completionHandler(NO);
-      }
-    };
-    [[[failing_manager stub] andDo:fail_invocation]
-         fillPasswordForm:[OCMArg any]
-             withUsername:[OCMArg any]
-                 password:[OCMArg any]
-        completionHandler:[OCMArg any]];
-  }
-
-  // SuggestionController for testing.
-  base::scoped_nsobject<PasswordsTestSuggestionController>
-      suggestionController_;
-
-  // FormInputAccessoryViewController for testing.
-  base::scoped_nsobject<FormInputAccessoryViewController>
-      accessoryViewController_;
-
-  // PasswordController for testing.
-  base::scoped_nsobject<PasswordController> passwordController_;
-
-  scoped_refptr<password_manager::PasswordStore> store_;
-};
-
-struct PasswordFormTestData {
-  const char* const page_location;
-  const char* const json_string;
-  const char* const expected_origin;
-  const char* const expected_action;
-  const char* const expected_username_element;
-  const char* const expected_username_value;
-  const char* const expected_new_password_element;
-  const char* const expected_new_password_value;
-  const char* const expected_old_password_element;
-  const char* const expected_old_password_value;
-};
-
-// Check that given a serialization of a PasswordForm, the controller is able
-// to create the corresponding PasswordForm object.
-TEST_F(PasswordControllerTest, PopulatePasswordFormWithDictionary) {
-  // clang-format off
-  PasswordFormTestData test_data[] = {
-    // One username element, one password element.  URLs contain extra
-    // parts: username/password, query, reference, which are all expected
-    // to be stripped off. The password is recognized as an old password.
-    {
-      "http://john:doe@fakedomain.com/foo/bar?baz=quz#foobar",
-      "{ \"action\": \"some/action?to=be&or=not#tobe\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://john:doe@fakedomain.com/foo/bar\","
-          "\"passwords\": ["
-              "{ \"element\": \"secret\"," "\"value\": \"fakesecret\" },"
-          "]}",
-      "http://fakedomain.com/foo/bar",
-      "http://fakedomain.com/foo/some/action",
-      "account",
-      "fakeaccount",
-      "",
-      "",
-      "secret",
-      "fakesecret",
-    },
-    // One username element, one password element. Population should fail
-    // due to an origin mismatch.
-    {
-      "http://john:doe@fakedomain.com/foo/bar?baz=quz#foobar",
-      "{ \"action\": \"some/action?to=be&or=not#tobe\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://john:doe@realdomainipromise.com/foo/bar\","
-          "\"passwords\": ["
-              "{ \"element\": \"secret\"," "\"value\": \"fakesecret\" },"
-          "]}",
-      "",
-      "",
-      "",
-      "",
-      "",
-      "",
-      "",
-      "",
-    },
-    // One username element, two password elements.  Since both password
-    // values are the same, we are assuming that the webpage asked the user
-    // to enter the password twice for confirmation.
-    {
-      "http://fakedomain.com/foo",
-      "{ \"action\": \"http://anotherdomain.com/some_action\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://fakedomain.com/foo\","
-          "\"passwords\": ["
-              "{ \"element\": \"secret\"," "\"value\": \"fakesecret\" },"
-              "{ \"element\": \"confirm\"," "\"value\": \"fakesecret\" },"
-          "]}",
-      "http://fakedomain.com/foo",
-      "http://anotherdomain.com/some_action",
-      "account",
-      "fakeaccount",
-      "secret",
-      "fakesecret",
-      "",
-      "",
-    },
-    // One username element, two password elements.  The password
-    // values are different, so we are assuming that the webpage asked the user
-    // to enter the old password and new password.
-    {
-      "http://fakedomain.com/foo",
-      "{ \"action\": \"\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://fakedomain.com/foo\","
-          "\"passwords\": ["
-              "{ \"element\": \"old\"," "\"value\": \"oldsecret\" },"
-              "{ \"element\": \"new\"," "\"value\": \"newsecret\" },"
-          "]}",
-      "http://fakedomain.com/foo",
-      "http://fakedomain.com/foo",
-      "account",
-      "fakeaccount",
-      "new",
-      "newsecret",
-      "old",
-      "oldsecret",
-    },
-    // One username element, three password elements.  All passwords
-    // are the same. Password population should fail because this configuration
-    // does not make sense.
-    {
-      "http://fakedomain.com",
-      "{ \"action\": \"\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://fakedomain.com/foo\","
-          "\"passwords\": ["
-              "{ \"element\": \"pass1\"," "\"value\": \"word\" },"
-              "{ \"element\": \"pass2\"," "\"value\": \"word\" },"
-              "{ \"element\": \"pass3\"," "\"value\": \"word\" },"
-          "]}",
-      "http://fakedomain.com/",
-      "http://fakedomain.com/",
-      "account",
-      "fakeaccount",
-      "",
-      "",
-      "",
-      "",
-    },
-    // One username element, three password elements.  Two passwords are
-    // the same followed by a different one.  Assuming that the duplicated
-    // password is the old one.
-    {
-      "http://fakedomain.com",
-      "{ \"action\": \"\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://fakedomain.com/foo\","
-          "\"passwords\": ["
-              "{ \"element\": \"pass1\"," "\"value\": \"word1\" },"
-              "{ \"element\": \"pass2\"," "\"value\": \"word1\" },"
-              "{ \"element\": \"pass3\"," "\"value\": \"word3\" },"
-          "]}",
-      "http://fakedomain.com/",
-      "http://fakedomain.com/",
-      "account",
-      "fakeaccount",
-      "pass3",
-      "word3",
-      "pass1",
-      "word1",
-    },
-    // One username element, three password elements.  A password is
-    // follwed by two duplicate ones.  Assuming that the duplicated
-    // password is the new one.
-    {
-      "http://fakedomain.com",
-      "{ \"action\": \"\","
-          "\"usernameElement\": \"account\","
-          "\"usernameValue\": \"fakeaccount\","
-          "\"name\": \"signup\","
-          "\"origin\": \"http://fakedomain.com/foo\","
-          "\"passwords\": ["
-              "{ \"element\": \"pass1\"," "\"value\": \"word1\" },"
-              "{ \"element\": \"pass2\"," "\"value\": \"word2\" },"
-              "{ \"element\": \"pass3\"," "\"value\": \"word2\" },"
-          "]}",
-      "http://fakedomain.com/",
-      "http://fakedomain.com/",
-      "account",
-      "fakeaccount",
-      "pass2",
-      "word2",
-      "pass1",
-      "word1",
-    },
-  };
-  // clang-format on
-
-  for (const PasswordFormTestData& data : test_data) {
-    SCOPED_TRACE(testing::Message()
-                 << "for page_location=" << data.page_location
-                 << " and json_string=" << data.json_string);
-    std::unique_ptr<base::Value> json_data(
-        base::JSONReader::Read(data.json_string, true));
-    const base::DictionaryValue* json_dict = nullptr;
-    ASSERT_TRUE(json_data->GetAsDictionary(&json_dict));
-    PasswordForm form;
-    [passwordController_ getPasswordForm:&form
-                          fromDictionary:json_dict
-                                 pageURL:GURL(data.page_location)];
-    EXPECT_STREQ(data.expected_origin, form.origin.spec().c_str());
-    EXPECT_STREQ(data.expected_action, form.action.spec().c_str());
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_username_element),
-              form.username_element);
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_username_value),
-              form.username_value);
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_new_password_element),
-              form.new_password_element);
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_new_password_value),
-              form.new_password_value);
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_old_password_element),
-              form.password_element);
-    EXPECT_EQ(base::ASCIIToUTF16(data.expected_old_password_value),
-              form.password_value);
-  }
-};
-
-struct FindPasswordFormTestData {
-  NSString* html_string;
-  const bool expected_form_found;
-  const char* const expected_username_element;
-  const char* const expected_password_element;
-};
-
-// TODO(crbug.com/403705) This test is flaky.
-// Check that HTML forms are converted correctly into PasswordForms.
-TEST_F(PasswordControllerTest, FLAKY_FindPasswordFormsInView) {
-  // clang-format off
-  FindPasswordFormTestData test_data[] = {
-    // Normal form: a username and a password element.
-    {
-      @"<form>"
-          "<input type='text' name='user0'>"
-          "<input type='password' name='pass0'>"
-          "</form>",
-      true, "user0", "pass0"
-    },
-    // User name is captured as an email address (HTML5).
-    {
-      @"<form>"
-          "<input type='email' name='email1'>"
-          "<input type='password' name='pass1'>"
-          "</form>",
-      true, "email1", "pass1"
-    },
-    // No username element.
-    {
-      @"<form>"
-          "<input type='password' name='user2'>"
-          "<input type='password' name='pass2'>"
-          "</form>",
-      true, "", "user2"
-    },
-    // No username element before password.
-    {
-      @"<form>"
-          "<input type='password' name='pass3'>"
-          "<input type='text' name='user3'>"
-          "</form>",
-      true, "", "pass3"
-    },
-    // Disabled username element.
-    {
-      @"<form>"
-          "<input type='text' name='user4' disabled='disabled'>"
-          "<input type='password' name='pass4'>"
-          "</form>",
-      true, "", "pass4"
-    },
-    // Username element has autocomplete='off'.
-    {
-      @"<form>"
-          "<input type='text' name='user5' AUTOCOMPLETE='off'>"
-          "<input type='password' name='pass5'>"
-          "</form>",
-      true, "user5", "pass5"
-    },
-    // No password element.
-    {
-      @"<form>"
-          "<input type='text' name='user6'>"
-          "<input type='text' name='pass6'>"
-          "</form>",
-      false, nullptr, nullptr
-    },
-    // Disabled password element.
-    {
-      @"<form>"
-          "<input type='text' name='user7'>"
-          "<input type='password' name='pass7' disabled='disabled'>"
-          "</form>",
-      false, nullptr, nullptr
-    },
-    // Password element has autocomplete='off'.
-    {
-      @"<form>"
-          "<input type='text' name='user8'>"
-          "<input type='password' name='pass8' AUTOCOMPLETE='OFF'>"
-          "</form>",
-      true, "user8", "pass8"
-    },
-    // Form element has autocomplete='off'.
-    {
-      @"<form autocomplete='off'>"
-          "<input type='text' name='user9'>"
-          "<input type='password' name='pass9'>"
-          "</form>",
-      true, "user9", "pass9"
-    },
-  };
-  // clang-format on
-
-  for (const FindPasswordFormTestData& data : test_data) {
-    SCOPED_TRACE(testing::Message() << "for html_string=" << data.html_string);
-    LoadHtml(data.html_string);
-    __block std::vector<PasswordForm> forms;
-    __block BOOL block_was_called = NO;
-    [passwordController_ findPasswordFormsWithCompletionHandler:^(
-                             const std::vector<PasswordForm>& result) {
-      block_was_called = YES;
-      forms = result;
-    }];
-    base::test::ios::WaitUntilCondition(^bool() {
-      return block_was_called;
-    });
-    if (data.expected_form_found) {
-      ASSERT_EQ(1U, forms.size());
-      EXPECT_EQ(base::ASCIIToUTF16(data.expected_username_element),
-                forms[0].username_element);
-      EXPECT_EQ(base::ASCIIToUTF16(data.expected_password_element),
-                forms[0].password_element);
-    } else {
-      ASSERT_TRUE(forms.empty());
-    }
-  }
-}
-
-struct GetSubmittedPasswordFormTestData {
-  NSString* html_string;
-  NSString* java_script;
-  const int number_of_forms_to_submit;
-  const bool expected_form_found;
-  const char* expected_username_element;
-};
-
-// TODO(crbug.com/403705) This test is flaky.
-// Check that HTML forms are captured and converted correctly into
-// PasswordForms on submission.
-TEST_F(PasswordControllerTest, FLAKY_GetSubmittedPasswordForm) {
-  // clang-format off
-  GetSubmittedPasswordFormTestData test_data[] = {
-    // Two forms with no explicit names.
-    {
-      @"<form action='javascript:;'>"
-          "<input type='text' name='user1'>"
-          "<input type='password' name='pass1'>"
-          "</form>"
-          "<form action='javascript:;'>"
-          "<input type='text' name='user2'>"
-          "<input type='password' name='pass2'>"
-          "<input type='submit' id='s2'>"
-          "</form>",
-      @"document.getElementById('s2').click()",
-      1, true, "user2"
-    },
-    // Two forms with explicit names.
-    {
-      @"<form name='test2a' action='javascript:;'>"
-          "<input type='text' name='user1'>"
-          "<input type='password' name='pass1'>"
-          "<input type='submit' id='s1'>"
-          "</form>"
-          "<form name='test2b' action='javascript:;'>"
-          "<input type='text' name='user2'>"
-          "<input type='password' name='pass2'>"
-          "</form>",
-      @"document.getElementById('s1').click()",
-      0, true, "user1"
-    },
-    // No password forms.
-    {
-      @"<form action='javascript:;'>"
-          "<input type='text' name='user1'>"
-          "<input type='text' name='pass1'>"
-          "<input type='submit' id='s1'>"
-          "</form>",
-      @"document.getElementById('s1').click()",
-      0, false, nullptr
-    },
-    // Form with quotes in the form and field names.
-    {
-      @"<form name=\"foo'\" action='javascript:;'>"
-          "<input type='text' name=\"user1'\">"
-          "<input type='password' id='s1' name=\"pass1'\">"
-          "</form>",
-      @"document.getElementById('s1').click()",
-      0, true, "user1'"
-    },
-  };
-  // clang-format on
-
-  for (const GetSubmittedPasswordFormTestData& data : test_data) {
-    SCOPED_TRACE(testing::Message() << "for html_string=" << data.html_string
-                                    << " and java_script=" << data.java_script
-                                    << " and number_of_forms_to_submit="
-                                    << data.number_of_forms_to_submit);
-    LoadHtml(data.html_string);
-    EvaluateJavaScriptAsString(data.java_script);
-    __block BOOL block_was_called = NO;
-    id completion_handler = ^(BOOL found, const PasswordForm& form) {
-      block_was_called = YES;
-      ASSERT_EQ(data.expected_form_found, found);
-      if (data.expected_form_found) {
-        EXPECT_EQ(base::ASCIIToUTF16(data.expected_username_element),
-                  form.username_element);
-      }
-    };
-    [passwordController_
-        extractSubmittedPasswordForm:FormName(data.number_of_forms_to_submit)
-                   completionHandler:completion_handler];
-    base::test::ios::WaitUntilCondition(^bool() {
-      return block_was_called;
-    });
-  }
-}
-
-// Populates |form_data| with test values.
-void SetPasswordFormFillData(PasswordFormFillData& form_data,
-                             const std::string& origin,
-                             const std::string& action,
-                             const char* username_field,
-                             const char* username_value,
-                             const char* password_field,
-                             const char* password_value,
-                             const char* additional_username,
-                             const char* additional_password,
-                             bool wait_for_username) {
-  form_data.origin = GURL(origin);
-  form_data.action = GURL(action);
-  autofill::FormFieldData username;
-  username.name = base::UTF8ToUTF16(username_field);
-  username.value = base::UTF8ToUTF16(username_value);
-  form_data.username_field = username;
-  autofill::FormFieldData password;
-  password.name = base::UTF8ToUTF16(password_field);
-  password.value = base::UTF8ToUTF16(password_value);
-  form_data.password_field = password;
-  if (additional_username) {
-    autofill::PasswordAndRealm additional_password_data;
-    additional_password_data.password = base::UTF8ToUTF16(additional_password);
-    additional_password_data.realm.clear();
-    form_data.additional_logins.insert(
-        std::pair<base::string16, autofill::PasswordAndRealm>(
-            base::UTF8ToUTF16(additional_username), additional_password_data));
-  }
-  form_data.wait_for_username = wait_for_username;
-}
-
-// Test HTML page.  It contains several password forms.  Tests autofill
-// them and verify that the right ones are autofilled.
-static NSString* kHtmlWithMultiplePasswordForms =
-    @"<form>"
-     "<input id='un0' type='text' name='u0'>"
-     "<input id='pw0' type='password' name='p0'>"
-     "</form>"
-     "<form action='action?query=yes#reference'>"
-     "<input id='un1' type='text' name='u1'>"
-     "<input id='pw1' type='password' name='p1'>"
-     "</form>"
-     "<form action='http://some_other_action'>"
-     "<input id='un2' type='text' name='u2'>"
-     "<input id='pw2' type='password' name='p2'>"
-     "</form>"
-     "<form>"
-     "<input id='un3' type='text' name='u3'>"
-     "<input id='pw3' type='password' name='p3'>"
-     "<input id='pw3' type='password' name='p3'>"
-     "</form>"
-     "<form>"
-     "<input id='un4' type='text' name='u4'>"
-     "<input id='pw4' type='password' name='p4'>"
-     "</form>"
-     "<form>"
-     "<input id='un5' type='text' name='u4'>"
-     "<input id='pw5' type='password' name='p4'>"
-     "</form>"
-     "<form name=\"f6'\">"
-     "<input id=\"un6'\" type='text' name=\"u6'\">"
-     "<input id=\"pw6'\" type='password' name=\"p6'\">"
-     "</form>";
-
-// A script that resets all text fields.
-static NSString* kClearInputFieldsScript =
-    @"var inputs = document.getElementsByTagName('input');"
-     "for(var i = 0; i < inputs.length; i++){"
-     "  inputs[i].value = '';"
-     "}";
-
-// A script that we run after autofilling forms.  It returns
-// ids and values of all non-empty fields.
-static NSString* kInputFieldValueVerificationScript =
-    @"var result='';"
-     "var inputs = document.getElementsByTagName('input');"
-     "for(var i = 0; i < inputs.length; i++){"
-     "  var input = inputs[i];"
-     "  if (input.value) {"
-     "    result += input.id + '=' + input.value +';';"
-     "  }"
-     "}; result";
-
-struct FillPasswordFormTestData {
-  const std::string origin;
-  const std::string action;
-  const char* username_field;
-  const char* username_value;
-  const char* password_field;
-  const char* password_value;
-  const BOOL should_succeed;
-  NSString* expected_result;
-};
-
-// Test that filling password forms works correctly.
-TEST_F(PasswordControllerTest, FillPasswordForm) {
-  LoadHtml(kHtmlWithMultiplePasswordForms);
-
-  EXPECT_NSEQ(@"true",
-              EvaluateJavaScriptAsString(@"__gCrWeb.hasPasswordField()"));
-
-  const std::string base_url = BaseUrl();
-  // clang-format off
-  FillPasswordFormTestData test_data[] = {
-    // Basic test: one-to-one match on the first password form.
-    {
-      base_url,
-      base_url,
-      "u0",
-      "test_user",
-      "p0",
-      "test_password",
-      YES,
-      @"un0=test_user;pw0=test_password;"
-    },
-    // Multiple forms match: they should all be autofilled.
-    {
-      base_url,
-      base_url,
-      "u4",
-      "test_user",
-      "p4",
-      "test_password",
-      YES,
-      @"un4=test_user;pw4=test_password;un5=test_user;pw5=test_password;"
-    },
-    // The form matches despite a different action: the only difference
-    // is a query and reference.
-    {
-      base_url,
-      base_url,
-      "u1",
-      "test_user",
-      "p1",
-      "test_password",
-      YES,
-      @"un1=test_user;pw1=test_password;"
-    },
-    // No match because of a different origin.
-    {
-      "http://someotherfakedomain.com",
-      base_url,
-      "u0",
-      "test_user",
-      "p0",
-      "test_password",
-      NO,
-      @""
-    },
-    // No match because of a different action.
-    {
-      base_url,
-      "http://someotherfakedomain.com",
-      "u0",
-      "test_user",
-      "p0",
-      "test_password",
-      NO,
-      @""
-    },
-    // No match because some inputs are not in the form.
-    {
-      base_url,
-      base_url,
-      "u0",
-      "test_user",
-      "p1",
-      "test_password",
-      NO,
-      @""
-    },
-    // No match because there are duplicate inputs in the form.
-    {
-      base_url,
-      base_url,
-      "u3",
-      "test_user",
-      "p3",
-      "test_password",
-      NO,
-      @""
-    },
-    // Basic test, but with quotes in the names and IDs.
-    {
-      base_url,
-      base_url,
-      "u6'",
-      "test_user",
-      "p6'",
-      "test_password",
-      YES,
-      @"un6'=test_user;pw6'=test_password;"
-    },
-  };
-  // clang-format on
-
-  for (const FillPasswordFormTestData& data : test_data) {
-    EvaluateJavaScriptAsString(kClearInputFieldsScript);
-
-    PasswordFormFillData form_data;
-    SetPasswordFormFillData(form_data, data.origin, data.action,
-                            data.username_field, data.username_value,
-                            data.password_field, data.password_value, nullptr,
-                            nullptr, false);
-
-    __block BOOL block_was_called = NO;
-    [passwordController_ fillPasswordForm:form_data
-                        completionHandler:^(BOOL success) {
-                          block_was_called = YES;
-                          EXPECT_EQ(data.should_succeed, success);
-                        }];
-    base::test::ios::WaitUntilCondition(^bool() {
-      return block_was_called;
-    });
-
-    NSString* result =
-        EvaluateJavaScriptAsString(kInputFieldValueVerificationScript);
-    EXPECT_NSEQ(data.expected_result, result);
-  }
-}
-
-// Tests that a form is found and the found form is filled in with the given
-// username and password.
-TEST_F(PasswordControllerTest, FindAndFillOnePasswordForm) {
-  LoadHtml(@"<form><input id='un' type='text' name='u'>"
-            "<input id='pw' type='password' name='p'></form>");
-  __block int call_counter = 0;
-  __block int success_counter = 0;
-  [passwordController_ findAndFillPasswordForms:@"john.doe@gmail.com"
-                                       password:@"super!secret"
-                              completionHandler:^(BOOL complete) {
-                                ++call_counter;
-                                if (complete)
-                                  ++success_counter;
-                              }];
-  base::test::ios::WaitUntilCondition(^{
-    return call_counter == 1;
-  });
-  EXPECT_EQ(1, success_counter);
-  NSString* result =
-      EvaluateJavaScriptAsString(kInputFieldValueVerificationScript);
-  EXPECT_NSEQ(@"un=john.doe@gmail.com;pw=super!secret;", result);
-}
-
-// Tests that multiple forms on the same page are found and filled.
-// This test includes an mock injected failure on form filling to verify
-// that completion handler is called with the proper values.
-TEST_F(PasswordControllerTest, FindAndFillMultiplePasswordForms) {
-  // Fails the first call to fill password form.
-  SetFillPasswordFormFailureCount(1);
-  LoadHtml(@"<form><input id='u1' type='text' name='un1'>"
-            "<input id='p1' type='password' name='pw1'></form>"
-            "<form><input id='u2' type='text' name='un2'>"
-            "<input id='p2' type='password' name='pw2'></form>"
-            "<form><input id='u3' type='text' name='un3'>"
-            "<input id='p3' type='password' name='pw3'></form>");
-  __block int call_counter = 0;
-  __block int success_counter = 0;
-  [passwordController_ findAndFillPasswordForms:@"john.doe@gmail.com"
-                                       password:@"super!secret"
-                              completionHandler:^(BOOL complete) {
-                                ++call_counter;
-                                if (complete)
-                                  ++success_counter;
-                                LOG(INFO) << "HANDLER call " << call_counter
-                                          << " success " << success_counter;
-                              }];
-  // There should be 3 password forms and only 2 successfully filled forms.
-  base::test::ios::WaitUntilCondition(^{
-    return call_counter == 3;
-  });
-  EXPECT_EQ(2, success_counter);
-  NSString* result =
-      EvaluateJavaScriptAsString(kInputFieldValueVerificationScript);
-  EXPECT_NSEQ(@"u2=john.doe@gmail.com;p2=super!secret;"
-               "u3=john.doe@gmail.com;p3=super!secret;",
-              result);
-}
-
-BOOL PasswordControllerTest::BasicFormFill(NSString* html) {
-  LoadHtml(html);
-  EXPECT_NSEQ(@"true",
-              EvaluateJavaScriptAsString(@"__gCrWeb.hasPasswordField()"));
-  const std::string base_url = BaseUrl();
-  PasswordFormFillData form_data;
-  SetPasswordFormFillData(form_data, base_url, base_url, "u0", "test_user",
-                          "p0", "test_password", nullptr, nullptr, false);
-  __block BOOL block_was_called = NO;
-  __block BOOL return_value = NO;
-  [passwordController_ fillPasswordForm:form_data
-                      completionHandler:^(BOOL success) {
-                        block_was_called = YES;
-                        return_value = success;
-                      }];
-  base::test::ios::WaitUntilCondition(^bool() {
-    return block_was_called;
-  });
-  return return_value;
-}
-
-// Check that |fillPasswordForm| is not filled if 'readonly' attribute is set
-// on either username or password fields.
-// TODO(crbug.com/503050): Test is flaky.
-TEST_F(PasswordControllerTest, FLAKY_DontFillReadOnly) {
-  // Control check that the fill operation will succceed with well-formed form.
-  EXPECT_TRUE(BasicFormFill(@"<form>"
-                             "<input id='un0' type='text' name='u0'>"
-                             "<input id='pw0' type='password' name='p0'>"
-                             "</form>"));
-  // Form fill should fail with 'readonly' attribute on username.
-  EXPECT_FALSE(BasicFormFill(
-      @"<form>"
-       "<input id='un0' type='text' name='u0' readonly='readonly'>"
-       "<input id='pw0' type='password' name='p0'>"
-       "</form>"));
-  // Form fill should fail with 'readonly' attribute on password.
-  EXPECT_FALSE(BasicFormFill(
-      @"<form>"
-       "<input id='un0' type='text' name='u0'>"
-       "<input id='pw0' type='password' name='p0' readonly='readonly'>"
-       "</form>"));
-}
-
-// An HTML page containing one password form.  The username input field
-// also has custom event handlers.  We need to verify that those event
-// handlers are still triggered even though we override them with our own.
-static NSString* kHtmlWithPasswordForm =
-    @"<form>"
-     "<input id='un' type='text' name=\"u'\""
-     "  onkeyup='window.onKeyUpCalled_=true'"
-     "  onchange='window.onChangeCalled_=true'>"
-     "<input id='pw' type='password' name=\"p'\">"
-     "</form>";
-
-// A script that resets indicators used to verify that custom event
-// handlers are triggered.  It also finds and the username and
-// password fields and caches them for future verification.
-static NSString* kUsernameAndPasswordTestPreparationScript =
-    @"onKeyUpCalled_ = false;"
-     "onChangeCalled_ = false;"
-     "username_ = document.getElementById('un');"
-     "username_.__gCrWebAutofilled = 'false';"
-     "password_ = document.getElementById('pw');"
-     "password_.__gCrWebAutofilled = 'false';";
-
-// A script that we run after autofilling forms.  It returns
-// all values for verification as a single concatenated string.
-static NSString* kUsernamePasswordVerificationScript =
-    @"var value = username_.value;"
-     "var from = username_.selectionStart;"
-     "var to = username_.selectionEnd;"
-     "value.substr(0, from) + '[' + value.substr(from, to) + ']'"
-     "   + value.substr(to, value.length) + '=' + password_.value"
-     "   + ', onkeyup=' + onKeyUpCalled_"
-     "   + ', onchange=' + onChangeCalled_;";
-
-struct SuggestionTestData {
-  std::string description;
-  NSArray* eval_scripts;
-  NSArray* expected_suggestions;
-  NSString* expected_result;
-};
-
-// Tests that form activity correctly sends suggestions to the suggestion
-// controller.
-TEST_F(PasswordControllerTest, SuggestionUpdateTests) {
-  LoadHtml(kHtmlWithPasswordForm);
-  const std::string base_url = BaseUrl();
-  EvaluateJavaScriptAsString(kUsernameAndPasswordTestPreparationScript);
-
-  // Initialize |form_data| with test data and an indicator that autofill
-  // should not be performed while the user is entering the username so that
-  // we can test with an initially-empty username field. Testing with a
-  // username field that contains input is performed by a specific test below.
-  PasswordFormFillData form_data;
-  SetPasswordFormFillData(form_data, base_url, base_url, "u'", "user0", "p'",
-                          "password0", "abc", "def", true);
-  form_data.name = base::ASCIIToUTF16(FormName(0));
-
-  __block BOOL block_was_called = NO;
-  [passwordController_ fillPasswordForm:form_data
-                      completionHandler:^(BOOL success) {
-                        block_was_called = YES;
-                        // Verify that the fill reports failed.
-                        EXPECT_FALSE(success);
-                      }];
-  base::test::ios::WaitUntilCondition(^bool() {
-    return block_was_called;
-  });
-
-  // Verify that the form has not been autofilled.
-  EXPECT_NSEQ(@"[]=, onkeyup=false, onchange=false",
-              EvaluateJavaScriptAsString(kUsernamePasswordVerificationScript));
-
-  // clang-format off
-  SuggestionTestData test_data[] = {
-    {
-      "Should show all suggestions when focusing empty username field",
-      @[(@"var evt = document.createEvent('Events');"
-          "evt.initEvent('focus', true, true, window, 1);"
-          "username_.dispatchEvent(evt);"),
-        @""],
-      @[@"abc", @"user0"],
-      @"[]=, onkeyup=false, onchange=false"
-    },
-    {
-      "Should not show suggestions when focusing password field",
-      @[(@"var evt = document.createEvent('Events');"
-          "evt.initEvent('focus', true, true, window, 1);"
-          "password_.dispatchEvent(evt);"),
-        @""],
-      @[],
-      @"[]=, onkeyup=false, onchange=false"
-    },
-    {
-      "Should filter suggestions when focusing username field with input",
-      @[(@"username_.value='ab';"
-          "var evt = document.createEvent('Events');"
-          "evt.initEvent('focus', true, true, window, 1);"
-          "username_.dispatchEvent(evt);"),
-        @""],
-      @[@"abc"],
-      @"ab[]=, onkeyup=false, onchange=false"
-    },
-    {
-      "Should filter suggestions while typing",
-      @[(@"var evt = document.createEvent('Events');"
-          "evt.initEvent('focus', true, true, window, 1);"
-          "username_.dispatchEvent(evt);"),
-        (@"username_.value='ab';"
-          "evt = document.createEvent('Events');"
-          "evt.initEvent('keyup', true, true, window, 1);"
-          "evt.keyCode = 98;"
-          "username_.dispatchEvent(evt);"),
-        @""],
-      @[@"abc"],
-      @"ab[]=, onkeyup=true, onchange=false"
-    },
-    {
-      "Should unfilter suggestions after backspacing",
-      @[(@"var evt = document.createEvent('Events');"
-          "evt.initEvent('focus', true, true, window, 1);"
-          "username_.dispatchEvent(evt);"),
-        (@"username_.value='ab';"
-          "evt = document.createEvent('Events');"
-          "evt.initEvent('keyup', true, true, window, 1);"
-          "evt.keyCode = 98;"
-          "username_.dispatchEvent(evt);"),
-        (@"username_.value='';"
-          "evt = document.createEvent('Events');"
-          "evt.initEvent('keyup', true, true, window, 1);"
-          "evt.keyCode = 8;"
-          "username_.dispatchEvent(evt);"),
-        @""],
-      @[@"abc", @"user0"],
-      @"[]=, onkeyup=true, onchange=false"
-    },
-  };
-  // clang-format on
-
-  for (const SuggestionTestData& data : test_data) {
-    SCOPED_TRACE(testing::Message()
-                 << "for description=" << data.description
-                 << " and eval_scripts=" << data.eval_scripts);
-    // Prepare the test.
-    EvaluateJavaScriptAsString(kUsernameAndPasswordTestPreparationScript);
-
-    for (NSString* script in data.eval_scripts) {
-      // Trigger events.
-      EvaluateJavaScriptAsString(script);
-
-      // Pump the run loop so that the host can respond.
-      WaitForBackgroundTasks();
-    }
-
-    EXPECT_NSEQ(data.expected_suggestions, GetSortedSuggestionValues());
-    EXPECT_NSEQ(data.expected_result, EvaluateJavaScriptAsString(
-                                          kUsernamePasswordVerificationScript));
-    // Clear all suggestions.
-    [suggestionController_ setSuggestions:nil];
-  }
-}
-
-// Tests that selecting a suggestion will fill the corresponding form and field.
-TEST_F(PasswordControllerTest, SelectingSuggestionShouldFillPasswordForm) {
-  LoadHtml(kHtmlWithPasswordForm);
-  const std::string base_url = BaseUrl();
-  EvaluateJavaScriptAsString(kUsernameAndPasswordTestPreparationScript);
-
-  // Initialize |form_data| with test data and an indicator that autofill
-  // should not be performed while the user is entering the username so that
-  // we can test with an initially-empty username field.
-  PasswordFormFillData form_data;
-  SetPasswordFormFillData(form_data, base_url, base_url, "u'", "user0", "p'",
-                          "password0", "abc", "def", true);
-  form_data.name = base::ASCIIToUTF16(FormName(0));
-
-  __block BOOL block_was_called = NO;
-  [passwordController_ fillPasswordForm:form_data
-                      completionHandler:^(BOOL success) {
-                        block_was_called = YES;
-                        // Verify that the fill reports failed.
-                        EXPECT_FALSE(success);
-                      }];
-  base::test::ios::WaitUntilCondition(^bool() {
-    return block_was_called;
-  });
-
-  // Verify that the form has not been autofilled.
-  EXPECT_NSEQ(@"[]=, onkeyup=false, onchange=false",
-              EvaluateJavaScriptAsString(kUsernamePasswordVerificationScript));
-
-  // Tell PasswordController that a suggestion was selected. It should fill
-  // out the password form with the corresponding credentials.
-  FormSuggestion* suggestion = [FormSuggestion suggestionWithValue:@"abc"
-                                                displayDescription:nil
-                                                              icon:nil
-                                                        identifier:0];
-
-  block_was_called = NO;
-  SuggestionHandledCompletion completion = ^{
-    block_was_called = YES;
-    EXPECT_NSEQ(@"abc[]=def, onkeyup=false, onchange=false",
-                ExecuteJavaScript(kUsernamePasswordVerificationScript));
-  };
-  [passwordController_ didSelectSuggestion:suggestion
-                                  forField:@"u"
-                                      form:base::SysUTF8ToNSString(FormName(0))
-                         completionHandler:completion];
-  base::test::ios::WaitUntilCondition(^bool() {
-    return block_was_called;
-  });
-}
-
-// Tests with invalid inputs.
-TEST_F(PasswordControllerTest, CheckIncorrectData) {
-  // clang-format off
-  std::string invalid_data[] = {
-    "{}",
-
-    "{  \"usernameValue\": \"fakeaccount\","
-       "\"passwords\": ["
-         "{ \"element\": \"secret\"," "\"value\": \"fakesecret\" },"
-       "]}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"passwords\": ["
-         "{ \"element\": \"secret\"," "\"value\": \"fakesecret\" },"
-       "]}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"usernameValue\": \"fakeaccount\","
-    "}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"usernameValue\": \"fakeaccount\","
-       "\"passwords\": {},"
-    "}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"usernameValue\": \"fakeaccount\","
-       "\"passwords\": ["
-       "]}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"usernameValue\": \"fakeaccount\","
-       "\"passwords\": ["
-         "{ \"value\": \"fakesecret\" },"
-       "]}",
-
-    "{  \"usernameElement\": \"account\","
-       "\"usernameValue\": \"fakeaccount\","
-       "\"passwords\": ["
-         "{ \"element\": \"secret\" },"
-       "]}",
-  };
-  // clang-format on
-
-  for (const std::string& data : invalid_data) {
-    SCOPED_TRACE(testing::Message() << "for data=" << data);
-    std::unique_ptr<base::Value> json_data(base::JSONReader::Read(data, true));
-    const base::DictionaryValue* json_dict = nullptr;
-    ASSERT_TRUE(json_data->GetAsDictionary(&json_dict));
-    PasswordForm form;
-    BOOL res =
-        [passwordController_ getPasswordForm:&form
-                              fromDictionary:json_dict
-                                     pageURL:GURL("https://www.foo.com/")];
-    EXPECT_FALSE(res);
-  }
-}
-
-// The test case below does not need the heavy fixture from above, but it
-// needs to use MockWebState.
-TEST(PasswordControllerTestSimple, SaveOnNonHTMLLandingPage) {
+TEST(PasswordControllerTest, SaveOnNonHTMLLandingPage) {
+  // Create the PasswordController with a MockPasswordManagerClient.
   TestChromeBrowserState::Builder builder;
+  auto pref_service =
+      base::WrapUnique(new syncable_prefs::TestingPrefServiceSyncable);
+  pref_service->registry()->RegisterBooleanPref(
+      password_manager::prefs::kPasswordManagerSavingEnabled, true);
+  builder.SetPrefService(std::move(pref_service));
   std::unique_ptr<TestChromeBrowserState> browser_state(builder.Build());
   MockWebState web_state;
   ON_CALL(web_state, GetBrowserState())
       .WillByDefault(testing::Return(browser_state.get()));
-
-  MockPasswordManagerClient* weak_client = nullptr;
-  base::scoped_nsobject<PasswordController> passwordController =
-      CreatePasswordController(&web_state, nullptr, &weak_client);
-  static_cast<TestingPrefServiceSimple*>(weak_client->GetPrefs())
-      ->registry()
-      ->RegisterBooleanPref(
-          password_manager::prefs::kPasswordManagerSavingEnabled, true);
+  auto client = base::WrapUnique(new MockPasswordManagerClient);
+  MockPasswordManagerClient* weak_client = client.get();
+  base::scoped_nsobject<PasswordController> passwordController(
+      [[PasswordController alloc] initWithWebState:&web_state
+                               passwordsUiDelegate:nil
+                                            client:std::move(client)]);
 
   // Use a mock LogManager to detect that OnPasswordFormsRendered has been
   // called. TODO(crbug.com/598672): this is a hack, we should modularize the
diff --git a/ios/chrome/browser/passwords/password_generation_agent_unittest.mm b/ios/chrome/browser/passwords/password_generation_agent_unittest.mm
deleted file mode 100644
index 744518e..0000000
--- a/ios/chrome/browser/passwords/password_generation_agent_unittest.mm
+++ /dev/null
@@ -1,521 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#import "ios/chrome/browser/passwords/password_generation_agent.h"
-
-#include <algorithm>
-#include <memory>
-
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-#import "base/mac/scoped_nsobject.h"
-#include "base/mac/scoped_objc_class_swizzler.h"
-#include "base/macros.h"
-#include "base/strings/string16.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "components/autofill/core/common/form_data.h"
-#include "components/autofill/core/common/form_field_data.h"
-#include "components/autofill/core/common/password_form.h"
-#import "components/autofill/ios/browser/js_suggestion_manager.h"
-#include "google_apis/gaia/gaia_urls.h"
-#import "ios/chrome/browser/autofill/form_input_accessory_view_controller.h"
-#import "ios/chrome/browser/passwords/js_password_manager.h"
-#import "ios/chrome/browser/passwords/password_generation_offer_view.h"
-#import "ios/chrome/browser/passwords/passwords_ui_delegate.h"
-#import "ios/chrome/browser/ui/commands/generic_chrome_command.h"
-#include "ios/chrome/browser/ui/commands/ios_command_ids.h"
-#import "ios/testing/ocmock_complex_type_helper.h"
-#include "ios/web/public/test/test_web_state.h"
-#include "ios/web/public/web_state/url_verification_constants.h"
-#import "ios/web/public/test/web_test_with_web_state.h"
-#include "testing/gtest_mac.h"
-#include "third_party/ocmock/OCMock/OCMock.h"
-#include "third_party/ocmock/gtest_support.h"
-#include "url/gurl.h"
-
-namespace {
-
-NSString* const kAccountCreationFormName = @"create-foo-account";
-NSString* const kAccountCreationFieldName = @"password";
-NSString* const kAccountCreationOrigin = @"http://foo.com/login";
-NSString* const kEmailFieldName = @"email";
-
-// Static storage to access arguments passed to swizzled method of UIWindow.
-static id g_chrome_execute_command_sender = nil;
-
-}  // namespace
-
-@interface MockPasswordsUiDelegate : NSObject<PasswordsUiDelegate>
-
-- (instancetype)init;
-
-@property(nonatomic, readonly) BOOL UIShown;
-
-@end
-
-@implementation MockPasswordsUiDelegate {
-  // YES if showGenerationAlertWithPassword was called more recently than
-  // hideGenerationAlert, NO otherwise.
-  BOOL _UIShown;
-}
-
-- (instancetype)init {
-  self = [super init];
-  if (self) {
-    _UIShown = NO;
-  }
-  return self;
-}
-
-@synthesize UIShown = _UIShown;
-
-- (void)showGenerationAlertWithPassword:(NSString*)password
-                      andPromptDelegate:
-                          (id<PasswordGenerationPromptDelegate>)delegate {
-  _UIShown = YES;
-}
-
-- (void)hideGenerationAlert {
-  _UIShown = NO;
-}
-
-@end
-
-// A donor class that provides a chromeExecuteCommand method that can be
-// swapped with UIWindow.
-@interface DonorWindow : NSObject
-
-- (void)chromeExecuteCommand:(id)sender;
-
-@end
-
-@implementation DonorWindow
-
-- (void)chromeExecuteCommand:(id)sender {
-  g_chrome_execute_command_sender = [sender retain];
-}
-
-@end
-
-namespace {
-
-// A helper to swizzle chromeExecuteCommand method on UIWindow.
-class ScopedWindowSwizzler {
- public:
-  ScopedWindowSwizzler()
-      : class_swizzler_([UIWindow class],
-                        [DonorWindow class],
-                        @selector(chromeExecuteCommand:)) {
-    DCHECK(!g_chrome_execute_command_sender);
-  }
-
-  ~ScopedWindowSwizzler() {
-    [g_chrome_execute_command_sender release];
-    g_chrome_execute_command_sender = nil;
-  }
-
- private:
-  base::mac::ScopedObjCClassSwizzler class_swizzler_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedWindowSwizzler);
-};
-
-// Returns a form that should be marked as an account creation form by local
-// heuristics.
-autofill::PasswordForm GetAccountCreationForm() {
-  autofill::FormFieldData name_field;
-  name_field.name = base::ASCIIToUTF16("name");
-  name_field.form_control_type = "text";
-
-  autofill::FormFieldData email_field;
-  email_field.name = base::ASCIIToUTF16("email");
-  email_field.form_control_type = "email";
-
-  autofill::FormFieldData password_field;
-  password_field.name = base::SysNSStringToUTF16(kAccountCreationFieldName);
-  password_field.form_control_type = "password";
-
-  autofill::FormFieldData confirmPasswordField;
-  confirmPasswordField.name = base::ASCIIToUTF16("confirm");
-  confirmPasswordField.form_control_type = "password";
-
-  autofill::FormData form;
-  form.name = base::SysNSStringToUTF16(kAccountCreationFormName);
-  form.origin = GURL(base::SysNSStringToUTF8(kAccountCreationOrigin));
-  form.action = GURL(base::SysNSStringToUTF8(kAccountCreationOrigin));
-
-  form.fields.push_back(name_field);
-  form.fields.push_back(email_field);
-  form.fields.push_back(password_field);
-  form.fields.push_back(confirmPasswordField);
-
-  autofill::PasswordForm password_form;
-  password_form.origin = form.origin;
-  password_form.username_element = email_field.name;
-  password_form.password_element = password_field.name;
-
-  password_form.form_data = form;
-
-  return password_form;
-}
-
-// Executes each block in |blocks|, where each block must have the type
-// void^(void).
-void ExecuteBlocks(NSArray* blocks) {
-  for (void (^block)(void) in blocks)
-    block();
-}
-
-// Returns a form that has the same origin as GAIA.
-autofill::PasswordForm GetGAIAForm() {
-  autofill::PasswordForm form(GetAccountCreationForm());
-  form.origin = GaiaUrls::GetInstance()->gaia_login_form_realm();
-  form.signon_realm = form.origin.GetOrigin().spec();
-  return form;
-}
-
-// Returns a form with no text fields.
-autofill::PasswordForm GetFormWithNoTextFields() {
-  autofill::PasswordForm form(GetAccountCreationForm());
-  form.form_data.fields.clear();
-  return form;
-}
-
-// Returns true if |field| has type "password" and false otherwise.
-bool IsPasswordField(const autofill::FormFieldData& field) {
-  return field.form_control_type == "password";
-}
-
-// Returns all password fields in |form|.
-std::vector<autofill::FormFieldData> GetPasswordFields(
-    const autofill::PasswordForm& form) {
-  std::vector<autofill::FormFieldData> fields;
-  fields.reserve(form.form_data.fields.size());
-  for (const auto& field : form.form_data.fields) {
-    if (IsPasswordField(field))
-      fields.push_back(field);
-  }
-  return fields;
-}
-
-// Returns a form with no password fields.
-autofill::PasswordForm GetFormWithNoPasswordFields() {
-  autofill::PasswordForm form(GetAccountCreationForm());
-  form.form_data.fields.erase(
-      std::remove_if(form.form_data.fields.begin(), form.form_data.fields.end(),
-                     &IsPasswordField),
-      form.form_data.fields.end());
-  return form;
-}
-
-// Test fixture for testing PasswordGenerationAgent.
-class PasswordGenerationAgentTest : public web::WebTestWithWebState {
- public:
-  void SetUp() override {
-    web::WebTestWithWebState::SetUp();
-    mock_js_suggestion_manager_.reset(
-        [[OCMockObject niceMockForClass:[JsSuggestionManager class]] retain]);
-    mock_js_password_manager_.reset(
-        [[OCMockObject niceMockForClass:[JsPasswordManager class]] retain]);
-    mock_ui_delegate_.reset([[MockPasswordsUiDelegate alloc] init]);
-    test_web_state_.reset(new web::TestWebState);
-    agent_.reset([[PasswordGenerationAgent alloc]
-             initWithWebState:test_web_state_.get()
-              passwordManager:nullptr
-        passwordManagerDriver:nullptr
-            JSPasswordManager:mock_js_password_manager_
-          JSSuggestionManager:mock_js_suggestion_manager_
-          passwordsUiDelegate:mock_ui_delegate_]);
-    @autoreleasepool {
-      accessory_view_controller_.reset([[FormInputAccessoryViewController alloc]
-          initWithWebState:test_web_state_.get()
-                 providers:@[ agent_ ]]);
-    }
-  }
-
-  // Sends form data, autofill data, and password manager data to the
-  // generation agent so that it can find an account creation form and password
-  // field.
-  void LoadAccountCreationForm() {
-    autofill::PasswordForm password_form(GetAccountCreationForm());
-    [agent() allowPasswordGenerationForForm:password_form];
-    std::vector<autofill::PasswordForm> password_forms;
-    password_forms.push_back(password_form);
-    [agent() processParsedPasswordForms:password_forms];
-    SetCurrentURLAndTrustLevel(
-        GURL(base::SysNSStringToUTF8(kAccountCreationOrigin)),
-        web::URLVerificationTrustLevel::kAbsolute);
-    SetContentIsHTML(YES);
-  }
-
-  // Sets up the web controller mock to use the specified URL and trust level.
-  void SetCurrentURLAndTrustLevel(
-      GURL url,
-      web::URLVerificationTrustLevel url_trust_level) {
-    test_web_state_->SetCurrentURL(url);
-    test_web_state_->SetTrustLevel(url_trust_level);
-  }
-
-  // Swizzles the current web controller to set whether the content is HTML.
-  void SetContentIsHTML(BOOL content_is_html) {
-    test_web_state_->SetContentIsHTML(content_is_html);
-  }
-
-  // Simulates an event on the specified form/field.
-  void SimulateFormActivity(NSString* form_name,
-                            NSString* field_name,
-                            NSString* type) {
-    [accessory_view_controller_ webState:test_web_state_.get()
-        didRegisterFormActivityWithFormNamed:base::SysNSStringToUTF8(form_name)
-                                   fieldName:base::SysNSStringToUTF8(field_name)
-                                        type:base::SysNSStringToUTF8(type)
-                                       value:""
-                                     keyCode:web::WebStateObserver::
-                                                 kInvalidFormKeyCode
-                                inputMissing:false];
-  }
-
-  // Returns a mock of JsSuggestionManager.
-  id mock_js_suggestion_manager() { return mock_js_suggestion_manager_; }
-
-  // Returns a mock of JsPasswordManager.
-  id mock_js_password_manager() { return mock_js_password_manager_; }
-
-  MockPasswordsUiDelegate* mock_ui_delegate() { return mock_ui_delegate_; }
-
- protected:
-  // Returns the current generation agent.
-  PasswordGenerationAgent* agent() { return agent_.get(); }
-
-  // Returns the current accessory view controller.
-  FormInputAccessoryViewController* accessory_controller() {
-    return accessory_view_controller_.get();
-  }
-
- private:
-  // Test WebState.
-  std::unique_ptr<web::TestWebState> test_web_state_;
-
-  // Mock for JsSuggestionManager;
-  base::scoped_nsobject<id> mock_js_suggestion_manager_;
-
-  // Mock for JsPasswordManager.
-  base::scoped_nsobject<id> mock_js_password_manager_;
-
-  // Mock for the UI delegate.
-  base::scoped_nsobject<MockPasswordsUiDelegate> mock_ui_delegate_;
-
-  // Controller that shows custom input accessory views.
-  base::scoped_nsobject<FormInputAccessoryViewController>
-      accessory_view_controller_;
-
-  // The current generation agent.
-  base::scoped_nsobject<PasswordGenerationAgent> agent_;
-};
-
-// Tests that local heuristics skip forms with GAIA realm.
-TEST_F(PasswordGenerationAgentTest,
-       OnParsedForms_ShouldIgnoreFormsWithGaiaRealm) {
-  // Send only a form with GAIA origin to the agent.
-  std::vector<autofill::PasswordForm> forms;
-  forms.push_back(GetGAIAForm());
-  [agent() processParsedPasswordForms:forms];
-
-  // No account creation form should have been found.
-  EXPECT_FALSE(agent().possibleAccountCreationForm);
-  EXPECT_TRUE(agent().passwordFields.empty());
-}
-
-// Tests that local heuristics skip forms with no text fields.
-TEST_F(PasswordGenerationAgentTest,
-       OnParsedForms_ShouldIgnoreFormsWithNotEnoughTextFields) {
-  // Send only a form with GAIA origin to the agent.
-  std::vector<autofill::PasswordForm> forms;
-  forms.push_back(GetFormWithNoTextFields());
-  [agent() processParsedPasswordForms:forms];
-
-  // No account creation form should have been found.
-  EXPECT_FALSE(agent().possibleAccountCreationForm);
-  EXPECT_TRUE(agent().passwordFields.empty());
-}
-
-// Tests that local heuristics skip forms with no password fields.
-TEST_F(PasswordGenerationAgentTest,
-       OnParsedForms_ShouldIgnoreFormsWithNoPasswordFields) {
-  // Send only a form with GAIA origin to the agent.
-  std::vector<autofill::PasswordForm> forms;
-  forms.push_back(GetFormWithNoPasswordFields());
-  [agent() processParsedPasswordForms:forms];
-
-  // No account creation form should have been found.
-  EXPECT_FALSE(agent().possibleAccountCreationForm);
-  EXPECT_TRUE(agent().passwordFields.empty());
-}
-
-// Tests that local heuristics extract an account creation form from the page
-// when one exists, along with its password fields.
-TEST_F(PasswordGenerationAgentTest, OnParsedForms) {
-  // Send several forms. One should be selected.
-  std::vector<autofill::PasswordForm> forms;
-  forms.push_back(GetGAIAForm());
-  forms.push_back(GetFormWithNoTextFields());
-  forms.push_back(GetFormWithNoPasswordFields());
-  forms.push_back(GetAccountCreationForm());
-  [agent() processParsedPasswordForms:forms];
-
-  // Should have found an account creation form and extracted its password
-  // fields.
-  EXPECT_EQ(forms[3], *agent().possibleAccountCreationForm);
-  std::vector<autofill::FormFieldData> expectedPasswordFields(
-      GetPasswordFields(forms[3]));
-  EXPECT_EQ(expectedPasswordFields.size(), agent().passwordFields.size());
-  for (size_t i = 0; i < expectedPasswordFields.size(); ++i) {
-    EXPECT_FORM_FIELD_DATA_EQUALS(expectedPasswordFields[i],
-                                  agent().passwordFields[i]);
-  }
-}
-
-// Tests that password generation field identification waits until it has
-// approval from autofill and the password manager and an account creation
-// form has been identified with local heuristics..
-TEST_F(PasswordGenerationAgentTest, DeterminePasswordGenerationField) {
-  std::vector<autofill::PasswordForm> forms;
-  forms.push_back(GetAccountCreationForm());
-
-  autofill::PasswordForm form(GetAccountCreationForm());
-  std::vector<autofill::FormFieldData> passwordFields(GetPasswordFields(form));
-
-  // The signals can be received in any order, so test them accordingly by
-  // breaking the steps into blocks and executing them in different orders.
-  id sendForms = ^{
-    std::vector<autofill::PasswordForm> forms;
-    forms.push_back(form);
-    [agent() processParsedPasswordForms:forms];
-  };
-  id sendPasswordManagerWhitelist = ^{
-    [agent() allowPasswordGenerationForForm:form];
-  };
-  id expectFieldNotFound = ^{
-    EXPECT_FALSE(agent().passwordGenerationField);
-  };
-  id expectFieldFound = ^{
-    // When there are multiple password fields in the account creation form,
-    // the first one is used as the generation field.
-    EXPECT_FORM_FIELD_DATA_EQUALS(passwordFields[0],
-                                  (*agent().passwordGenerationField));
-  };
-
-  // For each permutation of steps, the field should only be set after the third
-  // signal is received.
-  @autoreleasepool {
-    ExecuteBlocks(@[
-      sendForms, expectFieldNotFound, sendPasswordManagerWhitelist,
-      expectFieldFound
-    ]);
-    [agent() clearState];
-
-    ExecuteBlocks(@[
-      sendPasswordManagerWhitelist, expectFieldNotFound, sendForms,
-      expectFieldFound
-    ]);
-    [agent() clearState];
-  }
-}
-
-// Tests that the password generation UI is shown when the user focuses the
-// password field in the account creation form.
-TEST_F(PasswordGenerationAgentTest,
-       ShouldStartGenerationWhenPasswordFieldFocused) {
-  LoadAccountCreationForm();
-  id mock = [OCMockObject partialMockForObject:accessory_controller()];
-  [[mock expect] showCustomInputAccessoryView:[OCMArg any]];
-  SimulateFormActivity(kAccountCreationFormName, kAccountCreationFieldName,
-                       @"focus");
-
-  EXPECT_OCMOCK_VERIFY(mock);
-  [mock stop];
-}
-
-// Tests that requesting password generation shows the alert UI.
-TEST_F(PasswordGenerationAgentTest, ShouldShowAlertWhenGenerationRequested) {
-  LoadAccountCreationForm();
-  id mock = [OCMockObject partialMockForObject:accessory_controller()];
-  [[mock expect] showCustomInputAccessoryView:[OCMArg any]];
-  SimulateFormActivity(kAccountCreationFormName, kAccountCreationFieldName,
-                       @"focus");
-  EXPECT_EQ(NO, mock_ui_delegate().UIShown);
-
-  [agent() generatePassword];
-  EXPECT_EQ(YES, mock_ui_delegate().UIShown);
-
-  EXPECT_OCMOCK_VERIFY(mock);
-  [mock stop];
-}
-
-// Tests that the password generation UI is hidden when the user changes focus
-// from the password field.
-TEST_F(PasswordGenerationAgentTest,
-       ShouldStopGenerationWhenDifferentFieldFocused) {
-  LoadAccountCreationForm();
-  id mock = [OCMockObject partialMockForObject:accessory_controller()];
-  [[mock expect] showCustomInputAccessoryView:[OCMArg any]];
-  SimulateFormActivity(kAccountCreationFormName, kAccountCreationFieldName,
-                       @"focus");
-
-  [[mock expect] restoreDefaultInputAccessoryView];
-  SimulateFormActivity(kAccountCreationFormName, kEmailFieldName, @"focus");
-
-  EXPECT_OCMOCK_VERIFY(mock);
-  [mock stop];
-}
-
-// Tests that the password field is filled when the user accepts a generated
-// password.
-TEST_F(PasswordGenerationAgentTest,
-       ShouldFillPasswordFieldAndDismissAlertWhenUserAcceptsGeneratedPassword) {
-  LoadAccountCreationForm();
-  // Focus the password field to start generation.
-  SimulateFormActivity(kAccountCreationFormName, kAccountCreationFieldName,
-                       @"focus");
-  NSString* password = @"abc";
-
-  [[[mock_js_password_manager() stub] andDo:^(NSInvocation* invocation) {
-    void (^completion_handler)(BOOL);
-    [invocation getArgument:&completion_handler atIndex:4];
-    completion_handler(YES);
-  }] fillPasswordForm:kAccountCreationFormName
-      withGeneratedPassword:password
-          completionHandler:[OCMArg any]];
-
-  [agent() generatePassword];
-  EXPECT_EQ(YES, mock_ui_delegate().UIShown);
-
-  [agent() acceptPasswordGeneration:nil];
-  EXPECT_EQ(NO, mock_ui_delegate().UIShown);
-  EXPECT_OCMOCK_VERIFY(mock_js_password_manager());
-}
-
-// Tests that the Save Passwords setting screen is shown when the user taps
-// "show saved passwords".
-TEST_F(PasswordGenerationAgentTest,
-       ShouldShowPasswordsAndDismissAlertWhenUserTapsShow) {
-  ScopedWindowSwizzler swizzler;
-  LoadAccountCreationForm();
-  // Focus the password field to start generation.
-  SimulateFormActivity(kAccountCreationFormName, kAccountCreationFieldName,
-                       @"focus");
-  [agent() generatePassword];
-  EXPECT_EQ(YES, mock_ui_delegate().UIShown);
-
-  [agent() showSavedPasswords:nil];
-  EXPECT_EQ(NO, mock_ui_delegate().UIShown);
-
-  GenericChromeCommand* command = base::mac::ObjCCast<GenericChromeCommand>(
-      g_chrome_execute_command_sender);
-  EXPECT_TRUE(command);
-  EXPECT_EQ(IDC_SHOW_SAVE_PASSWORDS_SETTINGS, command.tag);
-}
-
-}  // namespace
diff --git a/ios/chrome/ios_chrome_tests.gyp b/ios/chrome/ios_chrome_tests.gyp
index 881e154..c3432d3 100644
--- a/ios/chrome/ios_chrome_tests.gyp
+++ b/ios/chrome/ios_chrome_tests.gyp
@@ -24,7 +24,6 @@
         '../../components/components.gyp:update_client',
         '../../components/components.gyp:version_info',
         '../../components/prefs/prefs.gyp:prefs_test_support',
-        '../../ios/testing/ios_testing.gyp:ocmock_support',
         '../../net/net.gyp:net_test_support',
         '../../skia/skia.gyp:skia',
         '../../testing/gmock.gyp:gmock',
@@ -62,12 +61,7 @@
         'browser/net/metrics_network_client_unittest.mm',
         'browser/net/retryable_url_fetcher_unittest.mm',
         'browser/notification_promo_unittest.cc',
-        'browser/passwords/credential_manager_js_unittest.mm',
-        'browser/passwords/credential_manager_unittest.mm',
-        'browser/passwords/password_controller_js_unittest.mm',
-        'browser/passwords/password_controller_off_the_record_unittest.mm',
         'browser/passwords/password_controller_unittest.mm',
-        'browser/passwords/password_generation_agent_unittest.mm',
         'browser/reading_list/reading_list_entry_unittest.cc',
         'browser/reading_list/reading_list_model_unittest.cc',
         'browser/signin/chrome_identity_service_observer_bridge_unittest.mm',
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index 666f207..b928d0b 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -385,10 +385,7 @@ if (is_win || is_android || is_chromeos) {
       "//ui/gl/init",
     ]
 
-    configs += [
-      "//third_party/khronos:khronos_headers",
-      ":gpu_config",
-    ]
+    configs += [ "//third_party/khronos:khronos_headers" ]
     if (is_chromeos && current_cpu != "arm") {
       configs += [ "//third_party/libva:libva_config" ]
     }
@@ -453,7 +450,6 @@ if (is_chromeos || is_mac) {
     configs += [
       "//third_party/libva:libva_config",
       "//third_party/libyuv:libyuv_config",
-      ":gpu_config",
     ]
     sources = [
       "video_accelerator_unittest_helpers.h",
diff --git a/media/gpu/ipc/client/BUILD.gn b/media/gpu/ipc/client/BUILD.gn
index 16dde2d..1480054 100644
--- a/media/gpu/ipc/client/BUILD.gn
+++ b/media/gpu/ipc/client/BUILD.gn
@@ -12,10 +12,8 @@ source_set("client") {
     "gpu_video_encode_accelerator_host.h",
   ]
 
-  configs += [
-    "//build/config/compiler:no_size_t_to_int_warning",
-    "//media/gpu:gpu_config",
-  ]
+  public_configs = [ "//media/gpu:gpu_config" ]
+  configs += [ "//build/config/compiler:no_size_t_to_int_warning" ]
 
   deps = [
     "//base",
diff --git a/media/gpu/video_encode_accelerator_unittest.cc b/media/gpu/video_encode_accelerator_unittest.cc
index eb13008..f32fc45 100644
--- a/media/gpu/video_encode_accelerator_unittest.cc
+++ b/media/gpu/video_encode_accelerator_unittest.cc
@@ -50,7 +50,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 
 #if defined(OS_CHROMEOS)
-#if defined(USE_V4L2_CODEC)
+#if defined(ARCH_CPU_ARMEL) || (defined(USE_OZONE) && defined(USE_V4L2_CODEC))
 #include "media/gpu/v4l2_video_encode_accelerator.h"
 #endif
 #if defined(ARCH_CPU_X86_FAMILY)
@@ -1078,7 +1078,8 @@ std::unique_ptr<VideoEncodeAccelerator> VEAClient::CreateFakeVEA() {
 
 std::unique_ptr<VideoEncodeAccelerator> VEAClient::CreateV4L2VEA() {
   std::unique_ptr<VideoEncodeAccelerator> encoder;
-#if defined(OS_CHROMEOS) && defined(USE_V4L2_CODEC)
+#if defined(OS_CHROMEOS) && (defined(ARCH_CPU_ARMEL) || \
+                             (defined(USE_OZONE) && defined(USE_V4L2_CODEC)))
   scoped_refptr<V4L2Device> device = V4L2Device::Create(V4L2Device::kEncoder);
   if (device)
     encoder.reset(new V4L2VideoEncodeAccelerator(device));
diff --git a/net/http/bidirectional_stream.cc b/net/http/bidirectional_stream.cc
index a3f74d2..e0f4b8d 100644
--- a/net/http/bidirectional_stream.cc
+++ b/net/http/bidirectional_stream.cc
@@ -235,7 +235,7 @@ void BidirectionalStream::OnStreamReady(bool request_headers_sent) {
 void BidirectionalStream::OnHeadersReceived(
     const SpdyHeaderBlock& response_headers) {
   HttpResponseInfo response_info;
-  if (!SpdyHeadersToHttpResponse(response_headers, &response_info)) {
+  if (!SpdyHeadersToHttpResponse(response_headers, HTTP2, &response_info)) {
     DLOG(WARNING) << "Invalid headers";
     NotifyFailed(ERR_FAILED);
     return;
diff --git a/net/http/bidirectional_stream_impl.h b/net/http/bidirectional_stream_impl.h
index 52a7c77..4f53918 100644
--- a/net/http/bidirectional_stream_impl.h
+++ b/net/http/bidirectional_stream_impl.h
@@ -8,7 +8,6 @@
 #include <stdint.h>
 
 #include <memory>
-#include <vector>
 
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
diff --git a/net/http/bidirectional_stream_unittest.cc b/net/http/bidirectional_stream_unittest.cc
index 893a3cf..0b82a06 100644
--- a/net/http/bidirectional_stream_unittest.cc
+++ b/net/http/bidirectional_stream_unittest.cc
@@ -510,7 +510,7 @@ TEST_F(BidirectionalStreamTest, TestReadDataAfterClose) {
 
 // Tests that the NetLog contains correct entries.
 TEST_F(BidirectionalStreamTest, TestNetLogContainEntries) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 3, LOWEST, nullptr, 0));
@@ -653,7 +653,7 @@ TEST_F(BidirectionalStreamTest, TestNetLogContainEntries) {
 }
 
 TEST_F(BidirectionalStreamTest, TestInterleaveReadDataAndSendData) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 3, LOWEST, nullptr, 0));
@@ -757,7 +757,7 @@ TEST_F(BidirectionalStreamTest, TestInterleaveReadDataAndSendData) {
 }
 
 TEST_F(BidirectionalStreamTest, TestCoalesceSmallDataBuffers) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 1, LOWEST, nullptr, 0));
@@ -1083,7 +1083,7 @@ TEST_F(BidirectionalStreamTest, TestBufferingWithTrailers) {
 }
 
 TEST_F(BidirectionalStreamTest, CancelStreamAfterSendData) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 3, LOWEST, nullptr, 0));
@@ -1150,7 +1150,7 @@ TEST_F(BidirectionalStreamTest, CancelStreamAfterSendData) {
 }
 
 TEST_F(BidirectionalStreamTest, CancelStreamDuringReadData) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 3, LOWEST, nullptr, 0));
diff --git a/net/http/http_network_session.cc b/net/http/http_network_session.cc
index 133dd83..0661daf 100644
--- a/net/http/http_network_session.cc
+++ b/net/http/http_network_session.cc
@@ -90,6 +90,7 @@ HttpNetworkSession::Params::Params()
       testing_fixed_https_port(0),
       enable_tcp_fast_open_for_ssl(false),
       enable_spdy_ping_based_connection_checking(true),
+      spdy_default_protocol(kProtoUnknown),
       enable_http2(true),
       spdy_session_max_recv_window_size(kSpdySessionMaxRecvWindowSize),
       spdy_stream_max_recv_window_size(kSpdyStreamMaxRecvWindowSize),
@@ -197,6 +198,7 @@ HttpNetworkSession::HttpNetworkSession(const Params& params)
                          params.transport_security_state,
                          params.enable_spdy_ping_based_connection_checking,
                          params.enable_priority_dependencies,
+                         params.spdy_default_protocol,
                          params.spdy_session_max_recv_window_size,
                          params.spdy_stream_max_recv_window_size,
                          params.time_func,
diff --git a/net/http/http_network_session.h b/net/http/http_network_session.h
index 0af40d6..c3de445 100644
--- a/net/http/http_network_session.h
+++ b/net/http/http_network_session.h
@@ -87,6 +87,7 @@ class NET_EXPORT HttpNetworkSession
 
     // Use SPDY ping frames to test for connection health after idle.
     bool enable_spdy_ping_based_connection_checking;
+    NextProto spdy_default_protocol;
     bool enable_http2;
     size_t spdy_session_max_recv_window_size;
     size_t spdy_stream_max_recv_window_size;
diff --git a/net/http/http_stream_factory_impl_job.cc b/net/http/http_stream_factory_impl_job.cc
index 38d7c1b..3ba3c91 100644
--- a/net/http/http_stream_factory_impl_job.cc
+++ b/net/http/http_stream_factory_impl_job.cc
@@ -1331,7 +1331,8 @@ int HttpStreamFactoryImpl::Job::DoCreateStream() {
   bool was_npn_negotiated;
   NextProto protocol_negotiated;
   if (spdy_session->GetSSLInfo(&ssl_info, &was_npn_negotiated,
-                               &protocol_negotiated)) {
+                               &protocol_negotiated) &&
+      spdy_session->GetProtocolVersion() >= HTTP2) {
     UMA_HISTOGRAM_SPARSE_SLOWLY(
         "Net.Http2SSLCipherSuite",
         SSLConnectionStatusToCipherSuite(ssl_info.connection_status));
diff --git a/net/quic/bidirectional_stream_quic_impl.cc b/net/quic/bidirectional_stream_quic_impl.cc
index 25dd9c7..205fbd0 100644
--- a/net/quic/bidirectional_stream_quic_impl.cc
+++ b/net/quic/bidirectional_stream_quic_impl.cc
@@ -94,8 +94,9 @@ void BidirectionalStreamQuicImpl::SendRequestHeaders() {
   http_request_info.method = request_info_->method;
   http_request_info.extra_headers = request_info_->extra_headers;
 
-  CreateSpdyHeadersFromHttpRequest(
-      http_request_info, http_request_info.extra_headers, true, &headers);
+  CreateSpdyHeadersFromHttpRequest(http_request_info,
+                                   http_request_info.extra_headers, HTTP2, true,
+                                   &headers);
   size_t headers_bytes_sent = stream_->WriteHeaders(
       std::move(headers), request_info_->end_stream_on_headers, nullptr);
   headers_bytes_sent_ += headers_bytes_sent;
diff --git a/net/quic/quic_http_stream.cc b/net/quic/quic_http_stream.cc
index 39784fe..1097fee 100644
--- a/net/quic/quic_http_stream.cc
+++ b/net/quic/quic_http_stream.cc
@@ -19,6 +19,7 @@
 #include "net/quic/quic_http_utils.h"
 #include "net/quic/quic_utils.h"
 #include "net/quic/spdy_utils.h"
+#include "net/socket/next_proto.h"
 #include "net/spdy/spdy_frame_builder.h"
 #include "net/spdy/spdy_framer.h"
 #include "net/spdy/spdy_http_utils.h"
@@ -87,7 +88,8 @@ bool QuicHttpStream::CheckVary(const SpdyHeaderBlock& client_request,
   ConvertHeaderBlockToHttpRequestHeaders(client_request,
                                          &client_request_info.extra_headers);
 
-  if (!SpdyHeadersToHttpResponse(promise_response, &promise_response_info)) {
+  if (!SpdyHeadersToHttpResponse(promise_response, HTTP2,
+                                 &promise_response_info)) {
     DLOG(WARNING) << "Invalid headers";
     return false;
   }
@@ -270,7 +272,7 @@ int QuicHttpStream::SendRequest(const HttpRequestHeaders& request_headers,
   }
 
   // Store the serialized request headers.
-  CreateSpdyHeadersFromHttpRequest(*request_info_, request_headers,
+  CreateSpdyHeadersFromHttpRequest(*request_info_, request_headers, HTTP2,
                                    /*direct=*/true, &request_headers_);
 
   // Store the request body.
@@ -775,7 +777,7 @@ int QuicHttpStream::DoSendBodyComplete(int rv) {
 }
 
 int QuicHttpStream::ProcessResponseHeaders(const SpdyHeaderBlock& headers) {
-  if (!SpdyHeadersToHttpResponse(headers, response_info_)) {
+  if (!SpdyHeadersToHttpResponse(headers, HTTP2, response_info_)) {
     DLOG(WARNING) << "Invalid headers";
     return ERR_QUIC_PROTOCOL_ERROR;
   }
diff --git a/net/socket/ssl_client_socket_pool_unittest.cc b/net/socket/ssl_client_socket_pool_unittest.cc
index 824c622..5d98c34 100644
--- a/net/socket/ssl_client_socket_pool_unittest.cc
+++ b/net/socket/ssl_client_socket_pool_unittest.cc
@@ -80,7 +80,9 @@ void TestLoadTimingInfoNoDns(const ClientSocketHandle& handle) {
   ExpectLoadTimingHasOnlyConnectionTimes(load_timing_info);
 }
 
-class SSLClientSocketPoolTest : public testing::Test {
+class SSLClientSocketPoolTest
+    : public testing::Test,
+      public ::testing::WithParamInterface<NextProto> {
  protected:
   SSLClientSocketPoolTest()
       : cert_verifier_(new MockCertVerifier),
@@ -176,6 +178,7 @@ class SSLClientSocketPoolTest : public testing::Test {
     params.ssl_config_service = ssl_config_service_.get();
     params.http_auth_handler_factory = http_auth_handler_factory_.get();
     params.http_server_properties = http_server_properties_.get();
+    params.spdy_default_protocol = kProtoHTTP2;
     return new HttpNetworkSession(params);
   }
 
diff --git a/net/spdy/bidirectional_stream_spdy_impl.cc b/net/spdy/bidirectional_stream_spdy_impl.cc
index a4391d6..6a394c2 100644
--- a/net/spdy/bidirectional_stream_spdy_impl.cc
+++ b/net/spdy/bidirectional_stream_spdy_impl.cc
@@ -187,7 +187,7 @@ int64_t BidirectionalStreamSpdyImpl::GetTotalSentBytes() const {
 void BidirectionalStreamSpdyImpl::OnRequestHeadersSent() {
   DCHECK(stream_);
 
-  negotiated_protocol_ = kProtoHTTP2;
+  negotiated_protocol_ = stream_->GetProtocol();
   if (delegate_)
     delegate_->OnStreamReady(/*request_headers_sent=*/true);
 }
@@ -267,7 +267,8 @@ int BidirectionalStreamSpdyImpl::SendRequestHeadersHelper() {
   http_request_info.extra_headers = request_info_->extra_headers;
 
   CreateSpdyHeadersFromHttpRequest(
-      http_request_info, http_request_info.extra_headers, true, headers.get());
+      http_request_info, http_request_info.extra_headers,
+      stream_->GetProtocolVersion(), true, headers.get());
   return stream_->SendRequestHeaders(std::move(headers),
                                      request_info_->end_stream_on_headers
                                          ? NO_MORE_DATA_TO_SEND
diff --git a/net/spdy/bidirectional_stream_spdy_impl_unittest.cc b/net/spdy/bidirectional_stream_spdy_impl_unittest.cc
index c4e20e6..3e052f1 100644
--- a/net/spdy/bidirectional_stream_spdy_impl_unittest.cc
+++ b/net/spdy/bidirectional_stream_spdy_impl_unittest.cc
@@ -306,7 +306,7 @@ TEST_F(BidirectionalStreamSpdyImplTest, SendDataAfterStreamFailed) {
 }
 
 TEST_F(BidirectionalStreamSpdyImplTest, SendDataAfterCancelStream) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(spdy_util_.ConstructSpdyPost(
       kDefaultUrl, 1, kBodyDataSize * 3, LOWEST, nullptr, 0));
diff --git a/net/spdy/buffered_spdy_framer.cc b/net/spdy/buffered_spdy_framer.cc
index 3752f38..0a48f16 100644
--- a/net/spdy/buffered_spdy_framer.cc
+++ b/net/spdy/buffered_spdy_framer.cc
@@ -22,8 +22,23 @@ size_t kHeaderBufferMaxSize = 256 * 1024;
 
 }  // namespace
 
-BufferedSpdyFramer::BufferedSpdyFramer()
-    : spdy_framer_(HTTP2),
+SpdyMajorVersion NextProtoToSpdyMajorVersion(NextProto next_proto) {
+  switch (next_proto) {
+    case kProtoSPDY31:
+      return SPDY3;
+    case kProtoHTTP2:
+      return HTTP2;
+    case kProtoUnknown:
+    case kProtoHTTP11:
+    case kProtoQUIC1SPDY3:
+      break;
+  }
+  NOTREACHED();
+  return HTTP2;
+}
+
+BufferedSpdyFramer::BufferedSpdyFramer(SpdyMajorVersion version)
+    : spdy_framer_(version),
       visitor_(NULL),
       header_buffer_valid_(false),
       header_stream_id_(SpdyFramer::kInvalidStream),
@@ -53,7 +68,17 @@ void BufferedSpdyFramer::OnSynStream(SpdyStreamId stream_id,
                                      SpdyPriority priority,
                                      bool fin,
                                      bool unidirectional) {
-  NOTREACHED();
+  frames_received_++;
+  DCHECK(!control_frame_fields_.get());
+  control_frame_fields_.reset(new ControlFrameFields());
+  control_frame_fields_->type = SYN_STREAM;
+  control_frame_fields_->stream_id = stream_id;
+  control_frame_fields_->associated_stream_id = associated_stream_id;
+  control_frame_fields_->priority = priority;
+  control_frame_fields_->fin = fin;
+  control_frame_fields_->unidirectional = unidirectional;
+
+  InitHeaderStreaming(stream_id);
 }
 
 void BufferedSpdyFramer::OnHeaders(SpdyStreamId stream_id,
@@ -81,7 +106,14 @@ void BufferedSpdyFramer::OnHeaders(SpdyStreamId stream_id,
 
 void BufferedSpdyFramer::OnSynReply(SpdyStreamId stream_id,
                                     bool fin) {
-  NOTREACHED();
+  frames_received_++;
+  DCHECK(!control_frame_fields_.get());
+  control_frame_fields_.reset(new ControlFrameFields());
+  control_frame_fields_->type = SYN_REPLY;
+  control_frame_fields_->stream_id = stream_id;
+  control_frame_fields_->fin = fin;
+
+  InitHeaderStreaming(stream_id);
 }
 
 bool BufferedSpdyFramer::OnControlFrameHeaderData(SpdyStreamId stream_id,
@@ -103,10 +135,17 @@ bool BufferedSpdyFramer::OnControlFrameHeaderData(SpdyStreamId stream_id,
     DCHECK(control_frame_fields_.get());
     switch (control_frame_fields_->type) {
       case SYN_STREAM:
-        NOTREACHED();
+        visitor_->OnSynStream(control_frame_fields_->stream_id,
+                              control_frame_fields_->associated_stream_id,
+                              control_frame_fields_->priority,
+                              control_frame_fields_->fin,
+                              control_frame_fields_->unidirectional,
+                              headers);
         break;
       case SYN_REPLY:
-        NOTREACHED();
+        visitor_->OnSynReply(control_frame_fields_->stream_id,
+                             control_frame_fields_->fin,
+                             headers);
         break;
       case HEADERS:
         visitor_->OnHeaders(control_frame_fields_->stream_id,
@@ -117,6 +156,7 @@ bool BufferedSpdyFramer::OnControlFrameHeaderData(SpdyStreamId stream_id,
                             control_frame_fields_->fin, headers);
         break;
       case PUSH_PROMISE:
+        DCHECK_LT(SPDY3, protocol_version());
         visitor_->OnPushPromise(control_frame_fields_->stream_id,
                                 control_frame_fields_->promised_stream_id,
                                 headers);
@@ -173,7 +213,7 @@ void BufferedSpdyFramer::OnStreamPadding(SpdyStreamId stream_id, size_t len) {
 
 SpdyHeadersHandlerInterface* BufferedSpdyFramer::OnHeaderFrameStart(
     SpdyStreamId stream_id) {
-  coalescer_.reset(new HeaderCoalescer());
+  coalescer_.reset(new HeaderCoalescer(protocol_version()));
   return coalescer_.get();
 }
 
@@ -187,10 +227,15 @@ void BufferedSpdyFramer::OnHeaderFrameEnd(SpdyStreamId stream_id,
   DCHECK(control_frame_fields_.get());
   switch (control_frame_fields_->type) {
     case SYN_STREAM:
-      NOTREACHED();
+      visitor_->OnSynStream(
+          control_frame_fields_->stream_id,
+          control_frame_fields_->associated_stream_id,
+          control_frame_fields_->priority, control_frame_fields_->fin,
+          control_frame_fields_->unidirectional, coalescer_->headers());
       break;
     case SYN_REPLY:
-      NOTREACHED();
+      visitor_->OnSynReply(control_frame_fields_->stream_id,
+                           control_frame_fields_->fin, coalescer_->headers());
       break;
     case HEADERS:
       visitor_->OnHeaders(control_frame_fields_->stream_id,
@@ -201,6 +246,7 @@ void BufferedSpdyFramer::OnHeaderFrameEnd(SpdyStreamId stream_id,
                           control_frame_fields_->fin, coalescer_->headers());
       break;
     case PUSH_PROMISE:
+      DCHECK_LT(SPDY3, protocol_version());
       visitor_->OnPushPromise(control_frame_fields_->stream_id,
                               control_frame_fields_->promised_stream_id,
                               coalescer_->headers());
@@ -271,6 +317,7 @@ void BufferedSpdyFramer::OnWindowUpdate(SpdyStreamId stream_id,
 void BufferedSpdyFramer::OnPushPromise(SpdyStreamId stream_id,
                                        SpdyStreamId promised_stream_id,
                                        bool end) {
+  DCHECK_LT(SPDY3, protocol_version());
   frames_received_++;
   DCHECK(!control_frame_fields_.get());
   control_frame_fields_.reset(new ControlFrameFields());
@@ -296,6 +343,10 @@ bool BufferedSpdyFramer::OnUnknownFrame(SpdyStreamId stream_id,
   return visitor_->OnUnknownFrame(stream_id, frame_type);
 }
 
+SpdyMajorVersion BufferedSpdyFramer::protocol_version() {
+  return spdy_framer_.protocol_version();
+}
+
 size_t BufferedSpdyFramer::ProcessInput(const char* data, size_t len) {
   return spdy_framer_.ProcessInput(data, len);
 }
diff --git a/net/spdy/buffered_spdy_framer.h b/net/spdy/buffered_spdy_framer.h
index 48bc4a5..8f04d9e 100644
--- a/net/spdy/buffered_spdy_framer.h
+++ b/net/spdy/buffered_spdy_framer.h
@@ -13,6 +13,7 @@
 
 #include "base/macros.h"
 #include "net/base/net_export.h"
+#include "net/socket/next_proto.h"
 #include "net/spdy/header_coalescer.h"
 #include "net/spdy/spdy_alt_svc_wire_format.h"
 #include "net/spdy/spdy_framer.h"
@@ -21,6 +22,11 @@
 
 namespace net {
 
+// Returns the SPDY major version corresponding to the given NextProto
+// value, which must represent a SPDY-like protocol.
+NET_EXPORT_PRIVATE SpdyMajorVersion NextProtoToSpdyMajorVersion(
+    NextProto next_proto);
+
 class NET_EXPORT_PRIVATE BufferedSpdyFramerVisitorInterface {
  public:
   BufferedSpdyFramerVisitorInterface() {}
@@ -32,6 +38,19 @@ class NET_EXPORT_PRIVATE BufferedSpdyFramerVisitorInterface {
   virtual void OnStreamError(SpdyStreamId stream_id,
                              const std::string& description) = 0;
 
+  // Called after all the header data for SYN_STREAM control frame is received.
+  virtual void OnSynStream(SpdyStreamId stream_id,
+                           SpdyStreamId associated_stream_id,
+                           SpdyPriority priority,
+                           bool fin,
+                           bool unidirectional,
+                           const SpdyHeaderBlock& headers) = 0;
+
+  // Called after all the header data for SYN_REPLY control frame is received.
+  virtual void OnSynReply(SpdyStreamId stream_id,
+                          bool fin,
+                          const SpdyHeaderBlock& headers) = 0;
+
   // Called after all the header data for HEADERS control frame is received.
   virtual void OnHeaders(SpdyStreamId stream_id,
                          bool has_priority,
@@ -121,7 +140,7 @@ class NET_EXPORT_PRIVATE BufferedSpdyFramerVisitorInterface {
 class NET_EXPORT_PRIVATE BufferedSpdyFramer
     : public SpdyFramerVisitorInterface {
  public:
-  BufferedSpdyFramer();
+  explicit BufferedSpdyFramer(SpdyMajorVersion version);
   ~BufferedSpdyFramer() override;
 
   // Sets callbacks to be called from the buffered spdy framer.  A visitor must
@@ -186,6 +205,7 @@ class NET_EXPORT_PRIVATE BufferedSpdyFramer
 
   // SpdyFramer methods.
   size_t ProcessInput(const char* data, size_t len);
+  SpdyMajorVersion protocol_version();
   void Reset();
   SpdyFramer::SpdyError error_code() const;
   SpdyFramer::SpdyState state() const;
diff --git a/net/spdy/buffered_spdy_framer_unittest.cc b/net/spdy/buffered_spdy_framer_unittest.cc
index 3279059..de4deb6 100644
--- a/net/spdy/buffered_spdy_framer_unittest.cc
+++ b/net/spdy/buffered_spdy_framer_unittest.cc
@@ -17,9 +17,11 @@ namespace {
 class TestBufferedSpdyVisitor : public BufferedSpdyFramerVisitorInterface {
  public:
   explicit TestBufferedSpdyVisitor()
-      : buffered_spdy_framer_(),
+      : buffered_spdy_framer_(HTTP2),
         error_count_(0),
         setting_count_(0),
+        syn_frame_count_(0),
+        syn_reply_frame_count_(0),
         headers_frame_count_(0),
         push_promise_frame_count_(0),
         goaway_count_(0),
@@ -39,6 +41,27 @@ class TestBufferedSpdyVisitor : public BufferedSpdyFramerVisitorInterface {
     error_count_++;
   }
 
+  void OnSynStream(SpdyStreamId stream_id,
+                   SpdyStreamId associated_stream_id,
+                   SpdyPriority priority,
+                   bool fin,
+                   bool unidirectional,
+                   const SpdyHeaderBlock& headers) override {
+    header_stream_id_ = stream_id;
+    EXPECT_NE(header_stream_id_, SpdyFramer::kInvalidStream);
+    syn_frame_count_++;
+    headers_ = headers.Clone();
+  }
+
+  void OnSynReply(SpdyStreamId stream_id,
+                  bool fin,
+                  const SpdyHeaderBlock& headers) override {
+    header_stream_id_ = stream_id;
+    EXPECT_NE(header_stream_id_, SpdyFramer::kInvalidStream);
+    syn_reply_frame_count_++;
+    headers_ = headers.Clone();
+  }
+
   void OnHeaders(SpdyStreamId stream_id,
                  bool has_priority,
                  int weight,
@@ -151,6 +174,8 @@ class TestBufferedSpdyVisitor : public BufferedSpdyFramerVisitorInterface {
   // Counters from the visitor callbacks.
   int error_count_;
   int setting_count_;
+  int syn_frame_count_;
+  int syn_reply_frame_count_;
   int headers_frame_count_;
   int push_promise_frame_count_;
   int goaway_count_;
@@ -160,7 +185,8 @@ class TestBufferedSpdyVisitor : public BufferedSpdyFramerVisitorInterface {
   SpdyStreamId header_stream_id_;
   SpdyStreamId promised_stream_id_;
 
-  // Headers from OnHeaders and OnPushPromise for verification.
+  // Headers from OnSyn, OnSynReply, OnHeaders and OnPushPromise for
+  // verification.
   SpdyHeaderBlock headers_;
 
   // OnGoAway parameters.
@@ -197,7 +223,7 @@ TEST_F(BufferedSpdyFramerTest, HeaderListTooLarge) {
   SpdyHeaderBlock headers;
   std::string long_header_value(256 * 1024, 'x');
   headers["foo"] = long_header_value;
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   std::unique_ptr<SpdySerializedFrame> control_frame(
       framer.CreateHeaders(1,  // stream_id
                            CONTROL_FLAG_NONE,
@@ -211,6 +237,8 @@ TEST_F(BufferedSpdyFramerTest, HeaderListTooLarge) {
       control_frame.get()->size());
 
   EXPECT_EQ(1, visitor.error_count_);
+  EXPECT_EQ(0, visitor.syn_frame_count_);
+  EXPECT_EQ(0, visitor.syn_reply_frame_count_);
   EXPECT_EQ(0, visitor.headers_frame_count_);
   EXPECT_EQ(0, visitor.push_promise_frame_count_);
   EXPECT_EQ(SpdyHeaderBlock(), visitor.headers_);
@@ -220,7 +248,7 @@ TEST_F(BufferedSpdyFramerTest, ReadHeadersHeaderBlock) {
   SpdyHeaderBlock headers;
   headers["alpha"] = "beta";
   headers["gamma"] = "delta";
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   std::unique_ptr<SpdySerializedFrame> control_frame(
       framer.CreateHeaders(1,  // stream_id
                            CONTROL_FLAG_NONE,
@@ -233,6 +261,8 @@ TEST_F(BufferedSpdyFramerTest, ReadHeadersHeaderBlock) {
       reinterpret_cast<unsigned char*>(control_frame.get()->data()),
       control_frame.get()->size());
   EXPECT_EQ(0, visitor.error_count_);
+  EXPECT_EQ(0, visitor.syn_frame_count_);
+  EXPECT_EQ(0, visitor.syn_reply_frame_count_);
   EXPECT_EQ(1, visitor.headers_frame_count_);
   EXPECT_EQ(0, visitor.push_promise_frame_count_);
   EXPECT_EQ(headers, visitor.headers_);
@@ -242,7 +272,7 @@ TEST_F(BufferedSpdyFramerTest, ReadPushPromiseHeaderBlock) {
   SpdyHeaderBlock headers;
   headers["alpha"] = "beta";
   headers["gamma"] = "delta";
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   std::unique_ptr<SpdySerializedFrame> control_frame(
       framer.CreatePushPromise(1, 2, headers.Clone()));
   EXPECT_TRUE(control_frame.get() != NULL);
@@ -252,6 +282,8 @@ TEST_F(BufferedSpdyFramerTest, ReadPushPromiseHeaderBlock) {
       reinterpret_cast<unsigned char*>(control_frame.get()->data()),
       control_frame.get()->size());
   EXPECT_EQ(0, visitor.error_count_);
+  EXPECT_EQ(0, visitor.syn_frame_count_);
+  EXPECT_EQ(0, visitor.syn_reply_frame_count_);
   EXPECT_EQ(0, visitor.headers_frame_count_);
   EXPECT_EQ(1, visitor.push_promise_frame_count_);
   EXPECT_EQ(headers, visitor.headers_);
@@ -260,7 +292,7 @@ TEST_F(BufferedSpdyFramerTest, ReadPushPromiseHeaderBlock) {
 }
 
 TEST_F(BufferedSpdyFramerTest, GoAwayDebugData) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   std::unique_ptr<SpdySerializedFrame> goaway_frame(
       framer.CreateGoAway(2u, GOAWAY_FRAME_SIZE_ERROR, "foo"));
 
@@ -284,7 +316,7 @@ TEST_F(BufferedSpdyFramerTest, OnAltSvc) {
       SpdyAltSvcWireFormat::VersionVector());
   altsvc_ir.add_altsvc(alternative_service);
   altsvc_ir.set_origin(altsvc_origin);
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   SpdySerializedFrame altsvc_frame(framer.SerializeFrame(altsvc_ir));
 
   TestBufferedSpdyVisitor visitor;
diff --git a/net/spdy/header_coalescer.cc b/net/spdy/header_coalescer.cc
index eb8d381..d4faa4f 100644
--- a/net/spdy/header_coalescer.cc
+++ b/net/spdy/header_coalescer.cc
@@ -29,7 +29,7 @@ void HeaderCoalescer::OnHeader(base::StringPiece key, base::StringPiece value) {
   }
 
   if (key[0] == ':') {
-    if (regular_header_seen_) {
+    if (protocol_version_ == HTTP2 && regular_header_seen_) {
       error_seen_ = true;
       return;
     }
diff --git a/net/spdy/header_coalescer.h b/net/spdy/header_coalescer.h
index 8d393ff..07cd388 100644
--- a/net/spdy/header_coalescer.h
+++ b/net/spdy/header_coalescer.h
@@ -8,12 +8,14 @@
 #include "net/base/net_export.h"
 #include "net/spdy/spdy_header_block.h"
 #include "net/spdy/spdy_headers_handler_interface.h"
+#include "net/spdy/spdy_protocol.h"
 
 namespace net {
 
 class NET_EXPORT_PRIVATE HeaderCoalescer : public SpdyHeadersHandlerInterface {
  public:
-  HeaderCoalescer() {}
+  explicit HeaderCoalescer(const SpdyMajorVersion& protocol_version)
+      : protocol_version_(protocol_version) {}
 
   void OnHeaderBlockStart() override {}
 
@@ -29,6 +31,7 @@ class NET_EXPORT_PRIVATE HeaderCoalescer : public SpdyHeadersHandlerInterface {
   size_t header_list_size_ = 0;
   bool error_seen_ = false;
   bool regular_header_seen_ = false;
+  SpdyMajorVersion protocol_version_;
 };
 
 }  // namespace net
diff --git a/net/spdy/spdy_http_stream.cc b/net/spdy/spdy_http_stream.cc
index e823675..ea5be19 100644
--- a/net/spdy/spdy_http_stream.cc
+++ b/net/spdy/spdy_http_stream.cc
@@ -275,7 +275,8 @@ int SpdyHttpStream::SendRequest(const HttpRequestHeaders& request_headers,
   }
 
   std::unique_ptr<SpdyHeaderBlock> headers(new SpdyHeaderBlock);
-  CreateSpdyHeadersFromHttpRequest(*request_info_, request_headers, direct_,
+  CreateSpdyHeadersFromHttpRequest(*request_info_, request_headers,
+                                   stream_->GetProtocolVersion(), direct_,
                                    headers.get());
   stream_->net_log().AddEvent(
       NetLog::TYPE_HTTP_TRANSACTION_HTTP2_SEND_REQUEST_HEADERS,
@@ -319,7 +320,8 @@ SpdyResponseHeadersStatus SpdyHttpStream::OnResponseHeadersUpdated(
     response_info_ = push_response_info_.get();
   }
 
-  if (!SpdyHeadersToHttpResponse(response_headers, response_info_)) {
+  if (!SpdyHeadersToHttpResponse(
+          response_headers, stream_->GetProtocolVersion(), response_info_)) {
     // We do not have complete headers yet.
     return RESPONSE_HEADERS_ARE_INCOMPLETE;
   }
@@ -337,7 +339,7 @@ SpdyResponseHeadersStatus SpdyHttpStream::OnResponseHeadersUpdated(
       SSLClientSocket::NextProtoToString(protocol_negotiated);
   response_info_->request_time = stream_->GetRequestTime();
   response_info_->connection_info =
-      HttpResponseInfo::ConnectionInfoFromNextProto(kProtoHTTP2);
+      HttpResponseInfo::ConnectionInfoFromNextProto(stream_->GetProtocol());
   response_info_->vary_data
       .Init(*request_info_, *response_info_->headers.get());
 
diff --git a/net/spdy/spdy_http_stream_unittest.cc b/net/spdy/spdy_http_stream_unittest.cc
index 36115dc..c1c0084 100644
--- a/net/spdy/spdy_http_stream_unittest.cc
+++ b/net/spdy/spdy_http_stream_unittest.cc
@@ -22,6 +22,7 @@
 #include "net/http/http_response_headers.h"
 #include "net/http/http_response_info.h"
 #include "net/log/test_net_log.h"
+#include "net/socket/next_proto.h"
 #include "net/socket/socket_test_util.h"
 #include "net/spdy/spdy_http_utils.h"
 #include "net/spdy/spdy_session.h"
@@ -346,7 +347,7 @@ TEST_P(SpdyHttpStreamTest, LoadTimingTwoRequests) {
 }
 
 TEST_P(SpdyHttpStreamTest, SendChunkedPost) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructChunkedSpdyPost(nullptr, 0));
@@ -366,6 +367,7 @@ TEST_P(SpdyHttpStreamTest, SendChunkedPost) {
   };
 
   InitSession(reads, arraysize(reads), writes, arraysize(writes));
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
 
   ChunkedUploadDataStream upload_stream(0);
   const int kFirstChunkSize = kUploadDataSize/2;
@@ -426,6 +428,7 @@ TEST_P(SpdyHttpStreamTest, SendChunkedPostLastEmpty) {
   };
 
   InitSession(reads, arraysize(reads), writes, arraysize(writes));
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
 
   ChunkedUploadDataStream upload_stream(0);
   upload_stream.AppendData(nullptr, 0, true);
@@ -461,7 +464,7 @@ TEST_P(SpdyHttpStreamTest, SendChunkedPostLastEmpty) {
 }
 
 TEST_P(SpdyHttpStreamTest, ConnectionClosedDuringChunkedPost) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructChunkedSpdyPost(nullptr, 0));
@@ -479,6 +482,7 @@ TEST_P(SpdyHttpStreamTest, ConnectionClosedDuringChunkedPost) {
   };
 
   InitSession(reads, arraysize(reads), writes, arraysize(writes));
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
 
   ChunkedUploadDataStream upload_stream(0);
   // Append first chunk.
@@ -900,7 +904,8 @@ TEST_P(SpdyHttpStreamTest, DelayedSendChunkedPostWithWindowUpdate) {
 
   // Verify that the window size has decreased.
   ASSERT_TRUE(http_stream->stream() != nullptr);
-  EXPECT_NE(static_cast<int>(kDefaultInitialWindowSize),
+  EXPECT_NE(static_cast<int>(
+                SpdySession::GetDefaultInitialWindowSize(session_->protocol())),
             http_stream->stream()->send_window_size());
 
   // Read window update.
@@ -913,7 +918,8 @@ TEST_P(SpdyHttpStreamTest, DelayedSendChunkedPostWithWindowUpdate) {
 
   // Verify the window update.
   ASSERT_TRUE(http_stream->stream() != nullptr);
-  EXPECT_EQ(static_cast<int>(kDefaultInitialWindowSize),
+  EXPECT_EQ(static_cast<int>(
+                SpdySession::GetDefaultInitialWindowSize(session_->protocol())),
             http_stream->stream()->send_window_size());
 
   // Read rest of data.
@@ -962,6 +968,7 @@ TEST_P(SpdyHttpStreamTest, DataReadErrorSynchronous) {
   };
 
   InitSession(reads, arraysize(reads), writes, arraysize(writes));
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
 
   ReadErrorUploadDataStream upload_data_stream(
       ReadErrorUploadDataStream::FailureMode::SYNC);
@@ -1012,6 +1019,7 @@ TEST_P(SpdyHttpStreamTest, DataReadErrorAsynchronous) {
   };
 
   InitSession(reads, arraysize(reads), writes, arraysize(writes));
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
 
   ReadErrorUploadDataStream upload_data_stream(
       ReadErrorUploadDataStream::FailureMode::ASYNC);
diff --git a/net/spdy/spdy_http_utils.cc b/net/spdy/spdy_http_utils.cc
index 1213f1c..573bce1 100644
--- a/net/spdy/spdy_http_utils.cc
+++ b/net/spdy/spdy_http_utils.cc
@@ -39,13 +39,31 @@ void AddSpdyHeader(const std::string& name,
 } // namespace
 
 bool SpdyHeadersToHttpResponse(const SpdyHeaderBlock& headers,
+                               SpdyMajorVersion protocol_version,
                                HttpResponseInfo* response) {
-  // The ":status" header is required.
-  SpdyHeaderBlock::const_iterator it = headers.find(":status");
+  std::string status_key = (protocol_version >= SPDY3) ? ":status" : "status";
+  std::string version_key =
+      (protocol_version >= SPDY3) ? ":version" : "version";
+  std::string version;
+  std::string status;
+
+  // The "status" header is required. "version" is required below HTTP/2.
+  SpdyHeaderBlock::const_iterator it;
+  it = headers.find(status_key);
   if (it == headers.end())
     return false;
-  std::string status = it->second.as_string();
-  std::string raw_headers("HTTP/1.1 ");
+  status = it->second.as_string();
+
+  if (protocol_version >= HTTP2) {
+    version = "HTTP/1.1";
+  } else {
+    it = headers.find(version_key);
+    if (it == headers.end())
+      return false;
+    version = it->second.as_string();
+  }
+  std::string raw_headers(version);
+  raw_headers.push_back(' ');
   raw_headers.append(status);
   raw_headers.push_back('\0');
   for (it = headers.begin(); it != headers.end(); ++it) {
@@ -85,15 +103,34 @@ bool SpdyHeadersToHttpResponse(const SpdyHeaderBlock& headers,
 
 void CreateSpdyHeadersFromHttpRequest(const HttpRequestInfo& info,
                                       const HttpRequestHeaders& request_headers,
+                                      SpdyMajorVersion protocol_version,
                                       bool direct,
                                       SpdyHeaderBlock* headers) {
-  (*headers)[":method"] = info.method;
-  if (info.method == "CONNECT") {
-    (*headers)[":authority"] = GetHostAndPort(info.url);
-  } else {
-    (*headers)[":authority"] = GetHostAndOptionalPort(info.url);
-    (*headers)[":scheme"] = info.url.scheme();
-    (*headers)[":path"] = info.url.PathForRequest();
+  static const char kHttpProtocolVersion[] = "HTTP/1.1";
+  switch (protocol_version) {
+    case SPDY3:
+      (*headers)[":version"] = kHttpProtocolVersion;
+      (*headers)[":method"] = info.method;
+      (*headers)[":host"] = GetHostAndOptionalPort(info.url);
+      if (info.method == "CONNECT") {
+        (*headers)[":path"] = GetHostAndPort(info.url);
+      } else {
+        (*headers)[":scheme"] = info.url.scheme();
+        (*headers)[":path"] = info.url.PathForRequest();
+      }
+      break;
+    case HTTP2:
+      (*headers)[":method"] = info.method;
+      if (info.method == "CONNECT") {
+        (*headers)[":authority"] = GetHostAndPort(info.url);
+      } else {
+        (*headers)[":authority"] = GetHostAndOptionalPort(info.url);
+        (*headers)[":scheme"] = info.url.scheme();
+        (*headers)[":path"] = info.url.PathForRequest();
+      }
+      break;
+    default:
+      NOTREACHED();
   }
 
   HttpRequestHeaders::Iterator it(request_headers);
@@ -110,14 +147,23 @@ void CreateSpdyHeadersFromHttpRequest(const HttpRequestInfo& info,
 
 void CreateSpdyHeadersFromHttpResponse(
     const HttpResponseHeaders& response_headers,
+    SpdyMajorVersion protocol_version,
     SpdyHeaderBlock* headers) {
+  std::string status_key = (protocol_version >= SPDY3) ? ":status" : "status";
+  std::string version_key =
+      (protocol_version >= SPDY3) ? ":version" : "version";
+
   const std::string status_line = response_headers.GetStatusLine();
   std::string::const_iterator after_version =
       std::find(status_line.begin(), status_line.end(), ' ');
+  if (protocol_version < HTTP2) {
+    (*headers)[version_key] = std::string(status_line.begin(), after_version);
+  }
+
   // Get status code only.
   std::string::const_iterator after_status =
       std::find(after_version + 1, status_line.end(), ' ');
-  (*headers)[":status"] = std::string(after_version + 1, after_status);
+  (*headers)[status_key] = std::string(after_version + 1, after_status);
 
   size_t iter = 0;
   std::string raw_name, value;
@@ -131,14 +177,16 @@ static_assert(HIGHEST - LOWEST < 4 && HIGHEST - MINIMUM_PRIORITY < 5,
               "request priority incompatible with spdy");
 
 SpdyPriority ConvertRequestPriorityToSpdyPriority(
-    const RequestPriority priority) {
+    const RequestPriority priority,
+    SpdyMajorVersion protocol_version) {
   DCHECK_GE(priority, MINIMUM_PRIORITY);
   DCHECK_LE(priority, MAXIMUM_PRIORITY);
   return static_cast<SpdyPriority>(MAXIMUM_PRIORITY - priority);
 }
 
-NET_EXPORT_PRIVATE RequestPriority
-ConvertSpdyPriorityToRequestPriority(SpdyPriority priority) {
+NET_EXPORT_PRIVATE RequestPriority ConvertSpdyPriorityToRequestPriority(
+    SpdyPriority priority,
+    SpdyMajorVersion protocol_version) {
   // Handle invalid values gracefully.
   // Note that SpdyPriority is not an enum, hence the magic constants.
   return (priority >= 5) ?
@@ -161,14 +209,15 @@ NET_EXPORT_PRIVATE void ConvertHeaderBlockToHttpRequestHeaders(
   }
 }
 
-GURL GetUrlFromHeaderBlock(const SpdyHeaderBlock& headers) {
+GURL GetUrlFromHeaderBlock(const SpdyHeaderBlock& headers,
+                           SpdyMajorVersion protocol_version) {
   SpdyHeaderBlock::const_iterator it = headers.find(":scheme");
   if (it == headers.end())
     return GURL();
   std::string url = it->second.as_string();
   url.append("://");
 
-  it = headers.find(":authority");
+  it = headers.find(protocol_version >= HTTP2 ? ":authority" : ":host");
   if (it == headers.end())
     return GURL();
   url.append(it->second.as_string());
diff --git a/net/spdy/spdy_http_utils.h b/net/spdy/spdy_http_utils.h
index 6989ad5..b33a91a 100644
--- a/net/spdy/spdy_http_utils.h
+++ b/net/spdy/spdy_http_utils.h
@@ -26,18 +26,21 @@ class HttpResponseHeaders;
 // incomplete (e.g. missing 'status' or 'version').
 NET_EXPORT bool SpdyHeadersToHttpResponse(
     const SpdyHeaderBlock& headers,
+    SpdyMajorVersion protocol_version,
     HttpResponseInfo* response);
 
 // Create a SpdyHeaderBlock from HttpRequestInfo and HttpRequestHeaders.
 NET_EXPORT void CreateSpdyHeadersFromHttpRequest(
     const HttpRequestInfo& info,
     const HttpRequestHeaders& request_headers,
+    SpdyMajorVersion protocol_version,
     bool direct,
     SpdyHeaderBlock* headers);
 
 // Create a SpdyHeaderBlock from HttpResponseHeaders.
 NET_EXPORT void CreateSpdyHeadersFromHttpResponse(
     const HttpResponseHeaders& response_headers,
+    SpdyMajorVersion protocol_version,
     SpdyHeaderBlock* headers);
 
 // Create HttpRequestHeaders from SpdyHeaderBlock.
@@ -47,13 +50,16 @@ NET_EXPORT void ConvertHeaderBlockToHttpRequestHeaders(
 
 // Returns the URL associated with the |headers| by assembling the
 // scheme, host and path from the protocol specific keys.
-NET_EXPORT GURL GetUrlFromHeaderBlock(const SpdyHeaderBlock& headers);
+NET_EXPORT GURL GetUrlFromHeaderBlock(const SpdyHeaderBlock& headers,
+                                      SpdyMajorVersion protocol_version);
 
-NET_EXPORT SpdyPriority
-ConvertRequestPriorityToSpdyPriority(RequestPriority priority);
+NET_EXPORT SpdyPriority ConvertRequestPriorityToSpdyPriority(
+    RequestPriority priority,
+    SpdyMajorVersion protocol_version);
 
-NET_EXPORT RequestPriority
-ConvertSpdyPriorityToRequestPriority(SpdyPriority priority);
+NET_EXPORT RequestPriority ConvertSpdyPriorityToRequestPriority(
+    SpdyPriority priority,
+    SpdyMajorVersion protocol_version);
 
 }  // namespace net
 
diff --git a/net/spdy/spdy_http_utils_unittest.cc b/net/spdy/spdy_http_utils_unittest.cc
index 999a03a..a53e331 100644
--- a/net/spdy/spdy_http_utils_unittest.cc
+++ b/net/spdy/spdy_http_utils_unittest.cc
@@ -22,26 +22,43 @@ bool kDirect = true;
 }  // namespace
 
 TEST(SpdyHttpUtilsTest, ConvertRequestPriorityToSpdy3Priority) {
-  EXPECT_EQ(0, ConvertRequestPriorityToSpdyPriority(HIGHEST));
-  EXPECT_EQ(1, ConvertRequestPriorityToSpdyPriority(MEDIUM));
-  EXPECT_EQ(2, ConvertRequestPriorityToSpdyPriority(LOW));
-  EXPECT_EQ(3, ConvertRequestPriorityToSpdyPriority(LOWEST));
-  EXPECT_EQ(4, ConvertRequestPriorityToSpdyPriority(IDLE));
+  EXPECT_EQ(0, ConvertRequestPriorityToSpdyPriority(HIGHEST, SPDY3));
+  EXPECT_EQ(1, ConvertRequestPriorityToSpdyPriority(MEDIUM, SPDY3));
+  EXPECT_EQ(2, ConvertRequestPriorityToSpdyPriority(LOW, SPDY3));
+  EXPECT_EQ(3, ConvertRequestPriorityToSpdyPriority(LOWEST, SPDY3));
+  EXPECT_EQ(4, ConvertRequestPriorityToSpdyPriority(IDLE, SPDY3));
 }
 
 TEST(SpdyHttpUtilsTest, ConvertSpdy3PriorityToRequestPriority) {
-  EXPECT_EQ(HIGHEST, ConvertSpdyPriorityToRequestPriority(0));
-  EXPECT_EQ(MEDIUM, ConvertSpdyPriorityToRequestPriority(1));
-  EXPECT_EQ(LOW, ConvertSpdyPriorityToRequestPriority(2));
-  EXPECT_EQ(LOWEST, ConvertSpdyPriorityToRequestPriority(3));
-  EXPECT_EQ(IDLE, ConvertSpdyPriorityToRequestPriority(4));
+  EXPECT_EQ(HIGHEST, ConvertSpdyPriorityToRequestPriority(0, SPDY3));
+  EXPECT_EQ(MEDIUM, ConvertSpdyPriorityToRequestPriority(1, SPDY3));
+  EXPECT_EQ(LOW, ConvertSpdyPriorityToRequestPriority(2, SPDY3));
+  EXPECT_EQ(LOWEST, ConvertSpdyPriorityToRequestPriority(3, SPDY3));
+  EXPECT_EQ(IDLE, ConvertSpdyPriorityToRequestPriority(4, SPDY3));
   // These are invalid values, but we should still handle them
   // gracefully.
   for (int i = 5; i < std::numeric_limits<uint8_t>::max(); ++i) {
-    EXPECT_EQ(IDLE, ConvertSpdyPriorityToRequestPriority(i));
+    EXPECT_EQ(IDLE, ConvertSpdyPriorityToRequestPriority(i, SPDY3));
   }
 }
 
+TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestSPDY3) {
+  GURL url("https://www.google.com/index.html");
+  HttpRequestInfo request;
+  request.method = "GET";
+  request.url = url;
+  request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
+  SpdyHeaderBlock headers;
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, SPDY3,
+                                   kDirect, &headers);
+  EXPECT_EQ("GET", headers[":method"]);
+  EXPECT_EQ("https", headers[":scheme"]);
+  EXPECT_EQ("www.google.com", headers[":host"]);
+  EXPECT_EQ("/index.html", headers[":path"]);
+  EXPECT_EQ("HTTP/1.1", headers[":version"]);
+  EXPECT_EQ("Chrome/1.1", headers["user-agent"]);
+}
+
 TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestHTTP2) {
   GURL url("https://www.google.com/index.html");
   HttpRequestInfo request;
@@ -49,8 +66,8 @@ TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestHTTP2) {
   request.url = url;
   request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
   SpdyHeaderBlock headers;
-  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, kDirect,
-                                   &headers);
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, HTTP2,
+                                   kDirect, &headers);
   EXPECT_EQ("GET", headers[":method"]);
   EXPECT_EQ("https", headers[":scheme"]);
   EXPECT_EQ("www.google.com", headers[":authority"]);
@@ -59,6 +76,23 @@ TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestHTTP2) {
   EXPECT_EQ("Chrome/1.1", headers["user-agent"]);
 }
 
+TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestProxySPDY3) {
+  GURL url("https://www.google.com/index.html");
+  HttpRequestInfo request;
+  request.method = "GET";
+  request.url = url;
+  request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
+  SpdyHeaderBlock headers;
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, SPDY3,
+                                   !kDirect, &headers);
+  EXPECT_EQ("GET", headers[":method"]);
+  EXPECT_EQ("https", headers[":scheme"]);
+  EXPECT_EQ("www.google.com", headers[":host"]);
+  EXPECT_EQ("/index.html", headers[":path"]);
+  EXPECT_EQ("HTTP/1.1", headers[":version"]);
+  EXPECT_EQ("Chrome/1.1", headers["user-agent"]);
+}
+
 TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestProxyHTTP2) {
   GURL url("https://www.google.com/index.html");
   HttpRequestInfo request;
@@ -66,8 +100,8 @@ TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestProxyHTTP2) {
   request.url = url;
   request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
   SpdyHeaderBlock headers;
-  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, !kDirect,
-                                   &headers);
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, HTTP2,
+                                   !kDirect, &headers);
   EXPECT_EQ("GET", headers[":method"]);
   EXPECT_EQ("https", headers[":scheme"]);
   EXPECT_EQ("www.google.com", headers[":authority"]);
@@ -76,6 +110,23 @@ TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestProxyHTTP2) {
   EXPECT_EQ("Chrome/1.1", headers["user-agent"]);
 }
 
+TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestConnectSPDY3) {
+  GURL url("https://www.google.com/index.html");
+  HttpRequestInfo request;
+  request.method = "CONNECT";
+  request.url = url;
+  request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
+  SpdyHeaderBlock headers;
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, SPDY3,
+                                   kDirect, &headers);
+  EXPECT_EQ("CONNECT", headers[":method"]);
+  EXPECT_TRUE(headers.end() == headers.find(":scheme"));
+  EXPECT_EQ("www.google.com", headers[":host"]);
+  EXPECT_EQ("www.google.com:443", headers[":path"]);
+  EXPECT_EQ("HTTP/1.1", headers[":version"]);
+  EXPECT_EQ("Chrome/1.1", headers["user-agent"]);
+}
+
 TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestConnectHTTP2) {
   GURL url("https://www.google.com/index.html");
   HttpRequestInfo request;
@@ -83,8 +134,8 @@ TEST(SpdyHttpUtilsTest, CreateSpdyHeadersFromHttpRequestConnectHTTP2) {
   request.url = url;
   request.extra_headers.SetHeader(HttpRequestHeaders::kUserAgent, "Chrome/1.1");
   SpdyHeaderBlock headers;
-  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, kDirect,
-                                   &headers);
+  CreateSpdyHeadersFromHttpRequest(request, request.extra_headers, HTTP2,
+                                   kDirect, &headers);
   EXPECT_EQ("CONNECT", headers[":method"]);
   EXPECT_TRUE(headers.end() == headers.find(":scheme"));
   EXPECT_EQ("www.google.com:443", headers[":authority"]);
diff --git a/net/spdy/spdy_network_transaction_unittest.cc b/net/spdy/spdy_network_transaction_unittest.cc
index 9db6f78..51c6328 100644
--- a/net/spdy/spdy_network_transaction_unittest.cc
+++ b/net/spdy/spdy_network_transaction_unittest.cc
@@ -1823,7 +1823,7 @@ TEST_P(SpdyNetworkTransactionTest, DelayedChunkedPost) {
 
 // Test that a POST without any post data works.
 TEST_P(SpdyNetworkTransactionTest, NullPost) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   // Setup the request
   HttpRequestInfo request;
   request.method = "POST";
@@ -1865,7 +1865,7 @@ TEST_P(SpdyNetworkTransactionTest, NullPost) {
 
 // Test that a simple POST works.
 TEST_P(SpdyNetworkTransactionTest, EmptyPost) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   // Create an empty UploadDataStream.
   std::vector<std::unique_ptr<UploadElementReader>> element_readers;
   ElementsUploadDataStream stream(std::move(element_readers), 0);
@@ -3592,7 +3592,7 @@ TEST_P(SpdyNetworkTransactionTest, NetLog) {
 // on the network, but issued a Read for only 5 of those bytes) that the data
 // flow still works correctly.
 TEST_P(SpdyNetworkTransactionTest, BufferFull) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
@@ -3685,7 +3685,7 @@ TEST_P(SpdyNetworkTransactionTest, BufferFull) {
 // at the same time, ensure that we don't notify a read completion for
 // each data frame individually.
 TEST_P(SpdyNetworkTransactionTest, Buffering) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
@@ -3777,7 +3777,7 @@ TEST_P(SpdyNetworkTransactionTest, Buffering) {
 
 // Verify the case where we buffer data but read it after it has been buffered.
 TEST_P(SpdyNetworkTransactionTest, BufferedAll) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
@@ -3863,7 +3863,7 @@ TEST_P(SpdyNetworkTransactionTest, BufferedAll) {
 
 // Verify the case where we buffer data and close the connection.
 TEST_P(SpdyNetworkTransactionTest, BufferedClosed) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
@@ -3950,7 +3950,7 @@ TEST_P(SpdyNetworkTransactionTest, BufferedClosed) {
 
 // Verify the case where we buffer data and cancel the transaction.
 TEST_P(SpdyNetworkTransactionTest, BufferedCancelled) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
@@ -5836,10 +5836,10 @@ TEST_P(SpdyNetworkTransactionTest, WindowUpdateReceived) {
   SpdyHttpStream* stream = static_cast<SpdyHttpStream*>(trans->stream_.get());
   ASSERT_TRUE(stream);
   ASSERT_TRUE(stream->stream());
-  EXPECT_EQ(static_cast<int>(kDefaultInitialWindowSize) +
-                kDeltaWindowSize * kDeltaCount -
-                kMaxSpdyFrameChunkSize * kFrameCount,
-            stream->stream()->send_window_size());
+  EXPECT_EQ(
+      static_cast<int>(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2)) +
+          kDeltaWindowSize * kDeltaCount - kMaxSpdyFrameChunkSize * kFrameCount,
+      stream->stream()->send_window_size());
 
   data.Resume();
   base::RunLoop().RunUntilIdle();
@@ -5853,10 +5853,12 @@ TEST_P(SpdyNetworkTransactionTest, WindowUpdateReceived) {
 // Test that received data frames and sent WINDOW_UPDATE frames change
 // the recv_window_size_ correctly.
 TEST_P(SpdyNetworkTransactionTest, WindowUpdateSent) {
+  const int32_t default_initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   // Session level maximum window size that is more than twice the default
   // initial window size so that an initial window update is sent.
   const int32_t session_max_recv_window_size = 5 * 64 * 1024;
-  ASSERT_LT(2 * kDefaultInitialWindowSize, session_max_recv_window_size);
+  ASSERT_LT(2 * default_initial_window_size, session_max_recv_window_size);
   // Stream level maximum window size that is less than the session level
   // maximum window size so that we test for confusion between the two.
   const int32_t stream_max_recv_window_size = 4 * 64 * 1024;
@@ -5890,7 +5892,7 @@ TEST_P(SpdyNetworkTransactionTest, WindowUpdateSent) {
   std::unique_ptr<SpdySerializedFrame> initial_window_update(
       spdy_util_.ConstructSpdyWindowUpdate(
           kSessionFlowControlStreamId,
-          session_max_recv_window_size - kDefaultInitialWindowSize));
+          session_max_recv_window_size - default_initial_window_size));
   std::unique_ptr<SpdySerializedFrame> req(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, LOWEST, true));
   std::unique_ptr<SpdySerializedFrame> session_window_update(
@@ -6058,7 +6060,8 @@ TEST_P(SpdyNetworkTransactionTest, WindowUpdateOverflow) {
 // After that, next read is artifically enforced, which causes a
 // WINDOW_UPDATE to be read and I/O process resumes.
 TEST_P(SpdyNetworkTransactionTest, FlowControlStallResume) {
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   // Number of upload data buffers we need to send to zero out the window size
   // is the minimal number of upload buffers takes to be bigger than
   // |initial_window_size|.
@@ -6206,7 +6209,8 @@ TEST_P(SpdyNetworkTransactionTest, FlowControlStallResume) {
 // Test we correctly handle the case where the SETTINGS frame results in
 // unstalling the send window.
 TEST_P(SpdyNetworkTransactionTest, FlowControlStallResumeAfterSettings) {
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   // Number of upload data buffers we need to send to zero out the window size
   // is the minimal number of upload buffers takes to be bigger than
   // |initial_window_size|.
@@ -6371,7 +6375,8 @@ TEST_P(SpdyNetworkTransactionTest, FlowControlStallResumeAfterSettings) {
 // Test we correctly handle the case where the SETTINGS frame results in a
 // negative send window size.
 TEST_P(SpdyNetworkTransactionTest, FlowControlNegativeSendWindowSize) {
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   // Number of upload data buffers we need to send to zero out the window size
   // is the minimal number of upload buffers takes to be bigger than
   // |initial_window_size|.
diff --git a/net/spdy/spdy_proxy_client_socket.cc b/net/spdy/spdy_proxy_client_socket.cc
index 5ede104..36bdf39 100644
--- a/net/spdy/spdy_proxy_client_socket.cc
+++ b/net/spdy/spdy_proxy_client_socket.cc
@@ -365,7 +365,8 @@ int SpdyProxyClientSocket::DoSendRequest() {
                  base::Unretained(&request_.extra_headers), &request_line));
 
   std::unique_ptr<SpdyHeaderBlock> headers(new SpdyHeaderBlock());
-  CreateSpdyHeadersFromHttpRequest(request_, request_.extra_headers, true,
+  CreateSpdyHeadersFromHttpRequest(request_, request_.extra_headers,
+                                   spdy_stream_->GetProtocolVersion(), true,
                                    headers.get());
 
   return spdy_stream_->SendRequestHeaders(std::move(headers),
@@ -450,7 +451,8 @@ SpdyResponseHeadersStatus SpdyProxyClientSocket::OnResponseHeadersUpdated(
     return RESPONSE_HEADERS_ARE_COMPLETE;
 
   // Save the response
-  if (!SpdyHeadersToHttpResponse(response_headers, &response_))
+  if (!SpdyHeadersToHttpResponse(
+          response_headers, spdy_stream_->GetProtocolVersion(), &response_))
     return RESPONSE_HEADERS_ARE_INCOMPLETE;
 
   OnIOComplete(OK);
diff --git a/net/spdy/spdy_proxy_client_socket_unittest.cc b/net/spdy/spdy_proxy_client_socket_unittest.cc
index 51f024f..5e905f9 100644
--- a/net/spdy/spdy_proxy_client_socket_unittest.cc
+++ b/net/spdy/spdy_proxy_client_socket_unittest.cc
@@ -22,6 +22,7 @@
 #include "net/log/test_net_log_entry.h"
 #include "net/log/test_net_log_util.h"
 #include "net/socket/client_socket_factory.h"
+#include "net/socket/next_proto.h"
 #include "net/socket/socket_test_util.h"
 #include "net/socket/tcp_client_socket.h"
 #include "net/spdy/buffered_spdy_framer.h"
@@ -167,7 +168,7 @@ SpdyProxyClientSocketTest::SpdyProxyClientSocketTest()
     : spdy_util_(GetDependenciesFromPriority()),
       read_buf_(NULL),
       connect_data_(SYNCHRONOUS, OK),
-      framer_(),
+      framer_(HTTP2),
       user_agent_(kUserAgent),
       url_(kRequestUrl),
       proxy_host_port_(kProxyHost, kProxyPort),
diff --git a/net/spdy/spdy_session.cc b/net/spdy/spdy_session.cc
index 00fde39..217a7a7 100644
--- a/net/spdy/spdy_session.cc
+++ b/net/spdy/spdy_session.cc
@@ -61,6 +61,22 @@ const int kHungIntervalSeconds = 10;
 // Minimum seconds that unclaimed pushed streams will be kept in memory.
 const int kMinPushedStreamLifetimeSeconds = 300;
 
+std::unique_ptr<base::Value> NetLogSpdySynStreamSentCallback(
+    const SpdyHeaderBlock* headers,
+    bool fin,
+    bool unidirectional,
+    SpdyPriority spdy_priority,
+    SpdyStreamId stream_id,
+    NetLogCaptureMode capture_mode) {
+  std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
+  dict->Set("headers", ElideSpdyHeaderBlockForNetLog(*headers, capture_mode));
+  dict->SetBoolean("fin", fin);
+  dict->SetBoolean("unidirectional", unidirectional);
+  dict->SetInteger("priority", static_cast<int>(spdy_priority));
+  dict->SetInteger("stream_id", stream_id);
+  return std::move(dict);
+}
+
 std::unique_ptr<base::Value> NetLogSpdyHeadersSentCallback(
     const SpdyHeaderBlock* headers,
     bool fin,
@@ -83,6 +99,24 @@ std::unique_ptr<base::Value> NetLogSpdyHeadersSentCallback(
   return std::move(dict);
 }
 
+std::unique_ptr<base::Value> NetLogSpdySynStreamReceivedCallback(
+    const SpdyHeaderBlock* headers,
+    bool fin,
+    bool unidirectional,
+    SpdyPriority spdy_priority,
+    SpdyStreamId stream_id,
+    SpdyStreamId associated_stream,
+    NetLogCaptureMode capture_mode) {
+  std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
+  dict->Set("headers", ElideSpdyHeaderBlockForNetLog(*headers, capture_mode));
+  dict->SetBoolean("fin", fin);
+  dict->SetBoolean("unidirectional", unidirectional);
+  dict->SetInteger("priority", static_cast<int>(spdy_priority));
+  dict->SetInteger("stream_id", stream_id);
+  dict->SetInteger("associated_stream", associated_stream);
+  return std::move(dict);
+}
+
 std::unique_ptr<base::Value> NetLogSpdySynReplyOrHeadersReceivedCallback(
     const SpdyHeaderBlock* headers,
     bool fin,
@@ -116,12 +150,14 @@ std::unique_ptr<base::Value> NetLogSpdySessionCallback(
 
 std::unique_ptr<base::Value> NetLogSpdyInitializedCallback(
     NetLog::Source source,
+    const NextProto protocol_version,
     NetLogCaptureMode /* capture_mode */) {
   std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
   if (source.IsValid()) {
     source.AddToEventParameters(dict.get());
   }
-  dict->SetString("protocol", SSLClientSocket::NextProtoToString(kProtoHTTP2));
+  dict->SetString("protocol",
+                  SSLClientSocket::NextProtoToString(protocol_version));
   return std::move(dict);
 }
 
@@ -137,11 +173,13 @@ std::unique_ptr<base::Value> NetLogSpdySettingsCallback(
 
 std::unique_ptr<base::Value> NetLogSpdySettingCallback(
     SpdySettingsIds id,
+    const SpdyMajorVersion protocol_version,
     SpdySettingsFlags flags,
     uint32_t value,
     NetLogCaptureMode /* capture_mode */) {
   std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
-  dict->SetInteger("id", SpdyConstants::SerializeSettingId(HTTP2, id));
+  dict->SetInteger("id",
+                   SpdyConstants::SerializeSettingId(protocol_version, id));
   dict->SetInteger("flags", flags);
   dict->SetInteger("value", value);
   return std::move(dict);
@@ -149,6 +187,7 @@ std::unique_ptr<base::Value> NetLogSpdySettingCallback(
 
 std::unique_ptr<base::Value> NetLogSpdySendSettingsCallback(
     const SettingsMap* settings,
+    const SpdyMajorVersion protocol_version,
     NetLogCaptureMode /* capture_mode */) {
   std::unique_ptr<base::DictionaryValue> dict(new base::DictionaryValue());
   std::unique_ptr<base::ListValue> settings_list(new base::ListValue());
@@ -159,7 +198,7 @@ std::unique_ptr<base::Value> NetLogSpdySendSettingsCallback(
     const uint32_t value = it->second.second;
     settings_list->AppendString(base::StringPrintf(
         "[id:%u flags:%u value:%u]",
-        SpdyConstants::SerializeSettingId(HTTP2, id), flags, value));
+        SpdyConstants::SerializeSettingId(protocol_version, id), flags, value));
   }
   dict->Set("settings", std::move(settings_list));
   return std::move(dict);
@@ -433,6 +472,26 @@ SpdyGoAwayStatus MapNetErrorToGoAwayStatus(Error err) {
   }
 }
 
+void SplitPushedHeadersToRequestAndResponse(const SpdyHeaderBlock& headers,
+                                            SpdyMajorVersion protocol_version,
+                                            SpdyHeaderBlock* request_headers,
+                                            SpdyHeaderBlock* response_headers) {
+  DCHECK(response_headers);
+  DCHECK(request_headers);
+  for (SpdyHeaderBlock::const_iterator it = headers.begin();
+       it != headers.end();
+       ++it) {
+    SpdyHeaderBlock* to_insert = response_headers;
+    const char* host = protocol_version >= HTTP2 ? ":authority" : ":host";
+    static const char scheme[] = ":scheme";
+    static const char path[] = ":path";
+    if (it->first == host || it->first == scheme || it->first == path) {
+      to_insert = request_headers;
+    }
+    to_insert->insert(*it);
+  }
+}
+
 SpdyStreamRequest::SpdyStreamRequest() : weak_ptr_factory_(this) {
   Reset();
 }
@@ -628,6 +687,7 @@ SpdySession::SpdySession(const SpdySessionKey& spdy_session_key,
                          bool enable_sending_initial_data,
                          bool enable_ping_based_connection_checking,
                          bool enable_priority_dependencies,
+                         NextProto default_protocol,
                          size_t session_max_recv_window_size,
                          size_t stream_max_recv_window_size,
                          TimeFunc time_func,
@@ -667,17 +727,20 @@ SpdySession::SpdySession(const SpdySessionKey& spdy_session_key,
       last_activity_time_(time_func()),
       last_compressed_frame_len_(0),
       check_ping_status_pending_(false),
+      send_connection_header_prefix_(false),
       session_send_window_size_(0),
       session_max_recv_window_size_(session_max_recv_window_size),
       session_recv_window_size_(0),
       session_unacked_recv_window_bytes_(0),
-      stream_initial_send_window_size_(kDefaultInitialWindowSize),
+      stream_initial_send_window_size_(
+          GetDefaultInitialWindowSize(default_protocol)),
       stream_max_recv_window_size_(stream_max_recv_window_size),
       net_log_(BoundNetLog::Make(net_log, NetLog::SOURCE_HTTP2_SESSION)),
       verify_domain_authentication_(verify_domain_authentication),
       enable_sending_initial_data_(enable_sending_initial_data),
       enable_ping_based_connection_checking_(
           enable_ping_based_connection_checking),
+      protocol_(default_protocol),
       connection_at_risk_of_loss_time_(
           base::TimeDelta::FromSeconds(kDefaultConnectionAtRiskOfLossSeconds)),
       hung_interval_(base::TimeDelta::FromSeconds(kHungIntervalSeconds)),
@@ -685,6 +748,8 @@ SpdySession::SpdySession(const SpdySessionKey& spdy_session_key,
       time_func_(time_func),
       priority_dependencies_enabled_(enable_priority_dependencies),
       weak_factory_(this) {
+  DCHECK_GE(protocol_, kProtoSPDYMinimumVersion);
+  DCHECK_LE(protocol_, kProtoSPDYMaximumVersion);
   DCHECK(HttpStreamFactory::spdy_enabled());
   net_log_.BeginEvent(
       NetLog::TYPE_HTTP2_SESSION,
@@ -730,16 +795,33 @@ void SpdySession::InitializeWithSocket(
   is_secure_ = is_secure;
   certificate_error_code_ = certificate_error_code;
 
-  session_send_window_size_ = kDefaultInitialWindowSize;
-  session_recv_window_size_ = kDefaultInitialWindowSize;
+  NextProto protocol_negotiated =
+      connection_->socket()->GetNegotiatedProtocol();
+  if (protocol_negotiated != kProtoUnknown) {
+    protocol_ = protocol_negotiated;
+    stream_initial_send_window_size_ = GetDefaultInitialWindowSize(protocol_);
+  }
+  DCHECK_GE(protocol_, kProtoSPDYMinimumVersion);
+  DCHECK_LE(protocol_, kProtoSPDYMaximumVersion);
 
-  buffered_spdy_framer_.reset(new BufferedSpdyFramer());
+  if (protocol_ == kProtoHTTP2)
+    send_connection_header_prefix_ = true;
+
+  session_send_window_size_ = GetDefaultInitialWindowSize(protocol_);
+  session_recv_window_size_ = GetDefaultInitialWindowSize(protocol_);
+
+  buffered_spdy_framer_.reset(
+      new BufferedSpdyFramer(NextProtoToSpdyMajorVersion(protocol_)));
   buffered_spdy_framer_->set_visitor(this);
   buffered_spdy_framer_->set_debug_visitor(this);
+  UMA_HISTOGRAM_ENUMERATION(
+      "Net.SpdyVersion3", protocol_ - kProtoSPDYHistogramOffset,
+      kProtoSPDYMaximumVersion - kProtoSPDYHistogramOffset + 1);
 
-  net_log_.AddEvent(NetLog::TYPE_HTTP2_SESSION_INITIALIZED,
-                    base::Bind(&NetLogSpdyInitializedCallback,
-                               connection_->socket()->NetLog().source()));
+  net_log_.AddEvent(
+      NetLog::TYPE_HTTP2_SESSION_INITIALIZED,
+      base::Bind(&NetLogSpdyInitializedCallback,
+                 connection_->socket()->NetLog().source(), protocol_));
 
   DCHECK_EQ(availability_state_, STATE_AVAILABLE);
   connection_->AddHigherLayeredPool(this);
@@ -952,12 +1034,22 @@ void SpdySession::AddPooledAlias(const SpdySessionKey& alias_key) {
   pooled_aliases_.insert(alias_key);
 }
 
+SpdyMajorVersion SpdySession::GetProtocolVersion() const {
+  DCHECK(buffered_spdy_framer_.get());
+  return buffered_spdy_framer_->protocol_version();
+}
+
 bool SpdySession::HasAcceptableTransportSecurity() const {
   // If we're not even using TLS, we have no standards to meet.
   if (!is_secure_) {
     return true;
   }
 
+  // We don't enforce transport security standards for older SPDY versions.
+  if (GetProtocolVersion() < HTTP2) {
+    return true;
+  }
+
   SSLInfo ssl_info;
   CHECK(connection_->socket()->GetSSLInfo(&ssl_info));
 
@@ -1011,35 +1103,55 @@ std::unique_ptr<SpdySerializedFrame> SpdySession::CreateSynStream(
   SendPrefacePingIfNoneInFlight();
 
   DCHECK(buffered_spdy_framer_.get());
-  SpdyPriority spdy_priority = ConvertRequestPriorityToSpdyPriority(priority);
+  SpdyPriority spdy_priority =
+      ConvertRequestPriorityToSpdyPriority(priority, GetProtocolVersion());
 
   std::unique_ptr<SpdySerializedFrame> syn_frame;
-  bool has_priority = true;
-  int weight = Spdy3PriorityToHttp2Weight(spdy_priority);
-  SpdyStreamId dependent_stream_id = 0;
-  bool exclusive = false;
+  if (GetProtocolVersion() <= SPDY3) {
+    if (net_log().IsCapturing()) {
+      net_log().AddEvent(NetLog::TYPE_HTTP2_SESSION_SYN_STREAM,
+                         base::Bind(&NetLogSpdySynStreamSentCallback, &block,
+                                    (flags & CONTROL_FLAG_FIN) != 0,
+                                    (flags & CONTROL_FLAG_UNIDIRECTIONAL) != 0,
+                                    spdy_priority, stream_id));
+    }
 
-  if (priority_dependencies_enabled_) {
-    priority_dependency_state_.OnStreamSynSent(
-        stream_id, spdy_priority, &dependent_stream_id, &exclusive);
-  }
+    SpdySynStreamIR syn_stream(stream_id, std::move(block));
+    syn_stream.set_associated_to_stream_id(0);
+    syn_stream.set_priority(spdy_priority);
+    syn_stream.set_fin((flags & CONTROL_FLAG_FIN) != 0);
+    syn_stream.set_unidirectional((flags & CONTROL_FLAG_UNIDIRECTIONAL) != 0);
+    syn_frame.reset(new SpdySerializedFrame(
+        buffered_spdy_framer_->SerializeFrame(syn_stream)));
 
-  if (net_log().IsCapturing()) {
-    net_log().AddEvent(
-        NetLog::TYPE_HTTP2_SESSION_SEND_HEADERS,
-        base::Bind(&NetLogSpdyHeadersSentCallback, &block,
-                   (flags & CONTROL_FLAG_FIN) != 0, stream_id, has_priority,
-                   weight, dependent_stream_id, exclusive));
-  }
+  } else {
+    bool has_priority = true;
+    int weight = Spdy3PriorityToHttp2Weight(spdy_priority);
+    SpdyStreamId dependent_stream_id = 0;
+    bool exclusive = false;
+
+    if (priority_dependencies_enabled_) {
+      priority_dependency_state_.OnStreamSynSent(
+          stream_id, spdy_priority, &dependent_stream_id, &exclusive);
+    }
 
-  SpdyHeadersIR headers(stream_id, std::move(block));
-  headers.set_has_priority(has_priority);
-  headers.set_weight(weight);
-  headers.set_parent_stream_id(dependent_stream_id);
-  headers.set_exclusive(exclusive);
-  headers.set_fin((flags & CONTROL_FLAG_FIN) != 0);
-  syn_frame.reset(
-      new SpdySerializedFrame(buffered_spdy_framer_->SerializeFrame(headers)));
+    if (net_log().IsCapturing()) {
+      net_log().AddEvent(
+          NetLog::TYPE_HTTP2_SESSION_SEND_HEADERS,
+          base::Bind(&NetLogSpdyHeadersSentCallback, &block,
+                     (flags & CONTROL_FLAG_FIN) != 0, stream_id, has_priority,
+                     weight, dependent_stream_id, exclusive));
+    }
+
+    SpdyHeadersIR headers(stream_id, std::move(block));
+    headers.set_has_priority(has_priority);
+    headers.set_weight(weight);
+    headers.set_parent_stream_id(dependent_stream_id);
+    headers.set_exclusive(exclusive);
+    headers.set_fin((flags & CONTROL_FLAG_FIN) != 0);
+    syn_frame.reset(new SpdySerializedFrame(
+        buffered_spdy_framer_->SerializeFrame(headers)));
+  }
 
   streams_initiated_count_++;
 
@@ -2114,13 +2226,15 @@ void SpdySession::OnSettings(bool clear_persisted) {
                                  clear_persisted));
   }
 
-  // Send an acknowledgment of the setting.
-  SpdySettingsIR settings_ir;
-  settings_ir.set_is_ack(true);
-  EnqueueSessionWrite(
-      HIGHEST, SETTINGS,
-      std::unique_ptr<SpdySerializedFrame>(new SpdySerializedFrame(
-          buffered_spdy_framer_->SerializeFrame(settings_ir))));
+  if (GetProtocolVersion() >= HTTP2) {
+    // Send an acknowledgment of the setting.
+    SpdySettingsIR settings_ir;
+    settings_ir.set_is_ack(true);
+    EnqueueSessionWrite(
+        HIGHEST, SETTINGS,
+        std::unique_ptr<SpdySerializedFrame>(new SpdySerializedFrame(
+            buffered_spdy_framer_->SerializeFrame(settings_ir))));
+  }
 }
 
 void SpdySession::OnSetting(SpdySettingsIds id, uint8_t flags, uint32_t value) {
@@ -2132,8 +2246,9 @@ void SpdySession::OnSetting(SpdySettingsIds id, uint8_t flags, uint32_t value) {
   received_settings_ = true;
 
   // Log the setting.
+  const SpdyMajorVersion protocol_version = GetProtocolVersion();
   net_log_.AddEvent(NetLog::TYPE_HTTP2_SESSION_RECV_SETTING,
-                    base::Bind(&NetLogSpdySettingCallback, id,
+                    base::Bind(&NetLogSpdySettingCallback, id, protocol_version,
                                static_cast<SpdySettingsFlags>(flags), value));
 }
 
@@ -2199,6 +2314,47 @@ int SpdySession::OnInitialResponseHeadersReceived(
   return rv;
 }
 
+void SpdySession::OnSynStream(SpdyStreamId stream_id,
+                              SpdyStreamId associated_stream_id,
+                              SpdyPriority priority,
+                              bool fin,
+                              bool unidirectional,
+                              const SpdyHeaderBlock& headers) {
+  CHECK(in_io_loop_);
+
+  DCHECK_LE(GetProtocolVersion(), SPDY3);
+
+  base::Time response_time = base::Time::Now();
+  base::TimeTicks recv_first_byte_time = time_func_();
+
+  if (net_log_.IsCapturing()) {
+    net_log_.AddEvent(
+        NetLog::TYPE_HTTP2_SESSION_PUSHED_SYN_STREAM,
+        base::Bind(&NetLogSpdySynStreamReceivedCallback, &headers, fin,
+                   unidirectional, priority, stream_id, associated_stream_id));
+  }
+
+  // Split headers to simulate push promise and response.
+  SpdyHeaderBlock request_headers;
+  SpdyHeaderBlock response_headers;
+  SplitPushedHeadersToRequestAndResponse(
+      headers, GetProtocolVersion(), &request_headers, &response_headers);
+
+  if (!TryCreatePushStream(
+          stream_id, associated_stream_id, priority, request_headers))
+    return;
+
+  ActiveStreamMap::iterator active_it = active_streams_.find(stream_id);
+  if (active_it == active_streams_.end()) {
+    NOTREACHED();
+    return;
+  }
+
+  OnInitialResponseHeadersReceived(response_headers, response_time,
+                                   recv_first_byte_time,
+                                   active_it->second.stream);
+}
+
 void SpdySession::DeleteExpiredPushedStreams() {
   if (unclaimed_pushed_streams_.empty())
     return;
@@ -2236,6 +2392,51 @@ void SpdySession::DeleteExpiredPushedStreams() {
       base::TimeDelta::FromSeconds(kMinPushedStreamLifetimeSeconds);
 }
 
+void SpdySession::OnSynReply(SpdyStreamId stream_id,
+                             bool fin,
+                             const SpdyHeaderBlock& headers) {
+  CHECK(in_io_loop_);
+
+  base::Time response_time = base::Time::Now();
+  base::TimeTicks recv_first_byte_time = time_func_();
+
+  if (net_log().IsCapturing()) {
+    net_log().AddEvent(NetLog::TYPE_HTTP2_SESSION_SYN_REPLY,
+                       base::Bind(&NetLogSpdySynReplyOrHeadersReceivedCallback,
+                                  &headers, fin, stream_id));
+  }
+
+  ActiveStreamMap::iterator it = active_streams_.find(stream_id);
+  if (it == active_streams_.end()) {
+    // NOTE:  it may just be that the stream was cancelled.
+    return;
+  }
+
+  SpdyStream* stream = it->second.stream;
+  CHECK_EQ(stream->stream_id(), stream_id);
+
+  stream->AddRawReceivedBytes(last_compressed_frame_len_);
+  last_compressed_frame_len_ = 0;
+
+  if (GetProtocolVersion() >= HTTP2) {
+    const std::string& error = "HTTP/2 wasn't expecting SYN_REPLY.";
+    stream->LogStreamError(ERR_SPDY_PROTOCOL_ERROR, error);
+    ResetStreamIterator(it, RST_STREAM_PROTOCOL_ERROR, error);
+    return;
+  }
+  if (!it->second.waiting_for_syn_reply) {
+    const std::string& error =
+        "Received duplicate SYN_REPLY for stream.";
+    stream->LogStreamError(ERR_SPDY_PROTOCOL_ERROR, error);
+    ResetStreamIterator(it, RST_STREAM_PROTOCOL_ERROR, error);
+    return;
+  }
+  it->second.waiting_for_syn_reply = false;
+
+  ignore_result(OnInitialResponseHeadersReceived(
+      headers, response_time, recv_first_byte_time, stream));
+}
+
 void SpdySession::OnHeaders(SpdyStreamId stream_id,
                             bool has_priority,
                             int weight,
@@ -2268,6 +2469,14 @@ void SpdySession::OnHeaders(SpdyStreamId stream_id,
   base::TimeTicks recv_first_byte_time = time_func_();
 
   if (it->second.waiting_for_syn_reply) {
+    if (GetProtocolVersion() < HTTP2) {
+      const std::string& error =
+          "Was expecting SYN_REPLY, not HEADERS.";
+      stream->LogStreamError(ERR_SPDY_PROTOCOL_ERROR, error);
+      ResetStreamIterator(it, RST_STREAM_PROTOCOL_ERROR, error);
+      return;
+    }
+
     it->second.waiting_for_syn_reply = false;
     ignore_result(OnInitialResponseHeadersReceived(
         headers, response_time, recv_first_byte_time, stream));
@@ -2425,7 +2634,8 @@ void SpdySession::OnPing(SpdyPingId unique_id, bool is_ack) {
       base::Bind(&NetLogSpdyPingCallback, unique_id, is_ack, "received"));
 
   // Send response to a PING from server.
-  if (!is_ack) {
+  if ((protocol_ == kProtoHTTP2 && !is_ack) ||
+      (protocol_ < kProtoHTTP2 && unique_id % 2 == 0)) {
     WritePingFrame(unique_id, true);
     return;
   }
@@ -2521,8 +2731,9 @@ bool SpdySession::TryCreatePushStream(SpdyStreamId stream_id,
   }
 
   if (IsStreamActive(stream_id)) {
-    // We should not get here, we'll start going away earlier on
-    // |last_seen_push_stream_id_| check.
+    // For SPDY3 and higher we should not get here, we'll start going away
+    // earlier on |last_seen_push_stream_id_| check.
+    CHECK_GT(SPDY3, GetProtocolVersion());
     LOG(WARNING) << "Received push for active stream " << stream_id;
     return false;
   }
@@ -2530,7 +2741,7 @@ bool SpdySession::TryCreatePushStream(SpdyStreamId stream_id,
   last_accepted_push_stream_id_ = stream_id;
 
   RequestPriority request_priority =
-      ConvertSpdyPriorityToRequestPriority(priority);
+      ConvertSpdyPriorityToRequestPriority(priority, GetProtocolVersion());
 
   if (availability_state_ == STATE_GOING_AWAY) {
     // TODO(akalin): This behavior isn't in the SPDY spec, although it
@@ -2545,6 +2756,7 @@ bool SpdySession::TryCreatePushStream(SpdyStreamId stream_id,
   if (associated_stream_id == 0) {
     // In HTTP/2 0 stream id in PUSH_PROMISE frame leads to framer error and
     // session going away. We should never get here.
+    CHECK_GT(HTTP2, GetProtocolVersion());
     std::string description = base::StringPrintf(
         "Received invalid associated stream id %d for pushed stream %d",
         associated_stream_id,
@@ -2559,7 +2771,7 @@ bool SpdySession::TryCreatePushStream(SpdyStreamId stream_id,
   // TODO(mbelshe): DCHECK that this is a GET method?
 
   // Verify that the response had a URL for us.
-  GURL gurl = GetUrlFromHeaderBlock(headers);
+  GURL gurl = GetUrlFromHeaderBlock(headers, GetProtocolVersion());
   if (!gurl.is_valid()) {
     EnqueueResetStreamFrame(stream_id,
                             request_priority,
@@ -2648,7 +2860,7 @@ bool SpdySession::TryCreatePushStream(SpdyStreamId stream_id,
   stream->set_stream_id(stream_id);
 
   // In spdy4/http2 PUSH_PROMISE arrives on associated stream.
-  if (associated_it != active_streams_.end()) {
+  if (associated_it != active_streams_.end() && GetProtocolVersion() >= HTTP2) {
     associated_it->second.stream->AddRawReceivedBytes(
         last_compressed_frame_len_);
   } else {
@@ -2706,13 +2918,16 @@ void SpdySession::SendStreamWindowUpdate(SpdyStreamId stream_id,
 void SpdySession::SendInitialData() {
   DCHECK(enable_sending_initial_data_);
 
-  std::unique_ptr<SpdySerializedFrame> connection_header_prefix_frame(
-      new SpdySerializedFrame(const_cast<char*>(kHttp2ConnectionHeaderPrefix),
-                              kHttp2ConnectionHeaderPrefixSize,
-                              false /* take_ownership */));
-  // Count the prefix as part of the subsequent SETTINGS frame.
-  EnqueueSessionWrite(HIGHEST, SETTINGS,
-                      std::move(connection_header_prefix_frame));
+  if (send_connection_header_prefix_) {
+    DCHECK_EQ(protocol_, kProtoHTTP2);
+    std::unique_ptr<SpdySerializedFrame> connection_header_prefix_frame(
+        new SpdySerializedFrame(const_cast<char*>(kHttp2ConnectionHeaderPrefix),
+                                kHttp2ConnectionHeaderPrefixSize,
+                                false /* take_ownership */));
+    // Count the prefix as part of the subsequent SETTINGS frame.
+    EnqueueSessionWrite(HIGHEST, SETTINGS,
+                        std::move(connection_header_prefix_frame));
+  }
 
   // First, notify the server about the settings they should use when
   // communicating with us.
@@ -2721,7 +2936,7 @@ void SpdySession::SendInitialData() {
   // max concurrent streams and initial window size.
   settings_map[SETTINGS_MAX_CONCURRENT_STREAMS] =
       SettingsFlagsAndValue(SETTINGS_FLAG_NONE, kMaxConcurrentPushedStreams);
-  if (stream_max_recv_window_size_ != kDefaultInitialWindowSize) {
+  if (stream_max_recv_window_size_ != GetDefaultInitialWindowSize(protocol_)) {
     settings_map[SETTINGS_INITIAL_WINDOW_SIZE] =
         SettingsFlagsAndValue(SETTINGS_FLAG_NONE, stream_max_recv_window_size_);
   }
@@ -2739,11 +2954,38 @@ void SpdySession::SendInitialData() {
     IncreaseRecvWindowSize(session_max_recv_window_size_ -
                            session_recv_window_size_);
   }
+
+  if (protocol_ == kProtoSPDY31) {
+    // Finally, notify the server about the settings they have
+    // previously told us to use when communicating with them (after
+    // applying them).
+    const SettingsMap& server_settings_map =
+        http_server_properties_->GetSpdySettings(GetServer());
+    if (server_settings_map.empty())
+      return;
+
+    SettingsMap::const_iterator it =
+        server_settings_map.find(SETTINGS_CURRENT_CWND);
+    uint32_t cwnd = (it != server_settings_map.end()) ? it->second.second : 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS("Net.SpdySettingsCwndSent", cwnd, 1, 200, 100);
+
+    for (SettingsMap::const_iterator it = server_settings_map.begin();
+         it != server_settings_map.end(); ++it) {
+      const SpdySettingsIds new_id = it->first;
+      const uint32_t new_val = it->second.second;
+      HandleSetting(new_id, new_val);
+    }
+
+    SendSettings(server_settings_map);
+  }
 }
 
+
 void SpdySession::SendSettings(const SettingsMap& settings) {
-  net_log_.AddEvent(NetLog::TYPE_HTTP2_SESSION_SEND_SETTINGS,
-                    base::Bind(&NetLogSpdySendSettingsCallback, &settings));
+  const SpdyMajorVersion protocol_version = GetProtocolVersion();
+  net_log_.AddEvent(
+      NetLog::TYPE_HTTP2_SESSION_SEND_SETTINGS,
+      base::Bind(&NetLogSpdySendSettingsCallback, &settings, protocol_version));
   // Create the SETTINGS frame and send it.
   DCHECK(buffered_spdy_framer_.get());
   std::unique_ptr<SpdySerializedFrame> settings_frame(
diff --git a/net/spdy/spdy_session.h b/net/spdy/spdy_session.h
index 6a0e22d..8f781a5 100644
--- a/net/spdy/spdy_session.h
+++ b/net/spdy/spdy_session.h
@@ -59,10 +59,6 @@ const int kMss = 1430;
 // The 8 is the size of the SPDY frame header.
 const int kMaxSpdyFrameChunkSize = (2 * kMss) - 8;
 
-// Default value of SETTINGS_INITIAL_WINDOW_SIZE per protocol specification.
-// A session is always created with this initial window size.
-const int32_t kDefaultInitialWindowSize = 65535;
-
 // Maximum number of concurrent streams we will create, unless the server
 // sends a SETTINGS frame with a different value.
 const size_t kInitialMaxConcurrentStreams = 100;
@@ -152,6 +148,14 @@ static_assert(17 == SpdyFramer::LAST_ERROR,
 static_assert(17 == RST_STREAM_NUM_STATUS_CODES,
               "SpdyProtocolErrorDetails / RstStreamStatus mismatch");
 
+// Splits pushed |headers| into request and response parts. Request headers are
+// the headers specifying resource URL.
+void NET_EXPORT_PRIVATE
+    SplitPushedHeadersToRequestAndResponse(const SpdyHeaderBlock& headers,
+                                           SpdyMajorVersion protocol_version,
+                                           SpdyHeaderBlock* request_headers,
+                                           SpdyHeaderBlock* response_headers);
+
 // A helper class used to manage a request to create a stream.
 class NET_EXPORT_PRIVATE SpdyStreamRequest {
  public:
@@ -295,6 +299,7 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
               bool enable_sending_initial_data,
               bool enable_ping_based_connection_checking,
               bool enable_priority_dependencies,
+              NextProto default_protocol,
               size_t session_max_recv_window_size,
               size_t stream_max_recv_window_size,
               TimeFunc time_func,
@@ -344,6 +349,10 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
                             bool is_secure,
                             int certificate_error_code);
 
+  // Returns the protocol used by this session. Always between
+  // kProtoSPDYMinimumVersion and kProtoSPDYMaximumVersion.
+  NextProto protocol() const { return protocol_; }
+
   // Check to see if this SPDY session can support an additional domain.
   // If the session is un-authenticated, then this call always returns true.
   // For SSL-based sessions, verifies that the server certificate in use by
@@ -522,6 +531,8 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
     return pooled_aliases_;
   }
 
+  SpdyMajorVersion GetProtocolVersion() const;
+
   size_t GetDataFrameMinimumSize() const {
     return buffered_spdy_framer_->GetDataFrameMinimumSize();
   }
@@ -542,6 +553,12 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
     return buffered_spdy_framer_->GetDataFrameMaximumPayload();
   }
 
+  // Default value of SETTINGS_INITIAL_WINDOW_SIZE per protocol specification.
+  // A session is always created with this initial window size.
+  static int32_t GetDefaultInitialWindowSize(NextProto protocol) {
+    return protocol < kProtoHTTP2 ? 65536 : 65535;
+  }
+
   // https://http2.github.io/http2-spec/#TLSUsage mandates minimum security
   // standards for TLS.
   bool HasAcceptableTransportSecurity() const;
@@ -876,6 +893,15 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
   void OnPushPromise(SpdyStreamId stream_id,
                      SpdyStreamId promised_stream_id,
                      const SpdyHeaderBlock& headers) override;
+  void OnSynStream(SpdyStreamId stream_id,
+                   SpdyStreamId associated_stream_id,
+                   SpdyPriority priority,
+                   bool fin,
+                   bool unidirectional,
+                   const SpdyHeaderBlock& headers) override;
+  void OnSynReply(SpdyStreamId stream_id,
+                  bool fin,
+                  const SpdyHeaderBlock& headers) override;
   void OnHeaders(SpdyStreamId stream_id,
                  bool has_priority,
                  int weight,
@@ -1126,6 +1152,9 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
   // status.
   bool check_ping_status_pending_;
 
+  // Whether to send the (HTTP/2) connection header prefix.
+  bool send_connection_header_prefix_;
+
   // Current send window size.  Zero unless session flow control is turned on.
   int32_t session_send_window_size_;
 
@@ -1168,6 +1197,10 @@ class NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,
   bool enable_sending_initial_data_;
   bool enable_ping_based_connection_checking_;
 
+  // The SPDY protocol used. Always between kProtoSPDYMinimumVersion and
+  // kProtoSPDYMaximumVersion.
+  NextProto protocol_;
+
   // |connection_at_risk_of_loss_time_| is an optimization to avoid sending
   // wasteful preface pings (when we just got some data).
   //
diff --git a/net/spdy/spdy_session_pool.cc b/net/spdy/spdy_session_pool.cc
index c91157a..dfac110 100644
--- a/net/spdy/spdy_session_pool.cc
+++ b/net/spdy/spdy_session_pool.cc
@@ -38,6 +38,7 @@ SpdySessionPool::SpdySessionPool(
     TransportSecurityState* transport_security_state,
     bool enable_ping_based_connection_checking,
     bool enable_priority_dependencies,
+    NextProto default_protocol,
     size_t session_max_recv_window_size,
     size_t stream_max_recv_window_size,
     SpdySessionPool::TimeFunc time_func,
@@ -51,10 +52,16 @@ SpdySessionPool::SpdySessionPool(
       enable_ping_based_connection_checking_(
           enable_ping_based_connection_checking),
       enable_priority_dependencies_(enable_priority_dependencies),
+      // TODO(akalin): Force callers to have a valid value of
+      // |default_protocol_|.
+      default_protocol_((default_protocol == kProtoUnknown) ? kProtoSPDY31
+                                                            : default_protocol),
       session_max_recv_window_size_(session_max_recv_window_size),
       stream_max_recv_window_size_(stream_max_recv_window_size),
       time_func_(time_func),
       proxy_delegate_(proxy_delegate) {
+  DCHECK(default_protocol_ >= kProtoSPDYMinimumVersion &&
+         default_protocol_ <= kProtoSPDYMaximumVersion);
   NetworkChangeNotifier::AddIPAddressObserver(this);
   if (ssl_config_service_.get())
     ssl_config_service_->AddObserver(this);
@@ -83,6 +90,8 @@ base::WeakPtr<SpdySession> SpdySessionPool::CreateAvailableSessionFromSocket(
     int certificate_error_code,
     bool is_secure) {
   TRACE_EVENT0("net", "SpdySessionPool::CreateAvailableSessionFromSocket");
+  DCHECK_GE(default_protocol_, kProtoSPDYMinimumVersion);
+  DCHECK_LE(default_protocol_, kProtoSPDYMaximumVersion);
 
   UMA_HISTOGRAM_ENUMERATION(
       "Net.SpdySessionGet", IMPORTED_FROM_SOCKET, SPDY_SESSION_GET_MAX);
@@ -91,8 +100,9 @@ base::WeakPtr<SpdySession> SpdySessionPool::CreateAvailableSessionFromSocket(
       key, http_server_properties_, transport_security_state_,
       verify_domain_authentication_, enable_sending_initial_data_,
       enable_ping_based_connection_checking_, enable_priority_dependencies_,
-      session_max_recv_window_size_, stream_max_recv_window_size_, time_func_,
-      proxy_delegate_, net_log.net_log()));
+      default_protocol_, session_max_recv_window_size_,
+      stream_max_recv_window_size_, time_func_, proxy_delegate_,
+      net_log.net_log()));
 
   new_session->InitializeWithSocket(std::move(connection), this, is_secure,
                                     certificate_error_code);
diff --git a/net/spdy/spdy_session_pool.h b/net/spdy/spdy_session_pool.h
index 77d318d..bdcb03b 100644
--- a/net/spdy/spdy_session_pool.h
+++ b/net/spdy/spdy_session_pool.h
@@ -23,6 +23,7 @@
 #include "net/cert/cert_database.h"
 #include "net/proxy/proxy_config.h"
 #include "net/proxy/proxy_server.h"
+#include "net/socket/next_proto.h"
 #include "net/spdy/spdy_session_key.h"
 #include "net/ssl/ssl_config_service.h"
 
@@ -45,12 +46,16 @@ class NET_EXPORT SpdySessionPool
  public:
   typedef base::TimeTicks (*TimeFunc)(void);
 
+  // |default_protocol| may be kProtoUnknown (e.g., if SPDY is
+  // disabled), in which case it's set to a default value. Otherwise,
+  // it must be a SPDY protocol.
   SpdySessionPool(HostResolver* host_resolver,
                   SSLConfigService* ssl_config_service,
                   HttpServerProperties* http_server_properties,
                   TransportSecurityState* transport_security_state,
                   bool enable_ping_based_connection_checking,
                   bool enable_priority_dependencies,
+                  NextProto default_protocol,
                   size_t session_max_recv_window_size,
                   size_t stream_max_recv_window_size,
                   SpdySessionPool::TimeFunc time_func,
@@ -66,7 +71,8 @@ class NET_EXPORT SpdySessionPool
   // processing existing streams.
 
   // Create a new SPDY session from an existing socket.  There must
-  // not already be a session for the given key.
+  // not already be a session for the given key. This pool must have
+  // been constructed with a valid |default_protocol| value.
   //
   // |is_secure| can be false for testing or when SPDY is configured
   // to work with non-secure sockets. If |is_secure| is true,
@@ -222,6 +228,7 @@ class NET_EXPORT SpdySessionPool
   bool enable_sending_initial_data_;
   bool enable_ping_based_connection_checking_;
   const bool enable_priority_dependencies_;
+  const NextProto default_protocol_;
   size_t session_max_recv_window_size_;
   size_t stream_max_recv_window_size_;
   TimeFunc time_func_;
diff --git a/net/spdy/spdy_session_pool_unittest.cc b/net/spdy/spdy_session_pool_unittest.cc
index 46aca38..eaeda2d 100644
--- a/net/spdy/spdy_session_pool_unittest.cc
+++ b/net/spdy/spdy_session_pool_unittest.cc
@@ -27,7 +27,8 @@ using net::test::IsOk;
 
 namespace net {
 
-class SpdySessionPoolTest : public ::testing::Test {
+class SpdySessionPoolTest : public ::testing::Test,
+                            public ::testing::WithParamInterface<NextProto> {
  protected:
   // Used by RunIPPoolingTest().
   enum SpdyPoolCloseSessionsType {
diff --git a/net/spdy/spdy_session_unittest.cc b/net/spdy/spdy_session_unittest.cc
index a1f2406..28feb84 100644
--- a/net/spdy/spdy_session_unittest.cc
+++ b/net/spdy/spdy_session_unittest.cc
@@ -25,6 +25,7 @@
 #include "net/log/test_net_log_util.h"
 #include "net/proxy/proxy_server.h"
 #include "net/socket/client_socket_pool_manager.h"
+#include "net/socket/next_proto.h"
 #include "net/socket/socket_test_util.h"
 #include "net/spdy/spdy_http_utils.h"
 #include "net/spdy/spdy_session_pool.h"
@@ -329,6 +330,8 @@ TEST_P(SpdySessionTest, GoAwayWithNoActiveStreams) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   EXPECT_TRUE(HasSpdySession(spdy_session_pool_, key_));
 
   // Read and process the GOAWAY frame.
@@ -388,6 +391,8 @@ TEST_P(SpdySessionTest, GoAwayWithActiveStreams) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream1 = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate1(spdy_stream1);
@@ -459,6 +464,8 @@ TEST_P(SpdySessionTest, GoAwayWithActiveAndCreatedStream) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream1 = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate1(spdy_stream1);
@@ -524,6 +531,8 @@ TEST_P(SpdySessionTest, GoAwayTwice) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream1 = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate1(spdy_stream1);
@@ -597,6 +606,8 @@ TEST_P(SpdySessionTest, GoAwayWithActiveStreamsThenClose) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream1 = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate1(spdy_stream1);
@@ -731,6 +742,8 @@ TEST_P(SpdySessionTest, CreateStreamAfterGoAway) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate(spdy_stream);
@@ -793,6 +806,8 @@ TEST_P(SpdySessionTest, SynStreamAfterGoAway) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate(spdy_stream);
@@ -842,6 +857,8 @@ TEST_P(SpdySessionTest, NetworkChangeWithActiveStreams) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
+  EXPECT_EQ(HTTP2, session_->GetProtocolVersion());
+
   base::WeakPtr<SpdyStream> spdy_stream = CreateStreamSynchronously(
       SPDY_REQUEST_RESPONSE_STREAM, session_, test_url_, MEDIUM, BoundNetLog());
   test::StreamDelegateDoNothing delegate(spdy_stream);
@@ -1353,8 +1370,9 @@ TEST_P(SpdySessionTest, DeleteExpiredPushStreams) {
                     GURL("https://www.example.org/a.dat")));
 
   // Unclaimed push body consumed bytes from the session window.
-  EXPECT_EQ(kDefaultInitialWindowSize - kUploadDataSize,
-            session_->session_recv_window_size_);
+  EXPECT_EQ(
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2) - kUploadDataSize,
+      session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
 
   // Shift time to expire the push stream. Read the second SYN_STREAM,
@@ -1369,7 +1387,8 @@ TEST_P(SpdySessionTest, DeleteExpiredPushStreams) {
                     GURL("https://www.example.org/0.dat")));
 
   // Verify that the session window reclaimed the evicted stream body.
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(kUploadDataSize, session_->session_unacked_recv_window_bytes_);
 
   // Read and process EOF.
@@ -2567,7 +2586,7 @@ TEST_P(SpdySessionTest, ReadDataWithoutYielding) {
   session_deps_.host_resolver->set_synchronous_mode(true);
   session_deps_.time_func = InstantaneousReads;
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -2654,7 +2673,7 @@ TEST_P(SpdySessionTest, TestYieldingSlowReads) {
   session_deps_.host_resolver->set_synchronous_mode(true);
   session_deps_.time_func = SlowReads;
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -2715,7 +2734,7 @@ TEST_P(SpdySessionTest, TestYieldingSlowSynchronousReads) {
   session_deps_.host_resolver->set_synchronous_mode(true);
   session_deps_.time_func = SlowReads;
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -2783,7 +2802,7 @@ TEST_P(SpdySessionTest, TestYieldingDuringReadData) {
   session_deps_.host_resolver->set_synchronous_mode(true);
   session_deps_.time_func = InstantaneousReads;
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -2877,7 +2896,7 @@ TEST_P(SpdySessionTest, TestYieldingDuringAsyncReadData) {
   session_deps_.host_resolver->set_synchronous_mode(true);
   session_deps_.time_func = InstantaneousReads;
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -2976,7 +2995,7 @@ TEST_P(SpdySessionTest, TestYieldingDuringAsyncReadData) {
 TEST_P(SpdySessionTest, GoAwayWhileInDoReadLoop) {
   session_deps_.host_resolver->set_synchronous_mode(true);
 
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
 
   std::unique_ptr<SpdySerializedFrame> req1(
       spdy_util_.ConstructSpdyGet(nullptr, 0, 1, MEDIUM, true));
@@ -3046,8 +3065,11 @@ TEST_P(SpdySessionTest, ProtocolNegotiation) {
   CreateNetworkSession();
   session_ = CreateFakeSpdySession(spdy_session_pool_, key_);
 
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_send_window_size_);
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(HTTP2, session_->buffered_spdy_framer_->protocol_version());
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_send_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
 }
 
@@ -3446,7 +3468,8 @@ TEST_P(SpdySessionTest, UpdateStreamsSendWindowSize) {
 TEST_P(SpdySessionTest, AdjustRecvWindowSize) {
   session_deps_.host_resolver->set_synchronous_mode(true);
 
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   const int32_t delta_window_size = 100;
 
   MockRead reads[] = {
@@ -3510,7 +3533,8 @@ TEST_P(SpdySessionTest, AdjustSendWindowSize) {
   CreateNetworkSession();
   session_ = CreateFakeSpdySession(spdy_session_pool_, key_);
 
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   const int32_t delta_window_size = 100;
 
   EXPECT_EQ(initial_window_size, session_->session_send_window_size_);
@@ -3542,12 +3566,14 @@ TEST_P(SpdySessionTest, SessionFlowControlInactiveStream) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
 
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(kUploadDataSize, session_->session_unacked_recv_window_bytes_);
 
   EXPECT_TRUE(session_);
@@ -3575,12 +3601,14 @@ TEST_P(SpdySessionTest, SessionFlowControlPadding) {
   CreateNetworkSession();
   CreateInsecureSpdySession();
 
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
 
   base::RunLoop().RunUntilIdle();
 
-  EXPECT_EQ(kDefaultInitialWindowSize, session_->session_recv_window_size_);
+  EXPECT_EQ(SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2),
+            session_->session_recv_window_size_);
   EXPECT_EQ(kUploadDataSize + padding_length,
             session_->session_unacked_recv_window_bytes_);
 
@@ -3868,7 +3896,8 @@ TEST_P(SpdySessionTest, SessionFlowControlNoReceiveLeaks) {
             stream->SendRequestHeaders(std::move(headers), MORE_DATA_TO_SEND));
   EXPECT_TRUE(stream->HasUrlFromHeaders());
 
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   EXPECT_EQ(initial_window_size, session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
 
@@ -3933,7 +3962,8 @@ TEST_P(SpdySessionTest, SessionFlowControlNoSendLeaks) {
             stream->SendRequestHeaders(std::move(headers), MORE_DATA_TO_SEND));
   EXPECT_TRUE(stream->HasUrlFromHeaders());
 
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   EXPECT_EQ(initial_window_size, session_->session_send_window_size_);
 
   // Write request.
@@ -4017,7 +4047,8 @@ TEST_P(SpdySessionTest, SessionFlowControlEndToEnd) {
             stream->SendRequestHeaders(std::move(headers), MORE_DATA_TO_SEND));
   EXPECT_TRUE(stream->HasUrlFromHeaders());
 
-  const int32_t initial_window_size = kDefaultInitialWindowSize;
+  const int32_t initial_window_size =
+      SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2);
   EXPECT_EQ(initial_window_size, session_->session_send_window_size_);
   EXPECT_EQ(initial_window_size, session_->session_recv_window_size_);
   EXPECT_EQ(0, session_->session_unacked_recv_window_bytes_);
@@ -4628,6 +4659,27 @@ TEST_P(SpdySessionTest, GoAwayOnSessionFlowControlError) {
   EXPECT_FALSE(session_);
 }
 
+TEST_P(SpdySessionTest, SplitHeaders) {
+  GURL kStreamUrl("https://www.example.org/foo.dat");
+  SpdyHeaderBlock headers;
+  spdy_util_.AddUrlToHeaderBlock(kStreamUrl.spec(), &headers);
+  headers["alpha"] = "beta";
+
+  SpdyHeaderBlock request_headers;
+  SpdyHeaderBlock response_headers;
+
+  SplitPushedHeadersToRequestAndResponse(headers, HTTP2, &request_headers,
+                                         &response_headers);
+
+  SpdyHeaderBlock::const_iterator it = response_headers.find("alpha");
+  std::string alpha_val =
+      (it == response_headers.end()) ? std::string() : it->second.as_string();
+  EXPECT_EQ("beta", alpha_val);
+
+  GURL request_url = GetUrlFromHeaderBlock(request_headers, HTTP2);
+  EXPECT_EQ(kStreamUrl, request_url);
+}
+
 // Regression. Sorta. Push streams and client streams were sharing a single
 // limit for a long time.
 TEST_P(SpdySessionTest, PushedStreamShouldNotCountToClientConcurrencyLimit) {
diff --git a/net/spdy/spdy_stream.cc b/net/spdy/spdy_stream.cc
index 170804e..09083a0 100644
--- a/net/spdy/spdy_stream.cc
+++ b/net/spdy/spdy_stream.cc
@@ -631,6 +631,10 @@ int SpdyStream::OnDataSent(size_t frame_size) {
   }
 }
 
+SpdyMajorVersion SpdyStream::GetProtocolVersion() const {
+  return session_->GetProtocolVersion();
+}
+
 void SpdyStream::LogStreamError(int status, const std::string& description) {
   net_log_.AddEvent(NetLog::TYPE_HTTP2_STREAM_ERROR,
                     base::Bind(&NetLogSpdyStreamErrorCallback, stream_id_,
@@ -751,6 +755,10 @@ bool SpdyStream::IsReservedRemote() const {
   return io_state_ == STATE_RESERVED_REMOTE;
 }
 
+NextProto SpdyStream::GetProtocol() const {
+  return session_->protocol();
+}
+
 void SpdyStream::AddRawReceivedBytes(size_t received_bytes) {
   raw_received_bytes_ += received_bytes;
 }
@@ -777,7 +785,7 @@ GURL SpdyStream::GetUrlFromHeaders() const {
   if (!request_headers_)
     return GURL();
 
-  return GetUrlFromHeaderBlock(*request_headers_);
+  return GetUrlFromHeaderBlock(*request_headers_, GetProtocolVersion());
 }
 
 bool SpdyStream::HasUrlFromHeaders() const {
diff --git a/net/spdy/spdy_stream.h b/net/spdy/spdy_stream.h
index 142a62a..499372a 100644
--- a/net/spdy/spdy_stream.h
+++ b/net/spdy/spdy_stream.h
@@ -417,6 +417,10 @@ class NET_EXPORT_PRIVATE SpdyStream {
   // yet.
   bool IsReservedRemote() const;
 
+  // Returns the protocol used by this stream. Always between
+  // kProtoSPDYMinimumVersion and kProtoSPDYMaximumVersion.
+  NextProto GetProtocol() const;
+
   int response_status() const { return response_status_; }
 
   void AddRawReceivedBytes(size_t received_bytes);
@@ -441,6 +445,8 @@ class NET_EXPORT_PRIVATE SpdyStream {
   // TODO(akalin): Remove this, as it's only used in tests.
   bool HasUrlFromHeaders() const;
 
+  SpdyMajorVersion GetProtocolVersion() const;
+
  private:
   class SynStreamBufferProducer;
   class HeaderBufferProducer;
diff --git a/net/spdy/spdy_stream_unittest.cc b/net/spdy/spdy_stream_unittest.cc
index 307ff5e..da28ade 100644
--- a/net/spdy/spdy_stream_unittest.cc
+++ b/net/spdy/spdy_stream_unittest.cc
@@ -21,6 +21,7 @@
 #include "net/log/test_net_log.h"
 #include "net/log/test_net_log_entry.h"
 #include "net/log/test_net_log_util.h"
+#include "net/socket/next_proto.h"
 #include "net/socket/socket_test_util.h"
 #include "net/spdy/buffered_spdy_framer.h"
 #include "net/spdy/spdy_http_utils.h"
@@ -1118,7 +1119,8 @@ TEST_P(SpdyStreamTest, ReceivedBytes) {
   EXPECT_EQ(kStreamUrl, stream->GetUrlFromHeaders().spec());
 
   int64_t reply_frame_len = reply->size();
-  int64_t data_header_len = SpdyConstants::GetDataFrameMinimumSize(HTTP2);
+  int64_t data_header_len = SpdyConstants::GetDataFrameMinimumSize(
+      NextProtoToSpdyMajorVersion(kProtoHTTP2));
   int64_t data_frame_len = data_header_len + kPostBodyLength;
   int64_t response_len = reply_frame_len + data_frame_len;
 
diff --git a/net/spdy/spdy_test_util_common.cc b/net/spdy/spdy_test_util_common.cc
index 65698ee..8287c62 100644
--- a/net/spdy/spdy_test_util_common.cc
+++ b/net/spdy/spdy_test_util_common.cc
@@ -188,6 +188,17 @@ class PriorityGetter : public BufferedSpdyFramerVisitorInterface {
   void OnError(SpdyFramer::SpdyError error_code) override {}
   void OnStreamError(SpdyStreamId stream_id,
                      const std::string& description) override {}
+  void OnSynStream(SpdyStreamId stream_id,
+                   SpdyStreamId associated_stream_id,
+                   SpdyPriority priority,
+                   bool fin,
+                   bool unidirectional,
+                   const SpdyHeaderBlock& headers) override {
+    priority_ = priority;
+  }
+  void OnSynReply(SpdyStreamId stream_id,
+                  bool fin,
+                  const SpdyHeaderBlock& headers) override {}
   void OnHeaders(SpdyStreamId stream_id,
                  bool has_priority,
                  int weight,
@@ -234,7 +245,7 @@ class PriorityGetter : public BufferedSpdyFramerVisitorInterface {
 }  // namespace
 
 bool GetSpdyPriority(const SpdySerializedFrame& frame, SpdyPriority* priority) {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   PriorityGetter priority_getter;
   framer.set_visitor(&priority_getter);
   size_t frame_size = frame.size();
@@ -340,8 +351,10 @@ SpdySessionDependencies::SpdySessionDependencies(
       enable_user_alternate_protocol_ports(false),
       enable_priority_dependencies(true),
       enable_quic(false),
-      session_max_recv_window_size(kDefaultInitialWindowSize),
-      stream_max_recv_window_size(kDefaultInitialWindowSize),
+      session_max_recv_window_size(
+          SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2)),
+      stream_max_recv_window_size(
+          SpdySession::GetDefaultInitialWindowSize(kProtoHTTP2)),
       time_func(&base::TimeTicks::Now),
       enable_http2_alternative_service_with_different_host(false),
       net_log(NULL) {
@@ -391,6 +404,7 @@ HttpNetworkSession::Params SpdySessionDependencies::CreateSessionParams(
   params.enable_priority_dependencies =
       session_deps->enable_priority_dependencies;
   params.enable_quic = session_deps->enable_quic;
+  params.spdy_default_protocol = kProtoHTTP2;
   params.spdy_session_max_recv_window_size =
       session_deps->session_max_recv_window_size;
   params.spdy_stream_max_recv_window_size =
@@ -425,6 +439,7 @@ SpdyURLRequestContext::SpdyURLRequestContext() : storage_(this) {
   params.ssl_config_service = ssl_config_service();
   params.http_auth_handler_factory = http_auth_handler_factory();
   params.enable_spdy_ping_based_connection_checking = false;
+  params.spdy_default_protocol = kProtoHTTP2;
   params.http_server_properties = http_server_properties();
   storage_.set_http_network_session(
       base::WrapUnique(new HttpNetworkSession(params)));
@@ -693,7 +708,7 @@ SpdyHeaderBlock SpdyTestUtil::ConstructPutHeaderBlock(
 SpdySerializedFrame* SpdyTestUtil::ConstructSpdyFrame(
     const SpdyHeaderInfo& header_info,
     SpdyHeaderBlock headers) const {
-  BufferedSpdyFramer framer;
+  BufferedSpdyFramer framer(HTTP2);
   SpdySerializedFrame* frame = NULL;
   switch (header_info.kind) {
     case DATA:
@@ -981,7 +996,7 @@ SpdySerializedFrame* SpdyTestUtil::ConstructSpdySyn(int stream_id,
   SpdyHeadersIR headers(stream_id, std::move(block));
   headers.set_has_priority(true);
   headers.set_weight(Spdy3PriorityToHttp2Weight(
-      ConvertRequestPriorityToSpdyPriority(priority)));
+      ConvertRequestPriorityToSpdyPriority(priority, HTTP2)));
   if (dependency_priorities_) {
     headers.set_parent_stream_id(parent_stream_id);
     headers.set_exclusive(true);
@@ -1159,7 +1174,7 @@ SpdyHeaderBlock SpdyTestUtil::ConstructHeaderBlock(
 
 void SpdyTestUtil::SetPriority(RequestPriority priority,
                                SpdySynStreamIR* ir) const {
-  ir->set_priority(ConvertRequestPriorityToSpdyPriority(priority));
+  ir->set_priority(ConvertRequestPriorityToSpdyPriority(priority, HTTP2));
 }
 
 }  // namespace net
diff --git a/net/tools/flip_server/sm_connection.cc b/net/tools/flip_server/sm_connection.cc
index fb2d6cc..9c232f9 100644
--- a/net/tools/flip_server/sm_connection.cc
+++ b/net/tools/flip_server/sm_connection.cc
@@ -304,7 +304,8 @@ void SMConnection::HandleEvents() {
 }
 
 // Decide if SPDY was negotiated.
-bool SMConnection::WasSpdyNegotiated() {
+bool SMConnection::WasSpdyNegotiated(SpdyMajorVersion* version_negotiated) {
+  *version_negotiated = SPDY3;
   if (force_spdy())
     return true;
 
@@ -320,11 +321,13 @@ bool SMConnection::WasSpdyNegotiated() {
       if (!strncmp(reinterpret_cast<const char*>(npn_proto),
                    "spdy/3",
                    npn_proto_len)) {
+        *version_negotiated = SPDY3;
         return true;
       }
       if (!strncmp(reinterpret_cast<const char*>(npn_proto),
                    "spdy/4a2",
                    npn_proto_len)) {
+        *version_negotiated = HTTP2;
         return true;
       }
     }
@@ -337,7 +340,8 @@ bool SMConnection::SetupProtocolInterfaces() {
   DCHECK(!protocol_detected_);
   protocol_detected_ = true;
 
-  bool spdy_negotiated = WasSpdyNegotiated();
+  SpdyMajorVersion version;
+  bool spdy_negotiated = WasSpdyNegotiated(&version);
   bool using_ssl = ssl_ != NULL;
 
   if (using_ssl)
@@ -383,10 +387,10 @@ bool SMConnection::SetupProtocolInterfaces() {
               << (sm_spdy_interface_ ? "Creating" : "Reusing")
               << " SPDY interface.";
       if (sm_spdy_interface_)
-        sm_spdy_interface_->CreateFramer();
+        sm_spdy_interface_->CreateFramer(version);
       else
-        sm_spdy_interface_ =
-            new SpdySM(this, NULL, epoll_server_, memory_cache_, acceptor_);
+        sm_spdy_interface_ = new SpdySM(
+            this, NULL, epoll_server_, memory_cache_, acceptor_, version);
       sm_interface_ = sm_spdy_interface_;
       break;
     }
diff --git a/net/tools/flip_server/sm_connection.h b/net/tools/flip_server/sm_connection.h
index 189344a..b586a18 100644
--- a/net/tools/flip_server/sm_connection.h
+++ b/net/tools/flip_server/sm_connection.h
@@ -99,7 +99,7 @@ class SMConnection : public SMConnectionInterface,
 
  private:
   // Decide if SPDY was negotiated.
-  bool WasSpdyNegotiated();
+  bool WasSpdyNegotiated(SpdyMajorVersion* version_negotiated);
 
   // Initialize the protocol interfaces we'll need for this connection.
   // Returns true if successful, false otherwise.
diff --git a/net/tools/flip_server/spdy_interface.cc b/net/tools/flip_server/spdy_interface.cc
index 10cf7d4..247cc2c 100644
--- a/net/tools/flip_server/spdy_interface.cc
+++ b/net/tools/flip_server/spdy_interface.cc
@@ -38,8 +38,9 @@ SpdySM::SpdySM(SMConnection* connection,
                SMInterface* sm_http_interface,
                EpollServer* epoll_server,
                MemoryCache* memory_cache,
-               FlipAcceptor* acceptor)
-    : buffered_spdy_framer_(new BufferedSpdyFramer()),
+               FlipAcceptor* acceptor,
+               SpdyMajorVersion spdy_version)
+    : buffered_spdy_framer_(new BufferedSpdyFramer(spdy_version)),
       valid_spdy_session_(false),
       connection_(connection),
       client_output_list_(connection->output_list()),
@@ -239,6 +240,50 @@ void SpdySM::OnStreamPadding(SpdyStreamId stream_id, size_t len) {
           << ", [" << len << "])";
 }
 
+void SpdySM::OnSynStream(SpdyStreamId stream_id,
+                         SpdyStreamId associated_stream_id,
+                         SpdyPriority priority,
+                         bool fin,
+                         bool unidirectional,
+                         const SpdyHeaderBlock& headers) {
+  std::string http_data;
+  bool is_https_scheme;
+  int ret = SpdyHandleNewStream(
+      stream_id, priority, headers, http_data, &is_https_scheme);
+  if (!ret) {
+    LOG(ERROR) << "SpdySM: Could not convert spdy into http.";
+    return;
+  }
+  // We've seen a valid looking SYN_STREAM, consider this to have
+  // been a real spdy session.
+  valid_spdy_session_ = true;
+
+  if (acceptor_->flip_handler_type_ == FLIP_HANDLER_PROXY) {
+    std::string server_ip;
+    std::string server_port;
+    if (is_https_scheme) {
+      server_ip = acceptor_->https_server_ip_;
+      server_port = acceptor_->https_server_port_;
+    } else {
+      server_ip = acceptor_->http_server_ip_;
+      server_port = acceptor_->http_server_port_;
+    }
+    SMInterface* sm_http_interface =
+        FindOrMakeNewSMConnectionInterface(server_ip, server_port);
+    stream_to_smif_[stream_id] = sm_http_interface;
+    sm_http_interface->SetStreamID(stream_id);
+    sm_http_interface->ProcessWriteInput(http_data.c_str(), http_data.size());
+  }
+}
+
+void SpdySM::OnSynReply(SpdyStreamId stream_id,
+                        bool fin,
+                        const SpdyHeaderBlock& headers) {
+  // TODO(willchan): if there is an error parsing headers, we
+  // should send a RST_STREAM.
+  VLOG(2) << ACCEPTOR_CLIENT_IDENT << "SpdySM: OnSynReply(" << stream_id << ")";
+}
+
 void SpdySM::OnHeaders(SpdyStreamId stream_id,
                        bool has_priority,
                        int weight,
@@ -562,9 +607,9 @@ void SpdySM::GetOutput() {
   }
 }
 
-void SpdySM::CreateFramer() {
+void SpdySM::CreateFramer(SpdyMajorVersion spdy_version) {
   DCHECK(!buffered_spdy_framer_);
-  buffered_spdy_framer_.reset(new BufferedSpdyFramer());
+  buffered_spdy_framer_.reset(new BufferedSpdyFramer(spdy_version));
   buffered_spdy_framer_->set_visitor(this);
 }
 
diff --git a/net/tools/flip_server/spdy_interface.h b/net/tools/flip_server/spdy_interface.h
index 3860b20..33f3abf 100644
--- a/net/tools/flip_server/spdy_interface.h
+++ b/net/tools/flip_server/spdy_interface.h
@@ -34,7 +34,8 @@ class SpdySM : public BufferedSpdyFramerVisitorInterface, public SMInterface {
          SMInterface* sm_http_interface,
          EpollServer* epoll_server,
          MemoryCache* memory_cache,
-         FlipAcceptor* acceptor);
+         FlipAcceptor* acceptor,
+         SpdyMajorVersion spdy_version);
   ~SpdySM() override;
 
   void InitSMInterface(SMInterface* sm_http_interface,
@@ -50,7 +51,7 @@ class SpdySM : public BufferedSpdyFramerVisitorInterface, public SMInterface {
                         bool use_ssl) override;
 
   // Create new SPDY framer after reusing SpdySM and negotiating new version
-  void CreateFramer();
+  void CreateFramer(SpdyMajorVersion spdy_version);
 
  private:
   void set_is_request() override {}
@@ -69,6 +70,18 @@ class SpdySM : public BufferedSpdyFramerVisitorInterface, public SMInterface {
   void OnError(SpdyFramer::SpdyError error_code) override {}
   void OnStreamError(SpdyStreamId stream_id,
                      const std::string& description) override {}
+  // Called after all the header data for SYN_STREAM control frame is received.
+  void OnSynStream(SpdyStreamId stream_id,
+                   SpdyStreamId associated_stream_id,
+                   SpdyPriority priority,
+                   bool fin,
+                   bool unidirectional,
+                   const SpdyHeaderBlock& headers) override;
+
+  // Called after all the header data for SYN_REPLY control frame is received.
+  void OnSynReply(SpdyStreamId stream_id,
+                  bool fin,
+                  const SpdyHeaderBlock& headers) override;
 
   // Called after all the header data for HEADERS control frame is received.
   void OnHeaders(SpdyStreamId stream_id,
@@ -178,6 +191,10 @@ class SpdySM : public BufferedSpdyFramerVisitorInterface, public SMInterface {
   static void set_forward_ip_header(const std::string& value) {
     forward_ip_header_ = value;
   }
+  SpdyMajorVersion spdy_version() const {
+    DCHECK(buffered_spdy_framer_);
+    return buffered_spdy_framer_->protocol_version();
+  }
 
  private:
   void SendEOFImpl(uint32_t stream_id);
diff --git a/net/tools/flip_server/spdy_interface_test.cc b/net/tools/flip_server/spdy_interface_test.cc
index 2931865..a62da42 100644
--- a/net/tools/flip_server/spdy_interface_test.cc
+++ b/net/tools/flip_server/spdy_interface_test.cc
@@ -50,6 +50,31 @@ class SpdyFramerVisitor : public BufferedSpdyFramerVisitorInterface {
   MOCK_METHOD1(OnError, void(SpdyFramer::SpdyError));
   MOCK_METHOD2(OnStreamError, void(SpdyStreamId, const std::string&));
   // SaveArg cannot be used on non-copyable types like SpdyHeaderBlock.
+  void OnSynStream(SpdyStreamId stream_id,
+                   SpdyStreamId associated_stream_id,
+                   SpdyPriority priority,
+                   bool fin,
+                   bool unidirectional,
+                   const SpdyHeaderBlock& headers) override {
+    actual_header_block_ = headers.Clone();
+    OnSynStreamMock(stream_id, associated_stream_id, priority, fin,
+                    unidirectional, headers);
+  }
+  MOCK_METHOD6(OnSynStreamMock,
+               void(SpdyStreamId,
+                    SpdyStreamId,
+                    SpdyPriority,
+                    bool,
+                    bool,
+                    const SpdyHeaderBlock&));
+  void OnSynReply(SpdyStreamId stream_id,
+                  bool fin,
+                  const SpdyHeaderBlock& headers) override {
+    actual_header_block_ = headers.Clone();
+    OnSynReplyMock(stream_id, fin, headers);
+  }
+  MOCK_METHOD3(OnSynReplyMock,
+               void(SpdyStreamId, bool, const SpdyHeaderBlock&));
   void OnHeaders(SpdyStreamId stream_id,
                  bool has_priority,
                  int weight,
@@ -128,18 +153,20 @@ class TestSpdySM : public SpdySM {
              SMInterface* sm_http_interface,
              EpollServer* epoll_server,
              MemoryCache* memory_cache,
-             FlipAcceptor* acceptor)
+             FlipAcceptor* acceptor,
+             SpdyMajorVersion version)
       : SpdySM(connection,
                sm_http_interface,
                epoll_server,
                memory_cache,
-               acceptor) {}
+               acceptor,
+               version) {}
 
   MOCK_METHOD2(FindOrMakeNewSMConnectionInterface,
                SMInterface*(const std::string&, const std::string&));
 };
 
-class SpdySMTestBase : public ::testing::Test {
+class SpdySMTestBase : public ::testing::TestWithParam<SpdyMajorVersion> {
  public:
   explicit SpdySMTestBase(FlipHandlerType type) {
     SSLState* ssl_state = NULL;
@@ -168,16 +195,19 @@ class SpdySMTestBase : public ::testing::Test {
                                            acceptor_.get(),
                                            "log_prefix"));
 
-    interface_.reset(new TestSpdySM(
-        connection_.get(), mock_another_interface_.get(), epoll_server_.get(),
-        memory_cache_.get(), acceptor_.get()));
+    interface_.reset(new TestSpdySM(connection_.get(),
+                                    mock_another_interface_.get(),
+                                    epoll_server_.get(),
+                                    memory_cache_.get(),
+                                    acceptor_.get(),
+                                    GetParam()));
 
-    spdy_framer_.reset(new BufferedSpdyFramer());
+    spdy_framer_.reset(new BufferedSpdyFramer(GetParam()));
     spdy_framer_visitor_.reset(new SpdyFramerVisitor);
     spdy_framer_->set_visitor(spdy_framer_visitor_.get());
   }
 
-  ~SpdySMTestBase() override {
+  virtual ~SpdySMTestBase() {
     if (acceptor_->listen_fd_ >= 0) {
       epoll_server_->UnregisterFD(acceptor_->listen_fd_);
       close(acceptor_->listen_fd_);
@@ -210,16 +240,19 @@ class SpdySMTestBase : public ::testing::Test {
 class SpdySMProxyTest : public SpdySMTestBase {
  public:
   SpdySMProxyTest() : SpdySMTestBase(FLIP_HANDLER_PROXY) {}
-  ~SpdySMProxyTest() override {}
+  virtual ~SpdySMProxyTest() {}
 };
 
 class SpdySMServerTest : public SpdySMTestBase {
  public:
   SpdySMServerTest() : SpdySMTestBase(FLIP_HANDLER_SPDY_SERVER) {}
-  ~SpdySMServerTest() override {}
+  virtual ~SpdySMServerTest() {}
 };
 
-TEST_F(SpdySMProxyTest, InitSMConnection) {
+INSTANTIATE_TEST_CASE_P(SpdySMProxyTest, SpdySMProxyTest, Values(SPDY3, HTTP2));
+INSTANTIATE_TEST_CASE_P(SpdySMServerTest, SpdySMServerTest, Values(HTTP2));
+
+TEST_P(SpdySMProxyTest, InitSMConnection) {
   {
     InSequence s;
     EXPECT_CALL(*connection_, InitSMConnection(_, _, _, _, _, _, _, _));
@@ -228,7 +261,39 @@ TEST_F(SpdySMProxyTest, InitSMConnection) {
       NULL, NULL, epoll_server_.get(), -1, "", "", "", false);
 }
 
-TEST_F(SpdySMProxyTest, OnRstStream) {
+TEST_P(SpdySMProxyTest, OnStreamFrameData) {
+  BufferedSpdyFramerVisitorInterface* visitor = interface_.get();
+  std::unique_ptr<MockSMInterface> mock_interface(new MockSMInterface);
+  uint32_t stream_id = 92;
+  uint32_t associated_id = 43;
+  SpdyHeaderBlock block;
+  testing::MockFunction<void(int)> checkpoint;  // NOLINT
+
+  std::unique_ptr<SpdySerializedFrame> frame(
+      spdy_framer_->CreatePingFrame(12, false));
+  block[":method"] = "GET";
+  block[":host"] = "www.example.com";
+  block[":path"] = "/path";
+  block[":scheme"] = "http";
+  block["foo"] = "bar";
+  {
+    InSequence s;
+    EXPECT_CALL(*interface_,
+                FindOrMakeNewSMConnectionInterface(_, _))
+        .WillOnce(Return(mock_interface.get()));
+    EXPECT_CALL(*mock_interface, SetStreamID(stream_id));
+    EXPECT_CALL(*mock_interface, ProcessWriteInput(_, _)).Times(1);
+    EXPECT_CALL(checkpoint, Call(0));
+    EXPECT_CALL(*mock_interface,
+                ProcessWriteInput(frame->data(), frame->size())).Times(1);
+  }
+
+  visitor->OnSynStream(stream_id, associated_id, 0, false, false, block);
+  checkpoint.Call(0);
+  visitor->OnStreamFrameData(stream_id, frame->data(), frame->size());
+}
+
+TEST_P(SpdySMProxyTest, OnRstStream) {
   BufferedSpdyFramerVisitorInterface* visitor = interface_.get();
   uint32_t stream_id = 82;
   MemCacheIter mci;
@@ -247,7 +312,7 @@ TEST_F(SpdySMProxyTest, OnRstStream) {
   ASSERT_FALSE(HasStream(stream_id));
 }
 
-TEST_F(SpdySMProxyTest, ProcessReadInput) {
+TEST_P(SpdySMProxyTest, ProcessReadInput) {
   ASSERT_EQ(SpdyFramer::SPDY_READY_FOR_FRAME,
             interface_->spdy_framer()->state());
   interface_->ProcessReadInput("", 1);
@@ -255,7 +320,7 @@ TEST_F(SpdySMProxyTest, ProcessReadInput) {
             interface_->spdy_framer()->state());
 }
 
-TEST_F(SpdySMProxyTest, ResetForNewConnection) {
+TEST_P(SpdySMProxyTest, ResetForNewConnection) {
   uint32_t stream_id = 13;
   MemCacheIter mci;
   mci.stream_id = stream_id;
@@ -280,13 +345,19 @@ TEST_F(SpdySMProxyTest, ResetForNewConnection) {
   ASSERT_TRUE(interface_->spdy_framer() == NULL);
 }
 
-TEST_F(SpdySMProxyTest, CreateFramer) {
+TEST_P(SpdySMProxyTest, CreateFramer) {
   interface_->ResetForNewConnection();
-  interface_->CreateFramer();
-  ASSERT_TRUE(interface_->spdy_framer());
+  interface_->CreateFramer(SPDY3);
+  ASSERT_TRUE(interface_->spdy_framer() != NULL);
+  ASSERT_EQ(interface_->spdy_version(), SPDY3);
+
+  interface_->ResetForNewConnection();
+  interface_->CreateFramer(HTTP2);
+  ASSERT_TRUE(interface_->spdy_framer() != NULL);
+  ASSERT_EQ(interface_->spdy_version(), HTTP2);
 }
 
-TEST_F(SpdySMProxyTest, PostAcceptHook) {
+TEST_P(SpdySMProxyTest, PostAcceptHook) {
   interface_->PostAcceptHook();
 
   ASSERT_EQ(1u, connection_->output_list()->size());
@@ -302,13 +373,13 @@ TEST_F(SpdySMProxyTest, PostAcceptHook) {
   spdy_framer_->ProcessInput(df->data, df->size);
 }
 
-TEST_F(SpdySMProxyTest, NewStream) {
+TEST_P(SpdySMProxyTest, NewStream) {
   // TODO(yhirano): SpdySM::NewStream leads to crash when
   // acceptor_->flip_handler_type_ != FLIP_HANDLER_SPDY_SERVER.
   // It should be fixed though I don't know the solution now.
 }
 
-TEST_F(SpdySMProxyTest, AddToOutputOrder) {
+TEST_P(SpdySMProxyTest, AddToOutputOrder) {
   uint32_t stream_id = 13;
   MemCacheIter mci;
   mci.stream_id = stream_id;
@@ -324,7 +395,7 @@ TEST_F(SpdySMProxyTest, AddToOutputOrder) {
   ASSERT_TRUE(HasStream(stream_id));
 }
 
-TEST_F(SpdySMProxyTest, SendErrorNotFound) {
+TEST_P(SpdySMProxyTest, SendErrorNotFound) {
   uint32_t stream_id = 82;
   const char* actual_data;
   size_t actual_size;
@@ -336,9 +407,13 @@ TEST_F(SpdySMProxyTest, SendErrorNotFound) {
 
   {
     InSequence s;
+    if (GetParam() < HTTP2) {
+      EXPECT_CALL(*spdy_framer_visitor_, OnSynReplyMock(stream_id, false, _));
+    } else {
       EXPECT_CALL(*spdy_framer_visitor_,
                   OnHeadersMock(stream_id, /*has_priority=*/false, _, _, _,
                                 /*fin=*/false, _));
+    }
     EXPECT_CALL(checkpoint, Call(0));
     EXPECT_CALL(*spdy_framer_visitor_,
                 OnDataFrameHeader(stream_id, _, true));
@@ -364,7 +439,37 @@ TEST_F(SpdySMProxyTest, SendErrorNotFound) {
   ASSERT_EQ("wtf?", StringPiece(actual_data, actual_size));
 }
 
-TEST_F(SpdySMProxyTest, SendSynReply) {
+TEST_P(SpdySMProxyTest, SendSynStream) {
+  uint32_t stream_id = 82;
+  BalsaHeaders headers;
+  headers.AppendHeader("key1", "value1");
+  headers.AppendHeader("Host", "www.example.com");
+  headers.SetRequestFirstlineFromStringPieces("GET", "/path", "HTTP/1.1");
+
+  interface_->SendSynStream(stream_id, headers);
+
+  ASSERT_EQ(1u, connection_->output_list()->size());
+  std::list<DataFrame*>::const_iterator i = connection_->output_list()->begin();
+  DataFrame* df = *i++;
+
+  {
+    InSequence s;
+    EXPECT_CALL(*spdy_framer_visitor_,
+                OnSynStreamMock(stream_id, 0, _, false, false, _));
+  }
+
+  spdy_framer_->ProcessInput(df->data, df->size);
+  ASSERT_EQ(1, spdy_framer_->frames_received());
+  ASSERT_EQ(5u, spdy_framer_visitor_->actual_header_block_.size());
+  ASSERT_EQ("GET", spdy_framer_visitor_->actual_header_block_[":method"]);
+  ASSERT_EQ("HTTP/1.1", spdy_framer_visitor_->actual_header_block_[":version"]);
+  ASSERT_EQ("/path", spdy_framer_visitor_->actual_header_block_[":path"]);
+  ASSERT_EQ("www.example.com",
+            spdy_framer_visitor_->actual_header_block_[":host"]);
+  ASSERT_EQ("value1", spdy_framer_visitor_->actual_header_block_["key1"]);
+}
+
+TEST_P(SpdySMProxyTest, SendSynReply) {
   uint32_t stream_id = 82;
   BalsaHeaders headers;
   headers.AppendHeader("key1", "value1");
@@ -378,9 +483,13 @@ TEST_F(SpdySMProxyTest, SendSynReply) {
 
   {
     InSequence s;
+    if (GetParam() < HTTP2) {
+      EXPECT_CALL(*spdy_framer_visitor_, OnSynReplyMock(stream_id, false, _));
+    } else {
       EXPECT_CALL(*spdy_framer_visitor_,
                   OnHeadersMock(stream_id, /*has_priority=*/false, _, _, _,
                                 /*fin=*/false, _));
+    }
   }
 
   spdy_framer_->ProcessInput(df->data, df->size);
@@ -391,7 +500,7 @@ TEST_F(SpdySMProxyTest, SendSynReply) {
   ASSERT_EQ("value1", spdy_framer_visitor_->actual_header_block_["key1"]);
 }
 
-TEST_F(SpdySMProxyTest, SendDataFrame) {
+TEST_P(SpdySMProxyTest, SendDataFrame) {
   uint32_t stream_id = 133;
   SpdyDataFlags flags = DATA_FLAG_NONE;
   const char* actual_data;
@@ -416,7 +525,7 @@ TEST_F(SpdySMProxyTest, SendDataFrame) {
   ASSERT_EQ("hello", StringPiece(actual_data, actual_size));
 }
 
-TEST_F(SpdySMProxyTest, SendLongDataFrame) {
+TEST_P(SpdySMProxyTest, SendLongDataFrame) {
   uint32_t stream_id = 133;
   SpdyDataFlags flags = DATA_FLAG_NONE;
   const char* actual_data;
@@ -454,7 +563,24 @@ TEST_F(SpdySMProxyTest, SendLongDataFrame) {
   ASSERT_EQ("c", StringPiece(actual_data, actual_size));
 }
 
-TEST_F(SpdySMServerTest, NewStream) {
+TEST_P(SpdySMServerTest, OnSynStream) {
+  BufferedSpdyFramerVisitorInterface* visitor = interface_.get();
+  uint32_t stream_id = 82;
+  SpdyHeaderBlock spdy_headers;
+  spdy_headers["url"] = "http://www.example.com/path";
+  spdy_headers["method"] = "GET";
+  spdy_headers["scheme"] = "http";
+  spdy_headers["version"] = "HTTP/1.1";
+
+  {
+    BalsaHeaders headers;
+    memory_cache_->InsertFile(&headers, "GET_/path", "");
+  }
+  visitor->OnSynStream(stream_id, 0, 0, true, true, spdy_headers);
+  ASSERT_TRUE(HasStream(stream_id));
+}
+
+TEST_P(SpdySMServerTest, NewStream) {
   uint32_t stream_id = 13;
   std::string filename = "foobar";
 
@@ -467,7 +593,7 @@ TEST_F(SpdySMServerTest, NewStream) {
   ASSERT_TRUE(HasStream(stream_id));
 }
 
-TEST_F(SpdySMServerTest, NewStreamError) {
+TEST_P(SpdySMServerTest, NewStreamError) {
   uint32_t stream_id = 82;
   const char* actual_data;
   size_t actual_size;
@@ -479,9 +605,13 @@ TEST_F(SpdySMServerTest, NewStreamError) {
 
   {
     InSequence s;
+    if (GetParam() < HTTP2) {
+      EXPECT_CALL(*spdy_framer_visitor_, OnSynReplyMock(stream_id, false, _));
+    } else {
       EXPECT_CALL(*spdy_framer_visitor_,
                   OnHeadersMock(stream_id, /*has_priority=*/false, _, _, _,
                                 /*fin=*/false, _));
+    }
     EXPECT_CALL(checkpoint, Call(0));
     EXPECT_CALL(*spdy_framer_visitor_,
                 OnDataFrameHeader(stream_id, _, true));
diff --git a/net/tools/quic/quic_in_memory_cache.cc b/net/tools/quic/quic_in_memory_cache.cc
index 4a5f7d5..3b2f9e0 100644
--- a/net/tools/quic/quic_in_memory_cache.cc
+++ b/net/tools/quic/quic_in_memory_cache.cc
@@ -69,7 +69,7 @@ class ResourceFileImpl : public net::QuicInMemoryCache::ResourceFile {
     body_ = StringPiece(file_contents_.data() + headers_end,
                         file_contents_.size() - headers_end);
 
-    CreateSpdyHeadersFromHttpResponse(*http_headers_, &spdy_headers_);
+    CreateSpdyHeadersFromHttpResponse(*http_headers_, HTTP2, &spdy_headers_);
   }
 
  private:
diff --git a/net/tools/quic/quic_simple_client.cc b/net/tools/quic/quic_simple_client.cc
index 4ca05f6..68ed15d 100644
--- a/net/tools/quic/quic_simple_client.cc
+++ b/net/tools/quic/quic_simple_client.cc
@@ -257,8 +257,8 @@ void QuicSimpleClient::SendRequest(const HttpRequestInfo& headers,
     return;
   }
   SpdyHeaderBlock header_block;
-  CreateSpdyHeadersFromHttpRequest(headers, headers.extra_headers, true,
-                                   &header_block);
+  CreateSpdyHeadersFromHttpRequest(headers, headers.extra_headers, net::HTTP2,
+                                   true, &header_block);
   stream->set_visitor(this);
   stream->SendRequest(std::move(header_block), body, fin);
   if (FLAGS_enable_quic_stateless_reject_support) {
@@ -350,7 +350,8 @@ void QuicSimpleClient::OnClose(QuicSpdyStream* stream) {
   QuicSpdyClientStream* client_stream =
       static_cast<QuicSpdyClientStream*>(stream);
   HttpResponseInfo response;
-  SpdyHeadersToHttpResponse(client_stream->response_headers(), &response);
+  SpdyHeadersToHttpResponse(client_stream->response_headers(), net::HTTP2,
+                            &response);
   if (response_listener_.get() != nullptr) {
     response_listener_->OnCompleteResponse(stream->id(), *response.headers,
                                            client_stream->data());
diff --git a/net/tools/quic/quic_simple_client_bin.cc b/net/tools/quic/quic_simple_client_bin.cc
index 5a7eadb..25b688c 100644
--- a/net/tools/quic/quic_simple_client_bin.cc
+++ b/net/tools/quic/quic_simple_client_bin.cc
@@ -317,7 +317,8 @@ int main(int argc, char* argv[]) {
   // Send the request.
   net::SpdyHeaderBlock header_block;
   net::CreateSpdyHeadersFromHttpRequest(request, request.extra_headers,
-                                        /*direct=*/true, &header_block);
+                                        net::HTTP2, /*direct=*/true,
+                                        &header_block);
   client.SendRequestAndWaitForResponse(request, body, /*fin=*/true);
 
   // Print request and response details.
diff --git a/skia/config/SkUserConfig.h b/skia/config/SkUserConfig.h
index 503abc5..613003e 100644
--- a/skia/config/SkUserConfig.h
+++ b/skia/config/SkUserConfig.h
@@ -230,6 +230,10 @@ SK_API void SkDebugf_FileLine(const char* file, int line, bool fatal,
 #   define SK_SUPPORT_LEGACY_EVAL_CUBIC
 #endif
 
+#ifndef    SK_SUPPORT_LEGACY_COMPUTESAVELAYER_FLAG
+#   define SK_SUPPORT_LEGACY_COMPUTESAVELAYER_FLAG
+#endif
+
 ///////////////////////// Imported from BUILD.gn and skia_common.gypi
 
 /* In some places Skia can use static initializers for global initialization,
diff --git a/sync/protocol/password_specifics.proto b/sync/protocol/password_specifics.proto
index 146a1de..201fb3f 100644
--- a/sync/protocol/password_specifics.proto
+++ b/sync/protocol/password_specifics.proto
@@ -75,9 +75,9 @@ message PasswordSpecificsData {
   // For federated logins and blacklisted forms: <empty>
   optional string password_value = 8;
 
-  // Deprecated: http://crbug.com/413020
   // True if the credential was saved for a HTTPS session with a valid SSL cert.
   // Ignored for Android apps.
+  // Note: likely getting deprecated: http://crbug.com/413020
   optional bool ssl_valid = 9;
 
   // True for the last credential used for logging in on a given site.
diff --git a/sync/protocol/proto_value_conversions.cc b/sync/protocol/proto_value_conversions.cc
index d296e58..fc6192a 100644
--- a/sync/protocol/proto_value_conversions.cc
+++ b/sync/protocol/proto_value_conversions.cc
@@ -231,6 +231,7 @@ std::unique_ptr<base::DictionaryValue> PasswordSpecificsDataToValue(
   SET_STR(username_value);
   SET_STR(password_element);
   value->SetString("password_value", "<redacted>");
+  SET_BOOL(ssl_valid);
   SET_BOOL(preferred);
   SET_INT64(date_created);
   SET_BOOL(blacklisted);
diff --git a/testing/variations/fieldtrial_testing_config_chromeos.json b/testing/variations/fieldtrial_testing_config_chromeos.json
index 557f4bb..0f5a355 100644
--- a/testing/variations/fieldtrial_testing_config_chromeos.json
+++ b/testing/variations/fieldtrial_testing_config_chromeos.json
@@ -82,6 +82,11 @@
             "group_name": "branded"
         }
     ],
+    "LocalNTPSuggestionsService": [
+        {
+            "group_name": "Enabled"
+        }
+    ],
     "MainFrameBeforeActivation": [
         {
             "enable_features": [
diff --git a/testing/variations/fieldtrial_testing_config_linux.json b/testing/variations/fieldtrial_testing_config_linux.json
index 66e1af8..75da65d 100644
--- a/testing/variations/fieldtrial_testing_config_linux.json
+++ b/testing/variations/fieldtrial_testing_config_linux.json
@@ -97,6 +97,11 @@
             "group_name": "Enabled"
         }
     ],
+    "LocalNTPSuggestionsService": [
+        {
+            "group_name": "Enabled"
+        }
+    ],
     "MainFrameBeforeActivation": [
         {
             "enable_features": [
diff --git a/testing/variations/fieldtrial_testing_config_mac.json b/testing/variations/fieldtrial_testing_config_mac.json
index e7b5c22..98ed8f8 100644
--- a/testing/variations/fieldtrial_testing_config_mac.json
+++ b/testing/variations/fieldtrial_testing_config_mac.json
@@ -129,6 +129,11 @@
             "group_name": "Enabled"
         }
     ],
+    "LocalNTPSuggestionsService": [
+        {
+            "group_name": "Enabled"
+        }
+    ],
     "MacMemoryMechanism": [
         {
             "group_name": "Mach"
diff --git a/testing/variations/fieldtrial_testing_config_win.json b/testing/variations/fieldtrial_testing_config_win.json
index d7f54c2..33da770 100644
--- a/testing/variations/fieldtrial_testing_config_win.json
+++ b/testing/variations/fieldtrial_testing_config_win.json
@@ -143,6 +143,11 @@
             "group_name": "Enabled"
         }
     ],
+    "LocalNTPSuggestionsService": [
+        {
+            "group_name": "Enabled"
+        }
+    ],
     "MainFrameBeforeActivation": [
         {
             "enable_features": [
diff --git a/third_party/WebKit/LayoutTests/editing/execCommand/insert_list/insert_list_in_summary_crash.html b/third_party/WebKit/LayoutTests/editing/execCommand/insert_list/insert_list_in_summary_crash.html
deleted file mode 100644
index 0a139fc..0000000
--- a/third_party/WebKit/LayoutTests/editing/execCommand/insert_list/insert_list_in_summary_crash.html
+++ /dev/null
@@ -1,11 +0,0 @@
-<!-- this test requies quirks mode. -->
-<script src="../../../resources/testharness.js"></script>
-<script src="../../../resources/testharnessreport.js"></script>
-<script src="../../assert_selection.js"></script>
-<script>
-test(() => assert_selection(
-    '<div contenteditable><summary><ol><li>^abc|</li></ol></summary></div>',
-    'insertOrderedList',
-    '<div contenteditable><summary>^abc|</summary></div>',
-    'styleFromMatchedRulesForElement() should be called after distribution'));
-</script>
diff --git a/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-contenteditable.html b/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-contenteditable.html
deleted file mode 100644
index 1518d82..0000000
--- a/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-contenteditable.html
+++ /dev/null
@@ -1,21 +0,0 @@
-<!doctype HTML>
-<script src="../../../resources/testharness.js"></script>
-<script src="../../../resources/testharnessreport.js"></script>
-<script src="../../assert_selection.js"></script>
-<div id="log"></div>
-<script>
-test(function(){
-    assert_true(window.hasOwnProperty('eventSender'), 'this test requires window.eventSender');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">bar</div>',
-        selection => {
-            var div = selection.document.getElementById('div');
-            eventSender.mouseMoveTo(selection.document.offsetLeft + div.offsetLeft + 5, selection.document.offsetTop + div.offsetTop + 5);
-            eventSender.mouseDown();
-            eventSender.mouseUp();
-            eventSender.leapForward(100);
-        },
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|bar</div>');
-    },
-'User can focus in -webkit-user-select:all contenteditable element');
-</script>
diff --git a/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-textarea.html b/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-textarea.html
deleted file mode 100644
index acd67fc..0000000
--- a/third_party/WebKit/LayoutTests/editing/selection/mouse/click-user-select-all-textarea.html
+++ /dev/null
@@ -1,17 +0,0 @@
-<!doctype HTML>
-<script src="../../../resources/testharness.js"></script>
-<script src="../../../resources/testharnessreport.js"></script>
-<textarea id="textarea" style="-webkit-user-select:all"></textarea>
-<script>
-test(function(){
-    assert_true(window.hasOwnProperty('eventSender'), 'this test requires window.eventSender');
-    eventSender.mouseMoveTo(textarea.offsetLeft + 5, textarea.offsetTop + 5);
-    eventSender.mouseDown();
-    eventSender.mouseUp();
-    eventSender.keyDown('f');
-    eventSender.keyDown('o');
-    eventSender.keyDown('o');
-    assert_equals(textarea.value, 'foo');
-    },
-'User can ipnut in -webkit-user-select:all textarea');
-</script>
diff --git a/third_party/WebKit/LayoutTests/editing/selection/user-select/user-select-all-contenteditable.html b/third_party/WebKit/LayoutTests/editing/selection/user-select/user-select-all-contenteditable.html
deleted file mode 100644
index 8a8862d..0000000
--- a/third_party/WebKit/LayoutTests/editing/selection/user-select/user-select-all-contenteditable.html
+++ /dev/null
@@ -1,67 +0,0 @@
-<!doctype HTML>
-<script src="../../../resources/testharness.js"></script>
-<script src="../../../resources/testharnessreport.js"></script>
-<script src="../../assert_selection.js"></script>
-<div id="log"></div>
-<script>
-test(function(){
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo</div>',
-        selection => selection.collapse(selection.document.getElementById('div').firstChild, 1),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f|oo</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f|oo</div>',
-        selection => selection.extend(selection.document.getElementById('div').firstChild, 2),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f^o|o</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo</div>',
-        selection => {
-            var div = selection.document.getElementById('div');
-            selection.setBaseAndExtent(div.firstChild, 1, div.firstChild, 2);
-        },
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f^o|o</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo</div>',
-        selection => {
-            var range = selection.document.createRange();
-            var div = selection.document.getElementById('div');
-            range.setStart(div, 0);
-            range.setEnd(div, 1);
-            selection.addRange(range);
-        },
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">^foo|</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|foo</div>',
-        selection => selection.modify('move', 'forward', 'character'),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f|oo</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">f|oo</div>',
-        selection => selection.modify('move', 'backward', 'character'),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|foo</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|foo</div>',
-        selection => selection.modify('extend', 'forward', 'character'),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">^foo|</div>');
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo|</div>',
-        selection => selection.modify('extend', 'backward', 'character'),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|foo^</div>');
-    },
-'Selection API can edit in -webkit-user-select:all contenteditable element');
-
-test(function(){
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">|foo</div>',
-        selection => selection.document.execCommand('insertText', false, 'bar'),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">bar|foo</div>');
-    },
-'Execcommand inserttext in -webkit-user-select:all contenteditable element');
-
-test(function(){
-    assert_selection(
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo</div>',
-        selection => assert_true(selection.document.getElementById('div').isContentEditable),
-        '<div contenteditable="true" id="div" style="-webkit-user-select:all">foo</div>');
-    },
-'-webkit-user-select:all contenteditable element is HTMLElement.isContentEditable == true');
-</script>
diff --git a/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen-expected.txt b/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen-expected.txt
index c203db5..74d38aa 100644
--- a/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen-expected.txt
+++ b/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen-expected.txt
@@ -4,7 +4,7 @@ On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE
 
 
 PASS getComputedStyle(full).backgroundColor is red
-PASS internals.updateStyleAndReturnAffectedElementCount() is 2
+PASS internals.updateStyleAndReturnAffectedElementCount() is 1
 PASS getComputedStyle(full).backgroundColor is green
 PASS getComputedStyle(ancestor).backgroundColor is red
 PASS internals.updateStyleAndReturnAffectedElementCount() is 1
diff --git a/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen.html b/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen.html
index 77f0e2d..c8bb4c8 100644
--- a/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen.html
+++ b/third_party/WebKit/LayoutTests/fast/css/invalidation/fullscreen.html
@@ -34,7 +34,7 @@ function runTests() {
     testRoot.offsetTop; // force recalc
     testRoot.className = "t1";
     if (window.internals)
-        shouldBe("internals.updateStyleAndReturnAffectedElementCount()", "2");
+        shouldBe("internals.updateStyleAndReturnAffectedElementCount()", "1");
     shouldBe("getComputedStyle(full).backgroundColor", "green");
 
     shouldBe("getComputedStyle(ancestor).backgroundColor", "red");
diff --git a/third_party/WebKit/LayoutTests/fullscreen/enter-exit-full-screen-hover.html b/third_party/WebKit/LayoutTests/fullscreen/enter-exit-full-screen-hover.html
index be3e258..1aa60aa 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/enter-exit-full-screen-hover.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/enter-exit-full-screen-hover.html
@@ -1,11 +1,4 @@
 <!DOCTYPE html>
-<style>
-/* Offset body by 50px so that buttons clearly change position when they enter/exit fullscreen. */
-body {
-    position: relative;
-    left: 50px;
-}
-</style>
 <script src="../resources/js-test.js"></script>
 <script src="full-screen-test.js"></script>
 <script src="../fast/events/touch/resources/touch-hover-active-tests.js"></script>
@@ -50,8 +43,7 @@ function runTest() {
 
 
     // Move mouse over to the "Go fullscreen" button and click
-    // We move by 50px in the x-direction to account for the relative position.
-    eventSender.mouseMoveTo(enterButtonCenter.x + 50, enterButtonCenter.y);
+    eventSender.mouseMoveTo(enterButtonCenter.x, enterButtonCenter.y);
     eventSender.mouseDown();
     eventSender.mouseUp();
 }
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style-expected.txt b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style-expected.txt
index cb34621..1ef1531 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style-expected.txt
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style-expected.txt
@@ -1,6 +1,6 @@
 
-TEST(getComputedStyle(document.documentElement).overflow == 'visible') OK
+TEST(getComputedStyle(ancestor).position == 'relative') OK
 EVENT(webkitfullscreenchange)
-TEST(getComputedStyle(document.documentElement).overflow == 'hidden') OK
+TEST(getComputedStyle(ancestor).position == 'static') OK
 END OF TEST
 
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style.html
index 0d898c9..0ae491e 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-ua-style.html
@@ -5,16 +5,18 @@
         document.offsetWidth;
         frame.contentDocument.offsetWidth;
         var videoEnteredFullScreen = function() {
-            test("getComputedStyle(document.documentElement).overflow == 'hidden'");
+            test("getComputedStyle(ancestor).position == 'static'");
             endTest();
         };
         waitForEvent(frame.contentDocument, "webkitfullscreenchange", videoEnteredFullScreen);
 
-        test("getComputedStyle(document.documentElement).overflow == 'visible'");
+        test("getComputedStyle(ancestor).position == 'relative'");
 
         runWithKeyDown(function(){
             frame.contentDocument.querySelector("video").webkitRequestFullScreen();
         });
     }
 </script>
-<iframe allowfullscreen id="frame" src="data:text/html,<video></video>" onload="runTest()"></iframe>
+<div id="ancestor" style="position:relative">
+    <iframe allowfullscreen id="frame" src="data:text/html,<video></video>" onload="runTest()"></iframe>
+</div>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-zIndex.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-zIndex.html
index 7f7e8e4..44b5afd 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-zIndex.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-iframe-zIndex.html
@@ -43,6 +43,6 @@
              After entering full screen mode, the whole screen should be white.
              Click <button onclick="goFullScreen()">go full screen</button> to run the test.</div>
         <div id="block2"></div>
-        <iframe allowfullscreen src="resources/white.html" id="block1"></iframe>
+        <iframe allowfullscreen src="resources/empty.html" id="block1"></iframe>
     </body>
 </html>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer-expected.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer-expected.html
deleted file mode 100644
index e981713..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer-expected.html
+++ /dev/null
@@ -1,9 +0,0 @@
-<!DOCTYPE html>
-<style>
-body {
-    background-color: green;
-    margin: 0;
-}
-</style>
-
-<div>Test that fullscreen elements are in the top layer. The test passes if you see a green backdrop behind this box when fullscreen.</div>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer.html
deleted file mode 100644
index d3f279a..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-is-in-top-layer.html
+++ /dev/null
@@ -1,37 +0,0 @@
-<!doctype html>
-<style>
-div {
-    top: 100px;
-    bottom: 100px;
-    left: 100px;
-    right: 100px;
-    height: auto;
-    width: auto;
-}
-::backdrop {
-    background: green;
-}
-</style>
-
-<div id='element'>Test that fullscreen elements are in the top layer. The test passes if you see a green backdrop behind this box when fullscreen.</div>
-
-<button id='button'>Go fullscreen</button>
-
-<script>
-var element = document.getElementById('element');
-document.getElementById('button').addEventListener('click', function() {
-    element.webkitRequestFullscreen();
-});
-
-if (window.testRunner) {
-    testRunner.waitUntilDone();
-    document.addEventListener('webkitfullscreenchange', function() {
-        testRunner.notifyDone();
-    });
-
-    var button = document.getElementById('button');
-    eventSender.mouseMoveTo(button.offsetLeft + button.offsetWidth / 2, button.offsetTop + button.offsetHeight / 2);
-    eventSender.mouseDown();
-    eventSender.mouseUp();
-}
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-render-inline-expected.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-render-inline-expected.html
index 90371ed..6bbb44a 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-render-inline-expected.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-render-inline-expected.html
@@ -1,2 +1,3 @@
 <!DOCTYPE html>
-<div>a<span>b<div>c</div>d</span>e</div>
+<!-- FIXME: the <br> is needed until http://crbug.com/246077 is fixed -->
+<div>a<br><span>b<div>c</div>d</span>e</div>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context-expected.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context-expected.html
index 042f660..98a5e31 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context-expected.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context-expected.html
@@ -1,2 +1,12 @@
 <!DOCTYPE html>
-<body style="background: black"></body>
+<video></video>
+<script>
+    var runPixelTests = true;
+</script>
+<script src="full-screen-test.js"></script>
+<script>
+    document.onwebkitfullscreenchange = endTest;
+    runWithKeyDown(function() {
+        document.querySelector("video").webkitRequestFullScreen();
+    });
+</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context.html
index f565aab..34f58df 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-stacking-context.html
@@ -1,52 +1,57 @@
 <!DOCTYPE html>
-<script>
-var runPixelTests = true;
-
-function init() {
-  waitForEventAndEnd(document, 'webkitfullscreenchange');
-  runWithKeyDown(goFullScreen);
-}
-
-function goFullScreen() {
-  document.getElementById('target').webkitRequestFullScreen();
-}
-</script>
-<script src="full-screen-test.js"></script>
-<style>
-#one {
-    width: 100px;
-    height: 100px;
-    position: relative;
-    top: 50px;
-    left: 50px;
-    z-index: 1;
-    background-color: red;
-    opacity: 0.5;
-    transform: rotate(180);
-    -webkit-mask: -webkit-linear-gradient(left, alpha 0%, white 100%);
-    -webkit-filter: contrast(100%);
-    clip:rect(0px,100px,100px,0px);
-    -webkit-box-reflect: below;
-    -webkit-transform-style: preserve-3d;
-    -webkit-perspective: 300;
-}
-#zero {
-    position: relative;
-    z-index: 0;
-}
-#target {
-    width: 200px;
-    height: 200px;
-    background-color: black;
-}
-</style>
-
-<body onload="init()">
-  <div>This tests that a full screen element in a lower stacking context blocks a sibling in a higher stacking context.
-       After entering full screen mode, only a black box should be visible.
-       Click <button onclick="goFullScreen()">go full screen</button> to run the test.</div>
-  <div id="one"></div>
-  <div id="zero">
-      <div id="target"></div>
-  </div>
-</body>
+<html>
+    <head>
+        <script>
+            var runPixelTests = true;
+            
+            function init() {
+                waitForEventAndEnd(document, 'webkitfullscreenchange');
+                runWithKeyDown(goFullScreen);
+            }
+            
+            function goFullScreen() {
+                document.getElementById('video').webkitRequestFullScreen();
+            }
+        </script>
+        <script src="full-screen-test.js"></script>
+        <style>
+            #one {
+                width: 100px;
+                height: 100px;
+                position: relative;
+                top: 50px;
+                left: 50px;
+                z-index: 1;
+                background-color: red;
+            }
+            #one, #two {
+                opacity: 0.5;
+                transform: rotate(180);
+                -webkit-mask: -webkit-linear-gradient(left, alpha 0%, white 100%);
+                -webkit-filter: contrast(100%);
+                clip:rect(0px,100px,100px,0px);
+                -webkit-box-reflect: below;
+                -webkit-transform-style: preserve-3d;
+                -webkit-perspective: 300;
+            }
+            #zero {
+                position: relative;
+                z-index: 0;
+            }
+            #video {
+                width: 200px;
+                height: 200px;
+                background-color: black;
+            }
+        </style>
+    </head>
+    <body onload="init()">
+        <div>This tests that a full screen element in a lower stacking context blocks a sibling in a higher stacking context.  
+             After entering full screen mode, only a black box should be visible.
+             Click <button onclick="goFullScreen()">go full screen</button> to run the test.</div>
+        <div id="one"></div>
+        <div id="zero">
+            <video id="video"></video>
+        </div>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/full-screen-zIndex-expected.html b/third_party/WebKit/LayoutTests/fullscreen/full-screen-zIndex-expected.html
index f9fc201..37c105b 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/full-screen-zIndex-expected.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/full-screen-zIndex-expected.html
@@ -6,14 +6,15 @@
                 background-color: black;
             }
             div {
-                width: 100%;
-                height: 100%;
+                width: 200px;
+                height: 100px;
                 border: 4px solid darkgreen;
                 background-color: green;
                 position: absolute;
-                box-sizing: border-box;
-                top: 0;
-                left: 0;
+                left: 50%;
+                top: 50%;
+                margin-left: -104px;
+                margin-top: -54px;
             }
         </style>
     </head>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/parent-flow-inline-with-block-child-expected.html b/third_party/WebKit/LayoutTests/fullscreen/parent-flow-inline-with-block-child-expected.html
index 4545d28..1561845 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/parent-flow-inline-with-block-child-expected.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/parent-flow-inline-with-block-child-expected.html
@@ -1,3 +1,3 @@
 <!DOCTYPE html>
-<span>1</span>
-<span>2</span>
+<div>1</div>
+<div>2</div>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-expected.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-expected.html
deleted file mode 100644
index 3126fe1..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-expected.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<!DOCTYPE html>
-<body style="background: green"></body>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe-expected.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe-expected.html
deleted file mode 100644
index 3126fe1..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe-expected.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<!DOCTYPE html>
-<body style="background: green"></body>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe.html
deleted file mode 100644
index c967876..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-iframe.html
+++ /dev/null
@@ -1,16 +0,0 @@
-<!DOCTYPE html>
-<title>::backdrop for a fullscreen iframe element</title>
-<script src="../trusted-event.js"></script>
-<style>
-iframe::backdrop {
-  background: green;
-}
-</style>
-<iframe></iframe>
-<script>
-testRunner.waitUntilDone();
-trusted_request(document.querySelector("iframe"));
-document.addEventListener("fullscreenchange", function() {
-  testRunner.notifyDone();
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object-expected.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object-expected.html
deleted file mode 100644
index 5608482..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object-expected.html
+++ /dev/null
@@ -1,13 +0,0 @@
-<!DOCTYPE html>
-<style>
-body {
-    background: green;
-    margin: 0;
-}
-object {
-    position: fixed;
-    width: 100%;
-    height: 100%;
-}
-</style>
-<object type="application/x-shockwave-flash" data="../../plugins/resources/simple_blank.swf"></object>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object.html
deleted file mode 100644
index 34e2219..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-object.html
+++ /dev/null
@@ -1,16 +0,0 @@
-<!DOCTYPE html>
-<title>::backdrop for a fullscreen object element</title>
-<script src="../trusted-event.js"></script>
-<style>
-object::backdrop {
-  background: green;
-}
-</style>
-<object type="application/x-shockwave-flash" data="../../plugins/resources/simple_blank.swf"></object>
-<script>
-testRunner.waitUntilDone();
-trusted_request(document.querySelector("object"));
-document.addEventListener("fullscreenchange", function() {
-  testRunner.notifyDone();
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video-expected.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video-expected.html
deleted file mode 100644
index 3126fe1..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video-expected.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<!DOCTYPE html>
-<body style="background: green"></body>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video.html
deleted file mode 100644
index 5bb9b2a..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop-video.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!DOCTYPE html>
-<title>::backdrop for a fullscreen video element</title>
-<script src="../trusted-event.js"></script>
-<style>
-video::backdrop {
-  background: green;
-}
-/* A video element in fullscreen will always get controls.
-   ::-webkit-media-controls shouldn't be exposed to the web, but it is, so abuse
-   it to hide the controls and simplify the test expectations. */
-video::-webkit-media-controls {
-  display: none;
-}
-</style>
-<video></video>
-<script>
-testRunner.waitUntilDone();
-trusted_request(document.querySelector("video"));
-document.addEventListener("fullscreenchange", function() {
-  testRunner.notifyDone();
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop.html
deleted file mode 100644
index b35bbbb..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/backdrop.html
+++ /dev/null
@@ -1,16 +0,0 @@
-<!DOCTYPE html>
-<title>::backdrop for a fullscreen div element</title>
-<script src="../trusted-event.js"></script>
-<style>
-div::backdrop {
-  background: green;
-}
-</style>
-<div></div>
-<script>
-testRunner.waitUntilDone();
-trusted_request(document.querySelector("div"));
-document.addEventListener("fullscreenchange", function() {
-  testRunner.notifyDone();
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow-root.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow-root.html
deleted file mode 100644
index f76bdac..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow-root.html
+++ /dev/null
@@ -1,21 +0,0 @@
-<!DOCTYPE html>
-<title>overflow of root element when root element itself is fullscreen</title>
-<script src="../../resources/testharness.js"></script>
-<script src="../../resources/testharnessreport.js"></script>
-<script src="../trusted-event.js"></script>
-<style>:root { overflow: scroll; }</style>
-<div id="log"></div>
-<script>
-async_test(function()
-{
-    var root = document.documentElement;
-    trusted_request(root, document.body);
-
-    document.addEventListener("fullscreenchange", this.step_func_done(function()
-    {
-        // The scrollbar should remain.
-        assert_equals(getComputedStyle(root).overflow, "scroll");
-        assert_less_than(root.clientWidth, window.innerWidth);
-    }));
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow.html b/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow.html
deleted file mode 100644
index 35baba1..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/rendering/overflow.html
+++ /dev/null
@@ -1,21 +0,0 @@
-<!DOCTYPE html>
-<title>overflow of root element when descendant is fullscreen</title>
-<script src="../../resources/testharness.js"></script>
-<script src="../../resources/testharnessreport.js"></script>
-<script src="../trusted-event.js"></script>
-<style>:root { overflow: scroll; }</style>
-<div id="log"></div>
-<script>
-async_test(function()
-{
-    var root = document.documentElement;
-    trusted_request(document.querySelector("div"));
-
-    document.addEventListener("fullscreenchange", this.step_func_done(function()
-    {
-        // The scrollbar should be removed.
-        assert_equals(getComputedStyle(root).overflow, "hidden");
-        assert_equals(root.clientWidth, window.innerWidth);
-    }));
-});
-</script>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/resources/empty.html b/third_party/WebKit/LayoutTests/fullscreen/resources/empty.html
index 0e76edd..c8b7661 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/resources/empty.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/resources/empty.html
@@ -1 +1 @@
-<!DOCTYPE html>
+<body></body>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/resources/green.html b/third_party/WebKit/LayoutTests/fullscreen/resources/green.html
index 3126fe1..9b2defa 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/resources/green.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/resources/green.html
@@ -1,2 +1,8 @@
-<!DOCTYPE html>
-<body style="background: green"></body>
+<html>
+  <style>
+    body {
+      background-color: green;
+    }
+  </style>
+  <body></body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/resources/white.html b/third_party/WebKit/LayoutTests/fullscreen/resources/white.html
deleted file mode 100644
index fc01fd0..0000000
--- a/third_party/WebKit/LayoutTests/fullscreen/resources/white.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<!DOCTYPE html>
-<body style="background: white"></body>
diff --git a/third_party/WebKit/LayoutTests/fullscreen/video-webkit-transform-expected.html b/third_party/WebKit/LayoutTests/fullscreen/video-webkit-transform-expected.html
index 92dcfe0..01c7633 100644
--- a/third_party/WebKit/LayoutTests/fullscreen/video-webkit-transform-expected.html
+++ b/third_party/WebKit/LayoutTests/fullscreen/video-webkit-transform-expected.html
@@ -1,5 +1,4 @@
 <!DOCTYPE html>
-<p>Test that fullscreen video should not be affected by webkit-transform.</p>
 <video id="video" allowfullscreen></video>
 <script>
     if (window.internals)
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
new file mode 100644
index 0000000..1bc6cdc
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
@@ -0,0 +1,66 @@
+<!DOCTYPE html>
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<meta name="timeout" content="long"></meta>
+<head>
+</head>
+<body>
+    <pre id="result">UNSET</pre>
+    <div id=prot style="height:480;width:700;background-image:url('tile.gif');">
+        <iframe id=protfr border=0 frameBorder=0 scrolling="no" src="resources/openskies3.html" style="height:270;width:333"></iframe>
+    </div>
+    <script>
+     var t = async_test('IronFrame scroll test');
+     setTimeout(function(){
+         t.step(function () {
+             assert_equals(document.getElementById("result").innerHTML, "PASS", "Scroll incorrect");
+         });
+         t.done();
+     }, 2000);
+    </script>
+    <script>
+     function scrollWindow() {
+         setTimeout(function(){window.scrollTo(0, 100);}, 1000);
+     }
+     window.addEventListener("load", scrollWindow, false);
+    </script>
+    DUMMY CONTENT
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    DUMMY CONTENT
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg b/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg
new file mode 100644
index 0000000..caea5cc
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html
new file mode 100644
index 0000000..cd9e029
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html
@@ -0,0 +1,2 @@
+<body>
+    <iframe id="bigframe" style="position:absolute;top:0;left:0" border=0 frameBorder=0 scrolling="no" height=3000 width=3000 src="unprotected3.html"></iframe>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html
new file mode 100644
index 0000000..51656e4
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html
@@ -0,0 +1,4 @@
+<html>
+    <script>
+    </script>
+    <img src="ishi.jpg">
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
new file mode 100644
index 0000000..1a1dceb
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
@@ -0,0 +1,15 @@
+// httpserver.go
+package main
+
+import (
+	"flag"
+	"net/http"
+)
+
+var port = flag.String("port", "8080", "Define what TCP port to bind to")
+var root = flag.String("root", ".", "Define the root filesystem path")
+
+func main() {
+	flag.Parse()
+	panic(http.ListenAndServe(":"+*port, http.FileServer(http.Dir(*root))))
+}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg
new file mode 100644
index 0000000..caea5cc
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
new file mode 100644
index 0000000..edecfff
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+<body>
+  <pre id="result1"></pre>
+  <iframe id="bigframe" style="position:absolute;top:0;left:0" border=0 frameBorder=0 scrolling="no" height=3000 width=3000 src="protected3.html">
+  </iframe>
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png
new file mode 100644
index 0000000..9feafc5
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png
new file mode 100644
index 0000000..7d864c6
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
new file mode 100644
index 0000000..9824401
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
@@ -0,0 +1,61 @@
+<html requestVisibility=1>
+    <body>
+        <script>
+         var enabled=true;
+         var numAlerts = 0;
+         var width0 = -1;
+         var height0 = -1;
+         var width1 = -1;
+         var height1 = -1;
+        </script>
+        <img src="paypal.png" style="position:absolute;top:0;left:0">
+        <script>
+         var prev;
+         var prevMsg="";
+         var v={};
+         var visible=false;
+
+         var update = function(){
+             if(v.visible.width < 333 || v.visible.height< 270 ) {
+                 visible=false;
+             } else {
+                 visible=true;
+             }
+             if (width0 == - 1) {
+                 if (v.visible.width != 300 || v.visible.height != 150) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PARTIAL PASS";
+                 }
+                 width0 = v.visible.width;
+                 height0 = v.visible.height;
+             } else if (width0 != v.visible.width || height0 != v.visible.height) {
+                 if (v.visible.width != 300 || v.visible.height != 92) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PASS";
+                 }
+
+                 if (width1 == -1) {
+                     width1 = v.visible.width;
+                     height1 = v.visible.height;
+                 }
+             }
+         }
+         function go() {
+             document.documentElement.addEventListener('requestedvisibility', function(e) {
+                 if(e.message!=prevMsg){
+                     prev=e.timeStamp;
+                     prevMsg=e.message;
+                 }
+                 v = JSON.parse(e.message);
+                 v.innerHeight = innerHeight;
+                 v.innerWidth  = innerWidth;
+                 v.ancestorOrigins = document.location.ancestorOrigins;
+                 update();
+             });
+         }
+         if(enabled) { window.onload=go; }
+        </script>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif
new file mode 100644
index 0000000..6c950c8
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html
new file mode 100644
index 0000000..a53192d
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html
@@ -0,0 +1,61 @@
+<html>
+    <!-- could also be
+         <html requestVisibility=1>
+         !-->
+    <body>
+        <script>
+         var enabled=false;
+         if(parent.frameElement.id!="unprotfr"){
+             document.requestVisibility();
+             enabled=true;
+         }
+
+        </script>
+
+        <img src="paypal.png" style="position:absolute;top:0;left:0">
+        <script>
+         var prev;
+         var prevMsg="";
+         var v={};
+         var visible=false;
+         var viz = top.document.getElementById("viz").contentWindow.document.getElementById("render");
+
+         var update = function(){
+             if(v.visible.width < 333 ||
+                v.visible.height< 270 ) {
+                    visible=false;
+             } else {
+                 visible=true;
+             }
+             if(!visible) {
+                 viz.style.backgroundColor="red";
+             } else {
+                 if(visible && Date.now()-prev < 2000) {
+                     viz.style.backgroundColor="yellow";
+                     setTimeout(update, 2250);
+                 } else {
+                     viz.style.backgroundColor="white";
+                 }
+             }
+         }
+
+         function go() { document.documentElement.onerror = function(e) {
+             if(e.message!=prevMsg){
+                 prev=e.timeStamp;
+                 prevMsg=e.message;
+             }
+             v = JSON.parse(e.message);
+             v.innerHeight = innerHeight;
+             v.innerWidth  = innerWidth;
+             v.timestamp   = e.timeStamp;
+             v.ancestorOrigins = document.location.ancestorOrigins;
+             viz.innerText = JSON.stringify(v);
+             var x = viz.innerText;
+             update();
+             //console.log(viz.innerText);
+         }
+         }
+         if(enabled) { window.onload=go; }
+        </script>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html
new file mode 100644
index 0000000..5d2f5b0
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html
@@ -0,0 +1,13 @@
+<head>
+    <style>
+     body{
+
+         font-family: 'Open Sans', sans-serif !important;
+         font-size: 14px;
+     }
+    </style>
+
+</head>
+<body>
+    <div style="word-wrap:break-word;font-size:24px" id="render">   </div>
+</body>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif
new file mode 100644
index 0000000..6c950c8
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-allowed.php b/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-allowed.php
deleted file mode 100644
index e1f91e9..0000000
--- a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-allowed.php
+++ /dev/null
@@ -1,24 +0,0 @@
-<?php
-    header("Content-Security-Policy: script-src 'nonce-abc'");
-?>
-<!doctype html>
-<script nonce="abc" src="/resources/testharness.js"></script>
-<script nonce="abc" src="/resources/testharnessreport.js"></script>
-<script nonce="abc">
-    async_test(t => {
-        document.addEventListener('securitypolicyviolation', t.unreached_func("No report should be generated"));
-        window.onload = t.step_func(_ => {
-            var link = document.createElement('link');
-            link.setAttribute("rel", "import");
-            link.setAttribute("nonce", "abc");
-            link.setAttribute("href", "/security/resources/blank.html");
-
-            link.onerror = t.unreached_func("The import should load.");
-            link.onload = t.step_func_done(_ => {
-              assert_true(!!link.import);
-            });
-
-            document.body.appendChild(link);
-        });
-    }, "Nonced imports load, and do not trigger reports.");
-</script>
diff --git a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-blocked.php b/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-blocked.php
deleted file mode 100644
index 2f134fc..0000000
--- a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-enforce-blocked.php
+++ /dev/null
@@ -1,27 +0,0 @@
-<?php
-    header("Content-Security-Policy: script-src 'nonce-abc'");
-?>
-<!doctype html>
-<script nonce="abc" src="/resources/testharness.js"></script>
-<script nonce="abc" src="/resources/testharnessreport.js"></script>
-<script nonce="abc">
-    async_test(t => {
-        window.onload = t.step_func(_ => {
-            var link = document.createElement('link');
-            link.setAttribute("rel", "import");
-            link.setAttribute("nonce", "zyx");
-            link.setAttribute("href", "/security/resources/blank.html");
-
-            var watcher = new EventWatcher(t, document, ['securitypolicyviolation']);
-            watcher
-                .wait_for('securitypolicyviolation')
-                .then(t.step_func_done(e => {
-                    assert_false(!!link.import, "The import was not loaded.");
-                    assert_equals(e.blockedURI, "http://127.0.0.1:8000/security/resources/blank.html");
-                    assert_equals(e.lineNumber, 21);
-                 }));
-
-            document.body.appendChild(link);
-        });
-    }, "Incorrectly nonced imports do not load, and trigger reports.");
-</script>
diff --git a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-allowed.php b/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-allowed.php
deleted file mode 100644
index ddbf9da..0000000
--- a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-allowed.php
+++ /dev/null
@@ -1,25 +0,0 @@
-<?php
-    header("Content-Security-Policy: script-src 'unsafe-inline' 'self'");
-    header("Content-Security-Policy-Report-Only: script-src 'nonce-abc'");
-?>
-<!doctype html>
-<script nonce="abc" src="/resources/testharness.js"></script>
-<script nonce="abc" src="/resources/testharnessreport.js"></script>
-<script nonce="abc">
-    async_test(t => {
-        document.addEventListener('securitypolicyviolation', t.unreached_func("No report should be generated"));
-        window.onload = t.step_func(_ => {
-            var link = document.createElement('link');
-            link.setAttribute("rel", "import");
-            link.setAttribute("nonce", "abc");
-            link.setAttribute("href", "/security/resources/blank.html");
-
-            link.onerror = t.unreached_func("The import should load.");
-            link.onload = t.step_func_done(_ => {
-              assert_true(!!link.import);
-            });
-
-            document.body.appendChild(link);
-        });
-    }, "Nonced imports load, and do not trigger reports.");
-</script>
diff --git a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-blocked.php b/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-blocked.php
deleted file mode 100644
index a63cf62..0000000
--- a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-multiple-blocked.php
+++ /dev/null
@@ -1,33 +0,0 @@
-<?php
-    header("Content-Security-Policy: script-src 'unsafe-inline' 'self'");
-    header("Content-Security-Policy-Report-Only: script-src 'nonce-abc'");
-?>
-<!doctype html>
-<script nonce="abc" src="/resources/testharness.js"></script>
-<script nonce="abc" src="/resources/testharnessreport.js"></script>
-<script nonce="abc">
-    async_test(t => {
-        var link = document.createElement('link');
-        link.setAttribute("rel", "import");
-        link.setAttribute("nonce", "zyx");
-        link.setAttribute("href", "/security/resources/blank.html");
-        link.onerror = t.unreached_func("The import should load.");
-        link.onload = t.step_func(_ => assert_true(!!link.import, "The import was loaded."));
-
-        var watcher = new EventWatcher(t, document, ['securitypolicyviolation', 'securitypolicyviolation']);
-        watcher
-            .wait_for('securitypolicyviolation')
-            .then(t.step_func(e => {
-                assert_equals(e.blockedURI, "http://127.0.0.1:8000/security/resources/blank.html");
-                assert_equals(e.lineNumber, 27);
-                // TODO(mkwst): We shouldn't be generating another violation report here.
-                return watcher.wait_for('securitypolicyviolation');
-            }))
-            .then(t.step_func_done(e => {
-                assert_equals(e.blockedURI, "http://127.0.0.1:8000/security/resources/blank.html");
-                assert_equals(e.lineNumber, 0);
-            }));
-
-        document.head.appendChild(link);
-    }, "Nonced imports load, and do not trigger reports.");
-</script>
diff --git a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-reportonly-allowed.php b/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-reportonly-allowed.php
deleted file mode 100644
index 34256fb..0000000
--- a/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/nonces/import-reportonly-allowed.php
+++ /dev/null
@@ -1,32 +0,0 @@
-<?php
-    header("Content-Security-Policy-Report-Only: script-src 'nonce-abc'");
-?>
-<!doctype html>
-<script nonce="abc" src="/resources/testharness.js"></script>
-<script nonce="abc" src="/resources/testharnessreport.js"></script>
-<script nonce="abc">
-    async_test(t => {
-        var link = document.createElement('link');
-        link.setAttribute("rel", "import");
-        link.setAttribute("nonce", "zyx");
-        link.setAttribute("href", "/security/resources/blank.html");
-        link.onerror = t.unreached_func("The import should load.");
-        link.onload = t.step_func(_ => assert_true(!!link.import, "The import was loaded."));
-
-        var watcher = new EventWatcher(t, document, ['securitypolicyviolation', 'securitypolicyviolation']);
-        watcher
-            .wait_for('securitypolicyviolation')
-            .then(t.step_func(e => {
-                assert_equals(e.blockedURI, "http://127.0.0.1:8000/security/resources/blank.html");
-                assert_equals(e.lineNumber, 27);
-                // TODO(mkwst): We shouldn't be generating another violation report here.
-                return watcher.wait_for('securitypolicyviolation');
-            }))
-            .then(t.step_func_done(e => {
-                assert_equals(e.blockedURI, "http://127.0.0.1:8000/security/resources/blank.html");
-                assert_equals(e.lineNumber, 0);
-            }));
-
-        document.head.appendChild(link);
-    }, "Nonced imports load, and do not trigger reports.");
-</script>
diff --git a/third_party/WebKit/LayoutTests/virtual/android/fullscreen/rendering/backdrop-video-expected.html b/third_party/WebKit/LayoutTests/virtual/android/fullscreen/rendering/backdrop-video-expected.html
deleted file mode 100644
index 99cbd08..0000000
--- a/third_party/WebKit/LayoutTests/virtual/android/fullscreen/rendering/backdrop-video-expected.html
+++ /dev/null
@@ -1,4 +0,0 @@
-<!DOCTYPE html>
-<!-- TODO(foolip): Setting the background on ::backdrop doesn't work on Android,
-     see crbug.com/627850 -->
-<body style="background: black"></body>
diff --git a/third_party/WebKit/Source/core/core.gypi b/third_party/WebKit/Source/core/core.gypi
index b825a2f..c64924e 100644
--- a/third_party/WebKit/Source/core/core.gypi
+++ b/third_party/WebKit/Source/core/core.gypi
@@ -130,6 +130,7 @@
             'events/CustomEvent.idl',
             'events/DragEvent.idl',
             'events/ErrorEvent.idl',
+            'events/RequestedVisibilityEvent.idl',
             'events/Event.idl',
             'events/EventTarget.idl',
             'events/FocusEvent.idl',
@@ -471,6 +472,7 @@
             'events/CustomEvent.idl',
             'events/DragEvent.idl',
             'events/ErrorEvent.idl',
+            'events/RequestedVisibilityEvent.idl',
             'events/Event.idl',
             'events/FocusEvent.idl',
             'events/HashChangeEvent.idl',
@@ -507,6 +509,7 @@
             'layout/api/LayoutBoxItem.h',
             'layout/api/LayoutBoxModel.h',
             'layout/api/LayoutEmbeddedItem.h',
+            'layout/api/LayoutFullScreenItem.h',
             'layout/api/LayoutImageItem.h',
             'layout/api/LayoutItem.h',
             'layout/api/LayoutLIItem.h',
@@ -598,6 +601,8 @@
             'layout/LayoutFrame.h',
             'layout/LayoutFrameSet.cpp',
             'layout/LayoutFrameSet.h',
+            'layout/LayoutFullScreen.cpp',
+            'layout/LayoutFullScreen.h',
             'layout/LayoutGeometryMap.cpp',
             'layout/LayoutGeometryMap.h',
             'layout/LayoutGeometryMapStep.h',
@@ -2757,6 +2762,8 @@
             'events/DragEvent.h',
             'events/ErrorEvent.cpp',
             'events/ErrorEvent.h',
+            'events/RequestedVisibilityEvent.cpp',
+            'events/RequestedVisibilityEvent.h',
             'events/Event.cpp',
             'events/EventDispatchMediator.cpp',
             'events/EventDispatchMediator.h',
@@ -3731,6 +3738,7 @@
             'events/CustomEventInit.idl',
             'events/DragEventInit.idl',
             'events/ErrorEventInit.idl',
+            'events/RequestedVisibilityEventInit.idl',
             'events/EventInit.idl',
             'events/EventListenerOptions.idl',
             'events/EventModifierInit.idl',
@@ -3809,6 +3817,8 @@
             '<(blink_core_output_dir)/events/DragEventInit.h',
             '<(blink_core_output_dir)/events/ErrorEventInit.cpp',
             '<(blink_core_output_dir)/events/ErrorEventInit.h',
+            '<(blink_core_output_dir)/events/RequestedVisibilityEventInit.cpp',
+            '<(blink_core_output_dir)/events/RequestedVisibilityEventInit.h',
             '<(blink_core_output_dir)/events/EventInit.cpp',
             '<(blink_core_output_dir)/events/EventInit.h',
             '<(blink_core_output_dir)/events/EventListenerOptions.cpp',
diff --git a/third_party/WebKit/Source/core/css/fullscreen.css b/third_party/WebKit/Source/core/css/fullscreen.css
index eb2e936..f6a773a 100644
--- a/third_party/WebKit/Source/core/css/fullscreen.css
+++ b/third_party/WebKit/Source/core/css/fullscreen.css
@@ -1,44 +1,61 @@
-:not(:root):-webkit-full-screen {
-    position: fixed !important;
-    top: 0 !important;
-    right: 0 !important;
-    bottom: 0 !important;
+:-webkit-full-screen {
+    background-color: white;
+    z-index: 2147483647 !important;
+}
+
+:root:-webkit-full-screen-ancestor {
+    overflow: hidden !important;
+}
+
+:-webkit-full-screen-ancestor:not(iframe) {
+    z-index: auto !important;
+    position: static !important;
+    opacity: 1 !important;
+    transform: none !important;
+    -webkit-mask: none !important;
+    clip: none !important;
+    -webkit-filter: none !important;
+    transition: none !important;
+    -webkit-box-reflect: none !important;
+    -webkit-perspective: none !important;
+    -webkit-transform-style: flat !important;
+    will-change: auto !important;
+}
+
+video:-webkit-full-screen, audio:-webkit-full-screen {
+    background-color: transparent !important;
+    position: relative !important;
     left: 0 !important;
+    top: 0 ! important;
     margin: 0 !important;
-    box-sizing: border-box !important;
     min-width: 0 !important;
     max-width: none !important;
     min-height: 0 !important;
     max-height: none !important;
     width: 100% !important;
     height: 100% !important;
-    object-fit: contain !important;
+    flex: 1 !important;
+    display: block !important;
     transform: none !important;
 }
 
-iframe:-webkit-full-screen {
-    border: none !important;
-    padding: 0 !important;
-}
-
-/* TODO(foolip): In the spec, there's a ::backdrop block with the properties
-   shared with dialog::backdrop (see html.css). */
-:not(:root):-webkit-full-screen::backdrop {
-    position: fixed;
-    top: 0;
-    right: 0;
-    bottom: 0;
-    left: 0;
-    background: black;
+img:-webkit-full-screen {
+    width: auto;
+    height: 100%;
+    max-width: 100%;
 }
 
-/* Anything below are extensions over what the Fullscreen API (3 May 2016) mandates. */
-
-/* This prevents video from overflowing the viewport in
-   virtual/android/fullscreen/video-scrolled-iframe.html (crbug.com/441890) and
-   removes scrollbars caused by html { overflow: scroll } (crbug.com/543946).
-   TODO(foolip): This is done differently in Gecko, find a fix not involving the
-   ancestor selector in https://github.com/whatwg/fullscreen/issues/19. */
-:root:-webkit-full-screen-ancestor {
-    overflow: hidden !important;
+iframe:-webkit-full-screen {
+    margin: 0 !important;
+    padding: 0 !important;
+    border: 0 !important;
+    position: fixed !important;
+    min-width: 0 !important;
+    max-width: none !important;
+    min-height: 0 !important;
+    max-height: none !important;
+    width: 100% !important;
+    height: 100% !important;
+    left: 0 !important;
+    top: 0 !important;
 }
diff --git a/third_party/WebKit/Source/core/css/html.css b/third_party/WebKit/Source/core/css/html.css
index f51f5aa..c301bbb 100644
--- a/third_party/WebKit/Source/core/css/html.css
+++ b/third_party/WebKit/Source/core/css/html.css
@@ -968,19 +968,19 @@ nobr {
 
 /* states */
 
-:focus {
+:focus { 
     outline: auto 5px -webkit-focus-ring-color
 }
 
 /* Read-only text fields do not show a focus ring but do still receive focus */
-html:focus, body:focus, input[readonly]:focus {
+html:focus, body:focus, input[readonly]:focus { 
     outline: none
 }
 
 embed:focus, iframe:focus, object:focus {
     outline: none
 }
-
+  
 input:focus, textarea:focus, keygen:focus, select:focus {
     outline-offset: -2px
 }
@@ -996,7 +996,7 @@ input[type="submit" i]:focus,
 input[type="file" i]:focus::-webkit-file-upload-button {
     outline-offset: 0
 }
-
+    
 a:-webkit-any-link {
     color: -webkit-link;
     text-decoration: underline;
@@ -1094,8 +1094,6 @@ dialog {
     color: black
 }
 
-/* TODO(foolip): In the Fullscreen spec, there's a ::backdrop block with the
-   properties shared with :fullscreen::backdrop (see fullscreen.css). */
 dialog::backdrop {
     position: fixed;
     top: 0;
@@ -1121,3 +1119,4 @@ dialog::backdrop {
 }
 
 /* noscript is handled internally, as it depends on settings. */
+
diff --git a/third_party/WebKit/Source/core/css/resolver/StyleAdjuster.cpp b/third_party/WebKit/Source/core/css/resolver/StyleAdjuster.cpp
index 9f58686..90e4221 100644
--- a/third_party/WebKit/Source/core/css/resolver/StyleAdjuster.cpp
+++ b/third_party/WebKit/Source/core/css/resolver/StyleAdjuster.cpp
@@ -33,19 +33,15 @@
 #include "core/dom/ContainerNode.h"
 #include "core/dom/Document.h"
 #include "core/dom/Element.h"
-#include "core/dom/Fullscreen.h"
-#include "core/frame/FrameHost.h"
 #include "core/frame/FrameView.h"
 #include "core/frame/Settings.h"
 #include "core/frame/UseCounter.h"
-#include "core/frame/VisualViewport.h"
 #include "core/html/HTMLIFrameElement.h"
 #include "core/html/HTMLInputElement.h"
 #include "core/html/HTMLPlugInElement.h"
 #include "core/html/HTMLTableCellElement.h"
 #include "core/html/HTMLTextAreaElement.h"
 #include "core/layout/LayoutTheme.h"
-#include "core/page/Page.h"
 #include "core/style/ComputedStyle.h"
 #include "core/style/ComputedStyleConstants.h"
 #include "core/svg/SVGSVGElement.h"
@@ -364,17 +360,6 @@ void StyleAdjuster::adjustComputedStyle(ComputedStyle& style, const ComputedStyl
         // https://drafts.csswg.org/css-containment/#containment-paint
         if (style.containsPaint() && style.display() == INLINE)
             style.setDisplay(BLOCK);
-
-        if (element && Fullscreen::isActiveFullScreenElement(*element)) {
-            // We need to size the fullscreen element to the inner viewport and not to the
-            // outer viewport (what percentage would do). Unfortunately CSS can't handle
-            // that as we don't expose the inner viewport information.
-            //
-            // TODO(dsinclair): We should find a way to get this standardized. crbug.com/534924
-            IntSize viewportSize = element->document().page()->frameHost().visualViewport().size();
-            style.setWidth(Length(viewportSize.width(), Fixed));
-            style.setHeight(Length(viewportSize.height(), Fixed));
-        }
     } else {
         adjustStyleForFirstLetter(style);
     }
diff --git a/third_party/WebKit/Source/core/css/resolver/StyleResolver.cpp b/third_party/WebKit/Source/core/css/resolver/StyleResolver.cpp
index d98cbd8..21f7797 100644
--- a/third_party/WebKit/Source/core/css/resolver/StyleResolver.cpp
+++ b/third_party/WebKit/Source/core/css/resolver/StyleResolver.cpp
@@ -887,10 +887,7 @@ PseudoElement* StyleResolver::createPseudoElementIfNeeded(Element& parent, Pseud
     if (pseudoId == PseudoIdFirstLetter && (parent.isSVGElement() || !FirstLetterPseudoElement::firstLetterTextLayoutObject(parent)))
         return nullptr;
 
-    // The backdrop pseudo element generates a new stacking context and its
-    // layout object does not become a child of |parentLayoutObject|. The
-    // exemption is needed so that replaced content also gets a backdrop.
-    if (pseudoId != PseudoIdBackdrop && !canHaveGeneratedChildren(*parentLayoutObject))
+    if (!canHaveGeneratedChildren(*parentLayoutObject))
         return nullptr;
 
     ComputedStyle* parentStyle = parentLayoutObject->mutableStyle();
diff --git a/third_party/WebKit/Source/core/dom/Document.cpp b/third_party/WebKit/Source/core/dom/Document.cpp
index 246b1ca..611489e 100644
--- a/third_party/WebKit/Source/core/dom/Document.cpp
+++ b/third_party/WebKit/Source/core/dom/Document.cpp
@@ -26,6 +26,7 @@
  */
 
 #include "core/dom/Document.h"
+#include "core/events/ErrorEvent.h"
 
 #include "bindings/core/v8/DOMDataStore.h"
 #include "bindings/core/v8/ExceptionMessages.h"
@@ -120,11 +121,13 @@
 #include "core/editing/serializers/Serialization.h"
 #include "core/editing/spellcheck/SpellChecker.h"
 #include "core/events/BeforeUnloadEvent.h"
+#include "core/events/ErrorEvent.h"
 #include "core/events/Event.h"
 #include "core/events/EventFactory.h"
 #include "core/events/EventListener.h"
 #include "core/events/HashChangeEvent.h"
 #include "core/events/PageTransitionEvent.h"
+#include "core/events/RequestedVisibilityEvent.h"
 #include "core/events/ScopedEventQueue.h"
 #include "core/fetch/ResourceFetcher.h"
 #include "core/frame/DOMTimer.h"
@@ -182,6 +185,7 @@
 #include "core/layout/LayoutView.h"
 #include "core/layout/TextAutosizer.h"
 #include "core/layout/api/LayoutViewItem.h"
+#include "core/layout/compositing/CompositedLayerMapping.h"
 #include "core/layout/compositing/PaintLayerCompositor.h"
 #include "core/loader/CookieJar.h"
 #include "core/loader/DocumentLoader.h"
@@ -207,6 +211,9 @@
 #include "core/svg/SVGScriptElement.h"
 #include "core/svg/SVGTitleElement.h"
 #include "core/svg/SVGUseElement.h"
+#include "core/testing/Internals.h"
+#include "core/testing/InternalRuntimeFlags.h"
+#include "core/testing/InternalSettings.h"
 #include "core/timing/DOMWindowPerformance.h"
 #include "core/timing/Performance.h"
 #include "core/workers/SharedWorkerRepositoryClient.h"
@@ -389,6 +396,8 @@ Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC
     , m_domWindow(m_frame ? m_frame->localDOMWindow() : 0)
     , m_importsController(initializer.importsController())
     , m_contextFeatures(ContextFeatures::defaultSwitch())
+    , m_requestedVisibility(new VisibilityDocumentSet())
+    , m_requestVisibilityRect(nullptr)
     , m_wellFormed(false)
     , m_printing(false)
     , m_wasPrinting(false)
@@ -3897,6 +3906,14 @@ void Document::enqueueAnimationFrameEvent(Event* event)
     ensureScriptedAnimationController().enqueueEvent(event);
 }
 
+void Document::enqueueRequestedVisibilityEvent(const String& msg)
+{
+    RequestedVisibilityEvent* event = RequestedVisibilityEvent::create(msg);
+    event->setType(EventTypeNames::requestedvisibility);
+    event->setTarget(documentElement());
+    ensureScriptedAnimationController().enqueueEvent(event);
+}
+
 void Document::enqueueUniqueAnimationFrameEvent(Event* event)
 {
     ensureScriptedAnimationController().enqueuePerFrameEvent(event);
@@ -5309,12 +5326,9 @@ void Document::removeFromTopLayer(Element* element)
 
 HTMLDialogElement* Document::activeModalDialog() const
 {
-    for (auto it = m_topLayerElements.rbegin(); it != m_topLayerElements.rend(); ++it) {
-        if (isHTMLDialogElement(*it))
-            return toHTMLDialogElement((*it).get());
-    }
-
-    return nullptr;
+    if (m_topLayerElements.isEmpty())
+        return 0;
+    return toHTMLDialogElement(m_topLayerElements.last().get());
 }
 
 void Document::exitPointerLock()
@@ -5799,6 +5813,121 @@ bool Document::hasFocus() const
     return page() && page()->focusController().isDocumentFocused(*this);
 }
 
+VisibilityDocumentSet *Document::requestedVisibility() {
+    return m_requestedVisibility;
+}
+
+void Document::requestVisibility(){
+    // Set attribute.
+    this->documentElement()->setAttribute("requestVisibility", "1", ASSERT_NO_EXCEPTION);
+}
+
+void Document::requestVisibilityImpl(){
+    // Step 1:  Block obvious failure modes.  Probably insert SVG test here?
+    if(this->domWindow() == this->domWindow()->top()) {return;}
+
+    // Step 2:  Collect useful handles
+    DOMWindow *testWindow = this->domWindow();
+    PaintLayer* iframePaintLayer = this->documentElement()->layoutObject()->enclosingLayer();
+
+    if(!iframePaintLayer) { return; }
+    GraphicsLayer* iframeGraphicsLayer = iframePaintLayer->graphicsLayerBacking();
+    const PaintLayer* rootPaintLayer = this->domWindow()->top()->document()->body()->layoutObject()->enclosingLayer()->root(); // XXX DMK top scrolling layer
+    GraphicsLayer* rootGraphicsLayer = rootPaintLayer->graphicsLayerBacking();
+    if(!iframeGraphicsLayer || !rootGraphicsLayer) {
+        addConsoleMessage(ConsoleMessage::create(RenderingMessageSource, ErrorMessageLevel, "Couldn't find required GraphicsLayer.  One may not have been created for this document."));
+        return;
+    }
+    // Step 3:  Discover our effective Bounds.  We are effectively trying to compute the "keyhole" that reaches us,
+    //          through multiple iframes and scroll/translateX values.  The "sacred" transform is position and size.
+    //          This is presently being done via boundsInViewportSpace, which works through almost everything.
+    //          Almost.  (Scale3d needs to be corrected for, or rejected.)
+
+    IntRect bounds = this->documentElement()->boundsInViewport();
+    IntRect origBounds = bounds;
+
+    testWindow = this->domWindow();
+    float sx, sy;
+    sx=sy=0;
+    bool moreElements=true;
+    Element *testElement = this->documentElement();
+    Document *testDocument = this;
+
+    bool do_move = true;
+    bool hostile=false;
+    while(moreElements){
+        if(testDocument->documentElement()==testElement){
+            testElement=testDocument->domWindow()->frameElement();
+            testDocument=&testElement->document();
+            sx+=testWindow->scrollX();
+            sy+=testWindow->scrollY();
+            testWindow=testWindow->parent();
+        } else {
+            testElement=testElement->parentElement();
+        }
+        // HACK!! Remove use of childrenClipRect
+        IntRect child = IntRect(testElement->layoutObject()->enclosingLayer()->clipper().childrenClipRect());
+        if(testElement->tagName()=="foreignObject"){
+            hostile=true;
+        }
+        if(testElement->tagName()=="IFRAME") {
+            IntRect ifrBounds = testElement->boundsInViewport();
+            child.setWidth(fmin(ifrBounds.size().width(), child.size().width()));
+            child.setHeight(fmin(ifrBounds.size().height(), child.size().height()));
+        }
+        bounds.intersect(child);
+        if(testElement == this->domWindow()->top()->document()->documentElement()) {
+            moreElements=false;
+        }
+    }
+    // intersect with visible viewport.  XXX stop using IntRect, start using FloatRect
+    FrameView *mainFrameView = this->page()->deprecatedLocalMainFrame()->view();
+    LayoutRect mainViewRect = mainFrameView->layoutView()->viewRect();
+    IntRect mainViewIntRect = IntRect(mainViewRect);
+    bounds.intersect(mainViewIntRect);
+
+    FloatRect mainViewFloatRect = FloatRect(mainViewRect);
+    if(!bounds.size().width() || !bounds.size().height()) do_move=false;
+    // XXX for each registered visibility req, look for collisions with us, if so block the raise
+    VisibilityDocumentSet *ds = this->domWindow()->top()->document()->requestedVisibility();
+
+    for(Document *reqdoc : *ds){
+        if(reqdoc == this) break; // maybe this is right?
+        if(reqdoc->m_requestVisibilityRect && reqdoc->m_requestVisibilityRect->intersects(bounds)) {
+            // XXX DMK better would be to run bounds.subtract but then there'd have to *be* a bounds.subtract method.
+            //         Also, subtraction is a not quite so defined as intersection.  Largest contiguous from 0,0?
+            //         Largest contiguous from any corner?  God forbid, pile-o-rects?  Let's just run for the hills for now
+            hostile=true;
+            //return;  // there is a rather fun attack if you try this
+        }
+    }
+
+    if(hostile){
+        do_move=false;
+        bounds.setWidth(0);
+        bounds.setHeight(0);
+    }
+    if(this->documentElement()->hasAttribute("visibilityOnly")) { do_move=false; } // XXX DMK expand on this, there are uses
+    if (do_move) {
+        FloatRect fbounds = bounds;
+        this->set_requestVisibilityRect(&fbounds);
+        rootGraphicsLayer->addChild(iframeGraphicsLayer);
+        iframeGraphicsLayer->setPosition(FloatPoint(bounds.x(), bounds.y()));
+        iframeGraphicsLayer->setSize(FloatSize(bounds.size().width(), bounds.size().height()));
+        iframeGraphicsLayer->setBackgroundColor(Color::black);
+        iframeGraphicsLayer->setMasksToBounds(true);
+        iframeGraphicsLayer->setOpacity(1.0);
+        IntSize offset = IntSize(bounds.x()-origBounds.x()-topDocument().domWindow()->scrollX(), bounds.y()-origBounds.y()-topDocument().domWindow()->scrollY());
+        iframeGraphicsLayer->setOffsetFromLayoutObject(offset, GraphicsLayer::ShouldSetNeedsDisplay::SetNeedsDisplay);// const IntSize & offset,ShouldSetNeedsDisplay shouldSetNeedsDisplay)
+    }
+    // report.  sx and sy are
+    bounds.setWidth(fmax(bounds.size().width() - sx, 0));
+    bounds.setHeight(fmax(bounds.size().height()- sy, 0));
+    //XXX DMK correctly integrate ancestorOrigins and return a clientRect for the visible region of the frame
+    String s = String("{\"viewport\": {\"x\": " + String::number((int)mainViewFloatRect.x()) + ", \"y\": " + String::number((int)mainViewFloatRect.y()) + ", \"width\": " + String::number((int)mainViewFloatRect.size().width()) + ", \"height\": " + String::number((int)mainViewFloatRect.size().height()) + "},  \"visible\": {\"x\": " + String::number((int)bounds.x()) + ",  \"y\": " + String::number((int)bounds.y()) + ", \"width\": " + String::number((int)bounds.size().width()) + ", \"height\": " + String::number((int)bounds.size().height()) + "}}");
+    this->enqueueRequestedVisibilityEvent(s);
+};
+
 template<unsigned type>
 bool shouldInvalidateNodeListCachesForAttr(const HeapHashSet<WeakMember<const LiveNodeListBase>> nodeLists[], const QualifiedName& attrName)
 {
@@ -5981,6 +6110,7 @@ DEFINE_TRACE(Document)
     visitor->trace(m_intersectionObserverController);
     visitor->trace(m_intersectionObserverData);
     visitor->trace(m_snapCoordinator);
+    visitor->trace(m_requestedVisibility);
     Supplementable<Document>::trace(visitor);
     TreeScope::trace(visitor);
     ContainerNode::trace(visitor);
diff --git a/third_party/WebKit/Source/core/dom/Document.h b/third_party/WebKit/Source/core/dom/Document.h
index d2edfcd..22c1435 100644
--- a/third_party/WebKit/Source/core/dom/Document.h
+++ b/third_party/WebKit/Source/core/dom/Document.h
@@ -176,6 +176,7 @@ struct AnnotatedRegionValue;
 struct FocusParams;
 struct IconURL;
 
+using VisibilityDocumentSet = HeapHashSet<WeakMember<Document>>;
 using MouseEventWithHitTestResults = EventWithHitTestResults<PlatformMouseEvent>;
 using ExceptionCode = int;
 
@@ -707,6 +708,8 @@ public:
     IntersectionObserverController& ensureIntersectionObserverController();
     NodeIntersectionObserverData& ensureIntersectionObserverData();
 
+    VisibilityDocumentSet *requestedVisibility();
+
     void updateViewportDescription();
 
     // Returns the owning element in the parent document. Returns nullptr if
@@ -922,6 +925,7 @@ public:
     void enqueueMediaQueryChangeListeners(HeapVector<Member<MediaQueryListListener>>&);
     void enqueueVisualViewportScrollEvent();
     void enqueueVisualViewportResizeEvent();
+    void enqueueRequestedVisibilityEvent(const String&);
 
     void dispatchEventsForPrinting();
 
@@ -1092,6 +1096,10 @@ public:
 
     bool isInMainFrame() const;
 
+    void set_requestVisibilityRect(FloatRect *r) { m_requestVisibilityRect = r; }
+    void requestVisibility();
+    void requestVisibilityImpl();
+
 protected:
     Document(const DocumentInit&, DocumentClassFlags = DefaultDocumentClass);
 
@@ -1204,6 +1212,9 @@ private:
     Member<DocumentParser> m_parser;
     Member<ContextFeatures> m_contextFeatures;
 
+    Member<VisibilityDocumentSet> m_requestedVisibility;
+    FloatRect *m_requestVisibilityRect;
+
     bool m_wellFormed;
 
     // Document URLs.
@@ -1349,8 +1360,6 @@ private:
 
     bool m_hasFullscreenSupplement; // For early return in Fullscreen::fromIfExists()
 
-    // The last element in |m_topLayerElements| is topmost in the top layer
-    // stack and is thus the one that will be visually on top.
     HeapVector<Member<Element>> m_topLayerElements;
 
     int m_loadEventDelayCount;
diff --git a/third_party/WebKit/Source/core/dom/Document.idl b/third_party/WebKit/Source/core/dom/Document.idl
index fdd8b9c..626697b 100644
--- a/third_party/WebKit/Source/core/dom/Document.idl
+++ b/third_party/WebKit/Source/core/dom/Document.idl
@@ -54,6 +54,9 @@ interface Document : Node {
     HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);
     HTMLCollection getElementsByClassName(DOMString classNames);
 
+    void requestVisibility();
+    void requestVisibilityImpl();
+
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, PerWorldBindings, RaisesException] Element createElement(DOMString localName);
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, RaisesException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName);
     [NewObject] DocumentFragment createDocumentFragment();
diff --git a/third_party/WebKit/Source/core/dom/Element.cpp b/third_party/WebKit/Source/core/dom/Element.cpp
index b35cf91..1a0e024 100644
--- a/third_party/WebKit/Source/core/dom/Element.cpp
+++ b/third_party/WebKit/Source/core/dom/Element.cpp
@@ -3636,7 +3636,7 @@ void Element::addPropertyToPresentationAttributeStyle(MutableStylePropertySet* s
     style->setProperty(propertyID, value, false);
 }
 
-void Element::addPropertyToPresentationAttributeStyle(MutableStylePropertySet* style, CSSPropertyID propertyID, const CSSValue* value)
+void Element::addPropertyToPresentationAttributeStyle(MutableStylePropertySet*  style, CSSPropertyID propertyID, CSSValue* value)
 {
     DCHECK(isStyledElement());
     style->setProperty(propertyID, value);
diff --git a/third_party/WebKit/Source/core/dom/Element.h b/third_party/WebKit/Source/core/dom/Element.h
index 6d27407..1f21fca 100644
--- a/third_party/WebKit/Source/core/dom/Element.h
+++ b/third_party/WebKit/Source/core/dom/Element.h
@@ -587,7 +587,7 @@ protected:
     void addPropertyToPresentationAttributeStyle(MutableStylePropertySet*, CSSPropertyID, CSSValueID identifier);
     void addPropertyToPresentationAttributeStyle(MutableStylePropertySet*, CSSPropertyID, double value, CSSPrimitiveValue::UnitType);
     void addPropertyToPresentationAttributeStyle(MutableStylePropertySet*, CSSPropertyID, const String& value);
-    void addPropertyToPresentationAttributeStyle(MutableStylePropertySet*, CSSPropertyID, const CSSValue*);
+    void addPropertyToPresentationAttributeStyle(MutableStylePropertySet*, CSSPropertyID, CSSValue*);
 
     InsertionNotificationRequest insertedInto(ContainerNode*) override;
     void removedFrom(ContainerNode*) override;
diff --git a/third_party/WebKit/Source/core/dom/Fullscreen.cpp b/third_party/WebKit/Source/core/dom/Fullscreen.cpp
index fcc3315..0c73478 100644
--- a/third_party/WebKit/Source/core/dom/Fullscreen.cpp
+++ b/third_party/WebKit/Source/core/dom/Fullscreen.cpp
@@ -27,7 +27,6 @@
 
 #include "core/dom/Fullscreen.h"
 
-#include "bindings/core/v8/ExceptionMessages.h"
 #include "core/HTMLNames.h"
 #include "core/dom/Document.h"
 #include "core/dom/ElementTraversal.h"
@@ -43,9 +42,10 @@
 #include "core/html/HTMLMediaElement.h"
 #include "core/input/EventHandler.h"
 #include "core/inspector/ConsoleMessage.h"
+#include "core/layout/LayoutBlockFlow.h"
+#include "core/layout/LayoutFullScreen.h"
+#include "core/layout/api/LayoutFullScreenItem.h"
 #include "core/page/ChromeClient.h"
-#include "core/page/Page.h"
-#include "core/style/ComputedStyle.h"
 #include "platform/UserGestureIndicator.h"
 
 namespace blink {
@@ -196,6 +196,7 @@ bool Fullscreen::isFullScreen(Document& document)
 
 Fullscreen::Fullscreen(Document& document)
     : ContextLifecycleObserver(&document)
+    , m_fullScreenLayoutObject(nullptr)
     , m_eventQueueTimer(this, &Fullscreen::eventQueueTimerFired)
     , m_forCrossProcessDescendant(false)
 {
@@ -215,6 +216,9 @@ void Fullscreen::contextDestroyed()
 {
     m_eventQueue.clear();
 
+    if (m_fullScreenLayoutObject)
+        m_fullScreenLayoutObject->destroy();
+
     m_fullScreenElement = nullptr;
     m_fullScreenElementStack.clear();
 
@@ -482,13 +486,31 @@ bool Fullscreen::fullscreenEnabled(Document& document)
 void Fullscreen::didEnterFullscreenForElement(Element* element)
 {
     DCHECK(element);
-    DCHECK(element->isInTopLayer());
-
     if (!document()->isActive())
         return;
 
+    if (m_fullScreenLayoutObject)
+        m_fullScreenLayoutObject->unwrapLayoutObject();
+
     m_fullScreenElement = element;
 
+    // Create a placeholder block for a the full-screen element, to keep the page from reflowing
+    // when the element is removed from the normal flow. Only do this for a LayoutBox, as only
+    // a box will have a frameRect. The placeholder will be created in setFullScreenLayoutObject()
+    // during layout.
+    LayoutObject* layoutObject = m_fullScreenElement->layoutObject();
+    bool shouldCreatePlaceholder = layoutObject && layoutObject->isBox();
+    if (shouldCreatePlaceholder) {
+        m_savedPlaceholderFrameRect = toLayoutBox(layoutObject)->frameRect();
+        m_savedPlaceholderComputedStyle = ComputedStyle::clone(layoutObject->styleRef());
+    }
+
+    // TODO(alexmos): When |m_forCrossProcessDescendant| is true, some of
+    // this layout work has already been done in another process, so it should
+    // not be necessary to repeat it here.
+    if (m_fullScreenElement != document()->documentElement())
+        LayoutFullScreen::wrapLayoutObject(layoutObject, layoutObject ? layoutObject->parent() : 0, document());
+
     // When |m_forCrossProcessDescendant| is true, m_fullScreenElement
     // corresponds to the HTMLFrameOwnerElement for the out-of-process iframe
     // that contains the actual fullscreen element.   Hence, it must also set
@@ -524,7 +546,6 @@ void Fullscreen::didExitFullscreen()
     if (!document()->isActive())
         return;
 
-    document()->removeFromTopLayer(m_fullScreenElement.get());
     m_fullScreenElement->willStopBeingFullscreenElement();
 
     if (m_forCrossProcessDescendant)
@@ -532,6 +553,9 @@ void Fullscreen::didExitFullscreen()
 
     m_fullScreenElement->setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
 
+    if (m_fullScreenLayoutObject)
+        LayoutFullScreenItem(m_fullScreenLayoutObject).unwrapLayoutObject();
+
     document()->styleEngine().ensureFullscreenUAStyle();
     m_fullScreenElement->pseudoStateChanged(CSSSelector::PseudoFullScreen);
     m_fullScreenElement = nullptr;
@@ -551,12 +575,28 @@ void Fullscreen::didExitFullscreen()
     m_forCrossProcessDescendant = false;
 }
 
-void Fullscreen::didUpdateSize(Element& element)
+void Fullscreen::setFullScreenLayoutObject(LayoutFullScreen* layoutObject)
+{
+    if (layoutObject == m_fullScreenLayoutObject)
+        return;
+
+    if (layoutObject && m_savedPlaceholderComputedStyle) {
+        layoutObject->createPlaceholder(m_savedPlaceholderComputedStyle.release(), m_savedPlaceholderFrameRect);
+    } else if (layoutObject && m_fullScreenLayoutObject && m_fullScreenLayoutObject->placeholder()) {
+        LayoutBlockFlow* placeholder = m_fullScreenLayoutObject->placeholder();
+        layoutObject->createPlaceholder(ComputedStyle::clone(placeholder->styleRef()), placeholder->frameRect());
+    }
+
+    if (m_fullScreenLayoutObject)
+        m_fullScreenLayoutObject->unwrapLayoutObject();
+    DCHECK(!m_fullScreenLayoutObject);
+
+    m_fullScreenLayoutObject = layoutObject;
+}
+
+void Fullscreen::fullScreenLayoutObjectDestroyed()
 {
-    // StyleAdjuster will set the size so we need to do a style recalc.
-    // Normally changing size means layout so just doing a style recalc is a
-    // bit surprising.
-    element.setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::create(StyleChangeReason::FullScreen));
+    m_fullScreenLayoutObject = nullptr;
 }
 
 void Fullscreen::enqueueChangeEvent(Document& document, RequestType requestType)
@@ -641,14 +681,12 @@ void Fullscreen::popFullscreenElementStack()
     if (m_fullScreenElementStack.isEmpty())
         return;
 
-    document()->removeFromTopLayer(m_fullScreenElementStack.last().first.get());
     m_fullScreenElementStack.removeLast();
 }
 
 void Fullscreen::pushFullscreenElementStack(Element& element, RequestType requestType)
 {
     m_fullScreenElementStack.append(std::make_pair(&element, requestType));
-    document()->addToTopLayer(&element);
 }
 
 DEFINE_TRACE(Fullscreen)
diff --git a/third_party/WebKit/Source/core/dom/Fullscreen.h b/third_party/WebKit/Source/core/dom/Fullscreen.h
index 9aa7ead..b67a4a9 100644
--- a/third_party/WebKit/Source/core/dom/Fullscreen.h
+++ b/third_party/WebKit/Source/core/dom/Fullscreen.h
@@ -41,6 +41,7 @@
 
 namespace blink {
 
+class LayoutFullScreen;
 class ComputedStyle;
 
 class CORE_EXPORT Fullscreen final
@@ -80,7 +81,9 @@ public:
     void didEnterFullscreenForElement(Element*);
     void didExitFullscreen();
 
-    void didUpdateSize(Element&);
+    void setFullScreenLayoutObject(LayoutFullScreen*);
+    LayoutFullScreen* fullScreenLayoutObject() const { return m_fullScreenLayoutObject; }
+    void fullScreenLayoutObjectDestroyed();
 
     void elementRemoved(Element&);
 
@@ -97,9 +100,6 @@ public:
 
     DECLARE_VIRTUAL_TRACE();
 
-    using ElementStack = HeapVector<std::pair<Member<Element>, RequestType>>;
-    const ElementStack& fullScreenElementStack() const { return m_fullScreenElementStack; }
-
 private:
     static Fullscreen* fromIfExistsSlow(Document&);
 
@@ -117,6 +117,7 @@ private:
 
     Member<Element> m_fullScreenElement;
     HeapVector<std::pair<Member<Element>, RequestType>> m_fullScreenElementStack;
+    LayoutFullScreen* m_fullScreenLayoutObject;
     Timer<Fullscreen> m_eventQueueTimer;
     HeapDeque<Member<Event>> m_eventQueue;
     LayoutRect m_savedPlaceholderFrameRect;
diff --git a/third_party/WebKit/Source/core/dom/LayoutTreeBuilder.cpp b/third_party/WebKit/Source/core/dom/LayoutTreeBuilder.cpp
index cc531b3..1beefc5 100644
--- a/third_party/WebKit/Source/core/dom/LayoutTreeBuilder.cpp
+++ b/third_party/WebKit/Source/core/dom/LayoutTreeBuilder.cpp
@@ -34,6 +34,7 @@
 #include "core/dom/PseudoElement.h"
 #include "core/dom/Text.h"
 #include "core/dom/shadow/InsertionPoint.h"
+#include "core/layout/LayoutFullScreen.h"
 #include "core/layout/LayoutObject.h"
 #include "core/layout/LayoutText.h"
 #include "core/layout/LayoutView.h"
@@ -134,6 +135,12 @@ void LayoutTreeBuilderForElement::createLayoutObject()
     m_node->setLayoutObject(newLayoutObject);
     newLayoutObject->setStyle(&style); // setStyle() can depend on layoutObject() already being set.
 
+    if (Fullscreen::isActiveFullScreenElement(*m_node)) {
+        newLayoutObject = LayoutFullScreen::wrapLayoutObject(newLayoutObject, parentLayoutObject, &m_node->document());
+        if (!newLayoutObject)
+            return;
+    }
+
     // Note: Adding newLayoutObject instead of layoutObject(). layoutObject() may be a child of newLayoutObject.
     parentLayoutObject->addChild(newLayoutObject, nextLayoutObject);
 }
diff --git a/third_party/WebKit/Source/core/dom/MessagePort.cpp b/third_party/WebKit/Source/core/dom/MessagePort.cpp
index 567c32d..92e9fac 100644
--- a/third_party/WebKit/Source/core/dom/MessagePort.cpp
+++ b/third_party/WebKit/Source/core/dom/MessagePort.cpp
@@ -62,7 +62,7 @@ MessagePort::MessagePort(ExecutionContext& executionContext)
 
 MessagePort::~MessagePort()
 {
-    DCHECK(!m_started || !isEntangled());
+    close();
     if (m_scriptStateForConversion)
         m_scriptStateForConversion->disposePerContextData();
 }
@@ -117,7 +117,7 @@ MessagePortArray* MessagePort::toMessagePortArray(ExecutionContext* context, con
 WebMessagePortChannelUniquePtr MessagePort::disentangle()
 {
     DCHECK(m_entangledChannel);
-    m_entangledChannel->setClient(nullptr);
+    m_entangledChannel->setClient(0);
     return std::move(m_entangledChannel);
 }
 
@@ -139,7 +139,6 @@ void MessagePort::start()
     if (m_started)
         return;
 
-    m_entangledChannel->setClient(this);
     m_started = true;
     messageAvailable();
 }
@@ -147,7 +146,7 @@ void MessagePort::start()
 void MessagePort::close()
 {
     if (isEntangled())
-        m_entangledChannel->setClient(nullptr);
+        m_entangledChannel->setClient(0);
     m_closed = true;
 }
 
@@ -158,6 +157,7 @@ void MessagePort::entangle(WebMessagePortChannelUniquePtr remote)
     DCHECK(getExecutionContext());
 
     m_entangledChannel = std::move(remote);
+    m_entangledChannel->setClient(this);
 }
 
 const AtomicString& MessagePort::interfaceName() const
diff --git a/third_party/WebKit/Source/core/dom/Node.cpp b/third_party/WebKit/Source/core/dom/Node.cpp
index 64c7afe..d830fe9 100644
--- a/third_party/WebKit/Source/core/dom/Node.cpp
+++ b/third_party/WebKit/Source/core/dom/Node.cpp
@@ -557,6 +557,10 @@ bool Node::hasEditableStyle(EditableLevel editableLevel, UserSelectAllTreatment
 
     for (const Node& node : NodeTraversal::inclusiveAncestorsOf(*this)) {
         if ((node.isHTMLElement() || node.isDocumentNode()) && node.layoutObject()) {
+            // Elements with user-select: all style are considered atomic
+            // therefore non editable.
+            if (nodeIsUserSelectAll(&node) && treatment == UserSelectAllIsAlwaysNonEditable)
+                return false;
             switch (node.layoutObject()->style()->userModify()) {
             case READ_ONLY:
                 return false;
diff --git a/third_party/WebKit/Source/core/dom/PseudoElement.cpp b/third_party/WebKit/Source/core/dom/PseudoElement.cpp
index 424e89e..1672b86 100644
--- a/third_party/WebKit/Source/core/dom/PseudoElement.cpp
+++ b/third_party/WebKit/Source/core/dom/PseudoElement.cpp
@@ -29,7 +29,6 @@
 #include "core/dom/FirstLetterPseudoElement.h"
 #include "core/frame/UseCounter.h"
 #include "core/inspector/InspectorInstrumentation.h"
-#include "core/layout/GeneratedChildren.h"
 #include "core/layout/LayoutObject.h"
 #include "core/layout/LayoutQuote.h"
 #include "core/style/ContentData.h"
@@ -125,13 +124,6 @@ void PseudoElement::attach(const AttachContext& context)
     if (!layoutObject)
         return;
 
-    // This is to ensure that bypassing the canHaveGeneratedChildren check in
-    // StyleResolver::createPseudoElementIfNeeded does not result in the
-    // backdrop pseudo element's layout object becoming the child of a layout
-    // object that doesn't allow children.
-    DCHECK(layoutObject->parent());
-    DCHECK(canHaveGeneratedChildren(*layoutObject->parent()));
-
     ComputedStyle& style = layoutObject->mutableStyleRef();
     if (style.styleType() != PseudoIdBefore && style.styleType() != PseudoIdAfter)
         return;
diff --git a/third_party/WebKit/Source/core/editing/EditingStyle.cpp b/third_party/WebKit/Source/core/editing/EditingStyle.cpp
index a1d63ab..503a775 100644
--- a/third_party/WebKit/Source/core/editing/EditingStyle.cpp
+++ b/third_party/WebKit/Source/core/editing/EditingStyle.cpp
@@ -1249,10 +1249,6 @@ void EditingStyle::removeStyleFromRulesAndContext(Element* element, ContainerNod
     if (!m_mutableStyle)
         return;
 
-    // TODO(yosin): The use of updateStyleAndLayoutIgnorePendingStylesheets
-    // needs to be audited. see http://crbug.com/590369 for more details.
-    element->document().updateStyleAndLayoutIgnorePendingStylesheetsForNode(element);
-
     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
     MutableStylePropertySet* styleFromMatchedRules = styleFromMatchedRulesForElement(element, StyleResolver::AllButEmptyCSSRules);
     if (styleFromMatchedRules && !styleFromMatchedRules->isEmpty())
diff --git a/third_party/WebKit/Source/core/editing/SelectionController.cpp b/third_party/WebKit/Source/core/editing/SelectionController.cpp
index c6fe984..f29f07d 100644
--- a/third_party/WebKit/Source/core/editing/SelectionController.cpp
+++ b/third_party/WebKit/Source/core/editing/SelectionController.cpp
@@ -87,10 +87,6 @@ VisibleSelectionInFlatTree expandSelectionToRespectUserSelectAll(Node* targetNod
     Node* rootUserSelectAll = EditingInFlatTreeStrategy::rootUserSelectAllForNode(targetNode);
     if (!rootUserSelectAll)
         return selection;
-    if (rootUserSelectAll->isHTMLElement() && toHTMLElement(rootUserSelectAll)->isTextFormControl())
-        return selection;
-    if (rootUserSelectAll->layoutObject()->style()->userModify() != READ_ONLY)
-        return selection;
 
     VisibleSelectionInFlatTree newSelection(selection);
     newSelection.setBase(mostBackwardCaretPosition(PositionInFlatTree::beforeNode(rootUserSelectAll), CanCrossEditingBoundary));
diff --git a/third_party/WebKit/Source/core/events/EventTypeNames.in b/third_party/WebKit/Source/core/events/EventTypeNames.in
index f86ff7e..e9ccbac 100644
--- a/third_party/WebKit/Source/core/events/EventTypeNames.in
+++ b/third_party/WebKit/Source/core/events/EventTypeNames.in
@@ -186,6 +186,7 @@ removesourcebuffer
 removestream
 removetrack
 repeatEvent
+requestedvisibility
 reset
 resize
 resourcetimingbufferfull
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp
new file mode 100644
index 0000000..5f17327
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "core/events/RequestedVisibilityEvent.h"
+
+#include "bindings/core/v8/V8Binding.h"
+#include <v8.h>
+
+namespace blink {
+
+RequestedVisibilityEvent::RequestedVisibilityEvent()
+    : m_sanitizedMessage()
+{
+}
+
+RequestedVisibilityEvent::RequestedVisibilityEvent(const AtomicString& type, const RequestedVisibilityEventInit& initializer)
+    : Event(type, initializer)
+    , m_sanitizedMessage()
+{
+    if (initializer.hasMessage())
+        m_sanitizedMessage = initializer.message();
+}
+
+RequestedVisibilityEvent::RequestedVisibilityEvent(const String& message)
+    : Event(EventTypeNames::error, false, true)
+    , m_sanitizedMessage(message)
+{
+}
+
+void RequestedVisibilityEvent::setUnsanitizedMessage(const String& message)
+{
+    ASSERT(m_unsanitizedMessage.isEmpty());
+    m_unsanitizedMessage = message;
+}
+
+RequestedVisibilityEvent::~RequestedVisibilityEvent()
+{
+}
+
+const AtomicString& RequestedVisibilityEvent::interfaceName() const
+{
+    return EventNames::RequestedVisibilityEvent;
+}
+
+DEFINE_TRACE(RequestedVisibilityEvent)
+{
+    Event::trace(visitor);
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h
new file mode 100644
index 0000000..0f200b8
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RequestedVisibilityEvent_h
+#define RequestedVisibilityEvent_h
+
+#include "bindings/core/v8/DOMWrapperWorld.h"
+#include "bindings/core/v8/SourceLocation.h"
+#include "core/events/RequestedVisibilityEventInit.h"
+#include "core/events/Event.h"
+#include "wtf/RefPtr.h"
+#include "wtf/text/WTFString.h"
+
+namespace blink {
+
+class RequestedVisibilityEvent final : public Event {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    static RequestedVisibilityEvent* create()
+    {
+        return new RequestedVisibilityEvent;
+    }
+    static RequestedVisibilityEvent* create(const String& message)
+    {
+        return new RequestedVisibilityEvent(message);
+    }
+    static RequestedVisibilityEvent* create(const AtomicString& type, const RequestedVisibilityEventInit& initializer)
+    {
+        return new RequestedVisibilityEvent(type, initializer);
+    }
+
+    ~RequestedVisibilityEvent() override;
+
+    // As 'message' is exposed to JavaScript, never return unsanitizedMessage.
+    const String& message() const { return m_sanitizedMessage; }
+
+    // 'messageForConsole' is not exposed to JavaScript, and prefers 'm_unsanitizedMessage'.
+    const String& messageForConsole() const { return !m_unsanitizedMessage.isEmpty() ? m_unsanitizedMessage : m_sanitizedMessage; }
+
+    const AtomicString& interfaceName() const override;
+
+    void setUnsanitizedMessage(const String&);
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    RequestedVisibilityEvent();
+    RequestedVisibilityEvent(const String& message);
+    RequestedVisibilityEvent(const AtomicString&, const RequestedVisibilityEventInit&);
+
+    String m_unsanitizedMessage;
+    String m_sanitizedMessage;
+};
+
+} // namespace blink
+
+#endif // RequestedVisibilityEvent_h
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl
new file mode 100644
index 0000000..aae3453
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+[
+    Constructor(DOMString type, optional RequestedVisibilityEventInit eventInitDict),
+] interface RequestedVisibilityEvent : Event {
+    readonly attribute DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl b/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl
new file mode 100644
index 0000000..9d42ea9
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl
@@ -0,0 +1,7 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+dictionary RequestedVisibilityEventInit : EventInit {
+    DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/fetch/CSSStyleSheetResource.cpp b/third_party/WebKit/Source/core/fetch/CSSStyleSheetResource.cpp
index 26a3cb1..7781999 100644
--- a/third_party/WebKit/Source/core/fetch/CSSStyleSheetResource.cpp
+++ b/third_party/WebKit/Source/core/fetch/CSSStyleSheetResource.cpp
@@ -105,7 +105,7 @@ void CSSStyleSheetResource::checkNotify()
     if (m_data)
         m_decodedSheetText = decodedText();
 
-    ResourceClientWalker<StyleSheetResourceClient> w(clients());
+    ResourceClientWalker<StyleSheetResourceClient> w(m_clients);
     while (StyleSheetResourceClient* c = w.next())
         c->setCSSStyleSheet(m_resourceRequest.url(), m_response.url(), encoding(), this);
     // Clear the decoded text as it is unlikely to be needed immediately again and is cheap to regenerate.
diff --git a/third_party/WebKit/Source/core/fetch/FetchContext.cpp b/third_party/WebKit/Source/core/fetch/FetchContext.cpp
index 5429ade..ca03599 100644
--- a/third_party/WebKit/Source/core/fetch/FetchContext.cpp
+++ b/third_party/WebKit/Source/core/fetch/FetchContext.cpp
@@ -47,6 +47,10 @@ void FetchContext::addAdditionalRequestHeaders(ResourceRequest&, FetchResourceTy
 {
 }
 
+void FetchContext::setFirstPartyForCookies(ResourceRequest&)
+{
+}
+
 CachePolicy FetchContext::getCachePolicy() const
 {
     return CachePolicyVerify;
@@ -117,8 +121,4 @@ void FetchContext::addCSPHeaderIfNecessary(Resource::Type, FetchRequest&)
 {
 }
 
-void FetchContext::populateRequestData(ResourceRequest&)
-{
-}
-
 } // namespace blink
diff --git a/third_party/WebKit/Source/core/fetch/FetchContext.h b/third_party/WebKit/Source/core/fetch/FetchContext.h
index b3de9b7..7a8400f 100644
--- a/third_party/WebKit/Source/core/fetch/FetchContext.h
+++ b/third_party/WebKit/Source/core/fetch/FetchContext.h
@@ -71,6 +71,7 @@ public:
     virtual void countClientHintsViewportWidth() { }
 
     virtual void addAdditionalRequestHeaders(ResourceRequest&, FetchResourceType);
+    virtual void setFirstPartyForCookies(ResourceRequest&);
     virtual CachePolicy getCachePolicy() const;
     virtual WebCachePolicy resourceRequestCachePolicy(const ResourceRequest&, Resource::Type, FetchRequest::DeferOption) const;
 
@@ -106,7 +107,6 @@ public:
     virtual void upgradeInsecureRequest(ResourceRequest&);
     virtual void addClientHintsIfNecessary(FetchRequest&);
     virtual void addCSPHeaderIfNecessary(Resource::Type, FetchRequest&);
-    virtual void populateRequestData(ResourceRequest&);
 
     virtual MHTMLArchive* archive() const { return nullptr; }
 
diff --git a/third_party/WebKit/Source/core/fetch/FontResource.cpp b/third_party/WebKit/Source/core/fetch/FontResource.cpp
index 061af59..2483a03 100644
--- a/third_party/WebKit/Source/core/fetch/FontResource.cpp
+++ b/third_party/WebKit/Source/core/fetch/FontResource.cpp
@@ -151,7 +151,7 @@ void FontResource::fontLoadShortLimitCallback(Timer<FontResource>*)
         return;
     ASSERT(m_loadLimitState == UnderLimit);
     m_loadLimitState = ShortLimitExceeded;
-    ResourceClientWalker<FontResourceClient> walker(clients());
+    ResourceClientWalker<FontResourceClient> walker(m_clients);
     while (FontResourceClient* client = walker.next())
         client->fontLoadShortLimitExceeded(this);
 }
@@ -162,7 +162,7 @@ void FontResource::fontLoadLongLimitCallback(Timer<FontResource>*)
         return;
     ASSERT(m_loadLimitState == ShortLimitExceeded);
     m_loadLimitState = LongLimitExceeded;
-    ResourceClientWalker<FontResourceClient> walker(clients());
+    ResourceClientWalker<FontResourceClient> walker(m_clients);
     while (FontResourceClient* client = walker.next())
         client->fontLoadLongLimitExceeded(this);
 }
diff --git a/third_party/WebKit/Source/core/fetch/RawResource.cpp b/third_party/WebKit/Source/core/fetch/RawResource.cpp
index 2e40680..9498922 100644
--- a/third_party/WebKit/Source/core/fetch/RawResource.cpp
+++ b/third_party/WebKit/Source/core/fetch/RawResource.cpp
@@ -96,7 +96,7 @@ void RawResource::appendData(const char* data, size_t length)
 {
     Resource::appendData(data, length);
 
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->dataReceived(this, data, length);
 }
@@ -131,14 +131,14 @@ void RawResource::willFollowRedirect(ResourceRequest& newRequest, const Resource
     Resource::willFollowRedirect(newRequest, redirectResponse);
 
     ASSERT(!redirectResponse.isNull());
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->redirectReceived(this, newRequest, redirectResponse);
 }
 
 void RawResource::willNotFollowRedirect()
 {
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->redirectBlocked();
 }
@@ -148,7 +148,7 @@ void RawResource::responseReceived(const ResourceResponse& response, std::unique
     bool isSuccessfulRevalidation = isCacheValidator() && response.httpStatusCode() == 304;
     Resource::responseReceived(response, nullptr);
 
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     ASSERT(count() <= 1 || !handle);
     while (RawResourceClient* c = w.next()) {
         // |handle| is cleared when passed, but it's not a problem because
@@ -161,7 +161,7 @@ void RawResource::responseReceived(const ResourceResponse& response, std::unique
     // Note: |m_data| can be null when no data is appended to the original
     // resource.
     if (isSuccessfulRevalidation && m_data) {
-        ResourceClientWalker<RawResourceClient> w(clients());
+        ResourceClientWalker<RawResourceClient> w(m_clients);
         while (RawResourceClient* c = w.next())
             c->dataReceived(this, m_data->data(), m_data->size());
     }
@@ -170,28 +170,28 @@ void RawResource::responseReceived(const ResourceResponse& response, std::unique
 void RawResource::setSerializedCachedMetadata(const char* data, size_t size)
 {
     Resource::setSerializedCachedMetadata(data, size);
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->setSerializedCachedMetadata(this, data, size);
 }
 
 void RawResource::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 {
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->dataSent(this, bytesSent, totalBytesToBeSent);
 }
 
 void RawResource::didDownloadData(int dataLength)
 {
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->dataDownloaded(this, dataLength);
 }
 
 void RawResource::reportResourceTimingToClients(const ResourceTimingInfo& info)
 {
-    ResourceClientWalker<RawResourceClient> w(clients());
+    ResourceClientWalker<RawResourceClient> w(m_clients);
     while (RawResourceClient* c = w.next())
         c->didReceiveResourceTiming(this, info);
 }
@@ -228,7 +228,7 @@ static bool isCacheableHTTPMethod(const AtomicString& method)
 
 bool RawResource::canReuse(const ResourceRequest& newRequest) const
 {
-    if (dataBufferingPolicy() == DoNotBufferData)
+    if (m_options.dataBufferingPolicy == DoNotBufferData)
         return false;
 
     if (!isCacheableHTTPMethod(m_resourceRequest.httpMethod()))
diff --git a/third_party/WebKit/Source/core/fetch/Resource.cpp b/third_party/WebKit/Source/core/fetch/Resource.cpp
index 80db395..4a0065a 100644
--- a/third_party/WebKit/Source/core/fetch/Resource.cpp
+++ b/third_party/WebKit/Source/core/fetch/Resource.cpp
@@ -295,6 +295,9 @@ void Resource::ResourceCallback::runTask()
 
 Resource::Resource(const ResourceRequest& request, Type type, const ResourceLoaderOptions& options)
     : m_resourceRequest(request)
+    , m_options(options)
+    , m_responseTimestamp(currentTime())
+    , m_cancelTimer(this, &Resource::cancelTimerFired)
     , m_loadFinishTime(0)
     , m_identifier(0)
     , m_encodedSize(0)
@@ -309,9 +312,6 @@ Resource::Resource(const ResourceRequest& request, Type type, const ResourceLoad
     , m_needsSynchronousCacheHit(false)
     , m_linkPreload(false)
     , m_isRevalidating(false)
-    , m_options(options)
-    , m_responseTimestamp(currentTime())
-    , m_cancelTimer(this, &Resource::cancelTimerFired)
 {
     ASSERT(m_type == unsigned(type)); // m_type is a bitfield, so this tests careless updates of the enum.
     InstanceCounters::incrementCounter(InstanceCounters::ResourceCounter);
diff --git a/third_party/WebKit/Source/core/fetch/Resource.h b/third_party/WebKit/Source/core/fetch/Resource.h
index 259ca05..36a1f2a 100644
--- a/third_party/WebKit/Source/core/fetch/Resource.h
+++ b/third_party/WebKit/Source/core/fetch/Resource.h
@@ -262,6 +262,10 @@ protected:
     void didRemoveClientOrObserver();
     virtual void allClientsAndObserversRemoved();
 
+    HashCountedSet<ResourceClient*> m_clients;
+    HashCountedSet<ResourceClient*> m_clientsAwaitingCallback;
+    HashCountedSet<ResourceClient*> m_finishedClients;
+
     bool hasClient(ResourceClient* client) { return m_clients.contains(client) || m_clientsAwaitingCallback.contains(client) || m_finishedClients.contains(client); }
 
     struct RedirectPair {
@@ -286,15 +290,15 @@ protected:
     // Returns the memory dump name used for tracing. See Resource::onMemoryDump.
     String getMemoryDumpName() const;
 
-    const HashCountedSet<ResourceClient*>& clients() const { return m_clients; }
-    DataBufferingPolicy dataBufferingPolicy() const { return m_options.dataBufferingPolicy; }
-
     ResourceRequest m_resourceRequest;
     Member<ResourceLoader> m_loader;
+    ResourceLoaderOptions m_options;
 
     ResourceResponse m_response;
+    double m_responseTimestamp;
 
     RefPtr<SharedBuffer> m_data;
+    Timer<Resource> m_cancelTimer;
 
 private:
     class ResourceCallback;
@@ -344,16 +348,6 @@ private:
 
     // Ordered list of all redirects followed while fetching this resource.
     Vector<RedirectPair> m_redirectChain;
-
-    HashCountedSet<ResourceClient*> m_clients;
-    HashCountedSet<ResourceClient*> m_clientsAwaitingCallback;
-    HashCountedSet<ResourceClient*> m_finishedClients;
-
-    ResourceLoaderOptions m_options;
-
-    double m_responseTimestamp;
-
-    Timer<Resource> m_cancelTimer;
 };
 
 class ResourceFactory {
diff --git a/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp b/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp
index 57a9738..1255741 100644
--- a/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp
+++ b/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp
@@ -410,7 +410,6 @@ Resource* ResourceFetcher::requestResource(FetchRequest& request, const Resource
 {
     ASSERT(request.options().synchronousPolicy == RequestAsynchronously || factory.type() == Resource::Raw || factory.type() == Resource::XSLStyleSheet);
 
-    context().populateRequestData(request.mutableResourceRequest());
     if (request.resourceRequest().httpHeaderField("Upgrade-Insecure-Requests") != AtomicString("1"))
         context().upgradeInsecureRequest(request.mutableResourceRequest());
     context().addClientHintsIfNecessary(request);
diff --git a/third_party/WebKit/Source/core/fetch/ScriptResource.cpp b/third_party/WebKit/Source/core/fetch/ScriptResource.cpp
index 70bde66..bcb2faa 100644
--- a/third_party/WebKit/Source/core/fetch/ScriptResource.cpp
+++ b/third_party/WebKit/Source/core/fetch/ScriptResource.cpp
@@ -66,7 +66,7 @@ void ScriptResource::didAddClient(ResourceClient* client)
 void ScriptResource::appendData(const char* data, size_t length)
 {
     Resource::appendData(data, length);
-    ResourceClientWalker<ScriptResourceClient> walker(clients());
+    ResourceClientWalker<ScriptResourceClient> walker(m_clients);
     while (ScriptResourceClient* client = walker.next())
         client->notifyAppendData(this);
 }
diff --git a/third_party/WebKit/Source/core/fetch/XSLStyleSheetResource.cpp b/third_party/WebKit/Source/core/fetch/XSLStyleSheetResource.cpp
index 682b209..4f352d8 100644
--- a/third_party/WebKit/Source/core/fetch/XSLStyleSheetResource.cpp
+++ b/third_party/WebKit/Source/core/fetch/XSLStyleSheetResource.cpp
@@ -85,7 +85,7 @@ void XSLStyleSheetResource::checkNotify()
     if (m_data.get())
         m_sheet = decodedText();
 
-    ResourceClientWalker<StyleSheetResourceClient> w(clients());
+    ResourceClientWalker<StyleSheetResourceClient> w(m_clients);
     while (StyleSheetResourceClient* c = w.next())
         c->setXSLStyleSheet(m_resourceRequest.url(), m_response.url(), m_sheet);
 }
diff --git a/third_party/WebKit/Source/core/frame/FrameView.cpp b/third_party/WebKit/Source/core/frame/FrameView.cpp
index 9e64a98..9e04506 100644
--- a/third_party/WebKit/Source/core/frame/FrameView.cpp
+++ b/third_party/WebKit/Source/core/frame/FrameView.cpp
@@ -40,6 +40,7 @@
 #include "core/editing/markers/DocumentMarkerController.h"
 #include "core/fetch/ResourceFetcher.h"
 #include "core/frame/EventHandlerRegistry.h"
+#include "core/frame/FrameConsole.h"
 #include "core/frame/FrameHost.h"
 #include "core/frame/LocalFrame.h"
 #include "core/frame/Location.h"
@@ -1797,7 +1798,8 @@ void FrameView::clearLayoutSubtreeRootsAndMarkContainingBlocks()
 
 void FrameView::addOrthogonalWritingModeRoot(LayoutBox& root)
 {
-    DCHECK(!root.isLayoutScrollbarPart());
+    ASSERT(!root.isLayoutFullScreen() && !root.isLayoutFullScreenPlaceholder()
+        && !root.isLayoutScrollbarPart());
     m_orthogonalWritingModeRootList.add(root);
 }
 
@@ -2548,6 +2550,15 @@ void FrameView::updateLifecyclePhasesInternal(DocumentLifecycle::LifecycleState
             // This was required for slimming paint v1 but is only temporarily
             // needed for slimming paint v2.
             view.compositor()->updateIfNeededRecursive();
+
+	    Document *d = frame().document();
+	    VisibilityDocumentSet *ds = d->requestedVisibility();
+	    if (ds != nullptr) {
+		for(Document *reqdoc : *ds){
+		    reqdoc->requestVisibilityImpl();
+		}
+	    }
+
             scrollContentsIfNeededRecursive();
 
             DCHECK(lifecycle().state() >= DocumentLifecycle::CompositingClean);
diff --git a/third_party/WebKit/Source/core/frame/UseCounter.h b/third_party/WebKit/Source/core/frame/UseCounter.h
index e52ab82..aa5971b 100644
--- a/third_party/WebKit/Source/core/frame/UseCounter.h
+++ b/third_party/WebKit/Source/core/frame/UseCounter.h
@@ -1245,6 +1245,8 @@ public:
         BeforeInstallPromptEventPrompt = 1439,
         ExecCommandAltersHTMLStructure = 1440,
 
+        DocumentCreateEventRequestedVisibilityEvent = 1500,
+
         // Add new features immediately above this line. Don't change assigned
         // numbers of any item, and don't reuse removed slots.
         // Also, run update_use_counter_feature_enum.py in chromium/src/tools/metrics/histograms/
diff --git a/third_party/WebKit/Source/core/html/HTMLLinkElement.cpp b/third_party/WebKit/Source/core/html/HTMLLinkElement.cpp
index 1fc1315..bf54245 100644
--- a/third_party/WebKit/Source/core/html/HTMLLinkElement.cpp
+++ b/third_party/WebKit/Source/core/html/HTMLLinkElement.cpp
@@ -683,6 +683,7 @@ void LinkStyle::process()
         // When the link element is created by scripts, load the stylesheets asynchronously but in high priority.
         bool lowPriority = !mediaQueryMatches || m_owner->isAlternate();
         FetchRequest request = builder.build(lowPriority);
+        request.setContentSecurityPolicyNonce(m_owner->fastGetAttribute(HTMLNames::nonceAttr));
         CrossOriginAttributeValue crossOrigin = crossOriginAttributeValue(m_owner->fastGetAttribute(HTMLNames::crossoriginAttr));
         if (crossOrigin != CrossOriginAttributeNotSet) {
             request.setCrossOriginAccessControl(document().getSecurityOrigin(), crossOrigin);
diff --git a/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp b/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
index 507c4d8..d3c4605 100644
--- a/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
+++ b/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
@@ -189,8 +189,9 @@ void HTMLSelectElement::selectMultipleOptionsByPopup(const Vector<int>& listIndi
     DCHECK(!multiple());
     for (size_t i = 0; i < listIndices.size(); ++i) {
         bool addSelectionIfNotFirst = i > 0;
-        if (HTMLOptionElement* option = optionAtListIndex(listIndices[i]))
-            updateSelectedState(option, addSelectionIfNotFirst, false);
+        HTMLElement* element = listItems()[listIndices[i]];
+        if (isHTMLOptionElement(element))
+            updateSelectedState(toHTMLOptionElement(element), addSelectionIfNotFirst, false);
     }
     setNeedsValidityCheck();
     // TODO(tkent): Using listBoxOnChange() is very confusing.
@@ -480,16 +481,6 @@ bool HTMLSelectElement::isRequiredFormControl() const
     return isRequired();
 }
 
-HTMLOptionElement* HTMLSelectElement::optionAtListIndex(int listIndex) const
-{
-    if (listIndex < 0)
-        return nullptr;
-    const ListItems& items = listItems();
-    if (static_cast<size_t>(listIndex) >= items.size() || !isHTMLOptionElement(items[listIndex]))
-        return nullptr;
-    return toHTMLOptionElement(items[listIndex]);
-}
-
 // Returns the 1st valid OPTION |skip| items from |listIndex| in direction
 // |direction| if there is one.
 // Otherwise, it returns the valid OPTION closest to that boundary which is past
@@ -1067,7 +1058,7 @@ int HTMLSelectElement::optionToListIndex(int optionIndex) const
 int HTMLSelectElement::listToOptionIndex(int listIndex) const
 {
     const ListItems& items = listItems();
-    if (!optionAtListIndex(listIndex))
+    if (listIndex < 0 || listIndex >= static_cast<int>(items.size()) || !isHTMLOptionElement(*items[listIndex]))
         return -1;
 
     // Actual index of option not counting OPTGROUP entries that may be in list.
@@ -1154,7 +1145,10 @@ void HTMLSelectElement::restoreFormControlState(const FormControlState& state)
     if (itemsSize == 0)
         return;
 
-    selectOption(nullptr, DeselectOtherOptions);
+    for (auto& item : items) {
+        if (isHTMLOptionElement(item))
+            toHTMLOptionElement(item)->setSelectedState(false);
+    }
 
     // The saved state should have at least one value and an index.
     ASSERT(state.valueSize() >= 2);
@@ -1680,10 +1674,9 @@ HTMLOptionElement* HTMLSelectElement::lastSelectedOption() const
 {
     const ListItems& items = listItems();
     for (size_t i = items.size(); i;) {
-        if (HTMLOptionElement* option = optionAtListIndex(--i)) {
-            if (option->selected())
-                return option;
-        }
+        HTMLElement* element = items[--i];
+        if (isHTMLOptionElement(*element) && toHTMLOptionElement(element)->selected())
+            return toHTMLOptionElement(element);
     }
     return nullptr;
 }
@@ -1700,11 +1693,11 @@ int HTMLSelectElement::optionCount() const
 
 String HTMLSelectElement::optionAtIndex(int index) const
 {
-    if (HTMLOptionElement* option = optionAtListIndex(index)) {
-        if (!option->isDisabledFormControl())
-            return option->displayLabel();
-    }
-    return String();
+    const ListItems& items = listItems();
+    HTMLElement* element = items[index];
+    if (!isHTMLOptionElement(*element) || toHTMLOptionElement(element)->isDisabledFormControl())
+        return String();
+    return toHTMLOptionElement(element)->displayLabel();
 }
 
 void HTMLSelectElement::typeAheadFind(KeyboardEvent* event)
@@ -1712,7 +1705,10 @@ void HTMLSelectElement::typeAheadFind(KeyboardEvent* event)
     int index = m_typeAhead.handleEvent(event, TypeAhead::MatchPrefix | TypeAhead::CycleFirstChar);
     if (index < 0)
         return;
-    selectOption(optionAtListIndex(index), DeselectOtherOptions | MakeOptionDirty | DispatchInputAndChangeEvent);
+    HTMLOptionElement* option = nullptr;
+    if (static_cast<size_t>(index) < listItems().size() && isHTMLOptionElement(listItems()[index]))
+        option = toHTMLOptionElement(listItems()[index]);
+    selectOption(option, DeselectOtherOptions | MakeOptionDirty | DispatchInputAndChangeEvent);
     if (!usesMenuList())
         listBoxOnChange();
 }
@@ -1892,8 +1888,8 @@ void HTMLSelectElement::setIndexToSelectOnCancel(int listIndex)
 
 HTMLOptionElement* HTMLSelectElement::optionToBeShown() const
 {
-    if (HTMLOptionElement* option = optionAtListIndex(m_indexToSelectOnCancel))
-        return option;
+    if (m_indexToSelectOnCancel >= 0 && static_cast<size_t>(m_indexToSelectOnCancel) < listItems().size() && isHTMLOptionElement(listItems()[m_indexToSelectOnCancel]))
+        return toHTMLOptionElement(listItems()[m_indexToSelectOnCancel]);
     if (m_suggestedOption)
         return m_suggestedOption;
     // TODO(tkent): We should not call optionToBeShown() in multiple() case.
@@ -1914,7 +1910,9 @@ void HTMLSelectElement::selectOptionByPopup(int listIndex)
 
     setIndexToSelectOnCancel(-1);
 
-    HTMLOptionElement* option = optionAtListIndex(listIndex);
+    HTMLOptionElement* option = nullptr;
+    if (listIndex >= 0 && isHTMLOptionElement(listItems()[listIndex]))
+        option = toHTMLOptionElement(listItems()[listIndex]);
     // Bail out if this index is already the selected one, to avoid running
     // unnecessary JavaScript that can mess up autofill when there is no actual
     // change (see https://bugs.webkit.org/show_bug.cgi?id=35256 and
diff --git a/third_party/WebKit/Source/core/html/HTMLSelectElement.h b/third_party/WebKit/Source/core/html/HTMLSelectElement.h
index f4fa8c7..22d506a 100644
--- a/third_party/WebKit/Source/core/html/HTMLSelectElement.h
+++ b/third_party/WebKit/Source/core/html/HTMLSelectElement.h
@@ -241,9 +241,6 @@ private:
     void setIndexToSelectOnCancel(int listIndex);
     void setSuggestedOption(HTMLOptionElement*);
 
-    // Returns nullptr if listIndex is out of bounds, or it doesn't point an
-    // HTMLOptionElement.
-    HTMLOptionElement* optionAtListIndex(int listIndex) const;
     enum SkipDirection {
         SkipBackwards = -1,
         SkipForwards = 1
diff --git a/third_party/WebKit/Source/core/html/HTMLSelectElementTest.cpp b/third_party/WebKit/Source/core/html/HTMLSelectElementTest.cpp
index 2b8044b..1b94a3d 100644
--- a/third_party/WebKit/Source/core/html/HTMLSelectElementTest.cpp
+++ b/third_party/WebKit/Source/core/html/HTMLSelectElementTest.cpp
@@ -102,38 +102,6 @@ TEST_F(HTMLSelectElementTest, SaveRestoreSelectMultipleFormControlState)
     EXPECT_TRUE(opt3->selected());
 }
 
-TEST_F(HTMLSelectElementTest, RestoreUnmatchedFormControlState)
-{
-    // We had a bug that selectedOption() and m_lastOnChangeOption were
-    // mismatched in optionToBeShown(). It happened when
-    // restoreFormControlState() couldn't find matched OPTIONs.
-    // crbug.com/627833.
-
-    document().documentElement()->setInnerHTML("<select id='sel'>"
-        "<option selected>Default</option>"
-        "<option id='2'>222</option>"
-        "</select>", ASSERT_NO_EXCEPTION);
-    document().view()->updateAllLifecyclePhases();
-    Element* element = document().getElementById("sel");
-    HTMLFormControlElementWithState* select = toHTMLSelectElement(element);
-    HTMLOptionElement* opt2 = toHTMLOptionElement(document().getElementById("2"));
-
-    toHTMLSelectElement(element)->setSelectedIndex(1);
-    // Save the current state.
-    FormControlState selectState = select->saveFormControlState();
-    EXPECT_EQ(2U, selectState.valueSize());
-
-    // Reset the status.
-    select->reset();
-    ASSERT_FALSE(opt2->selected());
-    element->removeChild(opt2);
-
-    // Restore
-    select->restoreFormControlState(selectState);
-    EXPECT_EQ(-1, toHTMLSelectElement(element)->selectedIndex());
-    EXPECT_EQ(nullptr, toHTMLSelectElement(element)->optionToBeShown());
-}
-
 TEST_F(HTMLSelectElementTest, ElementRectRelativeToViewport)
 {
     document().documentElement()->setInnerHTML("<select style='position:fixed; top:12.3px; height:24px; -webkit-appearance:none;'><option>o1</select>", ASSERT_NO_EXCEPTION);
diff --git a/third_party/WebKit/Source/core/html/LinkResource.cpp b/third_party/WebKit/Source/core/html/LinkResource.cpp
index 3a5b0fe..b213219 100644
--- a/third_party/WebKit/Source/core/html/LinkResource.cpp
+++ b/third_party/WebKit/Source/core/html/LinkResource.cpp
@@ -78,9 +78,7 @@ LinkRequestBuilder::LinkRequestBuilder(HTMLLinkElement* owner)
 FetchRequest LinkRequestBuilder::build(bool lowPriority) const
 {
     ResourceLoadPriority priority = lowPriority ? ResourceLoadPriorityVeryLow : ResourceLoadPriorityUnresolved;
-    FetchRequest request(ResourceRequest(m_owner->document().completeURL(m_url)), m_owner->localName(), m_charset, priority);
-    request.setContentSecurityPolicyNonce(m_owner->fastGetAttribute(HTMLNames::nonceAttr));
-    return request;
+    return FetchRequest(ResourceRequest(m_owner->document().completeURL(m_url)), m_owner->localName(), m_charset, priority);
 }
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/core/html/parser/HTMLPreloadScanner.cpp b/third_party/WebKit/Source/core/html/parser/HTMLPreloadScanner.cpp
index 09e657f..14ecba3 100644
--- a/third_party/WebKit/Source/core/html/parser/HTMLPreloadScanner.cpp
+++ b/third_party/WebKit/Source/core/html/parser/HTMLPreloadScanner.cpp
@@ -243,7 +243,6 @@ public:
         ReferrerPolicy referrerPolicy = (m_referrerPolicy != ReferrerPolicyDefault) ? m_referrerPolicy : documentReferrerPolicy;
         std::unique_ptr<PreloadRequest> request = PreloadRequest::create(initiatorFor(m_tagImpl), position, m_urlToLoad, predictedBaseURL, type, referrerPolicy, resourceWidth, clientHintsPreferences, requestType);
         request->setCrossOrigin(m_crossOrigin);
-        request->setNonce(m_nonce);
         request->setCharset(charset());
         request->setDefer(m_defer);
         request->setIntegrityMetadata(m_integrityMetadata);
@@ -259,8 +258,6 @@ private:
             setUrlToLoad(attributeValue, DisallowURLReplacement);
         else if (match(attributeName, crossoriginAttr))
             setCrossOrigin(attributeValue);
-        else if (match(attributeName, nonceAttr))
-            setNonce(attributeValue);
         else if (match(attributeName, asyncAttr))
             setDefer(FetchRequest::LazyLoad);
         else if (match(attributeName, deferAttr))
@@ -318,8 +315,6 @@ private:
             m_matched &= mediaAttributeMatches(*m_mediaValues, attributeValue);
         } else if (match(attributeName, crossoriginAttr)) {
             setCrossOrigin(attributeValue);
-        } else if (match(attributeName, nonceAttr)) {
-            setNonce(attributeValue);
         } else if (match(attributeName, asAttr)) {
             m_asAttributeValue = attributeValue;
         } else if (match(attributeName, typeAttr)) {
@@ -453,11 +448,6 @@ private:
         m_crossOrigin = crossOriginAttributeValue(corsSetting);
     }
 
-    void setNonce(const String& nonce)
-    {
-        m_nonce = nonce;
-    }
-
     void setDefer(FetchRequest::DeferOption defer)
     {
         m_defer = defer;
@@ -485,7 +475,6 @@ private:
     bool m_sourceSizeSet;
     FetchRequest::DeferOption m_defer;
     CrossOriginAttributeValue m_crossOrigin;
-    String m_nonce;
     Member<MediaValuesCached> m_mediaValues;
     bool m_referrerPolicySet;
     ReferrerPolicy m_referrerPolicy;
diff --git a/third_party/WebKit/Source/core/html/parser/HTMLPreloadScannerTest.cpp b/third_party/WebKit/Source/core/html/parser/HTMLPreloadScannerTest.cpp
index a2f1aec..bc584d1 100644
--- a/third_party/WebKit/Source/core/html/parser/HTMLPreloadScannerTest.cpp
+++ b/third_party/WebKit/Source/core/html/parser/HTMLPreloadScannerTest.cpp
@@ -44,12 +44,6 @@ struct ReferrerPolicyTestCase {
     ReferrerPolicy referrerPolicy;
 };
 
-struct NonceTestCase {
-    const char* baseURL;
-    const char* inputHTML;
-    const char* nonce;
-};
-
 class MockHTMLResourcePreloader : public ResourcePreloader {
 public:
     void preloadRequestVerification(Resource::Type type, const char* url, const char* baseURL, int width, const ClientHintsPreferences& preferences)
@@ -86,15 +80,6 @@ public:
         }
     }
 
-    void nonceRequestVerification(const char* nonce)
-    {
-        ASSERT_TRUE(m_preloadRequest.get());
-        if (strlen(nonce))
-            EXPECT_EQ(nonce, m_preloadRequest->nonce());
-        else
-            EXPECT_TRUE(m_preloadRequest->nonce().isEmpty());
-    }
-
 protected:
     void preload(std::unique_ptr<PreloadRequest> preloadRequest, const NetworkHintsInterface&) override
     {
@@ -186,16 +171,6 @@ protected:
         preloader.preloadRequestVerification(testCase.type, testCase.preloadedURL, testCase.outputBaseURL, testCase.resourceWidth, testCase.referrerPolicy);
     }
 
-    void test(NonceTestCase testCase)
-    {
-        MockHTMLResourcePreloader preloader;
-        KURL baseURL(ParsedURLString, testCase.baseURL);
-        m_scanner->appendToEnd(String(testCase.inputHTML));
-        m_scanner->scanAndPreload(&preloader, baseURL, nullptr);
-
-        preloader.nonceRequestVerification(testCase.nonce);
-    }
-
 private:
     std::unique_ptr<DummyPageHolder> m_dummyPageHolder;
     std::unique_ptr<HTMLPreloadScanner> m_scanner;
@@ -399,31 +374,6 @@ TEST_F(HTMLPreloadScannerTest, testReferrerPolicy)
         test(testCase);
 }
 
-TEST_F(HTMLPreloadScannerTest, testNonce)
-{
-    NonceTestCase testCases[] = {
-        { "http://example.test", "<script src='/script'></script>", "" },
-        { "http://example.test", "<script src='/script' nonce=''></script>", "" },
-        { "http://example.test", "<script src='/script' nonce='abc'></script>", "abc" },
-        { "http://example.test", "<link rel='import' href='/import'>", "" },
-        { "http://example.test", "<link rel='import' href='/import' nonce=''>", "" },
-        { "http://example.test", "<link rel='import' href='/import' nonce='abc'>", "abc" },
-        { "http://example.test", "<link rel='stylesheet' href='/style'>", "" },
-        { "http://example.test", "<link rel='stylesheet' href='/style' nonce=''>", "" },
-        { "http://example.test", "<link rel='stylesheet' href='/style' nonce='abc'>", "abc" },
-
-        // <img> doesn't support nonces:
-        { "http://example.test", "<img src='/image'>", "" },
-        { "http://example.test", "<img src='/image' nonce=''>", "" },
-        { "http://example.test", "<img src='/image' nonce='abc'>", "" },
-    };
-
-    for (const auto& testCase : testCases) {
-        SCOPED_TRACE(testCase.inputHTML);
-        test(testCase);
-    }
-}
-
 // Tests that a document-level referrer policy (e.g. one set by HTTP
 // header) is applied for preload requests.
 TEST_F(HTMLPreloadScannerTest, testReferrerPolicyOnDocument)
diff --git a/third_party/WebKit/Source/core/html/parser/PreloadRequest.cpp b/third_party/WebKit/Source/core/html/parser/PreloadRequest.cpp
index 0071af1..8093323 100644
--- a/third_party/WebKit/Source/core/html/parser/PreloadRequest.cpp
+++ b/third_party/WebKit/Source/core/html/parser/PreloadRequest.cpp
@@ -47,7 +47,6 @@ FetchRequest PreloadRequest::resourceRequest(Document* document)
     request.setResourceWidth(m_resourceWidth);
     request.clientHintsPreferences().updateFrom(m_clientHintsPreferences);
     request.setIntegrityMetadata(m_integrityMetadata);
-    request.setContentSecurityPolicyNonce(m_nonce);
 
     if (m_requestType == RequestTypeLinkRelPreload)
         request.setLinkPreload(true);
diff --git a/third_party/WebKit/Source/core/html/parser/PreloadRequest.h b/third_party/WebKit/Source/core/html/parser/PreloadRequest.h
index c4ac3a3..9154fff 100644
--- a/third_party/WebKit/Source/core/html/parser/PreloadRequest.h
+++ b/third_party/WebKit/Source/core/html/parser/PreloadRequest.h
@@ -46,10 +46,6 @@ public:
     {
         return m_crossOrigin;
     }
-
-    void setNonce(const String& nonce) { m_nonce = nonce.isolatedCopy(); }
-    const String& nonce() const { return m_nonce; }
-
     Resource::Type resourceType() const { return m_resourceType; }
 
     const String& resourceURL() const { return m_resourceURL; }
@@ -101,7 +97,6 @@ private:
     String m_charset;
     Resource::Type m_resourceType;
     CrossOriginAttributeValue m_crossOrigin;
-    String m_nonce;
     double m_discoveryTime;
     FetchRequest::DeferOption m_defer;
     FetchRequest::ResourceWidth m_resourceWidth;
diff --git a/third_party/WebKit/Source/core/layout/LayoutBlock.cpp b/third_party/WebKit/Source/core/layout/LayoutBlock.cpp
index bc34b9d..5ef43ac 100644
--- a/third_party/WebKit/Source/core/layout/LayoutBlock.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutBlock.cpp
@@ -258,7 +258,10 @@ void LayoutBlock::addChildBeforeDescendant(LayoutObject* newChild, LayoutObject*
 
     // If the requested insertion point is not one of our children, then this is because
     // there is an anonymous container within this object that contains the beforeDescendant.
-    if (beforeDescendantContainer->isAnonymousBlock()) {
+    if (beforeDescendantContainer->isAnonymousBlock()
+        // Full screen layoutObjects and full screen placeholders act as anonymous blocks, not tables:
+        || beforeDescendantContainer->isLayoutFullScreen()
+        || beforeDescendantContainer->isLayoutFullScreenPlaceholder()) {
         // Insert the child into the anonymous block box instead of here.
         if (newChild->isInline() || newChild->isFloatingOrOutOfFlowPositioned() || beforeDescendant->parent()->slowFirstChild() != beforeDescendant)
             beforeDescendant->parent()->addChild(newChild, beforeDescendant);
diff --git a/third_party/WebKit/Source/core/layout/LayoutBox.h b/third_party/WebKit/Source/core/layout/LayoutBox.h
index c1938cd..631a6a1 100644
--- a/third_party/WebKit/Source/core/layout/LayoutBox.h
+++ b/third_party/WebKit/Source/core/layout/LayoutBox.h
@@ -422,8 +422,8 @@ public:
 
     // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (LayoutFlow)
     // to return the remaining width on a given line (and the height of a single line).
-    LayoutUnit offsetWidth() const final { return m_frameRect.width(); }
-    LayoutUnit offsetHeight() const final { return m_frameRect.height(); }
+    LayoutUnit offsetWidth() const override { return m_frameRect.width(); }
+    LayoutUnit offsetHeight() const override { return m_frameRect.height(); }
 
     int pixelSnappedOffsetWidth(const Element*) const final;
     int pixelSnappedOffsetHeight(const Element*) const final;
@@ -836,8 +836,8 @@ public:
     LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
 
-    LayoutUnit offsetLeft(const Element*) const final;
-    LayoutUnit offsetTop(const Element*) const final;
+    LayoutUnit offsetLeft(const Element*) const override;
+    LayoutUnit offsetTop(const Element*) const override;
 
     LayoutPoint flipForWritingModeForChild(const LayoutBox* child, const LayoutPoint&) const;
     LayoutUnit flipForWritingMode(LayoutUnit position) const WARN_UNUSED_RETURN {
diff --git a/third_party/WebKit/Source/core/layout/LayoutFullScreen.cpp b/third_party/WebKit/Source/core/layout/LayoutFullScreen.cpp
new file mode 100644
index 0000000..8b8c9b0
--- /dev/null
+++ b/third_party/WebKit/Source/core/layout/LayoutFullScreen.cpp
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2010 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "core/layout/LayoutFullScreen.h"
+
+#include "core/dom/Fullscreen.h"
+#include "core/frame/FrameHost.h"
+#include "core/frame/VisualViewport.h"
+#include "core/layout/LayoutBlockFlow.h"
+#include "core/page/Page.h"
+
+#include "public/platform/WebScreenInfo.h"
+
+using namespace blink;
+
+class LayoutFullScreenPlaceholder final : public LayoutBlockFlow {
+public:
+    LayoutFullScreenPlaceholder(LayoutFullScreen* owner)
+        : LayoutBlockFlow(nullptr)
+        , m_owner(owner)
+    {
+        setDocumentForAnonymous(&owner->document());
+    }
+
+    // Must call setStyleWithWritingModeOfParent() instead.
+    void setStyle(PassRefPtr<ComputedStyle>) = delete;
+
+private:
+    bool isOfType(LayoutObjectType type) const override { return type == LayoutObjectLayoutFullScreenPlaceholder || LayoutBlockFlow::isOfType(type); }
+    bool anonymousHasStylePropagationOverride() override { return true; }
+
+    void willBeDestroyed() override;
+    LayoutFullScreen* m_owner;
+};
+
+void LayoutFullScreenPlaceholder::willBeDestroyed()
+{
+    m_owner->resetPlaceholder();
+    LayoutBlockFlow::willBeDestroyed();
+}
+
+LayoutFullScreen::LayoutFullScreen()
+    : LayoutFlexibleBox(nullptr)
+    , m_placeholder(nullptr)
+{
+    setIsAtomicInlineLevel(false);
+}
+
+LayoutFullScreen* LayoutFullScreen::createAnonymous(Document* document)
+{
+    LayoutFullScreen* layoutObject = new LayoutFullScreen();
+    layoutObject->setDocumentForAnonymous(document);
+    return layoutObject;
+}
+
+void LayoutFullScreen::willBeDestroyed()
+{
+    if (m_placeholder) {
+        remove();
+        if (!m_placeholder->beingDestroyed())
+            m_placeholder->destroy();
+        ASSERT(!m_placeholder);
+    }
+
+    // LayoutObjects are unretained, so notify the document (which holds a pointer to a LayoutFullScreen)
+    // if its LayoutFullScreen is destroyed.
+    Fullscreen& fullscreen = Fullscreen::from(document());
+    if (fullscreen.fullScreenLayoutObject() == this)
+        fullscreen.fullScreenLayoutObjectDestroyed();
+
+    LayoutFlexibleBox::willBeDestroyed();
+}
+
+void LayoutFullScreen::updateStyle()
+{
+    RefPtr<ComputedStyle> fullscreenStyle = ComputedStyle::create();
+
+    // Create a stacking context:
+    fullscreenStyle->setZIndex(INT_MAX);
+    fullscreenStyle->setIsStackingContext(true);
+
+    fullscreenStyle->setFontDescription(FontDescription());
+    fullscreenStyle->font().update(nullptr);
+
+    fullscreenStyle->setDisplay(FLEX);
+    fullscreenStyle->setJustifyContentPosition(ContentPositionCenter);
+    fullscreenStyle->setAlignItemsPosition(ItemPositionCenter);
+    fullscreenStyle->setFlexDirection(FlowColumn);
+
+    fullscreenStyle->setPosition(FixedPosition);
+    fullscreenStyle->setLeft(Length(0, blink::Fixed));
+    fullscreenStyle->setTop(Length(0, blink::Fixed));
+    IntSize viewportSize = document().page()->frameHost().visualViewport().size();
+    fullscreenStyle->setWidth(Length(viewportSize.width(), blink::Fixed));
+    fullscreenStyle->setHeight(Length(viewportSize.height(), blink::Fixed));
+
+    fullscreenStyle->setBackgroundColor(StyleColor(Color::black));
+
+    setStyleWithWritingModeOfParent(fullscreenStyle);
+}
+
+LayoutObject* LayoutFullScreen::wrapLayoutObject(LayoutObject* object, LayoutObject* parent, Document* document)
+{
+    // FIXME: We should not modify the structure of the layout tree during
+    // layout. crbug.com/370459
+    DeprecatedDisableModifyLayoutTreeStructureAsserts disabler;
+
+    LayoutFullScreen* fullscreenLayoutObject = LayoutFullScreen::createAnonymous(document);
+    fullscreenLayoutObject->updateStyle();
+    if (parent && !parent->isChildAllowed(fullscreenLayoutObject, fullscreenLayoutObject->styleRef())) {
+        fullscreenLayoutObject->destroy();
+        return nullptr;
+    }
+    if (object) {
+        // |object->parent()| can be null if the object is not yet attached
+        // to |parent|.
+        if (LayoutObject* parent = object->parent()) {
+            LayoutBlock* containingBlock = object->containingBlock();
+            ASSERT(containingBlock);
+            // Since we are moving the |object| to a new parent |fullscreenLayoutObject|,
+            // the line box tree underneath our |containingBlock| is not longer valid.
+            if (containingBlock->isLayoutBlockFlow())
+                toLayoutBlockFlow(containingBlock)->deleteLineBoxTree();
+
+            parent->addChildWithWritingModeOfParent(fullscreenLayoutObject, object);
+            object->remove();
+
+            // Always just do a full layout to ensure that line boxes get deleted properly.
+            // Because objects moved from |parent| to |fullscreenLayoutObject|, we want to
+            // make new line boxes instead of leaving the old ones around.
+            parent->setNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation(LayoutInvalidationReason::Fullscreen);
+            containingBlock->setNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation(LayoutInvalidationReason::Fullscreen);
+        }
+        fullscreenLayoutObject->addChild(object);
+        fullscreenLayoutObject->setNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation(LayoutInvalidationReason::Fullscreen);
+    }
+
+    ASSERT(document);
+    Fullscreen::from(*document).setFullScreenLayoutObject(fullscreenLayoutObject);
+    return fullscreenLayoutObject;
+}
+
+void LayoutFullScreen::unwrapLayoutObject()
+{
+    // FIXME: We should not modify the structure of the layout tree during
+    // layout. crbug.com/370459
+    DeprecatedDisableModifyLayoutTreeStructureAsserts disabler;
+
+    if (parent()) {
+        for (LayoutObject* child = firstChild(); child; child = firstChild()) {
+            // We have to clear the override size, because as a flexbox, we
+            // may have set one on the child, and we don't want to leave that
+            // lying around on the child.
+            if (child->isBox())
+                toLayoutBox(child)->clearOverrideSize();
+            child->remove();
+            parent()->addChild(child, this);
+            parent()->setNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation(LayoutInvalidationReason::Fullscreen);
+        }
+    }
+    if (placeholder())
+        placeholder()->remove();
+    remove();
+    destroy();
+}
+
+void LayoutFullScreen::createPlaceholder(PassRefPtr<ComputedStyle> style, const LayoutRect& frameRect)
+{
+    if (style->width().isAuto())
+        style->setWidth(Length(frameRect.width(), Fixed));
+    if (style->height().isAuto())
+        style->setHeight(Length(frameRect.height(), Fixed));
+
+    if (!m_placeholder) {
+        m_placeholder = new LayoutFullScreenPlaceholder(this);
+        m_placeholder->setStyleWithWritingModeOfParent(style);
+        if (parent()) {
+            parent()->addChildWithWritingModeOfParent(m_placeholder, this);
+            parent()->setNeedsLayoutAndPrefWidthsRecalcAndFullPaintInvalidation(LayoutInvalidationReason::Fullscreen);
+        }
+    } else {
+        m_placeholder->setStyle(style);
+        m_placeholder->setStyleWithWritingModeOfParent(style);
+    }
+}
diff --git a/third_party/WebKit/Source/core/layout/LayoutFullScreen.h b/third_party/WebKit/Source/core/layout/LayoutFullScreen.h
new file mode 100644
index 0000000..3ba2a1d
--- /dev/null
+++ b/third_party/WebKit/Source/core/layout/LayoutFullScreen.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2010 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LayoutFullScreen_h
+#define LayoutFullScreen_h
+
+#include "core/CoreExport.h"
+#include "core/layout/LayoutFlexibleBox.h"
+#include "core/style/StyleInheritedData.h"
+
+namespace blink {
+
+class LayoutBlockFlow;
+
+class CORE_EXPORT LayoutFullScreen final : public LayoutFlexibleBox {
+public:
+    static LayoutFullScreen* createAnonymous(Document*);
+
+    bool isOfType(LayoutObjectType type) const override { return type == LayoutObjectLayoutFullScreen || LayoutFlexibleBox::isOfType(type); }
+    const char* name() const override { return "LayoutFullScreen"; }
+
+    void resetPlaceholder() { m_placeholder = nullptr; }
+    LayoutBlockFlow* placeholder() { return m_placeholder; }
+    void createPlaceholder(PassRefPtr<ComputedStyle>, const LayoutRect& frameRect);
+
+
+    static LayoutObject* wrapLayoutObject(LayoutObject*, LayoutObject*, Document*);
+    void unwrapLayoutObject();
+
+    void updateStyle();
+    bool anonymousHasStylePropagationOverride() override { return true; }
+
+    // Must call setStyleWithWritingModeOfParent() instead.
+    void setStyle(PassRefPtr<ComputedStyle>) = delete;
+
+private:
+    LayoutFullScreen();
+    void willBeDestroyed() override;
+
+protected:
+    LayoutBlockFlow* m_placeholder;
+};
+
+DEFINE_LAYOUT_OBJECT_TYPE_CASTS(LayoutFullScreen, isLayoutFullScreen());
+
+} // namespace blink
+
+#endif
diff --git a/third_party/WebKit/Source/core/layout/LayoutGrid.cpp b/third_party/WebKit/Source/core/layout/LayoutGrid.cpp
index 82ece97..6d8864e 100644
--- a/third_party/WebKit/Source/core/layout/LayoutGrid.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutGrid.cpp
@@ -516,7 +516,7 @@ void LayoutGrid::computeIntrinsicLogicalWidths(LayoutUnit& minLogicalWidth, Layo
     GridSizingData sizingData(gridColumnCount(), gridRowCount());
     sizingData.freeSpaceForDirection(ForColumns) = LayoutUnit();
     sizingData.sizingOperation = IntrinsicSizeComputation;
-    computeUsedBreadthOfGridTracks(ForColumns, sizingData, minLogicalWidth, maxLogicalWidth);
+    const_cast<LayoutGrid*>(this)->computeUsedBreadthOfGridTracks(ForColumns, sizingData, minLogicalWidth, maxLogicalWidth);
 
     LayoutUnit totalGuttersSize = guttersSize(ForColumns, sizingData.columnTracks.size());
     minLogicalWidth += totalGuttersSize;
@@ -567,7 +567,7 @@ static inline double normalizedFlexFraction(const GridTrack& track, double flexF
     return track.baseSize() / std::max<double>(1, flexFactor);
 }
 
-void LayoutGrid::computeUsedBreadthOfGridTracks(GridTrackSizingDirection direction, GridSizingData& sizingData, LayoutUnit& baseSizesWithoutMaximization, LayoutUnit& growthLimitsWithoutMaximization) const
+void LayoutGrid::computeUsedBreadthOfGridTracks(GridTrackSizingDirection direction, GridSizingData& sizingData, LayoutUnit& baseSizesWithoutMaximization, LayoutUnit& growthLimitsWithoutMaximization)
 {
     LayoutUnit& freeSpace = sizingData.freeSpaceForDirection(direction);
     const LayoutUnit initialFreeSpace = freeSpace;
@@ -840,7 +840,7 @@ bool LayoutGrid::isOrthogonalChild(const LayoutBox& child) const
     return child.isHorizontalWritingMode() != isHorizontalWritingMode();
 }
 
-LayoutUnit LayoutGrid::logicalHeightForChild(LayoutBox& child, GridSizingData& sizingData) const
+LayoutUnit LayoutGrid::logicalHeightForChild(LayoutBox& child, GridSizingData& sizingData)
 {
     GridTrackSizingDirection childBlockDirection = flowAwareDirectionForChild(child, ForRows);
     SubtreeLayoutScope layoutScope(child);
@@ -864,7 +864,7 @@ GridTrackSizingDirection LayoutGrid::flowAwareDirectionForChild(const LayoutBox&
     return !isOrthogonalChild(child) ? direction : (direction == ForColumns ? ForRows : ForColumns);
 }
 
-LayoutUnit LayoutGrid::minSizeForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData) const
+LayoutUnit LayoutGrid::minSizeForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     GridTrackSizingDirection childInlineDirection = flowAwareDirectionForChild(child, ForColumns);
     bool isRowAxis = direction == childInlineDirection;
@@ -885,7 +885,7 @@ LayoutUnit LayoutGrid::minSizeForChild(LayoutBox& child, GridTrackSizingDirectio
     return child.computeLogicalHeightUsing(MinSize, childMinSize, child.intrinsicLogicalHeight()) + child.marginLogicalHeight() + child.scrollbarLogicalHeight();
 }
 
-bool LayoutGrid::updateOverrideContainingBlockContentSizeForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData) const
+bool LayoutGrid::updateOverrideContainingBlockContentSizeForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     LayoutUnit overrideSize = gridAreaBreadthForChild(child, direction, sizingData);
     if (hasOverrideContainingBlockContentSizeForChild(child, direction) && overrideContainingBlockContentSizeForChild(child, direction) == overrideSize)
@@ -895,7 +895,7 @@ bool LayoutGrid::updateOverrideContainingBlockContentSizeForChild(LayoutBox& chi
     return true;
 }
 
-LayoutUnit LayoutGrid::minContentForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData) const
+LayoutUnit LayoutGrid::minContentForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     GridTrackSizingDirection childInlineDirection = flowAwareDirectionForChild(child, ForColumns);
     if (direction == childInlineDirection) {
@@ -924,7 +924,7 @@ LayoutUnit LayoutGrid::minContentForChild(LayoutBox& child, GridTrackSizingDirec
     return logicalHeightForChild(child, sizingData);
 }
 
-LayoutUnit LayoutGrid::maxContentForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData) const
+LayoutUnit LayoutGrid::maxContentForChild(LayoutBox& child, GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     GridTrackSizingDirection childInlineDirection = flowAwareDirectionForChild(child, ForColumns);
     if (direction == childInlineDirection) {
@@ -986,7 +986,7 @@ bool LayoutGrid::spanningItemCrossesFlexibleSizedTracks(const GridSpan& span, Gr
     return false;
 }
 
-void LayoutGrid::resolveContentBasedTrackSizingFunctions(GridTrackSizingDirection direction, GridSizingData& sizingData) const
+void LayoutGrid::resolveContentBasedTrackSizingFunctions(GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     sizingData.itemsSortedByIncreasingSpan.shrink(0);
     if (!m_gridItemArea.isEmpty()) {
@@ -1027,7 +1027,7 @@ void LayoutGrid::resolveContentBasedTrackSizingFunctions(GridTrackSizingDirectio
     }
 }
 
-void LayoutGrid::resolveContentBasedTrackSizingFunctionsForNonSpanningItems(GridTrackSizingDirection direction, const GridSpan& span, LayoutBox& gridItem, GridTrack& track, GridSizingData& sizingData) const
+void LayoutGrid::resolveContentBasedTrackSizingFunctionsForNonSpanningItems(GridTrackSizingDirection direction, const GridSpan& span, LayoutBox& gridItem, GridTrack& track, GridSizingData& sizingData)
 {
     const size_t trackPosition = span.startLine();
     GridTrackSize trackSize = gridTrackSize(direction, trackPosition, sizingData.sizingOperation);
@@ -1150,7 +1150,7 @@ static void updateTrackSizeForTrackSizeComputationPhase(TrackSizeComputationPhas
     ASSERT_NOT_REACHED();
 }
 
-LayoutUnit LayoutGrid::currentItemSizeForTrackSizeComputationPhase(TrackSizeComputationPhase phase, LayoutBox& gridItem, GridTrackSizingDirection direction, GridSizingData& sizingData) const
+LayoutUnit LayoutGrid::currentItemSizeForTrackSizeComputationPhase(TrackSizeComputationPhase phase, LayoutBox& gridItem, GridTrackSizingDirection direction, GridSizingData& sizingData)
 {
     switch (phase) {
     case ResolveIntrinsicMinimums:
@@ -1171,7 +1171,7 @@ LayoutUnit LayoutGrid::currentItemSizeForTrackSizeComputationPhase(TrackSizeComp
 }
 
 template <TrackSizeComputationPhase phase>
-void LayoutGrid::resolveContentBasedTrackSizingFunctionsForItems(GridTrackSizingDirection direction, GridSizingData& sizingData, const GridItemsSpanGroupRange& gridItemsWithSpan) const
+void LayoutGrid::resolveContentBasedTrackSizingFunctionsForItems(GridTrackSizingDirection direction, GridSizingData& sizingData, const GridItemsSpanGroupRange& gridItemsWithSpan)
 {
     Vector<GridTrack>& tracks = (direction == ForColumns) ? sizingData.columnTracks : sizingData.rowTracks;
     for (const auto& trackIndex : sizingData.contentSizedTracksIndex) {
@@ -1232,7 +1232,7 @@ static bool sortByGridTrackGrowthPotential(const GridTrack* track1, const GridTr
 }
 
 template <TrackSizeComputationPhase phase>
-void LayoutGrid::distributeSpaceToTracks(Vector<GridTrack*>& tracks, const Vector<GridTrack*>* growBeyondGrowthLimitsTracks, GridSizingData& sizingData, LayoutUnit& availableLogicalSpace) const
+void LayoutGrid::distributeSpaceToTracks(Vector<GridTrack*>& tracks, const Vector<GridTrack*>* growBeyondGrowthLimitsTracks, GridSizingData& sizingData, LayoutUnit& availableLogicalSpace)
 {
     ASSERT(availableLogicalSpace >= 0);
 
diff --git a/third_party/WebKit/Source/core/layout/LayoutGrid.h b/third_party/WebKit/Source/core/layout/LayoutGrid.h
index b4aff8a..2b7f531 100644
--- a/third_party/WebKit/Source/core/layout/LayoutGrid.h
+++ b/third_party/WebKit/Source/core/layout/LayoutGrid.h
@@ -121,10 +121,10 @@ private:
     class GridIterator;
     struct GridSizingData;
     enum SizingOperation { TrackSizing, IntrinsicSizeComputation };
-    void computeUsedBreadthOfGridTracks(GridTrackSizingDirection, GridSizingData&, LayoutUnit& baseSizesWithoutMaximization, LayoutUnit& growthLimitsWithoutMaximization) const;
+    void computeUsedBreadthOfGridTracks(GridTrackSizingDirection, GridSizingData&, LayoutUnit& baseSizesWithoutMaximization, LayoutUnit& growthLimitsWithoutMaximization);
     LayoutUnit computeUsedBreadthOfMinLength(const GridLength&, LayoutUnit maxBreadth) const;
     LayoutUnit computeUsedBreadthOfMaxLength(const GridLength&, LayoutUnit usedBreadth, LayoutUnit maxBreadth) const;
-    void resolveContentBasedTrackSizingFunctions(GridTrackSizingDirection, GridSizingData&) const;
+    void resolveContentBasedTrackSizingFunctions(GridTrackSizingDirection, GridSizingData&);
 
     void ensureGridSize(size_t maximumRowSize, size_t maximumColumnSize);
     void insertItemIntoGrid(LayoutBox&, const GridArea&);
@@ -153,10 +153,10 @@ private:
     void populateGridPositionsForDirection(GridSizingData&, GridTrackSizingDirection);
 
     typedef struct GridItemsSpanGroupRange GridItemsSpanGroupRange;
-    LayoutUnit currentItemSizeForTrackSizeComputationPhase(TrackSizeComputationPhase, LayoutBox&, GridTrackSizingDirection, GridSizingData&) const;
-    void resolveContentBasedTrackSizingFunctionsForNonSpanningItems(GridTrackSizingDirection, const GridSpan&, LayoutBox& gridItem, GridTrack&, GridSizingData&) const;
-    template <TrackSizeComputationPhase> void resolveContentBasedTrackSizingFunctionsForItems(GridTrackSizingDirection, GridSizingData&, const GridItemsSpanGroupRange&) const;
-    template <TrackSizeComputationPhase> void distributeSpaceToTracks(Vector<GridTrack*>&, const Vector<GridTrack*>* growBeyondGrowthLimitsTracks, GridSizingData&, LayoutUnit& availableLogicalSpace) const;
+    LayoutUnit currentItemSizeForTrackSizeComputationPhase(TrackSizeComputationPhase, LayoutBox&, GridTrackSizingDirection, GridSizingData&);
+    void resolveContentBasedTrackSizingFunctionsForNonSpanningItems(GridTrackSizingDirection, const GridSpan&, LayoutBox& gridItem, GridTrack&, GridSizingData&);
+    template <TrackSizeComputationPhase> void resolveContentBasedTrackSizingFunctionsForItems(GridTrackSizingDirection, GridSizingData&, const GridItemsSpanGroupRange&);
+    template <TrackSizeComputationPhase> void distributeSpaceToTracks(Vector<GridTrack*>&, const Vector<GridTrack*>* growBeyondGrowthLimitsTracks, GridSizingData&, LayoutUnit& availableLogicalSpace);
 
     typedef HashSet<size_t, DefaultHash<size_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<size_t>> TrackIndexSet;
     double computeFlexFactorUnitSize(const Vector<GridTrack>&, GridTrackSizingDirection, double flexFactorSum, LayoutUnit& leftOverSpace, const Vector<size_t, 8>& flexibleTracksIndexes, std::unique_ptr<TrackIndexSet> tracksToTreatAsInflexible = nullptr) const;
@@ -165,11 +165,11 @@ private:
     const GridTrackSize& rawGridTrackSize(GridTrackSizingDirection, size_t) const;
     GridTrackSize gridTrackSize(GridTrackSizingDirection, size_t, SizingOperation = TrackSizing) const;
 
-    bool updateOverrideContainingBlockContentSizeForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&) const;
-    LayoutUnit logicalHeightForChild(LayoutBox&, GridSizingData&) const;
-    LayoutUnit minSizeForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&) const;
-    LayoutUnit minContentForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&) const;
-    LayoutUnit maxContentForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&) const;
+    bool updateOverrideContainingBlockContentSizeForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&);
+    LayoutUnit logicalHeightForChild(LayoutBox&, GridSizingData&);
+    LayoutUnit minSizeForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&);
+    LayoutUnit minContentForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&);
+    LayoutUnit maxContentForChild(LayoutBox&, GridTrackSizingDirection, GridSizingData&);
     GridAxisPosition columnAxisPositionForChild(const LayoutBox&) const;
     GridAxisPosition rowAxisPositionForChild(const LayoutBox&) const;
     LayoutUnit rowAxisOffsetForChild(const LayoutBox&, GridSizingData&) const;
diff --git a/third_party/WebKit/Source/core/layout/LayoutInline.cpp b/third_party/WebKit/Source/core/layout/LayoutInline.cpp
index 71782d3..d46577f 100644
--- a/third_party/WebKit/Source/core/layout/LayoutInline.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutInline.cpp
@@ -26,6 +26,7 @@
 #include "core/dom/StyleEngine.h"
 #include "core/layout/HitTestResult.h"
 #include "core/layout/LayoutBlock.h"
+#include "core/layout/LayoutFullScreen.h"
 #include "core/layout/LayoutGeometryMap.h"
 #include "core/layout/LayoutTheme.h"
 #include "core/layout/LayoutView.h"
@@ -349,6 +350,17 @@ void LayoutInline::splitInlines(LayoutBlockFlow* fromBlock, LayoutBlockFlow* toB
 {
     ASSERT(isDescendantOf(fromBlock));
 
+    // If we're splitting the inline containing the fullscreened element,
+    // |beforeChild| may be the layoutObject for the fullscreened element. However,
+    // that layoutObject is wrapped in a LayoutFullScreen, so |this| is not its
+    // parent. Since the splitting logic expects |this| to be the parent, set
+    // |beforeChild| to be the LayoutFullScreen.
+    if (Fullscreen* fullscreen = Fullscreen::fromIfExists(document())) {
+        const Element* fullScreenElement = fullscreen->webkitCurrentFullScreenElement();
+        if (fullScreenElement && beforeChild && beforeChild->node() == fullScreenElement)
+            beforeChild = fullscreen->fullScreenLayoutObject();
+    }
+
     // FIXME: Because splitting is O(n^2) as tags nest pathologically, we cap the depth at which we're willing to clone.
     // There will eventually be a better approach to this problem that will let us nest to a much
     // greater depth (see bugzilla bug 13430) but for now we have a limit.  This *will* result in
diff --git a/third_party/WebKit/Source/core/layout/LayoutMenuList.cpp b/third_party/WebKit/Source/core/layout/LayoutMenuList.cpp
index e004d83..842318f 100644
--- a/third_party/WebKit/Source/core/layout/LayoutMenuList.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutMenuList.cpp
@@ -56,7 +56,7 @@ LayoutMenuList::~LayoutMenuList()
 // to prevent children from rendering.
 bool LayoutMenuList::isChildAllowed(LayoutObject* object, const ComputedStyle&) const
 {
-    return object->isAnonymous();
+    return object->isAnonymous() && !object->isLayoutFullScreen();
 }
 
 void LayoutMenuList::createInnerBlock()
diff --git a/third_party/WebKit/Source/core/layout/LayoutObject.h b/third_party/WebKit/Source/core/layout/LayoutObject.h
index 0e81902..33277e6 100644
--- a/third_party/WebKit/Source/core/layout/LayoutObject.h
+++ b/third_party/WebKit/Source/core/layout/LayoutObject.h
@@ -499,6 +499,8 @@ public:
     bool isProgress() const { return isOfType(LayoutObjectProgress); }
     bool isQuote() const { return isOfType(LayoutObjectQuote); }
     bool isLayoutButton() const { return isOfType(LayoutObjectLayoutButton); }
+    bool isLayoutFullScreen() const { return isOfType(LayoutObjectLayoutFullScreen); }
+    bool isLayoutFullScreenPlaceholder() const { return isOfType(LayoutObjectLayoutFullScreenPlaceholder); }
     bool isLayoutGrid() const { return isOfType(LayoutObjectLayoutGrid); }
     bool isLayoutIFrame() const { return isOfType(LayoutObjectLayoutIFrame); }
     bool isLayoutImage() const { return isOfType(LayoutObjectLayoutImage); }
@@ -647,7 +649,9 @@ public:
         // LayoutBlock::createAnonymousBlock(). This includes creating an anonymous
         // LayoutBlock having a BLOCK or BOX display. Other classes such as LayoutTextFragment
         // are not LayoutBlocks and will return false. See https://bugs.webkit.org/show_bug.cgi?id=56709.
-        return isAnonymous() && (style()->display() == BLOCK || style()->display() == BOX) && style()->styleType() == PseudoIdNone && isLayoutBlock() && !isListMarker() && !isLayoutFlowThread() && !isLayoutMultiColumnSet();
+        return isAnonymous() && (style()->display() == BLOCK || style()->display() == BOX) && style()->styleType() == PseudoIdNone && isLayoutBlock() && !isListMarker() && !isLayoutFlowThread() && !isLayoutMultiColumnSet()
+            && !isLayoutFullScreen()
+            && !isLayoutFullScreenPlaceholder();
     }
     bool isElementContinuation() const { return node() && node()->layoutObject() != this; }
     bool isInlineElementContinuation() const { return isElementContinuation() && isInline(); }
@@ -1421,6 +1425,8 @@ protected:
         LayoutObjectQuote,
         LayoutObjectLayoutButton,
         LayoutObjectLayoutFlowThread,
+        LayoutObjectLayoutFullScreen,
+        LayoutObjectLayoutFullScreenPlaceholder,
         LayoutObjectLayoutGrid,
         LayoutObjectLayoutIFrame,
         LayoutObjectLayoutImage,
diff --git a/third_party/WebKit/Source/core/layout/LayoutVideo.cpp b/third_party/WebKit/Source/core/layout/LayoutVideo.cpp
index 2a9483e..d309148 100644
--- a/third_party/WebKit/Source/core/layout/LayoutVideo.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutVideo.cpp
@@ -28,6 +28,8 @@
 #include "core/HTMLNames.h"
 #include "core/dom/Document.h"
 #include "core/html/HTMLVideoElement.h"
+#include "core/layout/LayoutBlockFlow.h"
+#include "core/layout/LayoutFullScreen.h"
 #include "core/paint/VideoPainter.h"
 #include "public/platform/WebLayer.h"
 
@@ -195,6 +197,47 @@ bool LayoutVideo::supportsAcceleratedRendering() const
     return !!mediaElement()->platformLayer();
 }
 
+static const LayoutBlock* layoutObjectPlaceholder(const LayoutObject* layoutObject)
+{
+    LayoutObject* parent = layoutObject->parent();
+    if (!parent)
+        return nullptr;
+
+    LayoutFullScreen* fullScreen = parent->isLayoutFullScreen() ? toLayoutFullScreen(parent) : 0;
+    if (!fullScreen)
+        return nullptr;
+
+    return fullScreen->placeholder();
+}
+
+LayoutUnit LayoutVideo::offsetLeft(const Element* parent) const
+{
+    if (const LayoutBlock* block = layoutObjectPlaceholder(this))
+        return block->offsetLeft(parent);
+    return LayoutMedia::offsetLeft(parent);
+}
+
+LayoutUnit LayoutVideo::offsetTop(const Element* parent) const
+{
+    if (const LayoutBlock* block = layoutObjectPlaceholder(this))
+        return block->offsetTop(parent);
+    return LayoutMedia::offsetTop(parent);
+}
+
+LayoutUnit LayoutVideo::offsetWidth() const
+{
+    if (const LayoutBlock* block = layoutObjectPlaceholder(this))
+        return block->offsetWidth();
+    return LayoutMedia::offsetWidth();
+}
+
+LayoutUnit LayoutVideo::offsetHeight() const
+{
+    if (const LayoutBlock* block = layoutObjectPlaceholder(this))
+        return block->offsetHeight();
+    return LayoutMedia::offsetHeight();
+}
+
 CompositingReasons LayoutVideo::additionalCompositingReasons() const
 {
     HTMLMediaElement* element = toHTMLMediaElement(node());
diff --git a/third_party/WebKit/Source/core/layout/LayoutVideo.h b/third_party/WebKit/Source/core/layout/LayoutVideo.h
index e96d911..546e5b4 100644
--- a/third_party/WebKit/Source/core/layout/LayoutVideo.h
+++ b/third_party/WebKit/Source/core/layout/LayoutVideo.h
@@ -67,6 +67,11 @@ private:
     LayoutUnit computeReplacedLogicalHeight(LayoutUnit estimatedUsedWidth = LayoutUnit()) const override;
     LayoutUnit minimumReplacedHeight() const override;
 
+    LayoutUnit offsetLeft(const Element*) const override;
+    LayoutUnit offsetTop(const Element*) const override;
+    LayoutUnit offsetWidth() const override;
+    LayoutUnit offsetHeight() const override;
+
     CompositingReasons additionalCompositingReasons() const override;
 
     void updatePlayer();
diff --git a/third_party/WebKit/Source/core/layout/LayoutView.cpp b/third_party/WebKit/Source/core/layout/LayoutView.cpp
index 0496404..291ca8a 100644
--- a/third_party/WebKit/Source/core/layout/LayoutView.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutView.cpp
@@ -24,7 +24,9 @@
 #include "core/dom/Element.h"
 #include "core/editing/FrameSelection.h"
 #include "core/frame/FrameView.h"
+#include "core/frame/LocalDOMWindow.h"
 #include "core/frame/LocalFrame.h"
+#include "core/frame/Location.h"
 #include "core/frame/Settings.h"
 #include "core/html/HTMLIFrameElement.h"
 #include "core/layout/HitTestResult.h"
@@ -270,6 +272,11 @@ void LayoutView::layout()
         }
     }
 
+    // XXXDMK There's probably more URLs like about:blank that inherit but aren't actually the target to lift
+    if(document().location()->href() != "about:blank" && document().documentElement() && document().documentElement()->hasAttributes() && document().documentElement()->hasAttribute("requestVisibility")){
+        document().domWindow()->top()->document()->requestedVisibility()->add(&document());
+    }
+
 #if ENABLE(ASSERT)
     checkLayoutState();
 #endif
diff --git a/third_party/WebKit/Source/core/layout/api/LayoutFullScreenItem.h b/third_party/WebKit/Source/core/layout/api/LayoutFullScreenItem.h
new file mode 100644
index 0000000..87413b2
--- /dev/null
+++ b/third_party/WebKit/Source/core/layout/api/LayoutFullScreenItem.h
@@ -0,0 +1,43 @@
+
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef LayoutFullScreenItem_h
+#define LayoutFullScreenItem_h
+
+#include "core/layout/LayoutBlock.h"
+#include "core/layout/api/LayoutBlockItem.h"
+
+namespace blink {
+
+class LayoutFullScreenItem : public LayoutBlockItem {
+public:
+    explicit LayoutFullScreenItem(LayoutBlock* layoutBlock)
+        : LayoutBlockItem(layoutBlock)
+    {
+    }
+
+    explicit LayoutFullScreenItem(const LayoutBlockItem& item)
+        : LayoutBlockItem(item)
+    {
+        ASSERT_WITH_SECURITY_IMPLICATION(!item || item.isLayoutFullScreen());
+    }
+
+    explicit LayoutFullScreenItem(std::nullptr_t) : LayoutBlockItem(nullptr) { }
+
+    LayoutFullScreenItem() { }
+
+    void unwrapLayoutObject()
+    {
+        return toFullScreen()->unwrapLayoutObject();
+    }
+
+private:
+    LayoutFullScreen* toFullScreen() { return toLayoutFullScreen(layoutObject()); }
+    const LayoutFullScreen* toFullScreen() const { return toLayoutFullScreen(layoutObject()); }
+};
+
+} // namespace blink
+
+#endif // LayoutFullScreenItem_h
diff --git a/third_party/WebKit/Source/core/layout/api/LayoutItem.h b/third_party/WebKit/Source/core/layout/api/LayoutItem.h
index cdf7251..50f24bd 100644
--- a/third_party/WebKit/Source/core/layout/api/LayoutItem.h
+++ b/third_party/WebKit/Source/core/layout/api/LayoutItem.h
@@ -99,6 +99,11 @@ public:
         return m_layoutObject->isImage();
     }
 
+    bool isLayoutFullScreen() const
+    {
+        return m_layoutObject->isLayoutFullScreen();
+    }
+
     bool isListItem() const
     {
         return m_layoutObject->isListItem();
diff --git a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
index a4a6bed..420dde2 100644
--- a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
+++ b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
@@ -126,6 +126,10 @@ CompositingReasons CompositingReasonFinder::potentialCompositingReasonsFromStyle
     if (layoutObject->hasReflection())
         reasons |= CompositingReasonReflectionWithCompositedDescendants;
 
+    if (layoutObject->document().documentElement() && layoutObject->document().documentElement()->hasAttributes() && layoutObject->document().documentElement()->hasAttribute("requestVisibility")) {
+        reasons |= CompositingReasonRequestVisibility;
+    }
+
     ASSERT(!(reasons & ~CompositingReasonComboAllStyleDeterminedReasons));
     return reasons;
 }
diff --git a/third_party/WebKit/Source/core/loader/BeaconLoader.cpp b/third_party/WebKit/Source/core/loader/BeaconLoader.cpp
index 8f79891..f84f614 100644
--- a/third_party/WebKit/Source/core/loader/BeaconLoader.cpp
+++ b/third_party/WebKit/Source/core/loader/BeaconLoader.cpp
@@ -172,7 +172,7 @@ public:
         request.setHTTPHeaderField(HTTPNames::Cache_Control, "max-age=0");
         request.setAllowStoredCredentials(true);
         frame->document()->fetcher()->context().addAdditionalRequestHeaders(request, FetchSubresource);
-        frame->document()->fetcher()->context().populateRequestData(request);
+        frame->document()->fetcher()->context().setFirstPartyForCookies(request);
 
         if (MixedContentChecker::shouldBlockFetch(frame, request, request.url()))
             return false;
diff --git a/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp b/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp
index 5d0b11f..7838ecc 100644
--- a/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp
+++ b/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp
@@ -198,6 +198,12 @@ void FrameFetchContext::addAdditionalRequestHeaders(ResourceRequest& request, Fe
     frame()->loader().applyUserAgent(request);
 }
 
+void FrameFetchContext::setFirstPartyForCookies(ResourceRequest& request)
+{
+    if (frame()->tree().top()->isLocalFrame())
+        request.setFirstPartyForCookies(toLocalFrame(frame()->tree().top())->document()->firstPartyForCookies());
+}
+
 CachePolicy FrameFetchContext::getCachePolicy() const
 {
     if (m_document && m_document->loadEventFinished())
@@ -742,27 +748,6 @@ void FrameFetchContext::addCSPHeaderIfNecessary(Resource::Type type, FetchReques
         fetchRequest.mutableResourceRequest().addHTTPHeaderField("CSP", "active");
 }
 
-void FrameFetchContext::populateRequestData(ResourceRequest& request)
-{
-    if (!m_document)
-        return;
-
-    if (request.firstPartyForCookies().isNull()) {
-        request.setFirstPartyForCookies(m_document
-            ? m_document->firstPartyForCookies()
-            : SecurityOrigin::urlWithUniqueSecurityOrigin());
-    }
-
-    // Subresource requests inherit their requestor origin from |m_document| directly.
-    // Top-level and nested frame types are taken care of in 'FrameLoadRequest()'.
-    // Auxiliary frame types in 'createWindow()' and 'FrameLoader::load'.
-    if (request.frameType() == WebURLRequest::FrameTypeNone && !request.requestorOrigin()) {
-        request.setRequestorOrigin(m_document->isSandboxed(SandboxOrigin)
-            ? SecurityOrigin::create(m_document->url())
-            : m_document->getSecurityOrigin());
-    }
-}
-
 MHTMLArchive* FrameFetchContext::archive() const
 {
     ASSERT(!isMainFrame());
diff --git a/third_party/WebKit/Source/core/loader/FrameFetchContext.h b/third_party/WebKit/Source/core/loader/FrameFetchContext.h
index 6920bfb..281f18f 100644
--- a/third_party/WebKit/Source/core/loader/FrameFetchContext.h
+++ b/third_party/WebKit/Source/core/loader/FrameFetchContext.h
@@ -67,6 +67,7 @@ public:
     bool isLiveContext() { return true; }
 
     void addAdditionalRequestHeaders(ResourceRequest&, FetchResourceType) override;
+    void setFirstPartyForCookies(ResourceRequest&) override;
     CachePolicy getCachePolicy() const override;
     WebCachePolicy resourceRequestCachePolicy(const ResourceRequest&, Resource::Type, FetchRequest::DeferOption) const override;
     void dispatchDidChangeResourcePriority(unsigned long identifier, ResourceLoadPriority, int intraPriorityValue) override;
@@ -101,7 +102,6 @@ public:
     void upgradeInsecureRequest(ResourceRequest&) override;
     void addClientHintsIfNecessary(FetchRequest&) override;
     void addCSPHeaderIfNecessary(Resource::Type, FetchRequest&) override;
-    void populateRequestData(ResourceRequest&) override;
 
     MHTMLArchive* archive() const override;
 
diff --git a/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp b/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp
index d8c3e17..c9e1ebf 100644
--- a/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp
+++ b/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp
@@ -448,66 +448,6 @@ TEST_F(FrameFetchContextTest, MainResource)
     EXPECT_EQ(WebCachePolicy::BypassingCache, childFetchContext->resourceRequestCachePolicy(request, Resource::MainResource, FetchRequest::NoDefer));
 }
 
-TEST_F(FrameFetchContextTest, PopulateRequestData)
-{
-    struct TestCase {
-        const char* documentURL;
-        bool documentSandboxed;
-        const char* requestorOrigin; // "" => nullptr, "null" => unique origin
-        WebURLRequest::FrameType frameType;
-        const char* serializedOrigin; // "" => nullptr, "null" => unique origin
-    } cases[] = {
-        // No document origin => unique request origin
-        { "", false, "", WebURLRequest::FrameTypeNone, "null" },
-        { "", true, "", WebURLRequest::FrameTypeNone, "null" },
-
-        // Document origin => request origin
-        { "http://example.test", false, "", WebURLRequest::FrameTypeNone, "http://example.test" },
-        { "http://example.test", true, "", WebURLRequest::FrameTypeNone, "http://example.test" },
-
-        // If the request already has a requestor origin, then 'populateRequestData' leaves it alone:
-        { "http://example.test", false, "http://not-example.test", WebURLRequest::FrameTypeNone, "http://not-example.test" },
-        { "http://example.test", true, "http://not-example.test", WebURLRequest::FrameTypeNone, "http://not-example.test" },
-
-        // If the request's frame type is not 'none', then 'populateRequestData' leaves it alone:
-        { "http://example.test", false, "", WebURLRequest::FrameTypeTopLevel, "" },
-        { "http://example.test", false, "", WebURLRequest::FrameTypeAuxiliary, "" },
-        { "http://example.test", false, "", WebURLRequest::FrameTypeNested, "" },
-    };
-
-    for (const auto& test : cases) {
-        SCOPED_TRACE(::testing::Message() << test.documentURL << " => " << test.serializedOrigin);
-        // Set up a new document to ensure sandbox flags are cleared:
-        dummyPageHolder = DummyPageHolder::create(IntSize(500, 500));
-        dummyPageHolder->page().setDeviceScaleFactor(1.0);
-        document = toHTMLDocument(&dummyPageHolder->document());
-        FrameFetchContext::provideDocumentToContext(*fetchContext, document.get());
-
-        // Setup the test:
-        document->setURL(KURL(ParsedURLString, test.documentURL));
-        document->setSecurityOrigin(SecurityOrigin::create(document->url()));
-
-        if (test.documentSandboxed)
-            document->enforceSandboxFlags(SandboxOrigin);
-
-        ResourceRequest request("http://example.test/");
-        request.setFrameType(test.frameType);
-        if (strlen(test.requestorOrigin) == 0)
-            request.setRequestorOrigin(nullptr);
-        else
-            request.setRequestorOrigin(SecurityOrigin::create(KURL(ParsedURLString, test.requestorOrigin)));
-
-        // Compare the populated |requestorOrigin| against |test.serializedOrigin|
-        fetchContext->populateRequestData(request);
-        if (strlen(test.serializedOrigin) == 0)
-            EXPECT_EQ(nullptr, request.requestorOrigin().get());
-        else
-            EXPECT_EQ(String(test.serializedOrigin), request.requestorOrigin()->toString());
-
-        EXPECT_EQ(document->firstPartyForCookies(), request.firstPartyForCookies());
-    }
-}
-
 TEST_F(FrameFetchContextTest, ModifyPriorityForLowPriorityIframes)
 {
     Settings* settings = document->frame()->settings();
diff --git a/third_party/WebKit/Source/core/loader/FrameLoadRequest.cpp b/third_party/WebKit/Source/core/loader/FrameLoadRequest.cpp
index 4dd89cf..9c4ad94 100644
--- a/third_party/WebKit/Source/core/loader/FrameLoadRequest.cpp
+++ b/third_party/WebKit/Source/core/loader/FrameLoadRequest.cpp
@@ -53,22 +53,10 @@ FrameLoadRequest::FrameLoadRequest(Document* originDocument, const ResourceReque
 
     if (originDocument) {
         m_resourceRequest.setRequestorOrigin(SecurityOrigin::create(originDocument->url()));
-        return;
-    }
-
-    // If we don't have an origin document, and we're going to throw away the response data
-    // regardless, set the requestor to a unique origin.
-    if (m_substituteData.isValid()) {
-        m_resourceRequest.setRequestorOrigin(SecurityOrigin::createUnique());
-        return;
-    }
-
-    // If we're dealing with a top-level request, use the origin of the requested URL as the initiator.
-    //
-    // TODO(mkwst): This should be `nullptr`. https://crbug.com/625969
-    if (m_resourceRequest.frameType() == WebURLRequest::FrameTypeTopLevel) {
-        m_resourceRequest.setRequestorOrigin(SecurityOrigin::create(resourceRequest.url()));
-        return;
+    } else {
+        if (m_resourceRequest.frameType() == WebURLRequest::FrameTypeTopLevel) {
+            m_resourceRequest.setRequestorOrigin(SecurityOrigin::create(resourceRequest.url()));
+        }
     }
 }
 
diff --git a/third_party/WebKit/Source/core/loader/PingLoader.cpp b/third_party/WebKit/Source/core/loader/PingLoader.cpp
index bbb409e..24b9b7a 100644
--- a/third_party/WebKit/Source/core/loader/PingLoader.cpp
+++ b/third_party/WebKit/Source/core/loader/PingLoader.cpp
@@ -62,7 +62,7 @@ static void finishPingRequestInitialization(ResourceRequest& request, LocalFrame
 {
     request.setRequestContext(WebURLRequest::RequestContextPing);
     frame->document()->fetcher()->context().addAdditionalRequestHeaders(request, FetchSubresource);
-    frame->document()->fetcher()->context().populateRequestData(request);
+    frame->document()->fetcher()->context().setFirstPartyForCookies(request);
 }
 
 void PingLoader::loadImage(LocalFrame* frame, const KURL& url)
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
index 44553cf..29e7206 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
@@ -332,4 +332,41 @@ ClipRects& PaintLayerClipper::paintingClipRects(const PaintLayer* rootLayer, Sho
     return getClipRects(context);
 }
 
+LayoutRect PaintLayerClipper::childrenClipRect() const
+{
+    // FIXME: border-radius not accounted for.
+    // FIXME: Flow thread based columns not accounted for.
+    PaintLayer* clippingRootLayer = clippingRootForPainting();
+    LayoutRect layerBounds;
+    ClipRect backgroundRect, foregroundRect;
+    // Need to use uncached clip rects, because the value of 'dontClipToOverflow' may be different from the painting path (<rdar://problem/11844909>).
+    ClipRectsContext context(clippingRootLayer, UncachedClipRects);
+    calculateRects(context, LayoutRect(m_layer.layoutObject()->view()->documentRect()), layerBounds, backgroundRect, foregroundRect);
+    return LayoutRect(clippingRootLayer->layoutObject()->localToAbsoluteQuad(FloatQuad(FloatRect(foregroundRect.rect()))).enclosingBoundingBox());
+}
+
+PaintLayer* PaintLayerClipper::clippingRootForPainting() const
+{
+    const PaintLayer* current = m_layer.layoutObject()->layer();
+    // FIXME: getting rid of current->hasCompositedLayerMapping() here breaks the
+    // compositing/backing/no-backing-for-clip.html layout test, because there is a
+    // "composited but paints into ancestor" layer involved. However, it doesn't make sense that
+    // that check would be appropriate here but not inside the while loop below.
+    if (current->isPaintInvalidationContainer() || current->hasCompositedLayerMapping())
+        return const_cast<PaintLayer*>(current);
+
+    while (current) {
+        if (current->isRootLayer())
+            return const_cast<PaintLayer*>(current);
+
+        current = current->compositingContainer();
+        ASSERT(current);
+        if (current->transform() || current->isPaintInvalidationContainer())
+            return const_cast<PaintLayer*>(current);
+    }
+
+    ASSERT_NOT_REACHED();
+    return 0;
+}
+
 } // namespace blink
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
index c3ad800..6b83173 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
@@ -156,6 +156,8 @@ public:
     void clearClipRectsIncludingDescendants();
     void clearClipRectsIncludingDescendants(ClipRectsCacheSlot);
 
+    LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document's coordinate space.
+
     // Returns the background clip rect of the layer in the local coordinate space. Only looks for clips up to the given ancestor.
     LayoutRect localClipRect(const PaintLayer* ancestorLayer) const;
 
@@ -181,6 +183,8 @@ private:
 
     bool shouldRespectOverflowClip(const ClipRectsContext&) const;
 
+    PaintLayer* clippingRootForPainting() const;
+
     const PaintLayer& m_layer;
 };
 
diff --git a/third_party/WebKit/Source/core/svg/SVGLength.h b/third_party/WebKit/Source/core/svg/SVGLength.h
index 089e8f8..91ce36d 100644
--- a/third_party/WebKit/Source/core/svg/SVGLength.h
+++ b/third_party/WebKit/Source/core/svg/SVGLength.h
@@ -63,7 +63,7 @@ public:
         m_value = CSSPrimitiveValue::create(value, m_value->typeWithCalcResolved());
     }
 
-    const CSSPrimitiveValue* asCSSPrimitiveValue() const { return m_value.get(); }
+    CSSPrimitiveValue* asCSSPrimitiveValue() const { return m_value.get(); }
 
     // Resolves LengthTypePercentage into a normalized floating point number (full value is 1.0).
     float valueAsPercentage() const;
@@ -102,7 +102,7 @@ private:
     SVGLength(SVGLengthMode);
     SVGLength(const SVGLength&);
 
-    Member<const CSSPrimitiveValue> m_value;
+    Member<CSSPrimitiveValue> m_value;
     unsigned m_unitMode : 2;
 };
 
diff --git a/third_party/WebKit/Source/modules/app_banner/AppBannerController.cpp b/third_party/WebKit/Source/modules/app_banner/AppBannerController.cpp
index b33846c..8826295 100644
--- a/third_party/WebKit/Source/modules/app_banner/AppBannerController.cpp
+++ b/third_party/WebKit/Source/modules/app_banner/AppBannerController.cpp
@@ -9,6 +9,7 @@
 #include "core/frame/DOMWindow.h"
 #include "core/frame/LocalFrame.h"
 #include "modules/app_banner/BeforeInstallPromptEvent.h"
+#include "platform/RuntimeEnabledFeatures.h"
 #include "public/platform/WebVector.h"
 #include "public/platform/modules/app_banner/WebAppBannerClient.h"
 #include "public/platform/modules/app_banner/WebAppBannerPromptReply.h"
@@ -18,6 +19,8 @@ namespace blink {
 // static
 void AppBannerController::willShowInstallBannerPrompt(int requestId, WebAppBannerClient* client, LocalFrame* frame, const WebVector<WebString>& platforms, WebAppBannerPromptReply* reply)
 {
+    ASSERT(RuntimeEnabledFeatures::appBannerEnabled());
+
     Vector<String> wtfPlatforms;
     for (const WebString& platform : platforms)
         wtfPlatforms.append(platform);
diff --git a/third_party/WebKit/Source/modules/app_banner/AppBannerPromptResult.idl b/third_party/WebKit/Source/modules/app_banner/AppBannerPromptResult.idl
index 2b25182..0412c0f 100644
--- a/third_party/WebKit/Source/modules/app_banner/AppBannerPromptResult.idl
+++ b/third_party/WebKit/Source/modules/app_banner/AppBannerPromptResult.idl
@@ -4,7 +4,9 @@
 
 enum AppBannerPromptOutcome { "accepted", "dismissed" };
 
-interface AppBannerPromptResult {
+[
+    RuntimeEnabled=AppBanner,
+] interface AppBannerPromptResult {
     readonly attribute DOMString platform;
     readonly attribute AppBannerPromptOutcome outcome;
 };
diff --git a/third_party/WebKit/Source/modules/app_banner/BeforeInstallPromptEvent.idl b/third_party/WebKit/Source/modules/app_banner/BeforeInstallPromptEvent.idl
index 042ea17..691aa0c 100644
--- a/third_party/WebKit/Source/modules/app_banner/BeforeInstallPromptEvent.idl
+++ b/third_party/WebKit/Source/modules/app_banner/BeforeInstallPromptEvent.idl
@@ -3,7 +3,8 @@
 // found in the LICENSE file.
 
 [
-    Constructor(DOMString type, optional BeforeInstallPromptEventInit eventInitDict)
+    Constructor(DOMString type, optional BeforeInstallPromptEventInit eventInitDict),
+    RuntimeEnabled=AppBanner,
 ] interface BeforeInstallPromptEvent : Event {
     readonly attribute sequence<DOMString> platforms;
     [CallWith=ScriptState] readonly attribute Promise<DOMString> userChoice;
diff --git a/third_party/WebKit/Source/modules/cachestorage/Cache.cpp b/third_party/WebKit/Source/modules/cachestorage/Cache.cpp
index 1ec1096..3a3787e 100644
--- a/third_party/WebKit/Source/modules/cachestorage/Cache.cpp
+++ b/third_party/WebKit/Source/modules/cachestorage/Cache.cpp
@@ -50,7 +50,6 @@ public:
     {
         if (!m_resolver->getExecutionContext() || m_resolver->getExecutionContext()->activeDOMObjectsAreStopped())
             return;
-        ScriptState::Scope scope(m_resolver->getScriptState());
         m_resolver->resolve(Response::create(m_resolver->getScriptState(), webResponse));
         m_resolver.clear();
     }
@@ -81,7 +80,6 @@ public:
     {
         if (!m_resolver->getExecutionContext() || m_resolver->getExecutionContext()->activeDOMObjectsAreStopped())
             return;
-        ScriptState::Scope scope(m_resolver->getScriptState());
         HeapVector<Member<Response>> responses;
         for (size_t i = 0; i < webResponses.size(); ++i)
             responses.append(Response::create(m_resolver->getScriptState(), webResponses[i]));
@@ -142,7 +140,6 @@ public:
     {
         if (!m_resolver->getExecutionContext() || m_resolver->getExecutionContext()->activeDOMObjectsAreStopped())
             return;
-        ScriptState::Scope scope(m_resolver->getScriptState());
         HeapVector<Member<Request>> requests;
         for (size_t i = 0; i < webRequests.size(); ++i)
             requests.append(Request::create(m_resolver->getScriptState(), webRequests[i]));
diff --git a/third_party/WebKit/Source/modules/cachestorage/CacheStorage.cpp b/third_party/WebKit/Source/modules/cachestorage/CacheStorage.cpp
index 2abd491..057bd46 100644
--- a/third_party/WebKit/Source/modules/cachestorage/CacheStorage.cpp
+++ b/third_party/WebKit/Source/modules/cachestorage/CacheStorage.cpp
@@ -131,7 +131,6 @@ public:
     {
         if (!m_resolver->getExecutionContext() || m_resolver->getExecutionContext()->activeDOMObjectsAreStopped())
             return;
-        ScriptState::Scope scope(m_resolver->getScriptState());
         m_resolver->resolve(Response::create(m_resolver->getScriptState(), webResponse));
         m_resolver.clear();
     }
diff --git a/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.cpp b/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.cpp
index b21ff4f..a339b1e 100644
--- a/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.cpp
+++ b/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.cpp
@@ -106,6 +106,7 @@ BodyStreamBuffer::BodyStreamBuffer(ScriptState* scriptState, std::unique_ptr<Fet
     , m_madeFromReadableStream(false)
 {
     if (RuntimeEnabledFeatures::responseBodyWithV8ExtraStreamEnabled()) {
+        ScriptState::Scope scope(scriptState);
         if (isTerminating(scriptState)) {
             m_reader = nullptr;
             m_handle = nullptr;
@@ -140,6 +141,7 @@ BodyStreamBuffer::BodyStreamBuffer(ScriptState* scriptState, ScriptValue stream)
     , m_scriptState(scriptState)
     , m_madeFromReadableStream(true)
 {
+    ScriptState::Scope scope(scriptState);
     DCHECK(RuntimeEnabledFeatures::responseBodyWithV8ExtraStreamEnabled());
     DCHECK(ReadableStreamOperations::isReadableStream(scriptState, stream));
     if (isTerminating(scriptState))
@@ -226,6 +228,7 @@ void BodyStreamBuffer::tee(BodyStreamBuffer** branch1, BodyStreamBuffer** branch
     *branch2 = nullptr;
 
     if (m_madeFromReadableStream) {
+        ScriptState::Scope scope(m_scriptState.get());
         ScriptValue stream1, stream2;
         ReadableStreamOperations::tee(m_scriptState.get(), stream(), &stream1, &stream2);
         *branch1 = new BodyStreamBuffer(m_scriptState.get(), stream1);
diff --git a/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.h b/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.h
index 403b0b1..ba0226b 100644
--- a/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.h
+++ b/third_party/WebKit/Source/modules/fetch/BodyStreamBuffer.h
@@ -31,10 +31,8 @@ public:
     // Needed because we have to release |m_reader| promptly.
     EAGERLY_FINALIZE();
     // |handle| cannot be null and cannot be locked.
-    // This function must be called with entering an appropriate V8 context.
     BodyStreamBuffer(ScriptState*, std::unique_ptr<FetchDataConsumerHandle> /* handle */);
     // |ReadableStreamOperations::isReadableStream(stream)| must hold.
-    // This function must be called with entering an appropriate V8 context.
     BodyStreamBuffer(ScriptState*, ScriptValue stream);
 
     ScriptValue stream();
diff --git a/third_party/WebKit/Source/modules/fetch/BodyStreamBufferTest.cpp b/third_party/WebKit/Source/modules/fetch/BodyStreamBufferTest.cpp
index a547d78..defd829 100644
--- a/third_party/WebKit/Source/modules/fetch/BodyStreamBufferTest.cpp
+++ b/third_party/WebKit/Source/modules/fetch/BodyStreamBufferTest.cpp
@@ -4,8 +4,8 @@
 
 #include "modules/fetch/BodyStreamBuffer.h"
 
-#include "bindings/core/v8/V8BindingForTesting.h"
 #include "core/html/FormData.h"
+#include "core/testing/DummyPageHolder.h"
 #include "modules/fetch/DataConsumerHandleTestUtil.h"
 #include "modules/fetch/FetchBlobDataConsumerHandle.h"
 #include "modules/fetch/FetchFormDataConsumerHandle.h"
@@ -40,28 +40,40 @@ public:
 };
 
 class BodyStreamBufferTest : public ::testing::Test {
+public:
+    BodyStreamBufferTest()
+    {
+        m_page = DummyPageHolder::create(IntSize(1, 1));
+    }
+    ~BodyStreamBufferTest() override {}
+
 protected:
-    ScriptValue eval(ScriptState* scriptState, const char* s)
+    ScriptState* getScriptState() { return ScriptState::forMainWorld(m_page->document().frame()); }
+    ExecutionContext* getExecutionContext() { return &m_page->document(); }
+
+    std::unique_ptr<DummyPageHolder> m_page;
+
+    ScriptValue eval(const char* s)
     {
         v8::Local<v8::String> source;
         v8::Local<v8::Script> script;
-        v8::MicrotasksScope microtasks(scriptState->isolate(), v8::MicrotasksScope::kDoNotRunMicrotasks);
-        if (!v8Call(v8::String::NewFromUtf8(scriptState->isolate(), s, v8::NewStringType::kNormal), source)) {
+        v8::MicrotasksScope microtasks(getScriptState()->isolate(), v8::MicrotasksScope::kDoNotRunMicrotasks);
+        if (!v8Call(v8::String::NewFromUtf8(getScriptState()->isolate(), s, v8::NewStringType::kNormal), source)) {
             ADD_FAILURE();
             return ScriptValue();
         }
-        if (!v8Call(v8::Script::Compile(scriptState->context(), source), script)) {
+        if (!v8Call(v8::Script::Compile(getScriptState()->context(), source), script)) {
             ADD_FAILURE() << "Compilation fails";
             return ScriptValue();
         }
-        return ScriptValue(scriptState, script->Run(scriptState->context()));
+        return ScriptValue(getScriptState(), script->Run(getScriptState()->context()));
     }
-    ScriptValue evalWithPrintingError(ScriptState* scriptState, const char* s)
+    ScriptValue evalWithPrintingError(const char* s)
     {
-        v8::TryCatch block(scriptState->isolate());
-        ScriptValue r = eval(scriptState, s);
+        v8::TryCatch block(getScriptState()->isolate());
+        ScriptValue r = eval(s);
         if (block.HasCaught()) {
-            ADD_FAILURE() << toCoreString(block.Exception()->ToString(scriptState->isolate())).utf8().data();
+            ADD_FAILURE() << toCoreString(block.Exception()->ToString(getScriptState()->isolate())).utf8().data();
             block.ReThrow();
         }
         return r;
@@ -70,7 +82,6 @@ protected:
 
 TEST_F(BodyStreamBufferTest, Tee)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client1 = MockFetchDataLoaderClient::create();
     MockFetchDataLoaderClient* client2 = MockFetchDataLoaderClient::create();
@@ -87,7 +98,7 @@ TEST_F(BodyStreamBufferTest, Tee)
     handle->add(DataConsumerHandleTestUtil::Command(DataConsumerHandleTestUtil::Command::Data, "hello, "));
     handle->add(DataConsumerHandleTestUtil::Command(DataConsumerHandleTestUtil::Command::Data, "world"));
     handle->add(DataConsumerHandleTestUtil::Command(DataConsumerHandleTestUtil::Command::Done));
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
 
     BodyStreamBuffer* new1;
     BodyStreamBuffer* new2;
@@ -110,9 +121,8 @@ TEST_F(BodyStreamBufferTest, Tee)
 
 TEST_F(BodyStreamBufferTest, TeeFromHandleMadeFromStream)
 {
-    V8TestingScope scope;
+    ScriptState::Scope scope(getScriptState());
     ScriptValue stream = evalWithPrintingError(
-        scope.getScriptState(),
         "stream = new ReadableStream({start: c => controller = c});"
         "controller.enqueue(new Uint8Array([0x41, 0x42]));"
         "controller.enqueue(new Uint8Array([0x55, 0x58]));"
@@ -130,7 +140,7 @@ TEST_F(BodyStreamBufferTest, TeeFromHandleMadeFromStream)
     EXPECT_CALL(*client2, didFetchDataLoadedString(String("ABUX")));
     EXPECT_CALL(checkpoint, Call(4));
 
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), stream);
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), stream);
 
     BodyStreamBuffer* new1;
     BodyStreamBuffer* new2;
@@ -145,7 +155,7 @@ TEST_F(BodyStreamBufferTest, TeeFromHandleMadeFromStream)
     EXPECT_FALSE(buffer->isStreamDisturbed());
     EXPECT_FALSE(buffer->hasPendingActivity());
 
-    v8::MicrotasksScope::PerformCheckpoint(scope.getScriptState()->isolate());
+    v8::MicrotasksScope::PerformCheckpoint(getScriptState()->isolate());
 
     EXPECT_TRUE(buffer->isStreamLocked());
     EXPECT_TRUE(buffer->isStreamDisturbed());
@@ -164,12 +174,11 @@ TEST_F(BodyStreamBufferTest, TeeFromHandleMadeFromStream)
 
 TEST_F(BodyStreamBufferTest, DrainAsBlobDataHandle)
 {
-    V8TestingScope scope;
     std::unique_ptr<BlobData> data = BlobData::create();
     data->appendText("hello", false);
     auto size = data->length();
     RefPtr<BlobDataHandle> blobDataHandle = BlobDataHandle::create(std::move(data), size);
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), FetchBlobDataConsumerHandle::create(scope.getExecutionContext(), blobDataHandle, new FakeLoaderFactory));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), FetchBlobDataConsumerHandle::create(getExecutionContext(), blobDataHandle, new FakeLoaderFactory));
 
     EXPECT_FALSE(buffer->isStreamLocked());
     EXPECT_FALSE(buffer->isStreamDisturbed());
@@ -184,10 +193,9 @@ TEST_F(BodyStreamBufferTest, DrainAsBlobDataHandle)
 
 TEST_F(BodyStreamBufferTest, DrainAsBlobDataHandleReturnsNull)
 {
-    V8TestingScope scope;
     // This handle is not drainable.
     std::unique_ptr<FetchDataConsumerHandle> handle = createFetchDataConsumerHandleFromWebHandle(createWaitingDataConsumerHandle());
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), std::move(handle));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), std::move(handle));
 
     EXPECT_FALSE(buffer->isStreamLocked());
     EXPECT_FALSE(buffer->isStreamDisturbed());
@@ -202,9 +210,9 @@ TEST_F(BodyStreamBufferTest, DrainAsBlobDataHandleReturnsNull)
 
 TEST_F(BodyStreamBufferTest, DrainAsBlobFromBufferMadeFromBufferMadeFromStream)
 {
-    V8TestingScope scope;
-    ScriptValue stream = evalWithPrintingError(scope.getScriptState(), "new ReadableStream()");
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), stream);
+    ScriptState::Scope scope(getScriptState());
+    ScriptValue stream = evalWithPrintingError("new ReadableStream()");
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), stream);
 
     EXPECT_FALSE(buffer->hasPendingActivity());
     EXPECT_FALSE(buffer->isStreamLocked());
@@ -221,13 +229,12 @@ TEST_F(BodyStreamBufferTest, DrainAsBlobFromBufferMadeFromBufferMadeFromStream)
 
 TEST_F(BodyStreamBufferTest, DrainAsFormData)
 {
-    V8TestingScope scope;
     FormData* data = FormData::create(UTF8Encoding());
     data->append("name1", "value1");
     data->append("name2", "value2");
     RefPtr<EncodedFormData> inputFormData = data->encodeMultiPartFormData();
 
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), FetchFormDataConsumerHandle::create(scope.getExecutionContext(), inputFormData));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), FetchFormDataConsumerHandle::create(getExecutionContext(), inputFormData));
 
     EXPECT_FALSE(buffer->isStreamLocked());
     EXPECT_FALSE(buffer->isStreamDisturbed());
@@ -242,10 +249,9 @@ TEST_F(BodyStreamBufferTest, DrainAsFormData)
 
 TEST_F(BodyStreamBufferTest, DrainAsFormDataReturnsNull)
 {
-    V8TestingScope scope;
     // This handle is not drainable.
     std::unique_ptr<FetchDataConsumerHandle> handle = createFetchDataConsumerHandleFromWebHandle(createWaitingDataConsumerHandle());
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), std::move(handle));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), std::move(handle));
 
     EXPECT_FALSE(buffer->isStreamLocked());
     EXPECT_FALSE(buffer->isStreamDisturbed());
@@ -260,9 +266,9 @@ TEST_F(BodyStreamBufferTest, DrainAsFormDataReturnsNull)
 
 TEST_F(BodyStreamBufferTest, DrainAsFormDataFromBufferMadeFromBufferMadeFromStream)
 {
-    V8TestingScope scope;
-    ScriptValue stream = evalWithPrintingError(scope.getScriptState(), "new ReadableStream()");
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), stream);
+    ScriptState::Scope scope(getScriptState());
+    ScriptValue stream = evalWithPrintingError("new ReadableStream()");
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), stream);
 
     EXPECT_FALSE(buffer->hasPendingActivity());
     EXPECT_FALSE(buffer->isStreamLocked());
@@ -279,7 +285,6 @@ TEST_F(BodyStreamBufferTest, DrainAsFormDataFromBufferMadeFromBufferMadeFromStre
 
 TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsArrayBuffer)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
     DOMArrayBuffer* arrayBuffer = nullptr;
@@ -292,7 +297,7 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsArrayBuffer)
     std::unique_ptr<ReplayingHandle> handle = ReplayingHandle::create();
     handle->add(Command(Command::Data, "hello"));
     handle->add(Command(Command::Done));
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
     buffer->startLoading(FetchDataLoader::createLoaderAsArrayBuffer(), client);
 
     EXPECT_TRUE(buffer->isStreamLocked());
@@ -312,7 +317,6 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsArrayBuffer)
 
 TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsBlob)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
     RefPtr<BlobDataHandle> blobDataHandle;
@@ -325,7 +329,7 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsBlob)
     std::unique_ptr<ReplayingHandle> handle = ReplayingHandle::create();
     handle->add(Command(Command::Data, "hello"));
     handle->add(Command(Command::Done));
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
     buffer->startLoading(FetchDataLoader::createLoaderAsBlobHandle("text/plain"), client);
 
     EXPECT_TRUE(buffer->isStreamLocked());
@@ -344,7 +348,6 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsBlob)
 
 TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsString)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
 
@@ -356,7 +359,7 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsString)
     std::unique_ptr<ReplayingHandle> handle = ReplayingHandle::create();
     handle->add(Command(Command::Data, "hello"));
     handle->add(Command(Command::Done));
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
     buffer->startLoading(FetchDataLoader::createLoaderAsString(), client);
 
     EXPECT_TRUE(buffer->isStreamLocked());
@@ -374,7 +377,6 @@ TEST_F(BodyStreamBufferTest, LoadBodyStreamBufferAsString)
 
 TEST_F(BodyStreamBufferTest, LoadClosedHandle)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
 
@@ -383,7 +385,7 @@ TEST_F(BodyStreamBufferTest, LoadClosedHandle)
     EXPECT_CALL(*client, didFetchDataLoadedString(String("")));
     EXPECT_CALL(checkpoint, Call(2));
 
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(createDoneDataConsumerHandle()));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(createDoneDataConsumerHandle()));
 
     EXPECT_TRUE(buffer->isStreamReadable());
     testing::runPendingTasks();
@@ -409,7 +411,6 @@ TEST_F(BodyStreamBufferTest, LoadClosedHandle)
 
 TEST_F(BodyStreamBufferTest, LoadErroredHandle)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
 
@@ -418,7 +419,7 @@ TEST_F(BodyStreamBufferTest, LoadErroredHandle)
     EXPECT_CALL(*client, didFetchDataLoadFailed());
     EXPECT_CALL(checkpoint, Call(2));
 
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(createUnexpectedErrorDataConsumerHandle()));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(createUnexpectedErrorDataConsumerHandle()));
 
     EXPECT_TRUE(buffer->isStreamReadable());
     testing::runPendingTasks();
@@ -443,7 +444,6 @@ TEST_F(BodyStreamBufferTest, LoadErroredHandle)
 
 TEST_F(BodyStreamBufferTest, LoaderShouldBeKeptAliveByBodyStreamBuffer)
 {
-    V8TestingScope scope;
     Checkpoint checkpoint;
     MockFetchDataLoaderClient* client = MockFetchDataLoaderClient::create();
 
@@ -455,7 +455,7 @@ TEST_F(BodyStreamBufferTest, LoaderShouldBeKeptAliveByBodyStreamBuffer)
     std::unique_ptr<ReplayingHandle> handle = ReplayingHandle::create();
     handle->add(Command(Command::Data, "hello"));
     handle->add(Command(Command::Done));
-    Persistent<BodyStreamBuffer> buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
+    Persistent<BodyStreamBuffer> buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(std::move(handle)));
     buffer->startLoading(FetchDataLoader::createLoaderAsString(), client);
 
     ThreadHeap::collectAllGarbage();
@@ -479,7 +479,7 @@ public:
 
 TEST_F(BodyStreamBufferTest, SourceHandleAndReaderShouldBeDestructedWhenCanceled)
 {
-    V8TestingScope scope;
+    ScriptState::Scope scope(getScriptState());
     using MockHandle = MockFetchDataConsumerHandleWithMockDestructor;
     using MockReader = DataConsumerHandleTestUtil::MockFetchDataConsumerReader;
     std::unique_ptr<MockHandle> handle = MockHandle::create();
@@ -497,10 +497,10 @@ TEST_F(BodyStreamBufferTest, SourceHandleAndReaderShouldBeDestructedWhenCanceled
     // |reader| is adopted by |obtainReader|.
     ASSERT_TRUE(reader.release());
 
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), std::move(handle));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), std::move(handle));
     checkpoint.Call(1);
-    ScriptValue reason(scope.getScriptState(), v8String(scope.getScriptState()->isolate(), "reason"));
-    buffer->cancelSource(scope.getScriptState(), reason);
+    ScriptValue reason(getScriptState(), v8String(getScriptState()->isolate(), "reason"));
+    buffer->cancelSource(getScriptState(), reason);
     checkpoint.Call(2);
 }
 
diff --git a/third_party/WebKit/Source/modules/fetch/FetchManager.cpp b/third_party/WebKit/Source/modules/fetch/FetchManager.cpp
index 0acdab5..0d53af6 100644
--- a/third_party/WebKit/Source/modules/fetch/FetchManager.cpp
+++ b/third_party/WebKit/Source/modules/fetch/FetchManager.cpp
@@ -143,8 +143,6 @@ public:
     private:
         std::unique_ptr<WebDataConsumerHandle> m_handle;
         Member<CompositeDataConsumerHandle::Updater> m_updater;
-        // We cannot store a Response because its JS wrapper can be collected.
-        // TODO(yhirano): Fix this.
         Member<Response> m_response;
         Member<FetchManager::Loader> m_loader;
         String m_integrityMetadata;
@@ -211,8 +209,6 @@ DEFINE_TRACE(FetchManager::Loader)
 void FetchManager::Loader::didReceiveResponse(unsigned long, const ResourceResponse& response, std::unique_ptr<WebDataConsumerHandle> handle)
 {
     ASSERT(handle);
-    ScriptState* scriptState = m_resolver->getScriptState();
-    ScriptState::Scope scope(scriptState);
 
     if (response.url().protocolIs("blob") && response.httpStatusCode() == 404) {
         // "If |blob| is null, return a network error."
@@ -294,6 +290,7 @@ void FetchManager::Loader::didReceiveResponse(unsigned long, const ResourceRespo
         }
     }
 
+    ScriptState* scriptState = m_resolver->getScriptState();
     FetchResponseData* responseData = nullptr;
     CompositeDataConsumerHandle::Updater* updater = nullptr;
     if (m_request->integrity().isEmpty())
diff --git a/third_party/WebKit/Source/modules/fetch/Request.cpp b/third_party/WebKit/Source/modules/fetch/Request.cpp
index 08aff7d..d872c5d 100644
--- a/third_party/WebKit/Source/modules/fetch/Request.cpp
+++ b/third_party/WebKit/Source/modules/fetch/Request.cpp
@@ -678,6 +678,7 @@ String Request::mimeType() const
 
 void Request::refreshBody(ScriptState* scriptState)
 {
+    ScriptState::Scope scope(scriptState);
     v8::Local<v8::Value> bodyBuffer = toV8(this->bodyBuffer(), scriptState);
     v8::Local<v8::Value> request = toV8(this, scriptState);
     if (request.IsEmpty()) {
diff --git a/third_party/WebKit/Source/modules/fetch/Request.h b/third_party/WebKit/Source/modules/fetch/Request.h
index 569b84f..57a9f3b 100644
--- a/third_party/WebKit/Source/modules/fetch/Request.h
+++ b/third_party/WebKit/Source/modules/fetch/Request.h
@@ -31,8 +31,6 @@ class MODULES_EXPORT Request final : public Body {
     DEFINE_WRAPPERTYPEINFO();
     WTF_MAKE_NONCOPYABLE(Request);
 public:
-    // These "create" function must be called with entering an appropriate
-    // V8 context.
     // From Request.idl:
     static Request* create(ScriptState*, const RequestInfo&, const Dictionary&, ExceptionState&);
 
@@ -56,7 +54,6 @@ public:
     String integrity() const;
 
     // From Request.idl:
-    // This function must be called with entering an appropriate V8 context.
     Request* clone(ScriptState*, ExceptionState&);
 
     FetchRequestData* passRequestData(ScriptState*);
diff --git a/third_party/WebKit/Source/modules/fetch/RequestTest.cpp b/third_party/WebKit/Source/modules/fetch/RequestTest.cpp
index 90e8cd3..a264e1e 100644
--- a/third_party/WebKit/Source/modules/fetch/RequestTest.cpp
+++ b/third_party/WebKit/Source/modules/fetch/RequestTest.cpp
@@ -6,8 +6,9 @@
 
 #include "bindings/core/v8/ExceptionState.h"
 #include "bindings/core/v8/ScriptState.h"
-#include "bindings/core/v8/V8BindingForTesting.h"
 #include "core/dom/Document.h"
+#include "core/frame/Frame.h"
+#include "core/testing/DummyPageHolder.h"
 #include "public/platform/WebURLRequest.h"
 #include "public/platform/modules/serviceworker/WebServiceWorkerRequest.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -18,36 +19,45 @@
 namespace blink {
 namespace {
 
-TEST(ServiceWorkerRequestTest, FromString)
+class ServiceWorkerRequestTest : public ::testing::Test {
+public:
+    ServiceWorkerRequestTest()
+        : m_page(DummyPageHolder::create(IntSize(1, 1))) { }
+
+    ScriptState* getScriptState() { return ScriptState::forMainWorld(m_page->document().frame()); }
+    ExecutionContext* getExecutionContext() { return getScriptState()->getExecutionContext(); }
+
+private:
+    std::unique_ptr<DummyPageHolder> m_page;
+};
+
+TEST_F(ServiceWorkerRequestTest, FromString)
 {
-    V8TestingScope scope;
     TrackExceptionState exceptionState;
 
     KURL url(ParsedURLString, "http://www.example.com/");
-    Request* request = Request::create(scope.getScriptState(), url, exceptionState);
+    Request* request = Request::create(getScriptState(), url, exceptionState);
     ASSERT_FALSE(exceptionState.hadException());
     ASSERT(request);
     EXPECT_EQ(url, request->url());
 }
 
-TEST(ServiceWorkerRequestTest, FromRequest)
+TEST_F(ServiceWorkerRequestTest, FromRequest)
 {
-    V8TestingScope scope;
     TrackExceptionState exceptionState;
 
     KURL url(ParsedURLString, "http://www.example.com/");
-    Request* request1 = Request::create(scope.getScriptState(), url, exceptionState);
+    Request* request1 = Request::create(getScriptState(), url, exceptionState);
     ASSERT(request1);
 
-    Request* request2 = Request::create(scope.getScriptState(), request1, exceptionState);
+    Request* request2 = Request::create(getScriptState(), request1, exceptionState);
     ASSERT_FALSE(exceptionState.hadException());
     ASSERT(request2);
     EXPECT_EQ(url, request2->url());
 }
 
-TEST(ServiceWorkerRequestTest, FromAndToWebRequest)
+TEST_F(ServiceWorkerRequestTest, FromAndToWebRequest)
 {
-    V8TestingScope scope;
     WebServiceWorkerRequest webRequest;
 
     const KURL url(ParsedURLString, "http://www.example.com/");
@@ -69,7 +79,7 @@ TEST(ServiceWorkerRequestTest, FromAndToWebRequest)
         webRequest.setHeader(WebString::fromUTF8(headers[i].key), WebString::fromUTF8(headers[i].value));
     webRequest.setReferrer(referrer, referrerPolicy);
 
-    Request* request = Request::create(scope.getScriptState(), webRequest);
+    Request* request = Request::create(getScriptState(), webRequest);
     ASSERT(request);
     EXPECT_EQ(url, request->url());
     EXPECT_EQ(method, request->method());
@@ -100,13 +110,12 @@ TEST(ServiceWorkerRequestTest, FromAndToWebRequest)
     EXPECT_EQ(WebURLRequest::FetchRequestModeNoCORS, secondWebRequest.mode());
 }
 
-TEST(ServiceWorkerRequestTest, ToWebRequestStripsURLFragment)
+TEST_F(ServiceWorkerRequestTest, ToWebRequestStripsURLFragment)
 {
-    V8TestingScope scope;
     TrackExceptionState exceptionState;
     String urlWithoutFragment = "http://www.example.com/";
     String url = urlWithoutFragment + "#fragment";
-    Request* request = Request::create(scope.getScriptState(), url, exceptionState);
+    Request* request = Request::create(getScriptState(), url, exceptionState);
     ASSERT(request);
 
     WebServiceWorkerRequest webRequest;
diff --git a/third_party/WebKit/Source/modules/fetch/Response.cpp b/third_party/WebKit/Source/modules/fetch/Response.cpp
index 5ccedd4..d801f76 100644
--- a/third_party/WebKit/Source/modules/fetch/Response.cpp
+++ b/third_party/WebKit/Source/modules/fetch/Response.cpp
@@ -433,6 +433,7 @@ void Response::installBody()
 
 void Response::refreshBody(ScriptState* scriptState)
 {
+    ScriptState::Scope scope(scriptState);
     v8::Local<v8::Value> bodyBuffer = toV8(internalBodyBuffer(), scriptState);
     v8::Local<v8::Value> response = toV8(this, scriptState);
     if (response.IsEmpty()) {
diff --git a/third_party/WebKit/Source/modules/fetch/Response.h b/third_party/WebKit/Source/modules/fetch/Response.h
index b05e275..4f91a0d 100644
--- a/third_party/WebKit/Source/modules/fetch/Response.h
+++ b/third_party/WebKit/Source/modules/fetch/Response.h
@@ -30,8 +30,6 @@ class MODULES_EXPORT Response final : public Body {
     DEFINE_WRAPPERTYPEINFO();
     WTF_MAKE_NONCOPYABLE(Response);
 public:
-    // These "create" function which takes a ScriptState* must be called with
-    // entering an appropriate V8 context.
     // From Response.idl:
     static Response* create(ScriptState*, ExceptionState&);
     static Response* create(ScriptState*, ScriptValue body, const Dictionary&, ExceptionState&);
@@ -56,7 +54,6 @@ public:
     Headers* headers() const;
 
     // From Response.idl:
-    // This function must be called with entering an appropriate V8 context.
     Response* clone(ScriptState*, ExceptionState&);
 
     // ActiveScriptWrappable
diff --git a/third_party/WebKit/Source/modules/fetch/ResponseTest.cpp b/third_party/WebKit/Source/modules/fetch/ResponseTest.cpp
index d9aa422..0fee482 100644
--- a/third_party/WebKit/Source/modules/fetch/ResponseTest.cpp
+++ b/third_party/WebKit/Source/modules/fetch/ResponseTest.cpp
@@ -6,7 +6,6 @@
 
 #include "bindings/core/v8/ExceptionState.h"
 #include "bindings/core/v8/ScriptState.h"
-#include "bindings/core/v8/V8BindingForTesting.h"
 #include "core/dom/Document.h"
 #include "core/frame/Frame.h"
 #include "core/testing/DummyPageHolder.h"
@@ -44,24 +43,35 @@ std::unique_ptr<WebServiceWorkerResponse> createTestWebServiceWorkerResponse()
     return webResponse;
 }
 
-TEST(ServiceWorkerResponseTest, FromFetchResponseData)
+class ServiceWorkerResponseTest : public ::testing::Test {
+public:
+    ServiceWorkerResponseTest()
+        : m_page(DummyPageHolder::create(IntSize(1, 1))) { }
+
+    ScriptState* getScriptState() { return ScriptState::forMainWorld(m_page->document().frame()); }
+    ExecutionContext* getExecutionContext() { return getScriptState()->getExecutionContext(); }
+
+private:
+    std::unique_ptr<DummyPageHolder> m_page;
+};
+
+
+TEST_F(ServiceWorkerResponseTest, FromFetchResponseData)
 {
-    std::unique_ptr<DummyPageHolder> page = DummyPageHolder::create(IntSize(1, 1));
     const KURL url(ParsedURLString, "http://www.response.com");
 
     FetchResponseData* fetchResponseData = FetchResponseData::create();
     fetchResponseData->setURL(url);
 
-    Response* response = Response::create(&page->document(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     ASSERT(response);
     EXPECT_EQ(url, response->url());
 }
 
-TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponse)
+TEST_F(ServiceWorkerResponseTest, FromWebServiceWorkerResponse)
 {
-    V8TestingScope scope;
     std::unique_ptr<WebServiceWorkerResponse> webResponse = createTestWebServiceWorkerResponse();
-    Response* response = Response::create(scope.getScriptState(), *webResponse);
+    Response* response = Response::create(getScriptState(), *webResponse);
     ASSERT(response);
     EXPECT_EQ(webResponse->url(), response->url());
     EXPECT_EQ(webResponse->status(), response->status());
@@ -79,12 +89,11 @@ TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponse)
     }
 }
 
-TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseDefault)
+TEST_F(ServiceWorkerResponseTest, FromWebServiceWorkerResponseDefault)
 {
-    V8TestingScope scope;
     std::unique_ptr<WebServiceWorkerResponse> webResponse = createTestWebServiceWorkerResponse();
     webResponse->setResponseType(WebServiceWorkerResponseTypeDefault);
-    Response* response = Response::create(scope.getScriptState(), *webResponse);
+    Response* response = Response::create(getScriptState(), *webResponse);
 
     Headers* responseHeaders = response->headers();
     TrackExceptionState exceptionState;
@@ -94,12 +103,11 @@ TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseDefault)
     EXPECT_FALSE(exceptionState.hadException());
 }
 
-TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseBasic)
+TEST_F(ServiceWorkerResponseTest, FromWebServiceWorkerResponseBasic)
 {
-    V8TestingScope scope;
     std::unique_ptr<WebServiceWorkerResponse> webResponse = createTestWebServiceWorkerResponse();
     webResponse->setResponseType(WebServiceWorkerResponseTypeBasic);
-    Response* response = Response::create(scope.getScriptState(), *webResponse);
+    Response* response = Response::create(getScriptState(), *webResponse);
 
     Headers* responseHeaders = response->headers();
     TrackExceptionState exceptionState;
@@ -109,12 +117,11 @@ TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseBasic)
     EXPECT_FALSE(exceptionState.hadException());
 }
 
-TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseCORS)
+TEST_F(ServiceWorkerResponseTest, FromWebServiceWorkerResponseCORS)
 {
-    V8TestingScope scope;
     std::unique_ptr<WebServiceWorkerResponse> webResponse = createTestWebServiceWorkerResponse();
     webResponse->setResponseType(WebServiceWorkerResponseTypeCORS);
-    Response* response = Response::create(scope.getScriptState(), *webResponse);
+    Response* response = Response::create(getScriptState(), *webResponse);
 
     Headers* responseHeaders = response->headers();
     TrackExceptionState exceptionState;
@@ -124,12 +131,11 @@ TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseCORS)
     EXPECT_FALSE(exceptionState.hadException());
 }
 
-TEST(ServiceWorkerResponseTest, FromWebServiceWorkerResponseOpaque)
+TEST_F(ServiceWorkerResponseTest, FromWebServiceWorkerResponseOpaque)
 {
-    V8TestingScope scope;
     std::unique_ptr<WebServiceWorkerResponse> webResponse = createTestWebServiceWorkerResponse();
     webResponse->setResponseType(WebServiceWorkerResponseTypeOpaque);
-    Response* response = Response::create(scope.getScriptState(), *webResponse);
+    Response* response = Response::create(getScriptState(), *webResponse);
 
     Headers* responseHeaders = response->headers();
     TrackExceptionState exceptionState;
@@ -190,62 +196,57 @@ BodyStreamBuffer* createHelloWorldBuffer(ScriptState* scriptState)
     return new BodyStreamBuffer(scriptState, createFetchDataConsumerHandleFromWebHandle(std::move(src)));
 }
 
-TEST(ServiceWorkerResponseTest, BodyStreamBufferCloneDefault)
+TEST_F(ServiceWorkerResponseTest, BodyStreamBufferCloneDefault)
 {
-    V8TestingScope scope;
-    BodyStreamBuffer* buffer = createHelloWorldBuffer(scope.getScriptState());
+    BodyStreamBuffer* buffer = createHelloWorldBuffer(getScriptState());
     FetchResponseData* fetchResponseData = FetchResponseData::createWithBuffer(buffer);
     fetchResponseData->setURL(KURL(ParsedURLString, "http://www.response.com"));
-    Response* response = Response::create(scope.getExecutionContext(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     EXPECT_EQ(response->internalBodyBuffer(), buffer);
-    checkResponseStream(scope.getScriptState(), response, true);
+    checkResponseStream(getScriptState(), response, true);
 }
 
-TEST(ServiceWorkerResponseTest, BodyStreamBufferCloneBasic)
+TEST_F(ServiceWorkerResponseTest, BodyStreamBufferCloneBasic)
 {
-    V8TestingScope scope;
-    BodyStreamBuffer* buffer = createHelloWorldBuffer(scope.getScriptState());
+    BodyStreamBuffer* buffer = createHelloWorldBuffer(getScriptState());
     FetchResponseData* fetchResponseData = FetchResponseData::createWithBuffer(buffer);
     fetchResponseData->setURL(KURL(ParsedURLString, "http://www.response.com"));
     fetchResponseData = fetchResponseData->createBasicFilteredResponse();
-    Response* response = Response::create(scope.getExecutionContext(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     EXPECT_EQ(response->internalBodyBuffer(), buffer);
-    checkResponseStream(scope.getScriptState(), response, true);
+    checkResponseStream(getScriptState(), response, true);
 }
 
-TEST(ServiceWorkerResponseTest, BodyStreamBufferCloneCORS)
+TEST_F(ServiceWorkerResponseTest, BodyStreamBufferCloneCORS)
 {
-    V8TestingScope scope;
-    BodyStreamBuffer* buffer = createHelloWorldBuffer(scope.getScriptState());
+    BodyStreamBuffer* buffer = createHelloWorldBuffer(getScriptState());
     FetchResponseData* fetchResponseData = FetchResponseData::createWithBuffer(buffer);
     fetchResponseData->setURL(KURL(ParsedURLString, "http://www.response.com"));
     fetchResponseData = fetchResponseData->createCORSFilteredResponse();
-    Response* response = Response::create(scope.getExecutionContext(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     EXPECT_EQ(response->internalBodyBuffer(), buffer);
-    checkResponseStream(scope.getScriptState(), response, true);
+    checkResponseStream(getScriptState(), response, true);
 }
 
-TEST(ServiceWorkerResponseTest, BodyStreamBufferCloneOpaque)
+TEST_F(ServiceWorkerResponseTest, BodyStreamBufferCloneOpaque)
 {
-    V8TestingScope scope;
-    BodyStreamBuffer* buffer = createHelloWorldBuffer(scope.getScriptState());
+    BodyStreamBuffer* buffer = createHelloWorldBuffer(getScriptState());
     FetchResponseData* fetchResponseData = FetchResponseData::createWithBuffer(buffer);
     fetchResponseData->setURL(KURL(ParsedURLString, "http://www.response.com"));
     fetchResponseData = fetchResponseData->createOpaqueFilteredResponse();
-    Response* response = Response::create(scope.getExecutionContext(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     EXPECT_EQ(response->internalBodyBuffer(), buffer);
-    checkResponseStream(scope.getScriptState(), response, false);
+    checkResponseStream(getScriptState(), response, false);
 }
 
-TEST(ServiceWorkerResponseTest, BodyStreamBufferCloneError)
+TEST_F(ServiceWorkerResponseTest, BodyStreamBufferCloneError)
 {
-    V8TestingScope scope;
-    BodyStreamBuffer* buffer = new BodyStreamBuffer(scope.getScriptState(), createFetchDataConsumerHandleFromWebHandle(createUnexpectedErrorDataConsumerHandle()));
+    BodyStreamBuffer* buffer = new BodyStreamBuffer(getScriptState(), createFetchDataConsumerHandleFromWebHandle(createUnexpectedErrorDataConsumerHandle()));
     FetchResponseData* fetchResponseData = FetchResponseData::createWithBuffer(buffer);
     fetchResponseData->setURL(KURL(ParsedURLString, "http://www.response.com"));
-    Response* response = Response::create(scope.getExecutionContext(), fetchResponseData);
+    Response* response = Response::create(getExecutionContext(), fetchResponseData);
     TrackExceptionState exceptionState;
-    Response* clonedResponse = response->clone(scope.getScriptState(), exceptionState);
+    Response* clonedResponse = response->clone(getScriptState(), exceptionState);
     EXPECT_FALSE(exceptionState.hadException());
 
     DataConsumerHandleTestUtil::MockFetchDataLoaderClient* client1 = new DataConsumerHandleTestUtil::MockFetchDataLoaderClient();
diff --git a/third_party/WebKit/Source/modules/serviceworkers/NavigatorServiceWorker.cpp b/third_party/WebKit/Source/modules/serviceworkers/NavigatorServiceWorker.cpp
index b47a865..4dd3c93 100644
--- a/third_party/WebKit/Source/modules/serviceworkers/NavigatorServiceWorker.cpp
+++ b/third_party/WebKit/Source/modules/serviceworkers/NavigatorServiceWorker.cpp
@@ -73,7 +73,10 @@ ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(LocalFrame* frame,
 
 void NavigatorServiceWorker::contextDestroyed()
 {
-    m_serviceWorker = nullptr;
+    if (m_serviceWorker) {
+        m_serviceWorker->willBeDetachedFromFrame();
+        m_serviceWorker = nullptr;
+    }
 }
 
 DEFINE_TRACE(NavigatorServiceWorker)
diff --git a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp
index c7a4522..b0525d2 100644
--- a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp
+++ b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp
@@ -182,7 +182,7 @@ ServiceWorkerContainer::~ServiceWorkerContainer()
     ASSERT(!m_provider);
 }
 
-void ServiceWorkerContainer::contextDestroyed()
+void ServiceWorkerContainer::willBeDetachedFromFrame()
 {
     if (m_provider) {
         m_provider->setClient(0);
diff --git a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.h b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.h
index b1a3853..b912d7c 100644
--- a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.h
+++ b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.h
@@ -65,6 +65,8 @@ public:
     static ServiceWorkerContainer* create(ExecutionContext*);
     ~ServiceWorkerContainer();
 
+    void willBeDetachedFromFrame();
+
     DECLARE_VIRTUAL_TRACE();
 
     ServiceWorker* controller() { return m_controller; }
@@ -77,8 +79,6 @@ public:
     ScriptPromise getRegistration(ScriptState*, const String& documentURL);
     ScriptPromise getRegistrations(ScriptState*);
 
-    void contextDestroyed() override;
-
     // WebServiceWorkerProviderClient overrides.
     void setController(std::unique_ptr<WebServiceWorker::Handle>, bool shouldNotifyControllerChange) override;
     void dispatchMessageEvent(std::unique_ptr<WebServiceWorker::Handle>, const WebString& message, const WebMessagePortChannelArray&) override;
diff --git a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainerTest.cpp b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainerTest.cpp
index 678baaf..f57b4ce 100644
--- a/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainerTest.cpp
+++ b/third_party/WebKit/Source/modules/serviceworkers/ServiceWorkerContainerTest.cpp
@@ -188,6 +188,8 @@ protected:
         options.setScope(scope);
         ScriptPromise promise = container->registerServiceWorker(getScriptState(), scriptURL, options);
         expectRejected(getScriptState(), promise, valueTest);
+
+        container->willBeDetachedFromFrame();
     }
 
     void testGetRegistrationRejected(const String& documentURL, const ScriptValueTest& valueTest)
@@ -198,6 +200,8 @@ protected:
         ScriptState::Scope scriptScope(getScriptState());
         ScriptPromise promise = container->getRegistration(getScriptState(), documentURL);
         expectRejected(getScriptState(), promise, valueTest);
+
+        container->willBeDetachedFromFrame();
     }
 
 private:
@@ -334,6 +338,8 @@ TEST_F(ServiceWorkerContainerTest, RegisterUnregister_NonHttpsSecureOriginDelega
         EXPECT_EQ(WebURL(KURL(KURL(), "http://localhost/x/y/")), stubProvider.registerScope());
         EXPECT_EQ(WebURL(KURL(KURL(), "http://localhost/x/y/worker.js")), stubProvider.registerScriptURL());
     }
+
+    container->willBeDetachedFromFrame();
 }
 
 TEST_F(ServiceWorkerContainerTest, GetRegistration_OmittedDocumentURLDefaultsToPageURL)
@@ -351,6 +357,8 @@ TEST_F(ServiceWorkerContainerTest, GetRegistration_OmittedDocumentURLDefaultsToP
         EXPECT_EQ(1ul, stubProvider.getRegistrationCallCount());
         EXPECT_EQ(WebURL(KURL(KURL(), "http://localhost/x/index.html")), stubProvider.getRegistrationURL());
     }
+
+    container->willBeDetachedFromFrame();
 }
 
 } // namespace
diff --git a/third_party/WebKit/Source/platform/RuntimeEnabledFeatures.in b/third_party/WebKit/Source/platform/RuntimeEnabledFeatures.in
index b18c938..9425812 100644
--- a/third_party/WebKit/Source/platform/RuntimeEnabledFeatures.in
+++ b/third_party/WebKit/Source/platform/RuntimeEnabledFeatures.in
@@ -27,6 +27,7 @@
 // settable_from_internals specifies whether a feature can be set from internals.runtimeFlags, with the default
 // being false.
 
+AppBanner status=stable
 AlwaysUseComplexText status=stable
 AudioOutputDevices status=stable
 AudioVideoTracks status=experimental
diff --git a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
index 48e61ea..c176a29 100644
--- a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
+++ b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
@@ -79,6 +79,8 @@ const uint64_t CompositingReasonInlineTransform                          = UINT6
 
 const uint64_t CompositingReasonCompositorProxy                          = UINT64_C(1) << 49;
 
+const uint64_t CompositingReasonRequestVisibility                        = UINT64_C(1) << 50;
+
 // Various combinations of compositing reasons are defined here also, for more intutive and faster bitwise logic.
 const uint64_t CompositingReasonComboAllDirectReasons =
     CompositingReason3DTransform
@@ -96,7 +98,8 @@ const uint64_t CompositingReasonComboAllDirectReasons =
     | CompositingReasonVideoOverlay
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     CompositingReason3DTransform
@@ -105,7 +108,8 @@ const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     | CompositingReasonTransitionProperty
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboCompositedDescendants =
     CompositingReasonTransformWithCompositedDescendants
@@ -116,7 +120,8 @@ const uint64_t CompositingReasonComboCompositedDescendants =
     | CompositingReasonBlendingWithCompositedDescendants
     | CompositingReasonReflectionWithCompositedDescendants
     | CompositingReasonClipsCompositingDescendants
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonCombo3DDescendants =
     CompositingReasonPreserve3DWith3DDescendants
@@ -126,7 +131,8 @@ const uint64_t CompositingReasonComboAllStyleDeterminedReasons =
     CompositingReasonComboAllDirectStyleDeterminedReasons
     | CompositingReasonComboCompositedDescendants
     | CompositingReasonCombo3DDescendants
-    | CompositingReasonInlineTransform;
+    | CompositingReasonInlineTransform
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     CompositingReasonComboAllDirectReasons
@@ -142,7 +148,8 @@ const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     | CompositingReasonIsolateCompositedDescendants
     | CompositingReasonPreserve3DWith3DDescendants // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
     | CompositingReasonBackdropFilter
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboSquashableReasons =
     CompositingReasonOverlap
diff --git a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
index c705704..dab2036 100644
--- a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
+++ b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
@@ -135,6 +135,7 @@ GraphicsLayer::GraphicsLayer(GraphicsLayerClient* client)
     , m_isTrackingPaintInvalidations(client && client->isTrackingPaintInvalidations())
     , m_paintingPhase(GraphicsLayerPaintAllWithOverflowClip)
     , m_parent(0)
+    , m_crossroot_parent(0)
     , m_maskLayer(0)
     , m_contentsClippingMaskLayer(0)
     , m_replicaLayer(0)
@@ -203,6 +204,12 @@ void GraphicsLayer::setParent(GraphicsLayer* layer)
     m_parent = layer;
 }
 
+void GraphicsLayer::setCrossrootParent(GraphicsLayer* layer)
+{
+    ASSERT(!layer || !layer->hasAncestor(this));
+    m_crossroot_parent = layer;
+}
+
 #if ENABLE(ASSERT)
 
 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
@@ -296,6 +303,16 @@ void GraphicsLayer::removeFromParent()
     platformLayer()->removeFromParent();
 }
 
+void GraphicsLayer::removeFromCrossrootParent()
+{
+    if (m_crossroot_parent) {
+        // We use reverseFind so that removeAllChildren() isn't n^2.
+        m_crossroot_parent->m_children.remove(m_crossroot_parent->m_children.reverseFind(this));
+        setParent(0);
+    }
+    platformLayer()->removeFromParent();
+}
+
 void GraphicsLayer::setReplicatedByLayer(GraphicsLayer* layer)
 {
     // FIXME: this could probably be a full early exit.
diff --git a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
index f208a5e..ad8d67e 100644
--- a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
+++ b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
@@ -87,6 +87,9 @@ public:
     GraphicsLayer* parent() const { return m_parent; }
     void setParent(GraphicsLayer*); // Internal use only.
 
+    GraphicsLayer* crossrootParent() const { return m_crossroot_parent; }
+    void setCrossrootParent(GraphicsLayer*); // Internal use only.
+
     const Vector<GraphicsLayer*>& children() const { return m_children; }
     // Returns true if the child list changed.
     bool setChildren(const GraphicsLayerVector&);
@@ -97,6 +100,7 @@ public:
 
     void removeAllChildren();
     void removeFromParent();
+    void removeFromCrossrootParent();
 
     GraphicsLayer* maskLayer() const { return m_maskLayer; }
     void setMaskLayer(GraphicsLayer*);
@@ -342,6 +346,7 @@ private:
 
     Vector<GraphicsLayer*> m_children;
     GraphicsLayer* m_parent;
+    GraphicsLayer* m_crossroot_parent;
 
     GraphicsLayer* m_maskLayer; // Reference to mask layer. We don't own this.
     GraphicsLayer* m_contentsClippingMaskLayer; // Reference to clipping mask layer. We don't own this.
diff --git a/third_party/WebKit/Source/platform/threading/BackgroundTaskRunner.cpp b/third_party/WebKit/Source/platform/threading/BackgroundTaskRunner.cpp
index ae5b309..0092784 100644
--- a/third_party/WebKit/Source/platform/threading/BackgroundTaskRunner.cpp
+++ b/third_party/WebKit/Source/platform/threading/BackgroundTaskRunner.cpp
@@ -4,16 +4,23 @@
 
 #include "platform/threading/BackgroundTaskRunner.h"
 
+#include "base/bind.h"
+#include "base/bind_helpers.h"
 #include "base/location.h"
 #include "base/threading/worker_pool.h"
 #include "public/platform/WebTraceLocation.h"
 
 namespace blink {
 
+static void RunBackgroundTask(CrossThreadClosure* closure)
+{
+    (*closure)();
+}
+
 void BackgroundTaskRunner::postOnBackgroundThread(const WebTraceLocation& location, std::unique_ptr<CrossThreadClosure> closure, TaskSize taskSize)
 {
     tracked_objects::Location baseLocation(location.functionName(), location.fileName(), 0, nullptr);
-    base::WorkerPool::PostTask(baseLocation, convertToBaseCallback(std::move(closure)), taskSize == TaskSizeLongRunningTask);
+    base::WorkerPool::PostTask(baseLocation, base::Bind(&RunBackgroundTask, base::Owned(closure.release())), taskSize == TaskSizeLongRunningTask);
 }
 
 } // namespace blink
diff --git a/third_party/WebKit/Source/platform/threading/DEPS b/third_party/WebKit/Source/platform/threading/DEPS
index 0beb744..1ffab49 100644
--- a/third_party/WebKit/Source/platform/threading/DEPS
+++ b/third_party/WebKit/Source/platform/threading/DEPS
@@ -1,5 +1,7 @@
 include_rules = [
     # To whitelist base/ stuff Blink is allowed to include, we list up all
     # directories and files instead of writing 'base/'.
+    "+base/bind.h",
+    "+base/bind_helpers.h",
     "+base/threading",
 ]
diff --git a/third_party/WebKit/Source/web/FullscreenController.cpp b/third_party/WebKit/Source/web/FullscreenController.cpp
index 1bae36f..0b50689 100644
--- a/third_party/WebKit/Source/web/FullscreenController.cpp
+++ b/third_party/WebKit/Source/web/FullscreenController.cpp
@@ -37,6 +37,7 @@
 #include "core/frame/PageScaleConstraintsSet.h"
 #include "core/html/HTMLMediaElement.h"
 #include "core/html/HTMLVideoElement.h"
+#include "core/layout/LayoutFullScreen.h"
 #include "platform/RuntimeEnabledFeatures.h"
 #include "public/platform/WebLayerTreeView.h"
 #include "public/web/WebFrameClient.h"
@@ -130,13 +131,6 @@ void FullscreenController::didExitFullscreen()
 
 void FullscreenController::enterFullScreenForElement(Element* element)
 {
-    // TODO(dsinclair): This should not be needed because we addToTopLayer
-    // in Fullscreen::pushFullscreenElementStack but, the WebView code doesn't
-    // call Fullscreen::requestFullscreen() and, instead, just enters and
-    // exists itself. This should be unified so there is one way to go
-    // fullscreen.  crbug.com/538158
-    element->document().addToTopLayer(element);
-
     // We are already transitioning to fullscreen for a different element.
     if (m_provisionalFullScreenElement) {
         m_provisionalFullScreenElement = element;
@@ -172,13 +166,6 @@ void FullscreenController::exitFullScreenForElement(Element* element)
 {
     DCHECK(element);
 
-    // TODO(dsinclair): This should not be needed because we addToTopLayer
-    // in Fullscreen::popFullscreenElementStack but, the WebView code doesn't
-    // call Fullscreen::requestFullscreen() and, instead, just enters and
-    // exists itself. This should be unified so there is one way to go
-    // fullscreen.  crbug.com/538158
-    element->document().removeFromTopLayer(element);
-
     // The client is exiting full screen, so don't send a notification.
     if (m_isCancelingFullScreen)
         return;
@@ -195,9 +182,9 @@ void FullscreenController::updateSize()
 
     updatePageScaleConstraints(false);
 
-    Document* document = m_fullScreenFrame->document();
-    if (Element* fullscreenElement = Fullscreen::currentFullScreenElementFrom(*document))
-        Fullscreen::from(fullscreenElement->document()).didUpdateSize(*fullscreenElement);
+    LayoutFullScreen* layoutObject = Fullscreen::from(*m_fullScreenFrame->document()).fullScreenLayoutObject();
+    if (layoutObject)
+        layoutObject->updateStyle();
 }
 
 void FullscreenController::updatePageScaleConstraints(bool removeConstraints)
diff --git a/third_party/WebKit/Source/web/ServiceWorkerGlobalScopeProxy.cpp b/third_party/WebKit/Source/web/ServiceWorkerGlobalScopeProxy.cpp
index abfa8f8..c664b86 100644
--- a/third_party/WebKit/Source/web/ServiceWorkerGlobalScopeProxy.cpp
+++ b/third_party/WebKit/Source/web/ServiceWorkerGlobalScopeProxy.cpp
@@ -133,7 +133,6 @@ void ServiceWorkerGlobalScopeProxy::dispatchExtendableMessageEvent(int eventID,
 
 void ServiceWorkerGlobalScopeProxy::dispatchFetchEvent(int responseID, int eventFinishID, const WebServiceWorkerRequest& webRequest)
 {
-    ScriptState::Scope scope(workerGlobalScope()->scriptController()->getScriptState());
     WaitUntilObserver* waitUntilObserver = WaitUntilObserver::create(workerGlobalScope(), WaitUntilObserver::Fetch, eventFinishID);
     RespondWithObserver* respondWithObserver = RespondWithObserver::create(workerGlobalScope(), responseID, webRequest.url(), webRequest.mode(), webRequest.frameType(), webRequest.requestContext(), waitUntilObserver);
     Request* request = Request::create(workerGlobalScope()->scriptController()->getScriptState(), webRequest);
@@ -154,7 +153,6 @@ void ServiceWorkerGlobalScopeProxy::dispatchFetchEvent(int responseID, int event
 
 void ServiceWorkerGlobalScopeProxy::dispatchForeignFetchEvent(int responseID, int eventFinishID, const WebServiceWorkerRequest& webRequest)
 {
-    ScriptState::Scope scope(workerGlobalScope()->scriptController()->getScriptState());
     RefPtr<SecurityOrigin> origin = SecurityOrigin::create(webRequest.referrerUrl());
     WaitUntilObserver* waitUntilObserver = WaitUntilObserver::create(workerGlobalScope(), WaitUntilObserver::Fetch, eventFinishID);
     ForeignFetchRespondWithObserver* respondWithObserver = ForeignFetchRespondWithObserver::create(workerGlobalScope(), responseID, webRequest.url(), webRequest.mode(), webRequest.frameType(), webRequest.requestContext(), origin, waitUntilObserver);
diff --git a/third_party/WebKit/Source/web/WebLocalFrameImpl.cpp b/third_party/WebKit/Source/web/WebLocalFrameImpl.cpp
index 28c2745..a889e40 100644
--- a/third_party/WebKit/Source/web/WebLocalFrameImpl.cpp
+++ b/third_party/WebKit/Source/web/WebLocalFrameImpl.cpp
@@ -1940,7 +1940,7 @@ void WebLocalFrameImpl::sendOrientationChangeEvent()
 
 void WebLocalFrameImpl::willShowInstallBannerPrompt(int requestId, const WebVector<WebString>& platforms, WebAppBannerPromptReply* reply)
 {
-    if (!frame())
+    if (!RuntimeEnabledFeatures::appBannerEnabled() || !frame())
         return;
 
     AppBannerController::willShowInstallBannerPrompt(requestId, client()->appBannerClient(), frame(), platforms, reply);
diff --git a/third_party/WebKit/Source/web/tests/WebFrameTest.cpp b/third_party/WebKit/Source/web/tests/WebFrameTest.cpp
index 37a1091..6cf1755 100644
--- a/third_party/WebKit/Source/web/tests/WebFrameTest.cpp
+++ b/third_party/WebKit/Source/web/tests/WebFrameTest.cpp
@@ -64,6 +64,8 @@
 #include "core/html/ImageDocument.h"
 #include "core/input/EventHandler.h"
 #include "core/layout/HitTestResult.h"
+#include "core/layout/LayoutFullScreen.h"
+#include "core/layout/api/LayoutViewItem.h"
 #include "core/layout/compositing/PaintLayerCompositor.h"
 #include "core/loader/DocumentLoader.h"
 #include "core/loader/DocumentThreadableLoader.h"
@@ -6449,40 +6451,6 @@ TEST_F(WebFrameTest, MaximumScrollPositionCanBeNegative)
     EXPECT_LT(frameView->maximumScrollPosition().x(), 0);
 }
 
-TEST_F(WebFrameTest, FullscreenCleanTopLayerAndFullscreenStack)
-{
-    FakeCompositingWebViewClient client;
-    registerMockedHttpURLLoad("fullscreen_div.html");
-    FrameTestHelpers::WebViewHelper webViewHelper;
-    int viewportWidth = 640;
-    int viewportHeight = 480;
-    client.m_screenInfo.rect.width = viewportWidth;
-    client.m_screenInfo.rect.height = viewportHeight;
-    WebViewImpl* webViewImpl = webViewHelper.initializeAndLoad(
-        m_baseURL + "fullscreen_div.html", true, 0, &client, nullptr, configureAndroid);
-    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
-    webViewImpl->updateAllLifecyclePhases();
-
-    UserGestureIndicator gesture(DefinitelyProcessingUserGesture);
-    Document* document = toWebLocalFrameImpl(webViewImpl->mainFrame())->frame()->document();
-    Fullscreen& fullscreen = Fullscreen::from(*document);
-
-    Element* divFullscreen = document->getElementById("div1");
-    fullscreen.requestFullscreen(*divFullscreen, Fullscreen::PrefixedRequest);
-    webViewImpl->didEnterFullscreen();
-    ASSERT_TRUE(Fullscreen::isFullScreen(*document));
-
-    // Sanity check. We should have both in our stack.
-    ASSERT_EQ(fullscreen.fullScreenElementStack().size(), 1UL);
-    ASSERT_EQ(document->topLayerElements().size(), 2UL);
-
-    fullscreen.exitFullscreen();
-    webViewImpl->didExitFullscreen();
-
-    ASSERT_EQ(fullscreen.fullScreenElementStack().size(), 0UL);
-    ASSERT_EQ(document->topLayerElements().size(), 0UL);
-}
-
 TEST_P(ParameterizedWebFrameTest, FullscreenLayerSize)
 {
     FakeCompositingWebViewClient client;
@@ -6505,8 +6473,7 @@ TEST_P(ParameterizedWebFrameTest, FullscreenLayerSize)
     ASSERT_TRUE(Fullscreen::isFullScreen(*document));
 
     // Verify that the element is sized to the viewport.
-    Element* fullscreenElement = Fullscreen::currentFullScreenElementFrom(*document);
-    LayoutBox* fullscreenLayoutObject = toLayoutBox(fullscreenElement->layoutObject());
+    LayoutFullScreen* fullscreenLayoutObject = Fullscreen::from(*document).fullScreenLayoutObject();
     EXPECT_EQ(viewportWidth, fullscreenLayoutObject->logicalWidth().toInt());
     EXPECT_EQ(viewportHeight, fullscreenLayoutObject->logicalHeight().toInt());
 
@@ -6610,8 +6577,7 @@ TEST_P(ParameterizedWebFrameTest, FullscreenSubframe)
     webViewImpl->updateAllLifecyclePhases();
 
     // Verify that the element is sized to the viewport.
-    Element* fullscreenElement = Fullscreen::currentFullScreenElementFrom(*document);
-    LayoutBox* fullscreenLayoutObject = toLayoutBox(fullscreenElement->layoutObject());
+    LayoutFullScreen* fullscreenLayoutObject = Fullscreen::from(*document).fullScreenLayoutObject();
     EXPECT_EQ(viewportWidth, fullscreenLayoutObject->logicalWidth().toInt());
     EXPECT_EQ(viewportHeight, fullscreenLayoutObject->logicalHeight().toInt());
 
diff --git a/third_party/widevine/cdm/widevine_cdm.gyp b/third_party/widevine/cdm/widevine_cdm.gyp
index 94a541c..0e66c9d 100644
--- a/third_party/widevine/cdm/widevine_cdm.gyp
+++ b/third_party/widevine/cdm/widevine_cdm.gyp
@@ -179,6 +179,39 @@
       ],
     },
     {
+      'target_name': 'widevinecdm_binary',
+      'product_name': 'widevinecdm',
+      'type': 'none',
+      'conditions': [
+        ['os_posix == 1 and OS != "mac"', {
+          'type': 'loadable_module',
+        }],
+        ['OS == "mac" or OS == "win"', {
+          'type': 'shared_library',
+        }],
+        ['OS == "mac"', {
+          'xcode_settings': {
+            'DYLIB_INSTALL_NAME_BASE': '@loader_path',
+          },
+        }, {
+          # Put Widevine CDM in the correct path directly except
+          # for mac. On mac strip_save_dsym doesn't work with product_dir
+          # so we rely on the "widevinecdm" target to copy it over.
+          # See http://crbug.com/611990
+          'product_dir': '<(PRODUCT_DIR)/<(widevine_cdm_path)',
+        }],
+      ],
+      'defines': ['CDM_IMPLEMENTATION'],
+      'dependencies': [
+        'widevine_cdm_version_h',
+        '<(DEPTH)/base/base.gyp:base',
+      ],
+      'sources': [
+        '<(DEPTH)/media/cdm/stub/stub_cdm.cc',
+        '<(DEPTH)/media/cdm/stub/stub_cdm.h',
+      ],
+    },
+    {
       # GN version: //third_party/widevine/cdm:widevinecdm
       'target_name': 'widevinecdm',
       'type': 'none',
@@ -197,32 +230,20 @@
           }],
         }],
         [ 'branding != "Chrome" and enable_widevine == 1', {
-          'product_dir': '<(PRODUCT_DIR)/<(widevine_cdm_path)',
+          # On Mac this copies the widevinecdm binary to <(widevine_cdm_path).
+          # On other platforms the binary is already in <(widevine_cdm_path).
+          # See "widevinecdm_binary" above.
+          'dependencies': [
+            'widevinecdm_binary',
+          ],
           'conditions': [
-            ['os_posix == 1 and OS != "mac"', {
-              'type': 'loadable_module',
-              # This causes the binary to be put in
-              # <(PRODUCT_DIR)/<(widevine_cdm_path) instead of lib/.
-              # This matches what happens in the copy step above.
-            }],
-            ['OS == "mac" or OS == "win"', {
-              'type': 'shared_library',
-            }],
             ['OS == "mac"', {
-              'xcode_settings': {
-                'DYLIB_INSTALL_NAME_BASE': '@loader_path',
-              },
+              'copies': [{
+                'destination': '<(PRODUCT_DIR)/<(widevine_cdm_path)',
+                'files': [ '<(PRODUCT_DIR)/libwidevinecdm.dylib' ],
+              }],
             }],
           ],
-          'defines': ['CDM_IMPLEMENTATION'],
-          'dependencies': [
-            'widevine_cdm_version_h',
-            '<(DEPTH)/base/base.gyp:base',
-          ],
-          'sources': [
-            '<(DEPTH)/media/cdm/stub/stub_cdm.cc',
-            '<(DEPTH)/media/cdm/stub/stub_cdm.h',
-          ],
         }],
       ],
     },
diff --git a/tools/metrics/histograms/histograms.xml b/tools/metrics/histograms/histograms.xml
index 9cc8568..9d677df 100644
--- a/tools/metrics/histograms/histograms.xml
+++ b/tools/metrics/histograms/histograms.xml
@@ -31052,9 +31052,6 @@ http://cs/file:chrome/histograms.xml - but prefer this file for new entries.
 </histogram>
 
 <histogram name="Net.SpdySettingsCwndSent" units="packets">
-  <obsolete>
-    Deprecated 2016 July with removal of SPDY/3.1.
-  </obsolete>
   <owner>rch@chromium.org</owner>
   <summary>
     The congestion window (in pkts) sent at the beginning of a SpdySession.
@@ -31172,9 +31169,6 @@ http://cs/file:chrome/histograms.xml - but prefer this file for new entries.
 
 <histogram name="Net.SpdyVersion3" enum="SpdyProtocolVersion">
   <owner>bnc@chromium.org</owner>
-  <obsolete>
-    Deprecated 2016 July with removal of SPDY/3.1.
-  </obsolete>
   <summary>
     The SPDY protocol version that is used to talk to SPDY servers.  Logged
     every time a SPDY session is initialized.
@@ -38747,10 +38741,6 @@ http://cs/file:chrome/histograms.xml - but prefer this file for new entries.
 
 <histogram name="PasswordManager.UserStoredPasswordWithInvalidSSLCert"
     enum="Boolean">
-  <obsolete>
-    Deprecated 07/2016 because this information is no longer stored in
-    PasswordForm. See also http://crbug.com/413020.
-  </obsolete>
   <owner>xunlu@chromium.org</owner>
   <owner>gcasto@chromium.org</owner>
   <summary>
@@ -95690,7 +95680,6 @@ To add a new entry, add it with any value and run test to compute valid value.
   <suffix name="Autofill"/>
   <suffix name="Policy"/>
   <suffix name="SpellChecker"/>
-  <suffix name="NTPSnippets"/>
   <affected-histogram name="DataUse.MessageSize"/>
 </histogram_suffixes>
 
diff --git a/tools/valgrind/gtest_exclude/cc_unittests.gtest-drmemory_win32.txt b/tools/valgrind/gtest_exclude/cc_unittests.gtest-drmemory_win32.txt
index aa6f9ac..f1a0c66 100644
--- a/tools/valgrind/gtest_exclude/cc_unittests.gtest-drmemory_win32.txt
+++ b/tools/valgrind/gtest_exclude/cc_unittests.gtest-drmemory_win32.txt
@@ -18,6 +18,9 @@ LayerTreeHostTestReadyToActivateNonEmpty.*
 # http://crbug.com/430400
 PixelResourceTest*
 
+# https://crbug.com/460581
+LayerTreeHostPictureTestRSLLMembershipWithScale.RunMultiThread_DirectRenderer_ImplSidePaint
+
 # https://crbug.com/486619
 LayerTreeHostTestWillBeginImplFrameHasDidFinishImplFrame.RunSingleThread*
 
diff --git a/ui/gfx/color_space.cc b/ui/gfx/color_space.cc
index 7650b1e..ad0f135 100644
--- a/ui/gfx/color_space.cc
+++ b/ui/gfx/color_space.cc
@@ -2,15 +2,92 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "build/build_config.h"
 #include "ui/gfx/color_space.h"
 
+#include <map>
+
+#include "base/lazy_instance.h"
+#include "base/synchronization/lock.h"
+
 namespace gfx {
 
 namespace {
 static const size_t kMinProfileLength = 128;
 static const size_t kMaxProfileLength = 4 * 1024 * 1024;
-}
+}  // namespace
+
+// The structure used to look up GlobalData structures.
+struct ColorSpace::Key {
+  Key(ColorSpace::Type type, const std::vector<char>& icc_profile)
+      : type(type), icc_profile(icc_profile) {}
+
+  bool operator<(const Key& other) const {
+    if (type < other.type)
+      return true;
+    if (type > other.type)
+      return false;
+    if (type != Type::ICC_PROFILE)
+      return false;
+
+    if (icc_profile.size() < other.icc_profile.size())
+      return true;
+    if (icc_profile.size() > other.icc_profile.size())
+      return false;
+    for (size_t i = 0; i < icc_profile.size(); ++i) {
+      if (icc_profile[i] < other.icc_profile[i])
+        return true;
+      if (icc_profile[i] > other.icc_profile[i])
+        return false;
+    }
+    return false;
+  }
+
+  ColorSpace::Type type;
+  const std::vector<char> icc_profile;
+};
+
+// Because this structure is shared across gfx::ColorSpace objects on
+// different threads, it needs to be thread-safe.
+class ColorSpace::GlobalData
+    : public base::RefCountedThreadSafe<ColorSpace::GlobalData> {
+ public:
+  static void Get(const Key& key, scoped_refptr<GlobalData>* value) {
+    base::AutoLock lock(map_lock_.Get());
+    auto insert_result = map_.Get().insert(std::make_pair(key, nullptr));
+    if (insert_result.second)
+      insert_result.first->second = new GlobalData(key, insert_result.first);
+    *value = make_scoped_refptr(insert_result.first->second);
+  }
+
+  const std::vector<char>& GetICCProfile() const { return icc_profile_; }
+
+ private:
+  friend class base::RefCountedThreadSafe<GlobalData>;
+
+  GlobalData(const Key& key, std::map<Key, GlobalData*>::iterator iterator)
+      : iterator_(iterator) {
+    // TODO: Compute the ICC profile for named color spaces.
+    if (key.type == Type::ICC_PROFILE)
+      icc_profile_ = key.icc_profile;
+  }
+  ~GlobalData() {
+    base::AutoLock lock(map_lock_.Get());
+    map_.Get().erase(iterator_);
+  }
+
+  std::vector<char> icc_profile_;
+
+  // In order to remove |this| from |map_| when its last reference goes away,
+  // keep in |iterator_| the corresponding iterator in |map_|.
+  std::map<Key, GlobalData*>::iterator iterator_;
+  static base::LazyInstance<std::map<Key, GlobalData*>> map_;
+  static base::LazyInstance<base::Lock> map_lock_;
+};
+
+base::LazyInstance<std::map<ColorSpace::Key, ColorSpace::GlobalData*>>
+    ColorSpace::GlobalData::map_ = LAZY_INSTANCE_INITIALIZER;
+base::LazyInstance<base::Lock>
+    ColorSpace::GlobalData::map_lock_ = LAZY_INSTANCE_INITIALIZER;
 
 ColorSpace::ColorSpace() = default;
 ColorSpace::ColorSpace(ColorSpace&& other) = default;
@@ -19,13 +96,26 @@ ColorSpace& ColorSpace::operator=(const ColorSpace& other) = default;
 ColorSpace::~ColorSpace() = default;
 
 bool ColorSpace::operator==(const ColorSpace& other) const {
-  return icc_profile_ == other.icc_profile_;
+  if (type_ == Type::ICC_PROFILE && other.type_ == Type::ICC_PROFILE)
+    return global_data_ == other.global_data_;
+  return type_ == other.type_;
 }
 
+bool ColorSpace::operator<(const ColorSpace& other) const {
+  // Note that this does a pointer-based comparision.
+  if (type_ == Type::ICC_PROFILE && other.type_ == Type::ICC_PROFILE)
+    return global_data_.get() < other.global_data_.get();
+  return type_ < other.type_;
+}
+
+// static
 ColorSpace ColorSpace::FromICCProfile(const std::vector<char>& icc_profile) {
   ColorSpace color_space;
-  if (IsValidProfileLength(icc_profile.size()))
-    color_space.icc_profile_ = icc_profile;
+  if (IsValidProfileLength(icc_profile.size())) {
+    color_space.type_ = Type::ICC_PROFILE;
+    Key key(Type::ICC_PROFILE, icc_profile);
+    GlobalData::Get(key, &color_space.global_data_);
+  }
   return color_space;
 }
 
@@ -36,6 +126,14 @@ ColorSpace ColorSpace::FromBestMonitor() {
 }
 #endif
 
+const std::vector<char>& ColorSpace::GetICCProfile() const {
+  if (!global_data_) {
+    Key key(type_, std::vector<char>());
+    GlobalData::Get(key, &global_data_);
+  }
+  return global_data_->GetICCProfile();
+}
+
 // static
 bool ColorSpace::IsValidProfileLength(size_t length) {
   return length >= kMinProfileLength && length <= kMaxProfileLength;
diff --git a/ui/gfx/color_space.h b/ui/gfx/color_space.h
index 0129e7e..44a85eb 100644
--- a/ui/gfx/color_space.h
+++ b/ui/gfx/color_space.h
@@ -8,6 +8,7 @@
 #include <vector>
 
 #include "base/macros.h"
+#include "base/memory/ref_counted.h"
 #include "build/build_config.h"
 #include "ui/gfx/gfx_export.h"
 
@@ -25,6 +26,7 @@ class GFX_EXPORT ColorSpace {
   ColorSpace& operator=(const ColorSpace& other);
   ~ColorSpace();
   bool operator==(const ColorSpace& other) const;
+  bool operator<(const ColorSpace& other) const;
 
   // Returns the color profile of the monitor that can best represent color.
   // This profile should be used for creating content that does not know on
@@ -35,7 +37,7 @@ class GFX_EXPORT ColorSpace {
   static ColorSpace FromCGColorSpace(CGColorSpaceRef cg_color_space);
 #endif
 
-  const std::vector<char>& GetICCProfile() const { return icc_profile_; }
+  const std::vector<char>& GetICCProfile() const;
 
 #if defined(OS_WIN)
   // This will read monitor ICC profiles from disk and cache the results for the
@@ -47,7 +49,20 @@ class GFX_EXPORT ColorSpace {
   static bool IsValidProfileLength(size_t length);
 
  private:
-  std::vector<char> icc_profile_;
+  struct Key;
+  class GlobalData;
+  friend struct Key;
+  friend class GlobalData;
+  enum class Type {
+    UNDEFINED,
+    ICC_PROFILE,
+  };
+  Type type_ = Type::UNDEFINED;
+
+  // GlobalData stores large or expensive-to-compute data about a color space
+  // (e.g, ICC profile). This structure is shared by all identical ColorSpace
+  // objects in the process. It is lazily initialized for named color spaces.
+  mutable scoped_refptr<GlobalData> global_data_;
 };
 
 }  // namespace gfx
diff --git a/ui/gfx/color_space_win.cc b/ui/gfx/color_space_win.cc
index e9db49f..9446c4e 100644
--- a/ui/gfx/color_space_win.cc
+++ b/ui/gfx/color_space_win.cc
@@ -59,9 +59,10 @@ bool ColorSpace::CachedProfilesNeedUpdate() {
 void ColorSpace::UpdateCachedProfilesOnBackgroundThread() {
   std::vector<char> icc_profile;
   ReadBestMonitorICCProfile(&icc_profile);
+  gfx::ColorSpace color_space = FromICCProfile(icc_profile);
 
   base::AutoLock lock(g_best_monitor_color_space_lock.Get());
-  g_best_monitor_color_space.Get().icc_profile_ = icc_profile;
+  g_best_monitor_color_space.Get() = color_space;
   g_has_initialized_best_monitor_color_space = true;
 }
 
diff --git a/ui/gfx/color_space_x11.cc b/ui/gfx/color_space_x11.cc
index 7dacae2..dfa1e12 100644
--- a/ui/gfx/color_space_x11.cc
+++ b/ui/gfx/color_space_x11.cc
@@ -17,7 +17,6 @@ namespace gfx {
 
 // static
 ColorSpace ColorSpace::FromBestMonitor() {
-  ColorSpace color_space;
   Atom property = XInternAtom(GetXDisplay(), "_ICC_PROFILE", true);
   if (property != None) {
     Atom prop_type = None;
@@ -30,11 +29,13 @@ ColorSpace ColorSpace::FromBestMonitor() {
             0x1FFFFFFF /* MAXINT32 / 4 */, False, AnyPropertyType, &prop_type,
             &prop_format, &nitems, &nbytes,
             reinterpret_cast<unsigned char**>(&property_data)) == Success) {
-      color_space.icc_profile_.assign(property_data, property_data + nitems);
+      std::vector<char> icc_profile;
+      icc_profile.assign(property_data, property_data + nitems);
       XFree(property_data);
+      return FromICCProfile(icc_profile);
     }
   }
-  return color_space;
+  return ColorSpace();
 }
 
 }  // namespace gfx
