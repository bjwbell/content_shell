diff --git a/DEPS b/DEPS
index 0b765af..c6f0fa7 100644
--- a/DEPS
+++ b/DEPS
@@ -36,7 +36,7 @@ vars = {
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling Skia
   # and whatever else without interference from each other.
-  'skia_revision': 'ec559591ae8f2c7005ad3824b718df5f01747851',
+  'skia_revision': 'c6f411e72b1fea6608f540f64a57bcacbe3378cd',
   # Three lines of non-changing comments so that
   # the commit queue can handle CLs rolling V8
   # and whatever else without interference from each other.
diff --git a/blimp/client/README.md b/blimp/client/README.md
deleted file mode 100644
index 2f9108e..0000000
--- a/blimp/client/README.md
+++ /dev/null
@@ -1,175 +0,0 @@
-# Blimp Client
-
-This document contains documentation for the blimp client code organization.
-
-For a quick guide for how to add Java files to an existing directory, see
-[Adding Java files](#adding-java-files) below.
-
-[TOC]
-
-## Code Organization
-
-The blimp client has two main directories to be used for code, `core` and
-`public`. Embedders should only ever have to deal with the `public` directory.
-
-There are sub-directories resembling the ones in `core` for parts that needs to
-be exposed to embedders, such as `BlimpContents`.
-
-All Java-code is put in the `public/android` directory, with a package
-organization that resembles the one in `core`.
-
-Within `//blimp/client`, the `visibility` feature of GN is heavily used to
-ensure that embedders and dependencies are correctly set up. Currently, the
-`app` directory is not fully extracted out as an embedder, so it does sometime
-depend directly on code in `core`, but that should change when the migration to
-`core` is finished.
-
-### The core directory
-
-The `core` directory is to be used for all business logic code, and is an
-internal concept of the client code.
-
-There are sub-directories for logically separate parts, such as `contents` for
-code that relate to the contents of a web page. All Android code is put into
-their respective directories, so Android and Java-code related to `contents`
-is put in `contents/android`.
-
-Each of the sub-directories have their own `BUILD.gn` file, which includes
-targets for both C++ and Java.
-
-*   `//blimp/client/core/`
-    *   `android/` All Android-related code, including Java-code, that are for
-        the code living directly in `//blimp/client/core`.
-    *   `compositor/` Code related to the Chrome Compositor.
-    *   `contents/` Code related to the contents of a web page.
-    *   `contents/android/` JNI bridges and Java-code for `contents`.
-    *   `session/` Code related to the session with the engine.
-
-Most code in `core` do not need any Java counterparts unless the embedder is
-written for Android and it is typically only needed for things that relate to
-the embedder UI.
-
-#### Actual and dummy implementations of core
-
-The `core` directory has two implementations of the public API, a dummy one
-and a real one. The default is to use the dummy API, but an embedder can choose
-to enable full blimp support by setting the GN arguments `enable_blimp_client`
-to `true`.
-
-Basically only the implementation of BlimpClientContext has been split out into
-two parts (both in C++ and Java), and the choice of which backing implementation
-to be used is selected by the `enable_blimp_client` flag.
-
-### The public directory
-
-The `public` directory represents the public API of the blimp client, to be
-used by the embedders.
-
-Embedders should be able to depend on `//blimp/client/public` for C++ code,
-and for Java they should depend on `//blimp/client/public:public_java`. This
-automatically pulls in the dependencies on the code in `core`.
-
-*   `//blimp/client/public/`
-    *   `android/` All Android-related code, including Java-code. This includes
-        also code from all the sub-directories such as `contents`.
-    *   `contents/` Code from `//blimp/client/core/contents/` that needs to be
-        exposed to embedders.
-    *   `session/` Code from `//blimp/client/core/session/` that needs to be
-        exposed to embedders.
-
-### Other directories
-
-#### The app directory
-
-The `app` directory represents the directory that contains embedder code for
-a Blimp application on its own. Under a transition period, this directory
-also contains code that depends directly on `core`, until everything can be
-updated to depend only on `public`.
-
-#### The feature directory
-
-The `feature` directory is from the old directory organization, and all the
-content of this will move over to the `core` directory. The feature-specific
-code will move together with the usage of the feature itself, such as
-`core/contents`.
-
-#### The session directory
-
-The `session` directory is from the old directory organization, and all the
-content of this will move over to the `core/session` directory.
-
-#### The test directory
-
-The `test` directory contains tools helpful for testing client code.
-
-### Adding Java files {#adding-java-files}
-
-Most of Blimp is written in C++, but some parts have to be written in Java for
-the Android platform. For those parts of the code, it is required to add an
-`android` sub-directory, and put JNI-bridges and Java files within there.
-
-This will mostly happen in a sub-directory of `core`, so the following section
-explains how to add a Java file with JNI hooks for the imaginary sub-directory `//blimp/client/core/foo`. Conceptually, it's adding a Java-version of the C++
-class `Foo`, that lives in `//blimp/client/core/foo/foo.[cc|h]`.
-
-*   The file Foo.java should be added at:
-    `//blimp/client/core/foo/android/java/src/org/chromium/blimp/core/foo/Foo.java`
-
-*   The JNI-bridge should live in:
-    `//blimp/client/core/foo/android/foo_android.[cc|h]`
-
-*   Add the JNI-bridge JNI registration to:
-     `//blimp/client/core/android/blimp_jni_registrar.cc`
-
-*   Add this to the top of `//blimp/client/core/foo/BUILD.gn`:
-
-    ```python
-    if (is_android) {
-      import("//build/config/android/config.gni")
-      import("//build/config/android/rules.gni")
-    }
-    ```
-
-*   Add the following targets to `//blimp/client/core/foo/BUILD.gn`:
-
-    ```python
-    android_library("foo_java") {
-      visibility = [ "//blimp/client/*" ]
-
-      java_files = [
-        "android/java/src/org/chromium/blimp/core/foo/Foo.java",
-      ]
-
-      deps = [
-        ...
-      ]
-    }
-
-    generate_jni("jni_headers") {
-      visibility = [ ":*" ]
-
-      sources = [
-        "android/java/src/org/chromium/blimp/core/foo/Foo.java",
-      ]
-
-      jni_package = "blimp/client/core/contents"
-    }
-    ```
-
-*   Edit the target `//blimp/client/core/foo:foo` to add this Android-part:
-
-    ```python
-    source_set("foo") {
-
-      ...
-
-      if (is_android) {
-       sources += [
-         "android/foo.cc",
-         "android/foo.h",
-       ]
-
-       deps += [ ":jni_headers" ]
-      }
-    }
-    ```
diff --git a/chrome/VERSION b/chrome/VERSION
index 1f31d15..1c44b7c 100644
--- a/chrome/VERSION
+++ b/chrome/VERSION
@@ -1,4 +1,4 @@
 MAJOR=54
 MINOR=0
-BUILD=2823
+BUILD=2822
 PATCH=0
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ShortcutHelper.java b/chrome/android/java/src/org/chromium/chrome/browser/ShortcutHelper.java
index 936279d..022ec47 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/ShortcutHelper.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ShortcutHelper.java
@@ -511,17 +511,13 @@ public class ShortcutHelper {
     }
 
     /**
-     * Generates a scope URL based on the passed in URL. It should be used if the Web Manifest
-     * does not specify a scope URL.
+     * Returns the URL with all but the last component of its path removed. This is used if the
+     * Web Manifest does not specify a scope. This method assumes that the URL passed in is a
+     * valid URL with a path that contains at least one "/".
      * @param url The url to convert to a scope.
      * @return The scope.
      */
-    @CalledByNative
     public static String getScopeFromUrl(String url) {
-        // Scope URL is generated by:
-        // - Removing last component of the URL.
-        // - Clearing the URL's query and fragment.
-
         Uri uri = Uri.parse(url);
         List<String> path = uri.getPathSegments();
         int endIndex = path.size();
@@ -539,6 +535,7 @@ public class ShortcutHelper {
         }
         builder.path(scope_path);
 
+        // Clear out the query and fragment.
         builder.fragment("");
         builder.query("");
         return builder.build().toString();
diff --git a/chrome/browser/android/shortcut_helper.cc b/chrome/browser/android/shortcut_helper.cc
index 8d8066c..9afc815 100644
--- a/chrome/browser/android/shortcut_helper.cc
+++ b/chrome/browser/android/shortcut_helper.cc
@@ -283,15 +283,6 @@ bool ShortcutHelper::IsWebApkInstalled(const GURL& url) {
   return Java_ShortcutHelper_isWebApkInstalled(env, java_url.obj());
 }
 
-GURL ShortcutHelper::GetScopeFromURL(const GURL& url) {
-  JNIEnv* env = base::android::AttachCurrentThread();
-  ScopedJavaLocalRef<jstring> java_url =
-      base::android::ConvertUTF8ToJavaString(env, url.spec());
-  ScopedJavaLocalRef<jstring> java_scope_url =
-      Java_ShortcutHelper_getScopeFromUrl(env, java_url.obj());
-  return GURL(base::android::ConvertJavaStringToUTF16(env, java_scope_url));
-}
-
 // Callback used by Java when the shortcut has been created.
 // |splash_image_callback| is a pointer to a base::Closure allocated in
 // AddShortcutInBackgroundWithSkBitmap, so reinterpret_cast it back and run it.
diff --git a/chrome/browser/android/shortcut_helper.h b/chrome/browser/android/shortcut_helper.h
index c41bba6..8f489d3 100644
--- a/chrome/browser/android/shortcut_helper.h
+++ b/chrome/browser/android/shortcut_helper.h
@@ -110,10 +110,6 @@ class ShortcutHelper {
   // can handle |url|.
   static bool IsWebApkInstalled(const GURL& url);
 
-  // Generates a scope URL based on the passed in |url|. It should be used
-  // when the Web Manifest does not specify a scope URL.
-  static GURL GetScopeFromURL(const GURL& url);
-
  private:
   ShortcutHelper() = delete;
   ~ShortcutHelper() = delete;
diff --git a/chrome/browser/android/webapk/webapk_installer.cc b/chrome/browser/android/webapk/webapk_installer.cc
index d07f5a5..645f842 100644
--- a/chrome/browser/android/webapk/webapk_installer.cc
+++ b/chrome/browser/android/webapk/webapk_installer.cc
@@ -50,9 +50,7 @@ const int kDownloadTimeoutMs = 20000;
 // Returns the scope from |info| if it is specified. Otherwise, returns the
 // default scope.
 GURL GetScope(const ShortcutInfo& info) {
-  return (info.scope.is_valid())
-      ? info.scope
-      : ShortcutHelper::GetScopeFromURL(info.url);
+  return (info.scope.is_valid()) ? info.scope : info.url.GetOrigin();
 }
 
 // Computes a murmur2 hash of |bitmap|'s PNG encoded bytes.
diff --git a/chrome/browser/android/webapk/webapk_installer.h b/chrome/browser/android/webapk/webapk_installer.h
index c1ba56a..35046dc 100644
--- a/chrome/browser/android/webapk/webapk_installer.h
+++ b/chrome/browser/android/webapk/webapk_installer.h
@@ -45,6 +45,9 @@ class WebApkInstaller : public net::URLFetcherDelegate {
                   const SkBitmap& shorcut_icon);
   ~WebApkInstaller() override;
 
+  // Register JNI methods.
+  static bool Register(JNIEnv* env);
+
   // Talks to the Chrome WebAPK server to generate a WebAPK on the server and to
   // Google Play to install the generated WebAPK. Calls |callback| after the
   // request to install the WebAPK is sent to Google Play.
diff --git a/chrome/browser/apps/guest_view/web_view_browsertest.cc b/chrome/browser/apps/guest_view/web_view_browsertest.cc
index 68bb927..61822ac 100644
--- a/chrome/browser/apps/guest_view/web_view_browsertest.cc
+++ b/chrome/browser/apps/guest_view/web_view_browsertest.cc
@@ -36,7 +36,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/renderer_context_menu/render_view_context_menu.h"
 #include "chrome/browser/renderer_context_menu/render_view_context_menu_test_util.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
@@ -108,15 +108,15 @@ using guest_view::TestGuestViewManager;
 using guest_view::TestGuestViewManagerFactory;
 using prerender::PrerenderLinkManager;
 using prerender::PrerenderLinkManagerFactory;
-using task_manager::browsertest_util::MatchAboutBlankTab;
-using task_manager::browsertest_util::MatchAnyApp;
-using task_manager::browsertest_util::MatchAnyBackground;
-using task_manager::browsertest_util::MatchAnyTab;
-using task_manager::browsertest_util::MatchAnyWebView;
-using task_manager::browsertest_util::MatchApp;
-using task_manager::browsertest_util::MatchBackground;
-using task_manager::browsertest_util::MatchWebView;
-using task_manager::browsertest_util::WaitForTaskManagerRows;
+using task_management::browsertest_util::MatchAboutBlankTab;
+using task_management::browsertest_util::MatchAnyApp;
+using task_management::browsertest_util::MatchAnyBackground;
+using task_management::browsertest_util::MatchAnyTab;
+using task_management::browsertest_util::MatchAnyWebView;
+using task_management::browsertest_util::MatchApp;
+using task_management::browsertest_util::MatchBackground;
+using task_management::browsertest_util::MatchWebView;
+using task_management::browsertest_util::WaitForTaskManagerRows;
 using ui::MenuModel;
 
 namespace {
diff --git a/chrome/browser/background/background_contents.cc b/chrome/browser/background/background_contents.cc
index 7192ee7..20e9490 100644
--- a/chrome/browser/background/background_contents.cc
+++ b/chrome/browser/background/background_contents.cc
@@ -12,7 +12,7 @@
 #include "chrome/browser/extensions/chrome_extension_web_contents_observer.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/renderer_preferences_util.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/webui/chrome_web_ui_controller_factory.h"
 #include "chrome/common/url_constants.h"
 #include "content/public/browser/notification_service.h"
@@ -66,7 +66,7 @@ BackgroundContents::BackgroundContents(
       web_contents_.get());
 
   // Add the TaskManager-specific tag for the BackgroundContents.
-  task_manager::WebContentsTags::CreateForBackgroundContents(
+  task_management::WebContentsTags::CreateForBackgroundContents(
       web_contents_.get(), this);
 
   // Close ourselves when the application is shutting down.
diff --git a/chrome/browser/chromeos/resource_reporter/resource_reporter.cc b/chrome/browser/chromeos/resource_reporter/resource_reporter.cc
index 0266e48..1428201 100644
--- a/chrome/browser/chromeos/resource_reporter/resource_reporter.cc
+++ b/chrome/browser/chromeos/resource_reporter/resource_reporter.cc
@@ -14,7 +14,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/sys_info.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "components/rappor/rappor_service.h"
 #include "content/public/browser/browser_thread.h"
 
@@ -81,10 +81,11 @@ struct TaskRecordMemoryLessThan {
 
 }  // namespace
 
-ResourceReporter::TaskRecord::TaskRecord(task_manager::TaskId task_id)
-    : id(task_id), cpu_percent(0.0), memory_bytes(0), is_background(false) {}
+ResourceReporter::TaskRecord::TaskRecord(task_management::TaskId task_id)
+    : id(task_id), cpu_percent(0.0), memory_bytes(0), is_background(false) {
+}
 
-ResourceReporter::TaskRecord::TaskRecord(task_manager::TaskId the_id,
+ResourceReporter::TaskRecord::TaskRecord(task_management::TaskId the_id,
                                          const std::string& task_name,
                                          double cpu_percent,
                                          int64_t memory_bytes,
@@ -93,7 +94,8 @@ ResourceReporter::TaskRecord::TaskRecord(task_manager::TaskId the_id,
       task_name_for_rappor(task_name),
       cpu_percent(cpu_percent),
       memory_bytes(memory_bytes),
-      is_background(background) {}
+      is_background(background) {
+}
 
 ResourceReporter::~ResourceReporter() {
 }
@@ -110,7 +112,7 @@ void ResourceReporter::StartMonitoring() {
     return;
 
   is_monitoring_ = true;
-  task_manager::TaskManagerInterface::GetTaskManager()->AddObserver(this);
+  task_management::TaskManagerInterface::GetTaskManager()->AddObserver(this);
   memory_pressure_listener_.reset(new base::MemoryPressureListener(
       base::Bind(&ResourceReporter::OnMemoryPressure, base::Unretained(this))));
 }
@@ -123,14 +125,14 @@ void ResourceReporter::StopMonitoring() {
 
   is_monitoring_ = false;
   memory_pressure_listener_.reset();
-  task_manager::TaskManagerInterface::GetTaskManager()->RemoveObserver(this);
+  task_management::TaskManagerInterface::GetTaskManager()->RemoveObserver(this);
 }
 
-void ResourceReporter::OnTaskAdded(task_manager::TaskId id) {
+void ResourceReporter::OnTaskAdded(task_management::TaskId id) {
   // Ignore this event.
 }
 
-void ResourceReporter::OnTaskToBeRemoved(task_manager::TaskId id) {
+void ResourceReporter::OnTaskToBeRemoved(task_management::TaskId id) {
   auto it = task_records_.find(id);
   if (it == task_records_.end())
     return;
@@ -155,7 +157,7 @@ void ResourceReporter::OnTaskToBeRemoved(task_manager::TaskId id) {
 }
 
 void ResourceReporter::OnTasksRefreshed(
-    const task_manager::TaskIdList& task_ids) {
+    const task_management::TaskIdList& task_ids) {
   have_seen_first_task_manager_refresh_ = true;
 
   // A priority queue to sort the task records by their |cpu|. Greatest |cpu|
@@ -182,16 +184,16 @@ void ResourceReporter::OnTasksRefreshed(
     // don't have any privacy issues.
     const auto task_type = observed_task_manager()->GetType(id);
     switch (task_type) {
-      case task_manager::Task::UNKNOWN:
-      case task_manager::Task::ZYGOTE:
+      case task_management::Task::UNKNOWN:
+      case task_management::Task::ZYGOTE:
         break;
 
-      case task_manager::Task::BROWSER:
+      case task_management::Task::BROWSER:
         last_browser_process_cpu_ = cpu_usage;
         last_browser_process_memory_ = memory_usage >= 0 ? memory_usage : 0;
         break;
 
-      case task_manager::Task::GPU:
+      case task_management::Task::GPU:
         last_gpu_process_cpu_ = cpu_usage;
         last_gpu_process_memory_ = memory_usage >= 0 ? memory_usage : 0;
         break;
@@ -244,10 +246,11 @@ const size_t ResourceReporter::kTopConsumersCount = 10U;
 
 ResourceReporter::ResourceReporter()
     : TaskManagerObserver(base::TimeDelta::FromSeconds(kRefreshIntervalSeconds),
-                          task_manager::REFRESH_TYPE_CPU |
-                              task_manager::REFRESH_TYPE_MEMORY |
-                              task_manager::REFRESH_TYPE_PRIORITY),
-      system_cpu_cores_range_(GetCurrentSystemCpuCoresRange()) {}
+                          task_management::REFRESH_TYPE_CPU |
+                              task_management::REFRESH_TYPE_MEMORY |
+                                  task_management::REFRESH_TYPE_PRIORITY),
+      system_cpu_cores_range_(GetCurrentSystemCpuCoresRange()) {
+}
 
 // static
 std::unique_ptr<rappor::Sample> ResourceReporter::CreateRapporSample(
diff --git a/chrome/browser/chromeos/resource_reporter/resource_reporter.h b/chrome/browser/chromeos/resource_reporter/resource_reporter.h
index 763740a..0d23391 100644
--- a/chrome/browser/chromeos/resource_reporter/resource_reporter.h
+++ b/chrome/browser/chromeos/resource_reporter/resource_reporter.h
@@ -17,7 +17,7 @@
 #include "base/memory/memory_pressure_listener.h"
 #include "base/memory/singleton.h"
 #include "base/time/time.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
 #include "components/metrics/metrics_service.h"
 #include "components/rappor/sample.h"
 
@@ -27,21 +27,21 @@ namespace chromeos {
 // Chrome tasks and reports a weighted random sample of them via Rappor whenever
 // memory pressure is critical. The reporting is limited to once per
 // |kMinimumTimeBetweenReportsInMS|.
-class ResourceReporter : public task_manager::TaskManagerObserver {
+class ResourceReporter : public task_management::TaskManagerObserver {
  public:
   // A collection of the data of a task manager's task that the ResourceReporter
   // is interested in.
   struct TaskRecord {
-    explicit TaskRecord(task_manager::TaskId task_id);
+    explicit TaskRecord(task_management::TaskId task_id);
 
-    TaskRecord(task_manager::TaskId task_id,
+    TaskRecord(task_management::TaskId task_id,
                const std::string& task_name,
                double cpu_percent,
                int64_t memory_bytes,
                bool background);
 
     // The ID of the task.
-    task_manager::TaskId id;
+    task_management::TaskId id;
 
     // The canonicalized task name to be used to represent the task in a Rappor
     // sample.
@@ -70,10 +70,10 @@ class ResourceReporter : public task_manager::TaskManagerObserver {
   void StartMonitoring();
   void StopMonitoring();
 
-  // task_manager::TaskManagerObserver:
-  void OnTaskAdded(task_manager::TaskId id) override;
-  void OnTaskToBeRemoved(task_manager::TaskId id) override;
-  void OnTasksRefreshed(const task_manager::TaskIdList& task_ids) override;
+  // task_management::TaskManagerObserver:
+  void OnTaskAdded(task_management::TaskId id) override;
+  void OnTaskToBeRemoved(task_management::TaskId id) override;
+  void OnTasksRefreshed(const task_management::TaskIdList& task_ids) override;
 
  private:
   friend struct base::DefaultSingletonTraits<ResourceReporter>;
@@ -164,7 +164,7 @@ class ResourceReporter : public task_manager::TaskManagerObserver {
 
   // Contains the collected data about the currently running tasks from the most
   // recent task manager refresh.
-  std::map<task_manager::TaskId, std::unique_ptr<TaskRecord>> task_records_;
+  std::map<task_management::TaskId, std::unique_ptr<TaskRecord>> task_records_;
 
   // Contains the top |kTopConsumerCount| CPU consumer tasks sorted in a
   // descending order by their CPU usage.
diff --git a/chrome/browser/chromeos/resource_reporter/resource_reporter_unittest.cc b/chrome/browser/chromeos/resource_reporter/resource_reporter_unittest.cc
index bf9198b..82958d3 100644
--- a/chrome/browser/chromeos/resource_reporter/resource_reporter_unittest.cc
+++ b/chrome/browser/chromeos/resource_reporter/resource_reporter_unittest.cc
@@ -14,10 +14,10 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/timer/mock_timer.h"
 #include "chrome/browser/chromeos/resource_reporter/resource_reporter.h"
-#include "chrome/browser/task_manager/test_task_manager.h"
+#include "chrome/browser/task_management/test_task_manager.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-using task_manager::TaskId;
+using task_management::TaskId;
 
 namespace chromeos {
 
@@ -46,7 +46,7 @@ const ResourceReporter::TaskRecord kTestTasks[] = {
 
 // A list of task IDs that will be removed from the task manager later after all
 // the above tasks have been added.
-const task_manager::TaskId kIdsOfTasksToRemove[] = {
+const task_management::TaskId kIdsOfTasksToRemove[] = {
     4, 7, 12, 8, 5,
 };
 
@@ -63,7 +63,7 @@ const size_t kTasksToBeRemovedSize = arraysize(kIdsOfTasksToRemove);
 
 // A test implementation of the task manager that can be used to collect CPU and
 // memory usage so that they can be tested with the resource reporter.
-class DummyTaskManager : public task_manager::TestTaskManager {
+class DummyTaskManager : public task_management::TestTaskManager {
  public:
   DummyTaskManager() {
     set_timer_for_testing(
@@ -71,7 +71,7 @@ class DummyTaskManager : public task_manager::TestTaskManager {
   }
   ~DummyTaskManager() override {}
 
-  // task_manager::TestTaskManager:
+  // task_management::TestTaskManager:
   double GetCpuUsage(TaskId task_id) const override {
     return tasks_.at(task_id)->cpu_percent;
   }
@@ -81,16 +81,16 @@ class DummyTaskManager : public task_manager::TestTaskManager {
   const std::string& GetTaskNameForRappor(TaskId task_id) const override {
     return tasks_.at(task_id)->task_name_for_rappor;
   }
-  task_manager::Task::Type GetType(TaskId task_id) const override {
+  task_management::Task::Type GetType(TaskId task_id) const override {
     switch (task_id) {
       case 3:
-        return task_manager::Task::BROWSER;
+        return task_management::Task::BROWSER;
 
       case 6:
-        return task_manager::Task::GPU;
+        return task_management::Task::GPU;
 
       default:
-        return task_manager::Task::RENDERER;
+        return task_management::Task::RENDERER;
     }
   }
 
diff --git a/chrome/browser/devtools/devtools_window.cc b/chrome/browser/devtools/devtools_window.cc
index 5a3f23b..6a2a45d 100644
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -17,7 +17,7 @@
 #include "chrome/browser/infobars/infobar_service.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #include "chrome/browser/ui/browser_list.h"
@@ -768,7 +768,8 @@ DevToolsWindow::DevToolsWindow(Profile* profile,
 
   // Tag the DevTools main WebContents with its TaskManager specific UserData
   // so that it shows up in the task manager.
-  task_manager::WebContentsTags::CreateForDevToolsContents(main_web_contents_);
+  task_management::WebContentsTags::CreateForDevToolsContents(
+      main_web_contents_);
 
   std::vector<base::Callback<void(DevToolsWindow*)>> copy(
       g_creation_callbacks.Get());
@@ -958,7 +959,7 @@ void DevToolsWindow::WebContentsCreated(WebContents* source_contents,
 
     // Tag the DevTools toolbox WebContents with its TaskManager specific
     // UserData so that it shows up in the task manager.
-    task_manager::WebContentsTags::CreateForDevToolsContents(
+    task_management::WebContentsTags::CreateForDevToolsContents(
         toolbox_web_contents_);
   }
 }
diff --git a/chrome/browser/extensions/api/processes/processes_api.cc b/chrome/browser/extensions/api/processes/processes_api.cc
index e43d5df..3527bf9 100644
--- a/chrome/browser/extensions/api/processes/processes_api.cc
+++ b/chrome/browser/extensions/api/processes/processes_api.cc
@@ -16,7 +16,7 @@
 #include "chrome/browser/extensions/api/tabs/tabs_constants.h"
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/common/extensions/api/processes.h"
 #include "content/public/browser/browser_child_process_host.h"
 #include "content/public/browser/child_process_data.h"
@@ -43,17 +43,17 @@ base::LazyInstance<BrowserContextKeyedAPIFactory<ProcessesAPI>>
 int64_t GetRefreshTypesFlagOnlyEssentialData() {
   // This is the only non-optional data in the Process as defined by the API in
   // processes.idl.
-  return task_manager::REFRESH_TYPE_NACL;
+  return task_management::REFRESH_TYPE_NACL;
 }
 
 // This does not include memory. The memory refresh flag will only be added once
 // a listener to OnUpdatedWithMemory event is added.
 int64_t GetRefreshTypesForProcessOptionalData() {
-  return task_manager::REFRESH_TYPE_CPU |
-      task_manager::REFRESH_TYPE_NETWORK_USAGE |
-      task_manager::REFRESH_TYPE_SQLITE_MEMORY |
-      task_manager::REFRESH_TYPE_V8_MEMORY |
-      task_manager::REFRESH_TYPE_WEBCACHE_STATS;
+  return task_management::REFRESH_TYPE_CPU |
+      task_management::REFRESH_TYPE_NETWORK_USAGE |
+      task_management::REFRESH_TYPE_SQLITE_MEMORY |
+      task_management::REFRESH_TYPE_V8_MEMORY |
+      task_management::REFRESH_TYPE_WEBCACHE_STATS;
 }
 
 std::unique_ptr<api::processes::Cache> CreateCacheData(
@@ -65,37 +65,37 @@ std::unique_ptr<api::processes::Cache> CreateCacheData(
 }
 
 api::processes::ProcessType GetProcessType(
-    task_manager::Task::Type task_type) {
+    task_management::Task::Type task_type) {
   switch (task_type) {
-    case task_manager::Task::BROWSER:
+    case task_management::Task::BROWSER:
       return api::processes::PROCESS_TYPE_BROWSER;
 
-    case task_manager::Task::RENDERER:
+    case task_management::Task::RENDERER:
       return api::processes::PROCESS_TYPE_RENDERER;
 
-    case task_manager::Task::EXTENSION:
-    case task_manager::Task::GUEST:
+    case task_management::Task::EXTENSION:
+    case task_management::Task::GUEST:
       return api::processes::PROCESS_TYPE_EXTENSION;
 
-    case task_manager::Task::PLUGIN:
+    case task_management::Task::PLUGIN:
       return api::processes::PROCESS_TYPE_PLUGIN;
 
-    case task_manager::Task::WORKER:
+    case task_management::Task::WORKER:
       return api::processes::PROCESS_TYPE_WORKER;
 
-    case task_manager::Task::NACL:
+    case task_management::Task::NACL:
       return api::processes::PROCESS_TYPE_NACL;
 
-    case task_manager::Task::UTILITY:
+    case task_management::Task::UTILITY:
       return api::processes::PROCESS_TYPE_UTILITY;
 
-    case task_manager::Task::GPU:
+    case task_management::Task::GPU:
       return api::processes::PROCESS_TYPE_GPU;
 
-    case task_manager::Task::UNKNOWN:
-    case task_manager::Task::ARC:
-    case task_manager::Task::SANDBOX_HELPER:
-    case task_manager::Task::ZYGOTE:
+    case task_management::Task::UNKNOWN:
+    case task_management::Task::ARC:
+    case task_management::Task::SANDBOX_HELPER:
+    case task_management::Task::ZYGOTE:
       return api::processes::PROCESS_TYPE_OTHER;
   }
 
@@ -108,8 +108,8 @@ api::processes::ProcessType GetProcessType(
 // optional fields in |api::processes::Process| except for |private_memory|,
 // which should be filled later if needed.
 void FillProcessData(
-    task_manager::TaskId id,
-    task_manager::TaskManagerInterface* task_manager,
+    task_management::TaskId id,
+    task_management::TaskManagerInterface* task_manager,
     bool include_optional,
     api::processes::Process* out_process) {
   DCHECK(out_process);
@@ -121,7 +121,7 @@ void FillProcessData(
   out_process->nacl_debug_port = task_manager->GetNaClDebugStubPort(id);
 
   // Collect the tab IDs of all the tasks sharing this renderer if any.
-  const task_manager::TaskIdList tasks_on_process =
+  const task_management::TaskIdList tasks_on_process =
       task_manager->GetIdsOfTasksSharingSameProcess(id);
   for (const auto& task_id : tasks_on_process) {
     api::processes::TaskInfo task_info;
@@ -171,8 +171,8 @@ void FillProcessData(
 ////////////////////////////////////////////////////////////////////////////////
 
 ProcessesEventRouter::ProcessesEventRouter(content::BrowserContext* context)
-    : task_manager::TaskManagerObserver(base::TimeDelta::FromSeconds(1),
-                                        task_manager::REFRESH_TYPE_NONE),
+    : task_management::TaskManagerObserver(base::TimeDelta::FromSeconds(1),
+                                           task_management::REFRESH_TYPE_NONE),
       browser_context_(context),
       listeners_(0) {
 }
@@ -185,7 +185,7 @@ void ProcessesEventRouter::ListenerAdded() {
 
   if (listeners_++ == 0) {
     // The first listener to be added.
-    task_manager::TaskManagerInterface::GetTaskManager()->AddObserver(this);
+    task_management::TaskManagerInterface::GetTaskManager()->AddObserver(this);
   }
 }
 
@@ -194,12 +194,12 @@ void ProcessesEventRouter::ListenerRemoved() {
 
   if (--listeners_ == 0) {
     // Last listener to be removed.
-    task_manager::TaskManagerInterface::GetTaskManager()->RemoveObserver(
+    task_management::TaskManagerInterface::GetTaskManager()->RemoveObserver(
         this);
   }
 }
 
-void ProcessesEventRouter::OnTaskAdded(task_manager::TaskId id) {
+void ProcessesEventRouter::OnTaskAdded(task_management::TaskId id) {
   if (!HasEventListeners(api::processes::OnCreated::kEventName))
     return;
 
@@ -217,7 +217,7 @@ void ProcessesEventRouter::OnTaskAdded(task_manager::TaskId id) {
                 api::processes::OnCreated::Create(process));
 }
 
-void ProcessesEventRouter::OnTaskToBeRemoved(task_manager::TaskId id) {
+void ProcessesEventRouter::OnTaskToBeRemoved(task_management::TaskId id) {
   if (!HasEventListeners(api::processes::OnExited::kEventName))
     return;
 
@@ -237,7 +237,7 @@ void ProcessesEventRouter::OnTaskToBeRemoved(task_manager::TaskId id) {
 }
 
 void ProcessesEventRouter::OnTasksRefreshedWithBackgroundCalculations(
-    const task_manager::TaskIdList& task_ids) {
+    const task_management::TaskIdList& task_ids) {
   const bool has_on_updated_listeners =
       HasEventListeners(api::processes::OnUpdated::kEventName);
   const bool has_on_updated_with_memory_listeners =
@@ -308,7 +308,7 @@ void ProcessesEventRouter::OnTasksRefreshedWithBackgroundCalculations(
   }
 }
 
-void ProcessesEventRouter::OnTaskUnresponsive(task_manager::TaskId id) {
+void ProcessesEventRouter::OnTaskUnresponsive(task_management::TaskId id) {
   if (!HasEventListeners(api::processes::OnUnresponsive::kEventName))
     return;
 
@@ -341,7 +341,7 @@ bool ProcessesEventRouter::HasEventListeners(
 }
 
 bool ProcessesEventRouter::ShouldReportOnCreatedOrOnExited(
-    task_manager::TaskId id,
+    task_management::TaskId id,
     int* out_child_process_host_id) const {
   // Is it the first task to be created or the last one to be removed?
   if (observed_task_manager()->GetNumberOfTasksOnSameProcess(id) != 1)
@@ -362,7 +362,7 @@ bool ProcessesEventRouter::ShouldReportOnCreatedOrOnExited(
 }
 
 void ProcessesEventRouter::UpdateRefreshTypesFlagsBasedOnListeners() {
-  int64_t refresh_types = task_manager::REFRESH_TYPE_NONE;
+  int64_t refresh_types = task_management::REFRESH_TYPE_NONE;
   if (HasEventListeners(api::processes::OnCreated::kEventName) ||
       HasEventListeners(api::processes::OnUnresponsive::kEventName)) {
     refresh_types |= GetRefreshTypesFlagOnlyEssentialData();
@@ -372,7 +372,7 @@ void ProcessesEventRouter::UpdateRefreshTypesFlagsBasedOnListeners() {
     refresh_types |= GetRefreshTypesForProcessOptionalData();
 
   if (HasEventListeners(api::processes::OnUpdatedWithMemory::kEventName))
-    refresh_types |= task_manager::REFRESH_TYPE_MEMORY;
+    refresh_types |= task_management::REFRESH_TYPE_MEMORY;
 
   SetRefreshTypesFlags(refresh_types);
 }
@@ -558,7 +558,7 @@ ProcessesTerminateFunction::TerminateIfAllowed(base::ProcessHandle handle) {
 ////////////////////////////////////////////////////////////////////////////////
 
 ProcessesGetProcessInfoFunction::ProcessesGetProcessInfoFunction()
-    : task_manager::TaskManagerObserver(
+    : task_management::TaskManagerObserver(
           base::TimeDelta::FromSeconds(1),
           GetRefreshTypesFlagOnlyEssentialData()) {
 }
@@ -574,7 +574,7 @@ ExtensionFunction::ResponseAction ProcessesGetProcessInfoFunction::Run() {
 
   include_memory_ = params->include_memory;
   if (include_memory_)
-    AddRefreshType(task_manager::REFRESH_TYPE_MEMORY);
+    AddRefreshType(task_management::REFRESH_TYPE_MEMORY);
 
   // Keep this object alive until the first of either OnTasksRefreshed() or
   // OnTasksRefreshedWithBackgroundCalculations() is received depending on
@@ -583,13 +583,13 @@ ExtensionFunction::ResponseAction ProcessesGetProcessInfoFunction::Run() {
 
   // The task manager needs to be enabled for this function.
   // Start observing the task manager and wait for the next refresh event.
-  task_manager::TaskManagerInterface::GetTaskManager()->AddObserver(this);
+  task_management::TaskManagerInterface::GetTaskManager()->AddObserver(this);
 
   return RespondLater();
 }
 
 void ProcessesGetProcessInfoFunction::OnTasksRefreshed(
-    const task_manager::TaskIdList& task_ids) {
+    const task_management::TaskIdList& task_ids) {
   // Memory is background calculated and will be ready when
   // OnTasksRefreshedWithBackgroundCalculations() is invoked.
   if (include_memory_)
@@ -600,7 +600,7 @@ void ProcessesGetProcessInfoFunction::OnTasksRefreshed(
 
 void
 ProcessesGetProcessInfoFunction::OnTasksRefreshedWithBackgroundCalculations(
-    const task_manager::TaskIdList& task_ids) {
+    const task_management::TaskIdList& task_ids) {
   if (!include_memory_)
     return;
 
@@ -610,7 +610,7 @@ ProcessesGetProcessInfoFunction::OnTasksRefreshedWithBackgroundCalculations(
 ProcessesGetProcessInfoFunction::~ProcessesGetProcessInfoFunction() {}
 
 void ProcessesGetProcessInfoFunction::GatherDataAndRespond(
-    const task_manager::TaskIdList& task_ids) {
+    const task_management::TaskIdList& task_ids) {
   // If there are no process IDs specified, it means we need to return all of
   // the ones we know of.
   const bool specific_processes_requested = !process_host_ids_.empty();
@@ -682,7 +682,7 @@ void ProcessesGetProcessInfoFunction::GatherDataAndRespond(
       api::processes::GetProcessInfo::Results::Create(processes)));
 
   // Stop observing the task manager, and balance the AddRef() in Run().
-  task_manager::TaskManagerInterface::GetTaskManager()->RemoveObserver(this);
+  task_management::TaskManagerInterface::GetTaskManager()->RemoveObserver(this);
   Release();
 }
 
diff --git a/chrome/browser/extensions/api/processes/processes_api.h b/chrome/browser/extensions/api/processes/processes_api.h
index 1950e1e..9b0a32a 100644
--- a/chrome/browser/extensions/api/processes/processes_api.h
+++ b/chrome/browser/extensions/api/processes/processes_api.h
@@ -8,7 +8,7 @@
 #include <vector>
 
 #include "base/macros.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
 #include "extensions/browser/browser_context_keyed_api_factory.h"
 #include "extensions/browser/event_router.h"
 #include "extensions/browser/extension_event_histogram_value.h"
@@ -20,7 +20,7 @@ namespace extensions {
 
 // Observes the Task Manager and routes the notifications as events to the
 // extension system.
-class ProcessesEventRouter : public task_manager::TaskManagerObserver {
+class ProcessesEventRouter : public task_management::TaskManagerObserver {
  public:
   explicit ProcessesEventRouter(content::BrowserContext* context);
   ~ProcessesEventRouter() override;
@@ -31,13 +31,13 @@ class ProcessesEventRouter : public task_manager::TaskManagerObserver {
   // Called when an extension process with a listener exits or removes it.
   void ListenerRemoved();
 
-  // task_manager::TaskManagerObserver:
-  void OnTaskAdded(task_manager::TaskId id) override;
-  void OnTaskToBeRemoved(task_manager::TaskId id) override;
-  void OnTasksRefreshed(const task_manager::TaskIdList& task_ids) override {}
+  // task_management::TaskManagerObserver:
+  void OnTaskAdded(task_management::TaskId id) override;
+  void OnTaskToBeRemoved(task_management::TaskId id) override;
+  void OnTasksRefreshed(const task_management::TaskIdList& task_ids) override {}
   void OnTasksRefreshedWithBackgroundCalculations(
-      const task_manager::TaskIdList& task_ids) override;
-  void OnTaskUnresponsive(task_manager::TaskId id) override;
+      const task_management::TaskIdList& task_ids) override;
+  void OnTaskUnresponsive(task_management::TaskId id) override;
 
  private:
   friend class ::ProcessesApiTest;
@@ -53,7 +53,7 @@ class ProcessesEventRouter : public task_manager::TaskManagerObserver {
   // Returns true if the task with the given |id| should be reported as created
   // or removed. |out_child_process_host_id| will be filled with the valid ID of
   // the process to report in the event.
-  bool ShouldReportOnCreatedOrOnExited(task_manager::TaskId id,
+  bool ShouldReportOnCreatedOrOnExited(task_management::TaskId id,
                                        int* out_child_process_host_id) const;
 
   // Updates the requested task manager refresh types flags depending on what
@@ -159,19 +159,19 @@ class ProcessesTerminateFunction : public UIThreadExtensionFunction {
 // details corresponding to the process IDs supplied as input.
 class ProcessesGetProcessInfoFunction :
     public UIThreadExtensionFunction,
-    public task_manager::TaskManagerObserver {
+    public task_management::TaskManagerObserver {
  public:
   ProcessesGetProcessInfoFunction();
 
   // UIThreadExtensionFunction:
   ExtensionFunction::ResponseAction Run() override;
 
-  // task_manager::TaskManagerObserver:
-  void OnTaskAdded(task_manager::TaskId id) override {}
-  void OnTaskToBeRemoved(task_manager::TaskId id) override {}
-  void OnTasksRefreshed(const task_manager::TaskIdList& task_ids) override;
+  // task_management::TaskManagerObserver:
+  void OnTaskAdded(task_management::TaskId id) override {}
+  void OnTaskToBeRemoved(task_management::TaskId id) override {}
+  void OnTasksRefreshed(const task_management::TaskIdList& task_ids) override;
   void OnTasksRefreshedWithBackgroundCalculations(
-      const task_manager::TaskIdList& task_ids) override;
+      const task_management::TaskIdList& task_ids) override;
 
   DECLARE_EXTENSION_FUNCTION("processes.getProcessInfo",
                              PROCESSES_GETPROCESSINFO);
@@ -185,7 +185,7 @@ class ProcessesGetProcessInfoFunction :
   // This function will be called by either OnTasksRefreshed() or
   // OnTasksRefreshedWithBackgroundCalculations() depending on whether memory is
   // requested.
-  void GatherDataAndRespond(const task_manager::TaskIdList& task_ids);
+  void GatherDataAndRespond(const task_management::TaskIdList& task_ids);
 
   std::vector<int> process_host_ids_;
   bool include_memory_ = false;
diff --git a/chrome/browser/extensions/api/processes/processes_apitest.cc b/chrome/browser/extensions/api/processes/processes_apitest.cc
index d75a406..626e6a3 100644
--- a/chrome/browser/extensions/api/processes/processes_apitest.cc
+++ b/chrome/browser/extensions/api/processes/processes_apitest.cc
@@ -5,7 +5,7 @@
 #include "base/command_line.h"
 #include "chrome/browser/extensions/api/processes/processes_api.h"
 #include "chrome/browser/extensions/extension_apitest.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #include "chrome/browser/ui/browser_window.h"
@@ -56,11 +56,11 @@ IN_PROC_BROWSER_TEST_F(ProcessesApiTest, ProcessesApiListeners) {
   ASSERT_TRUE(listener2.WaitUntilSatisfied());
 
   // The memory refresh type must be enabled now.
-  const task_manager::TaskManagerInterface* task_manager =
-      task_manager::TaskManagerInterface::GetTaskManager();
+  const task_management::TaskManagerInterface* task_manager =
+      task_management::TaskManagerInterface::GetTaskManager();
   EXPECT_EQ(2, GetListenersCount());
   EXPECT_TRUE(task_manager->IsResourceRefreshEnabled(
-      task_manager::REFRESH_TYPE_MEMORY));
+      task_management::REFRESH_TYPE_MEMORY));
 
   // Unload the extensions and make sure the listeners count is updated.
   UnloadExtension(extension2->id());
diff --git a/chrome/browser/extensions/chrome_extensions_browser_client.cc b/chrome/browser/extensions/chrome_extensions_browser_client.cc
index 9836496..ef67583 100644
--- a/chrome/browser/extensions/chrome_extensions_browser_client.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_client.cc
@@ -36,7 +36,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/bluetooth/chrome_extension_bluetooth_chooser.h"
 #include "chrome/common/channel_info.h"
 #include "chrome/common/chrome_paths.h"
@@ -367,8 +367,8 @@ void ChromeExtensionsBrowserClient::AttachExtensionTaskManagerTag(
     case VIEW_TYPE_EXTENSION_POPUP:
     case VIEW_TYPE_LAUNCHER_PAGE:
       // These are the only types that are tracked by the ExtensionTag.
-      task_manager::WebContentsTags::CreateForExtension(web_contents,
-                                                        view_type);
+      task_management::WebContentsTags::CreateForExtension(web_contents,
+                                                           view_type);
       return;
 
     case VIEW_TYPE_BACKGROUND_CONTENTS:
@@ -376,10 +376,10 @@ void ChromeExtensionsBrowserClient::AttachExtensionTaskManagerTag(
     case VIEW_TYPE_PANEL:
     case VIEW_TYPE_TAB_CONTENTS:
       // Those types are tracked by other tags:
-      // BACKGROUND_CONTENTS --> task_manager::BackgroundContentsTag.
+      // BACKGROUND_CONTENTS --> task_management::BackgroundContentsTag.
       // GUEST --> extensions::ChromeGuestViewManagerDelegate.
-      // PANEL --> task_manager::PanelTag.
-      // TAB_CONTENTS --> task_manager::TabContentsTag.
+      // PANEL --> task_management::PanelTag.
+      // TAB_CONTENTS --> task_management::TabContentsTag.
       // These tags are created and attached to the web_contents in other
       // locations, and they must be ignored here.
       return;
diff --git a/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc b/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc
index 027f09e..e3cee47 100644
--- a/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc
+++ b/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc
@@ -5,7 +5,7 @@
 #include "chrome/browser/guest_view/chrome_guest_view_manager_delegate.h"
 
 #include "build/build_config.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/app_mode/app_session.h"
@@ -27,7 +27,7 @@ void ChromeGuestViewManagerDelegate::OnGuestAdded(
   // Attaches the task-manager-specific tag for the GuestViews to its
   // |guest_web_contents| so that their corresponding tasks show up in the task
   // manager.
-  task_manager::WebContentsTags::CreateForGuestContents(guest_web_contents);
+  task_management::WebContentsTags::CreateForGuestContents(guest_web_contents);
 
 #if defined(OS_CHROMEOS)
   // Notifies kiosk session about the added guest.
diff --git a/chrome/browser/net/chrome_network_delegate.cc b/chrome/browser/net/chrome_network_delegate.cc
index fab1bca..7bc351f 100644
--- a/chrome/browser/net/chrome_network_delegate.cc
+++ b/chrome/browser/net/chrome_network_delegate.cc
@@ -34,7 +34,7 @@
 #include "chrome/browser/net/request_source_bandwidth_histograms.h"
 #include "chrome/browser/net/safe_search_util.h"
 #include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/features.h"
 #include "chrome/common/pref_names.h"
@@ -360,7 +360,8 @@ void ChromeNetworkDelegate::OnNetworkBytesReceived(net::URLRequest* request,
 #if defined(ENABLE_TASK_MANAGER)
   // Note: Currently, OnNetworkBytesReceived is only implemented for HTTP jobs,
   // not FTP or other types, so those kinds of bytes will not be reported here.
-  task_manager::TaskManagerInterface::OnRawBytesRead(*request, bytes_received);
+  task_management::TaskManagerInterface::OnRawBytesRead(*request,
+                                                        bytes_received);
 #endif  // defined(ENABLE_TASK_MANAGER)
 
   ReportDataUsageStats(request, 0 /* tx_bytes */, bytes_received);
diff --git a/chrome/browser/policy/policy_browsertest.cc b/chrome/browser/policy/policy_browsertest.cc
index a765274..2179548 100644
--- a/chrome/browser/policy/policy_browsertest.cc
+++ b/chrome/browser/policy/policy_browsertest.cc
@@ -74,7 +74,7 @@
 #include "chrome/browser/search/search.h"
 #include "chrome/browser/search_engines/template_url_service_factory.h"
 #include "chrome/browser/ssl/ssl_blocking_page.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/browser/translate/chrome_translate_client.h"
 #include "chrome/browser/translate/translate_service.h"
 #include "chrome/browser/ui/bookmarks/bookmark_bar.h"
@@ -3690,7 +3690,7 @@ IN_PROC_BROWSER_TEST_F(PolicyTest, SSLErrorOverridingDisallowed) {
 // TaskManagerEndProcessEnabled policy
 IN_PROC_BROWSER_TEST_F(PolicyTest, TaskManagerEndProcessEnabled) {
   // By default it's allowed to end tasks.
-  EXPECT_TRUE(task_manager::TaskManagerInterface::IsEndProcessEnabled());
+  EXPECT_TRUE(task_management::TaskManagerInterface::IsEndProcessEnabled());
 
   // Disabling ending tasks in task manager by policy
   PolicyMap policies1;
@@ -3700,7 +3700,7 @@ IN_PROC_BROWSER_TEST_F(PolicyTest, TaskManagerEndProcessEnabled) {
   UpdateProviderPolicy(policies1);
 
   // Policy should not allow ending tasks anymore.
-  EXPECT_FALSE(task_manager::TaskManagerInterface::IsEndProcessEnabled());
+  EXPECT_FALSE(task_management::TaskManagerInterface::IsEndProcessEnabled());
 
   // Enabling ending tasks in task manager by policy
   PolicyMap policies2;
@@ -3710,7 +3710,7 @@ IN_PROC_BROWSER_TEST_F(PolicyTest, TaskManagerEndProcessEnabled) {
   UpdateProviderPolicy(policies2);
 
   // Policy should allow ending tasks again.
-  EXPECT_TRUE(task_manager::TaskManagerInterface::IsEndProcessEnabled());
+  EXPECT_TRUE(task_management::TaskManagerInterface::IsEndProcessEnabled());
 }
 
 #if defined(ENABLE_MEDIA_ROUTER)
diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
index 64d4108..4e445d4 100644
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -52,7 +52,7 @@
 #include "chrome/browser/renderer_host/pepper/device_id_fetcher.h"
 #include "chrome/browser/search/search.h"
 #include "chrome/browser/signin/signin_manager_factory.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/browser/tracing/chrome_tracing_delegate.h"
 #include "chrome/browser/ui/app_list/app_list_prefs.h"
 #include "chrome/browser/ui/app_list/app_list_service.h"
@@ -368,7 +368,7 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 #endif
 
 #if defined(ENABLE_TASK_MANAGER)
-  task_manager::TaskManagerInterface::RegisterPrefs(registry);
+  task_management::TaskManagerInterface::RegisterPrefs(registry);
 #endif  // defined(ENABLE_TASK_MANAGER)
 
 #if BUILDFLAG(ENABLE_BACKGROUND)
diff --git a/chrome/browser/prerender/prerender_browsertest.cc b/chrome/browser/prerender/prerender_browsertest.cc
index 4208e6c..eac7cc0 100644
--- a/chrome/browser/prerender/prerender_browsertest.cc
+++ b/chrome/browser/prerender/prerender_browsertest.cc
@@ -54,9 +54,9 @@
 #include "chrome/browser/renderer_host/chrome_resource_dispatcher_host_delegate.h"
 #include "chrome/browser/safe_browsing/local_database_manager.h"
 #include "chrome/browser/safe_browsing/test_safe_browsing_service.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -143,7 +143,7 @@ using net::NetworkChangeNotifier;
 using safe_browsing::LocalSafeBrowsingDatabaseManager;
 using safe_browsing::SafeBrowsingService;
 using safe_browsing::SBThreatType;
-using task_manager::browsertest_util::WaitForTaskManagerRows;
+using task_management::browsertest_util::WaitForTaskManagerRows;
 
 // Prerender tests work as follows:
 //
diff --git a/chrome/browser/prerender/prerender_contents.cc b/chrome/browser/prerender/prerender_contents.cc
index 18f221b..f9e9b1c 100644
--- a/chrome/browser/prerender/prerender_contents.cc
+++ b/chrome/browser/prerender/prerender_contents.cc
@@ -23,7 +23,7 @@
 #include "chrome/browser/prerender/prerender_manager_factory.h"
 #include "chrome/browser/prerender/prerender_resource_throttle.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/tab_helpers.h"
 #include "chrome/browser/ui/web_contents_sizer.h"
 #include "chrome/common/prerender_messages.h"
@@ -264,7 +264,7 @@ void PrerenderContents::StartPrerendering(
 
   // Tag the prerender contents with the task manager specific prerender tag, so
   // that it shows up in the task manager.
-  task_manager::WebContentsTags::CreateForPrerenderContents(
+  task_management::WebContentsTags::CreateForPrerenderContents(
       prerender_contents_.get());
 
   web_contents_delegate_.reset(new WebContentsDelegateImpl(this));
@@ -652,7 +652,7 @@ std::unique_ptr<WebContents> PrerenderContents::ReleasePrerenderContents() {
 
   // Clear the task manager tag we added earlier to our
   // WebContents since it's no longer a prerender contents.
-  task_manager::WebContentsTags::ClearTag(prerender_contents_.get());
+  task_management::WebContentsTags::ClearTag(prerender_contents_.get());
 
   return std::move(prerender_contents_);
 }
diff --git a/chrome/browser/printing/print_preview_dialog_controller.cc b/chrome/browser/printing/print_preview_dialog_controller.cc
index 6211d5c..7aa4b42 100644
--- a/chrome/browser/printing/print_preview_dialog_controller.cc
+++ b/chrome/browser/printing/print_preview_dialog_controller.cc
@@ -19,7 +19,7 @@
 #include "chrome/browser/chrome_notification_types.h"
 #include "chrome/browser/extensions/chrome_extension_web_contents_observer.h"
 #include "chrome/browser/printing/print_view_manager.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_window.h"
@@ -386,7 +386,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(
   waiting_for_new_preview_page_ = true;
 
   // Make the print preview WebContents show up in the task manager.
-  task_manager::WebContentsTags::CreateForPrintingContents(preview_dialog);
+  task_management::WebContentsTags::CreateForPrintingContents(preview_dialog);
 
   AddObservers(initiator);
   AddObservers(preview_dialog);
diff --git a/chrome/browser/printing/print_preview_dialog_controller_browsertest.cc b/chrome/browser/printing/print_preview_dialog_controller_browsertest.cc
index a9f65b3..1e93654 100644
--- a/chrome/browser/printing/print_preview_dialog_controller_browsertest.cc
+++ b/chrome/browser/printing/print_preview_dialog_controller_browsertest.cc
@@ -18,7 +18,7 @@
 #include "chrome/browser/plugins/chrome_plugin_service_filter.h"
 #include "chrome/browser/plugins/plugin_prefs.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
@@ -348,8 +348,9 @@ base::string16 GetExpectedPrefix() {
                                     base::string16());
 }
 
-const std::vector<task_manager::WebContentsTag*>& GetTrackedTags() {
-  return task_manager::WebContentsTagsManager::GetInstance()->tracked_tags();
+const std::vector<task_management::WebContentsTag*>& GetTrackedTags() {
+  return task_management::WebContentsTagsManager::GetInstance()->
+      tracked_tags();
 }
 
 IN_PROC_BROWSER_TEST_F(PrintPreviewDialogControllerBrowserTest,
@@ -362,12 +363,12 @@ IN_PROC_BROWSER_TEST_F(PrintPreviewDialogControllerBrowserTest,
 
   // Create a task manager and expect the pre-existing print previews are
   // provided.
-  task_manager::MockWebContentsTaskManager task_manager;
+  task_management::MockWebContentsTaskManager task_manager;
   EXPECT_TRUE(task_manager.tasks().empty());
   task_manager.StartObserving();
   ASSERT_EQ(3U, task_manager.tasks().size());
-  const task_manager::Task* pre_existing_task = task_manager.tasks().back();
-  EXPECT_EQ(task_manager::Task::RENDERER, pre_existing_task->GetType());
+  const task_management::Task* pre_existing_task = task_manager.tasks().back();
+  EXPECT_EQ(task_management::Task::RENDERER, pre_existing_task->GetType());
   const base::string16 pre_existing_title = pre_existing_task->title();
   const base::string16 expected_prefix = GetExpectedPrefix();
   EXPECT_TRUE(base::StartsWith(pre_existing_title,
@@ -386,8 +387,8 @@ IN_PROC_BROWSER_TEST_F(PrintPreviewDialogControllerBrowserTest,
   PrintPreview();
   EXPECT_EQ(3U, GetTrackedTags().size());
   ASSERT_EQ(3U, task_manager.tasks().size());
-  const task_manager::Task* task = task_manager.tasks().back();
-  EXPECT_EQ(task_manager::Task::RENDERER, task->GetType());
+  const task_management::Task* task = task_manager.tasks().back();
+  EXPECT_EQ(task_management::Task::RENDERER, task->GetType());
   const base::string16 title = task->title();
   EXPECT_TRUE(base::StartsWith(title,
                                expected_prefix,
diff --git a/chrome/browser/task_management/DEPS b/chrome/browser/task_management/DEPS
new file mode 100644
index 0000000..de9193f
--- /dev/null
+++ b/chrome/browser/task_management/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+extensions/strings/grit/extensions_strings.h"
+]
diff --git a/chrome/browser/task_management/OWNERS b/chrome/browser/task_management/OWNERS
new file mode 100644
index 0000000..422a446
--- /dev/null
+++ b/chrome/browser/task_management/OWNERS
@@ -0,0 +1,2 @@
+afakhry@chromium.org
+nick@chromium.org
diff --git a/chrome/browser/task_management/mock_web_contents_task_manager.cc b/chrome/browser/task_management/mock_web_contents_task_manager.cc
new file mode 100644
index 0000000..b0549db
--- /dev/null
+++ b/chrome/browser/task_management/mock_web_contents_task_manager.cc
@@ -0,0 +1,46 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+
+#include "base/stl_util.h"
+#include "build/build_config.h"
+
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/resource_reporter/resource_reporter.h"
+#endif  // defined(OS_CHROMEOS)
+
+namespace task_management {
+
+MockWebContentsTaskManager::MockWebContentsTaskManager() {}
+
+MockWebContentsTaskManager::~MockWebContentsTaskManager() {}
+
+void MockWebContentsTaskManager::TaskAdded(Task* task) {
+  DCHECK(task);
+  DCHECK(!ContainsValue(tasks_, task));
+  tasks_.push_back(task);
+}
+
+void MockWebContentsTaskManager::TaskRemoved(Task* task) {
+  DCHECK(task);
+  DCHECK(ContainsValue(tasks_, task));
+  tasks_.erase(std::find(tasks_.begin(), tasks_.end(), task));
+}
+
+void MockWebContentsTaskManager::StartObserving() {
+#if defined(OS_CHROMEOS)
+  // On ChromeOS, the ResourceReporter needs to be turned off so as not to
+  // interfere with the tests.
+  chromeos::ResourceReporter::GetInstance()->StopMonitoring();
+#endif  // defined(OS_CHROMEOS)
+
+  provider_.SetObserver(this);
+}
+
+void MockWebContentsTaskManager::StopObserving() {
+  provider_.ClearObserver();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/mock_web_contents_task_manager.h b/chrome/browser/task_management/mock_web_contents_task_manager.h
new file mode 100644
index 0000000..73db011
--- /dev/null
+++ b/chrome/browser/task_management/mock_web_contents_task_manager.h
@@ -0,0 +1,41 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task_provider_observer.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h"
+
+namespace task_management {
+
+// Defines a test class that will act as a task manager that is designed to
+// only observe the WebContents-based tasks.
+class MockWebContentsTaskManager : public TaskProviderObserver {
+ public:
+  MockWebContentsTaskManager();
+  ~MockWebContentsTaskManager() override;
+
+  // task_management::TaskProviderObserver:
+  void TaskAdded(Task* task) override;
+  void TaskRemoved(Task* task) override;
+
+  // Start / Stop observing the WebContentsTaskProvider.
+  void StartObserving();
+  void StopObserving();
+
+  const std::vector<Task*>& tasks() const { return tasks_; }
+
+ private:
+  std::vector<Task*> tasks_;
+  WebContentsTaskProvider provider_;
+
+  DISALLOW_COPY_AND_ASSIGN(MockWebContentsTaskManager);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
diff --git a/chrome/browser/task_management/providers/arc/arc_process_task.cc b/chrome/browser/task_management/providers/arc/arc_process_task.cc
new file mode 100644
index 0000000..435eee3
--- /dev/null
+++ b/chrome/browser/task_management/providers/arc/arc_process_task.cc
@@ -0,0 +1,174 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/arc/arc_process_task.h"
+
+#include "base/bind.h"
+#include "base/i18n/rtl.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/arc/arc_service_manager.h"
+#include "components/arc/common/process.mojom.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/child_process_host.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/image/image.h"
+
+namespace task_management {
+
+namespace {
+
+base::string16 MakeTitle(const std::string& process_name,
+                         arc::mojom::ProcessState process_state) {
+  int name_template = IDS_TASK_MANAGER_ARC_PREFIX;
+  switch (process_state) {
+    case arc::mojom::ProcessState::PERSISTENT:
+    case arc::mojom::ProcessState::PERSISTENT_UI:
+    case arc::mojom::ProcessState::TOP:
+      name_template = IDS_TASK_MANAGER_ARC_SYSTEM;
+      break;
+    case arc::mojom::ProcessState::BOUND_FOREGROUND_SERVICE:
+    case arc::mojom::ProcessState::FOREGROUND_SERVICE:
+    case arc::mojom::ProcessState::SERVICE:
+    case arc::mojom::ProcessState::IMPORTANT_FOREGROUND:
+    case arc::mojom::ProcessState::IMPORTANT_BACKGROUND:
+      name_template = IDS_TASK_MANAGER_ARC_PREFIX_BACKGROUND_SERVICE;
+      break;
+    case arc::mojom::ProcessState::RECEIVER:
+      name_template = IDS_TASK_MANAGER_ARC_PREFIX_RECEIVER;
+      break;
+    default:
+      break;
+  }
+  base::string16 title = l10n_util::GetStringFUTF16(
+      name_template, base::UTF8ToUTF16(process_name));
+  base::i18n::AdjustStringForLocaleDirection(&title);
+  return title;
+}
+
+scoped_refptr<arc::ActivityIconLoader> GetIconLoader() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  arc::ArcServiceManager* arc_service_manager = arc::ArcServiceManager::Get();
+  if (!arc_service_manager)
+    return nullptr;
+  return arc_service_manager->icon_loader();
+}
+
+// An activity name for retrieving the package's default icon without
+// specifying an activity name.
+constexpr char kEmptyActivityName[] = "";
+
+}  // namespace
+
+ArcProcessTask::ArcProcessTask(base::ProcessId pid,
+                               base::ProcessId nspid,
+                               const std::string& process_name,
+                               arc::mojom::ProcessState process_state,
+                               const std::vector<std::string>& packages)
+    : Task(MakeTitle(process_name, process_state),
+           process_name,
+           nullptr /* icon */,
+           pid),
+      nspid_(nspid),
+      process_name_(process_name),
+      process_state_(process_state),
+      // |packages| contains an alphabetically-sorted list of package names the
+      // process has. Since the Task class can hold only one icon per process,
+      // and there is no reliable way to pick the most important process from
+      // the |packages| list, just use the first item in the list.
+      package_name_(packages.empty() ? "" : packages.at(0)),
+      weak_ptr_factory_(this) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  StartIconLoading();
+}
+
+void ArcProcessTask::StartIconLoading() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (package_name_.empty())
+    return;
+
+  scoped_refptr<arc::ActivityIconLoader> icon_loader = GetIconLoader();
+  arc::ActivityIconLoader::GetResult result =
+      arc::ActivityIconLoader::GetResult::FAILED_ARC_NOT_READY;
+  if (icon_loader) {
+    std::vector<arc::ActivityIconLoader::ActivityName> activities = {
+        {package_name_, kEmptyActivityName}};
+    result = icon_loader->GetActivityIcons(
+        activities, base::Bind(&ArcProcessTask::OnIconLoaded,
+                               weak_ptr_factory_.GetWeakPtr()));
+  }
+
+  if (result == arc::ActivityIconLoader::GetResult::FAILED_ARC_NOT_READY) {
+    // Need to retry loading the icon.
+    arc::ArcBridgeService::Get()->intent_helper()->AddObserver(this);
+  }
+}
+
+ArcProcessTask::~ArcProcessTask() {
+  arc::ArcBridgeService::Get()->intent_helper()->RemoveObserver(this);
+}
+
+Task::Type ArcProcessTask::GetType() const {
+  return Task::ARC;
+}
+
+int ArcProcessTask::GetChildProcessUniqueID() const {
+  // ARC process is not a child process of the browser.
+  return content::ChildProcessHost::kInvalidUniqueID;
+}
+
+bool ArcProcessTask::IsKillable() {
+  // Do not kill persistent processes.
+  return process_state_ > arc::mojom::ProcessState::PERSISTENT_UI;
+}
+
+void ArcProcessTask::Kill() {
+  arc::mojom::ProcessInstance* arc_process_instance =
+      arc::ArcBridgeService::Get()->process()->instance();
+  if (!arc_process_instance) {
+    LOG(ERROR) << "ARC process instance is not ready.";
+    return;
+  }
+  if (arc::ArcBridgeService::Get()->process()->version() < 1) {
+    LOG(ERROR) << "ARC KillProcess IPC is unavailable.";
+    return;
+  }
+  arc_process_instance->KillProcess(nspid_,
+                                    "Killed manually from Task Manager");
+}
+
+void ArcProcessTask::OnInstanceReady() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  VLOG(2) << "intent_helper instance is ready. Fetching the icon for "
+          << package_name_;
+  arc::ArcBridgeService::Get()->intent_helper()->RemoveObserver(this);
+
+  // Instead of calling into StartIconLoading() directly, return to the main
+  // loop first to make sure other ArcBridgeService observers are notified.
+  // Otherwise, arc::ActivityIconLoader::GetActivityIcon() may fail again.
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::Bind(&ArcProcessTask::StartIconLoading,
+                                              weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ArcProcessTask::SetProcessState(arc::mojom::ProcessState process_state) {
+  process_state_ = process_state;
+}
+
+void ArcProcessTask::OnIconLoaded(
+    std::unique_ptr<arc::ActivityIconLoader::ActivityToIconsMap> icons) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  for (const auto& kv : *icons) {
+    const gfx::Image& icon = kv.second.icon16;
+    if (icon.IsEmpty())
+      continue;
+    set_icon(*icon.ToImageSkia());
+    break;  // Since the parent class can hold only one icon, break here.
+  }
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/arc/arc_process_task.h b/chrome/browser/task_management/providers/arc/arc_process_task.h
new file mode 100644
index 0000000..3edf653
--- /dev/null
+++ b/chrome/browser/task_management/providers/arc/arc_process_task.h
@@ -0,0 +1,67 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/task_management/providers/task.h"
+#include "components/arc/arc_bridge_service.h"
+#include "components/arc/common/process.mojom.h"
+#include "components/arc/instance_holder.h"
+#include "components/arc/intent_helper/activity_icon_loader.h"
+
+namespace task_management {
+
+// Defines a task that represents an ARC process.
+class ArcProcessTask
+    : public Task,
+      public arc::InstanceHolder<arc::mojom::IntentHelperInstance>::Observer {
+ public:
+  ArcProcessTask(base::ProcessId pid,
+                 base::ProcessId nspid,
+                 const std::string& process_name,
+                 arc::mojom::ProcessState process_state,
+                 const std::vector<std::string>& packages);
+  ~ArcProcessTask() override;
+
+  // task_management::Task:
+  Type GetType() const override;
+  int GetChildProcessUniqueID() const override;
+  bool IsKillable() override;
+  void Kill() override;
+
+  // arc::InstanceHolder<arc::mojom::IntentHelperInstance>::Observer:
+  void OnInstanceReady() override;
+
+  void SetProcessState(arc::mojom::ProcessState process_state);
+
+  base::ProcessId nspid() const { return nspid_; }
+  const std::string& process_name() const { return process_name_; }
+
+ private:
+  void StartIconLoading();
+  void OnIconLoaded(
+      std::unique_ptr<arc::ActivityIconLoader::ActivityToIconsMap> icons);
+
+  const base::ProcessId nspid_;
+  const std::string process_name_;
+  arc::mojom::ProcessState process_state_;
+  const std::string package_name_;
+
+  // Note: This should remain the last member so it'll be destroyed and
+  // invalidate the weak pointers before any other members are destroyed.
+  base::WeakPtrFactory<ArcProcessTask> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ArcProcessTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
diff --git a/chrome/browser/task_management/providers/arc/arc_process_task_provider.cc b/chrome/browser/task_management/providers/arc/arc_process_task_provider.cc
new file mode 100644
index 0000000..e119ded
--- /dev/null
+++ b/chrome/browser/task_management/providers/arc/arc_process_task_provider.cc
@@ -0,0 +1,130 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/arc/arc_process_task_provider.h"
+
+#include <stddef.h>
+
+#include <queue>
+#include <set>
+#include <utility>
+#include <vector>
+
+#include "base/logging.h"
+#include "base/process/process.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/trace_event/trace_event.h"
+#include "chrome/browser/chromeos/arc/arc_process.h"
+#include "chrome/browser/chromeos/arc/arc_process_service.h"
+#include "components/arc/common/process.mojom.h"
+
+namespace task_management {
+
+namespace {
+
+const int kUpdateProcessListDelaySeconds = 1;
+
+}  // namespace
+
+using std::set;
+using arc::ArcProcess;
+using base::Process;
+using base::ProcessId;
+
+ArcProcessTaskProvider::ArcProcessTaskProvider()
+    : is_updating_(false), weak_ptr_factory_(this) {}
+
+ArcProcessTaskProvider::~ArcProcessTaskProvider() {}
+
+Task* ArcProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
+                                                  int child_id,
+                                                  int route_id) {
+  // ARC tasks are not associated with any URL request.
+  return nullptr;
+}
+
+void ArcProcessTaskProvider::OnUpdateProcessList(
+    const std::vector<ArcProcess>& processes) {
+  TRACE_EVENT0("browser", "ArcProcessTaskProvider::OnUpdateProcessList");
+
+  if (!is_updating_)
+    return;
+
+  // NB: |processes| can be already stale here because it is sent via IPC, and
+  // we can never avoid that. See also the comment at the declaration of
+  // ArcProcessTaskProvider.
+
+  set<ProcessId> nspid_to_remove;
+  for (const auto& entry : nspid_to_task_)
+    nspid_to_remove.insert(entry.first);
+
+  for (const auto& entry : processes) {
+    if (nspid_to_remove.erase(entry.nspid()) == 0) {
+      // New arc process.
+      std::unique_ptr<ArcProcessTask>& task = nspid_to_task_[entry.nspid()];
+      // After calling NotifyObserverTaskAdded(), the raw pointer of |task| is
+      // remebered somewhere else. One should not (implicitly) delete the
+      // referenced object before calling NotifyObserverTaskRemoved() first
+      // (crbug.com/587707).
+      DCHECK(!task.get()) <<
+          "Task with the same pid should not be added twice.";
+      task.reset(new ArcProcessTask(entry.pid(), entry.nspid(),
+                                    entry.process_name(), entry.process_state(),
+                                    entry.packages()));
+      NotifyObserverTaskAdded(task.get());
+    } else {
+      // Update process state of existing process.
+      std::unique_ptr<ArcProcessTask>& task = nspid_to_task_[entry.nspid()];
+      DCHECK(task.get());
+      task->SetProcessState(entry.process_state());
+    }
+  }
+
+  for (const auto& entry : nspid_to_remove) {
+    // Stale arc process.
+    NotifyObserverTaskRemoved(nspid_to_task_[entry].get());
+    nspid_to_task_.erase(entry);
+  }
+  ScheduleNextRequest();
+}
+
+void ArcProcessTaskProvider::RequestProcessList() {
+  arc::ArcProcessService* arc_process_service =
+      arc::ArcProcessService::Get();
+  auto callback = base::Bind(&ArcProcessTaskProvider::OnUpdateProcessList,
+                             weak_ptr_factory_.GetWeakPtr());
+  if (!arc_process_service ||
+      !arc_process_service->RequestProcessList(callback)) {
+    VLOG(2) << "ARC process instance is not ready.";
+    // Update with the empty ARC process list.
+    // Note that this can happen in the middle of the session if the user has
+    // just opted out from ARC.
+    callback.Run(std::vector<ArcProcess>());
+  }
+}
+
+void ArcProcessTaskProvider::StartUpdating() {
+  is_updating_ = true;
+  RequestProcessList();
+}
+
+void ArcProcessTaskProvider::StopUpdating() {
+  is_updating_ = false;
+  nspid_to_task_.clear();
+}
+
+void ArcProcessTaskProvider::ScheduleNextRequest() {
+  if (!is_updating_)
+    return;
+  // TODO(nya): Remove this timer once ARC starts to send us UpdateProcessList
+  // message when the process list changed. As of today, ARC does not send
+  // the process list unless we request it by RequestProcessList message.
+  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
+      FROM_HERE,
+      base::Bind(&ArcProcessTaskProvider::RequestProcessList,
+                 weak_ptr_factory_.GetWeakPtr()),
+      base::TimeDelta::FromSeconds(kUpdateProcessListDelaySeconds));
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/arc/arc_process_task_provider.h b/chrome/browser/task_management/providers/arc/arc_process_task_provider.h
new file mode 100644
index 0000000..49aea04
--- /dev/null
+++ b/chrome/browser/task_management/providers/arc/arc_process_task_provider.h
@@ -0,0 +1,68 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/process/process.h"
+#include "chrome/browser/chromeos/arc/arc_process.h"
+#include "chrome/browser/task_management/providers/arc/arc_process_task.h"
+#include "chrome/browser/task_management/providers/task_provider.h"
+
+namespace task_management {
+
+// This provides the ARC process tasks.
+//
+// Since this provider obtains ARC process information via IPC and procfs,
+// it can never avoid race conditions. For example, in an extreme case such as
+// fork(2) is called millions of times in a second, this provider can return
+// wrong results. However, its chance is very low, and even if we hit the case,
+// the worst outcome is just that an app (non-system) process which
+// the user did not intend to choose is killed. Since apps are designed
+// to be killed at any time, it sounds acceptable.
+class ArcProcessTaskProvider : public TaskProvider {
+ public:
+  ArcProcessTaskProvider();
+  ~ArcProcessTaskProvider() override;
+
+  // task_management::TaskProvider:
+  Task* GetTaskOfUrlRequest(int origin_pid,
+                            int child_id,
+                            int route_id) override;
+
+ private:
+  // Auto-retry if ARC bridge service is not ready.
+  void RequestProcessList();
+
+  void OnUpdateProcessList(const std::vector<arc::ArcProcess>& processes);
+
+  // task_management::TaskProvider:
+  void StartUpdating() override;
+  void StopUpdating() override;
+
+  void ScheduleNextRequest();
+
+  std::map<base::ProcessId, std::unique_ptr<ArcProcessTask>> nspid_to_task_;
+
+  // Whether to continue the periodical polling.
+  bool is_updating_;
+
+  // Always keep this the last member of this class to make sure it's the
+  // first thing to be destructed.
+  base::WeakPtrFactory<ArcProcessTaskProvider> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ArcProcessTaskProvider);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_management/providers/browser_process_task.cc b/chrome/browser/task_management/providers/browser_process_task.cc
new file mode 100644
index 0000000..3a9b5cf
--- /dev/null
+++ b/chrome/browser/task_management/providers/browser_process_task.cc
@@ -0,0 +1,102 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/browser_process_task.h"
+
+#include "base/command_line.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/common/content_switches.h"
+#include "grit/theme_resources.h"
+#include "net/proxy/proxy_resolver_v8.h"
+#include "third_party/sqlite/sqlite3.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace task_management {
+
+namespace {
+
+gfx::ImageSkia* g_default_icon = nullptr;
+
+gfx::ImageSkia* GetDefaultIcon() {
+  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
+      g_default_icon = ResourceBundle::GetSharedInstance().
+          GetImageSkiaNamed(IDR_PRODUCT_LOGO_16);
+    if (g_default_icon)
+      g_default_icon->MakeThreadSafe();
+  }
+
+  return g_default_icon;
+}
+
+bool ReportsV8Stats() {
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  return !command_line->HasSwitch(switches::kWinHttpProxyResolver) &&
+      !command_line->HasSwitch(switches::kSingleProcess);
+}
+
+}  // namespace
+
+BrowserProcessTask::BrowserProcessTask()
+    : Task(l10n_util::GetStringUTF16(IDS_TASK_MANAGER_WEB_BROWSER_CELL_TEXT),
+           "Browser Process",
+           GetDefaultIcon(),
+           base::GetCurrentProcessHandle()),
+       allocated_v8_memory_(-1),
+       used_v8_memory_(-1),
+       used_sqlite_memory_(-1),
+       reports_v8_stats_(ReportsV8Stats()) {
+}
+
+BrowserProcessTask::~BrowserProcessTask() {
+}
+
+bool BrowserProcessTask::IsKillable() {
+  // Never kill the browser process.
+  return false;
+}
+
+void BrowserProcessTask::Kill() {
+  // Never kill the browser process.
+}
+
+void BrowserProcessTask::Refresh(const base::TimeDelta& update_interval,
+                                 int64_t refresh_flags) {
+  Task::Refresh(update_interval, refresh_flags);
+
+  if (reports_v8_stats_ && (refresh_flags & REFRESH_TYPE_V8_MEMORY) != 0) {
+    allocated_v8_memory_ =
+        static_cast<int64_t>(net::ProxyResolverV8::GetTotalHeapSize());
+    used_v8_memory_ =
+        static_cast<int64_t>(net::ProxyResolverV8::GetUsedHeapSize());
+  }
+
+  if ((refresh_flags & REFRESH_TYPE_SQLITE_MEMORY) != 0)
+    used_sqlite_memory_ = static_cast<int64_t>(sqlite3_memory_used());
+}
+
+Task::Type BrowserProcessTask::GetType() const {
+  return Task::BROWSER;
+}
+
+int BrowserProcessTask::GetChildProcessUniqueID() const {
+  return 0;
+}
+
+int64_t BrowserProcessTask::GetSqliteMemoryUsed() const {
+  return used_sqlite_memory_;
+}
+
+int64_t BrowserProcessTask::GetV8MemoryAllocated() const {
+  return allocated_v8_memory_;
+}
+
+int64_t BrowserProcessTask::GetV8MemoryUsed() const {
+  return used_v8_memory_;
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/browser_process_task.h b/chrome/browser/task_management/providers/browser_process_task.h
new file mode 100644
index 0000000..fe548dd
--- /dev/null
+++ b/chrome/browser/task_management/providers/browser_process_task.h
@@ -0,0 +1,43 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_H_
+
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task.h"
+
+namespace task_management {
+
+// Defines the task that represents the one and only browser main process.
+class BrowserProcessTask : public Task {
+ public:
+  BrowserProcessTask();
+  ~BrowserProcessTask() override;
+
+  // task_management::Task:
+  bool IsKillable() override;
+  void Kill() override;
+  void Refresh(const base::TimeDelta& update_interval,
+               int64_t refresh_flags) override;
+  Type GetType() const override;
+  int GetChildProcessUniqueID() const override;
+  int64_t GetSqliteMemoryUsed() const override;
+  int64_t GetV8MemoryAllocated() const override;
+  int64_t GetV8MemoryUsed() const override;
+
+ private:
+  int64_t allocated_v8_memory_;
+  int64_t used_v8_memory_;
+  int64_t used_sqlite_memory_;
+  bool reports_v8_stats_;
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_H_
diff --git a/chrome/browser/task_management/providers/browser_process_task_provider.cc b/chrome/browser/task_management/providers/browser_process_task_provider.cc
new file mode 100644
index 0000000..121b563
--- /dev/null
+++ b/chrome/browser/task_management/providers/browser_process_task_provider.cc
@@ -0,0 +1,34 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/browser_process_task_provider.h"
+
+namespace task_management {
+
+BrowserProcessTaskProvider::BrowserProcessTaskProvider() {
+}
+
+BrowserProcessTaskProvider::~BrowserProcessTaskProvider() {
+}
+
+Task* BrowserProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
+                                                      int child_id,
+                                                      int route_id) {
+  if (origin_pid == 0 && child_id == -1)
+    return &browser_process_task_;
+
+  return nullptr;
+}
+
+void BrowserProcessTaskProvider::StartUpdating() {
+  NotifyObserverTaskAdded(&browser_process_task_);
+}
+
+void BrowserProcessTaskProvider::StopUpdating() {
+  // There's nothing to do here. The browser process task live as long as the
+  // browser lives and when StopUpdating() is called the |observer_| has already
+  // been cleared.
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/browser_process_task_provider.h b/chrome/browser/task_management/providers/browser_process_task_provider.h
new file mode 100644
index 0000000..da36224
--- /dev/null
+++ b/chrome/browser/task_management/providers/browser_process_task_provider.h
@@ -0,0 +1,40 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/browser_process_task.h"
+#include "chrome/browser/task_management/providers/task_provider.h"
+
+namespace task_management {
+
+// This provides the browser process task which lives as long as the browser
+// lives.
+class BrowserProcessTaskProvider : public TaskProvider {
+ public:
+  BrowserProcessTaskProvider();
+  ~BrowserProcessTaskProvider() override;
+
+  // task_management::TaskProvider:
+  Task* GetTaskOfUrlRequest(int origin_pid,
+                            int child_id,
+                            int route_id) override;
+
+ private:
+  // task_management::TaskProvider:
+  void StartUpdating() override;
+  void StopUpdating() override;
+
+  // This is the task that represents the one and only main browser process. It
+  // lives as long as the browser lives.
+  BrowserProcessTask browser_process_task_;
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTaskProvider);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_management/providers/browser_process_task_unittest.cc b/chrome/browser/task_management/providers/browser_process_task_unittest.cc
new file mode 100644
index 0000000..00b9b75
--- /dev/null
+++ b/chrome/browser/task_management/providers/browser_process_task_unittest.cc
@@ -0,0 +1,88 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/browser_process_task_provider.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/grit/generated_resources.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+class BrowserProcessTaskProviderTest
+    : public testing::Test,
+      public TaskProviderObserver {
+ public:
+  BrowserProcessTaskProviderTest()
+      : provided_task_(nullptr) {
+  }
+
+  ~BrowserProcessTaskProviderTest() override {}
+
+  // task_management::TaskProviderObserver:
+  void TaskAdded(Task* task) override {
+    provided_task_ = task;
+  }
+  void TaskRemoved(Task* task) override {
+    // This will never be called in the case of a browser process task provider.
+    FAIL();
+  }
+
+ protected:
+  Task* provided_task_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTaskProviderTest);
+};
+
+// Tests the browser process task provider and browser process task itself.
+TEST_F(BrowserProcessTaskProviderTest, TestObserving) {
+  BrowserProcessTaskProvider provider;
+  EXPECT_EQ(nullptr, provided_task_);
+  provider.SetObserver(this);
+  EXPECT_NE(nullptr, provided_task_);
+  provider.ClearObserver();
+  EXPECT_NE(nullptr, provided_task_);
+}
+
+// Testing retrieving the task from the provider using the ids of a URL request.
+TEST_F(BrowserProcessTaskProviderTest, GetTaskOfUrlRequest) {
+  BrowserProcessTaskProvider provider;
+  EXPECT_EQ(nullptr, provided_task_);
+  provider.SetObserver(this);
+  EXPECT_NE(nullptr, provided_task_);
+
+  Task* result = provider.GetTaskOfUrlRequest(1, 0, 0);
+  EXPECT_EQ(nullptr, result);
+  result = provider.GetTaskOfUrlRequest(0, -1, 0);
+  EXPECT_EQ(provided_task_, result);
+}
+
+// Test the provided browser process task itself.
+TEST_F(BrowserProcessTaskProviderTest, TestProvidedTask) {
+  BrowserProcessTaskProvider provider;
+  EXPECT_EQ(nullptr, provided_task_);
+  provider.SetObserver(this);
+  ASSERT_NE(nullptr, provided_task_);
+
+  EXPECT_EQ(base::GetCurrentProcessHandle(), provided_task_->process_handle());
+  EXPECT_EQ(base::GetCurrentProcId(), provided_task_->process_id());
+  EXPECT_FALSE(provided_task_->ReportsWebCacheStats());
+  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_TASK_MANAGER_WEB_BROWSER_CELL_TEXT),
+            provided_task_->title());
+  EXPECT_EQ(Task::BROWSER, provided_task_->GetType());
+  EXPECT_EQ(0, provided_task_->GetChildProcessUniqueID());
+  const int received_bytes = 1024;
+  EXPECT_FALSE(provided_task_->ReportsNetworkUsage());
+  EXPECT_EQ(-1, provided_task_->network_usage());
+  provided_task_->OnNetworkBytesRead(received_bytes);
+  // Do a refresh with a 1-second update time.
+  provided_task_->Refresh(base::TimeDelta::FromSeconds(1),
+                          REFRESH_TYPE_NETWORK_USAGE);
+  EXPECT_TRUE(provided_task_->ReportsNetworkUsage());
+  EXPECT_EQ(received_bytes, provided_task_->network_usage());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/child_process_task.cc b/chrome/browser/task_management/providers/child_process_task.cc
new file mode 100644
index 0000000..10c7438
--- /dev/null
+++ b/chrome/browser/task_management/providers/child_process_task.cc
@@ -0,0 +1,240 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/child_process_task.h"
+
+#include <utility>
+
+#include "base/i18n/rtl.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/process_resource_usage.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/nacl/common/nacl_process_type.h"
+#include "content/public/browser/browser_child_process_host.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_data.h"
+#include "content/public/common/process_type.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension_set.h"
+#include "grit/theme_resources.h"
+#include "services/shell/public/cpp/interface_provider.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace task_management {
+
+namespace {
+
+gfx::ImageSkia* g_default_icon = nullptr;
+
+gfx::ImageSkia* GetDefaultIcon() {
+  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
+    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
+        IDR_PLUGINS_FAVICON);
+  }
+
+  return g_default_icon;
+}
+
+base::string16 GetLocalizedTitle(const base::string16& title,
+                                 int process_type) {
+  base::string16 result_title = title;
+  if (result_title.empty()) {
+    switch (process_type) {
+      case content::PROCESS_TYPE_PPAPI_PLUGIN:
+      case content::PROCESS_TYPE_PPAPI_BROKER:
+        result_title = l10n_util::GetStringUTF16(
+            IDS_TASK_MANAGER_UNKNOWN_PLUGIN_NAME);
+        break;
+      default:
+        // Nothing to do for non-plugin processes.
+        break;
+    }
+  }
+
+  // Explicitly mark name as LTR if there is no strong RTL character,
+  // to avoid the wrong concatenation result similar to "!Yahoo Mail: the
+  // best web-based Email: NIGULP", in which "NIGULP" stands for the Hebrew
+  // or Arabic word for "plugin".
+  base::i18n::AdjustStringForLocaleDirection(&result_title);
+
+  switch (process_type) {
+    case content::PROCESS_TYPE_UTILITY:
+      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_UTILITY_PREFIX,
+                                        result_title);
+    case content::PROCESS_TYPE_GPU:
+      return l10n_util::GetStringUTF16(IDS_TASK_MANAGER_GPU_PREFIX);
+    case content::PROCESS_TYPE_PPAPI_PLUGIN:
+      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PLUGIN_PREFIX,
+                                        result_title);
+    case content::PROCESS_TYPE_PPAPI_BROKER:
+      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PLUGIN_BROKER_PREFIX,
+                                        result_title);
+    case PROCESS_TYPE_NACL_BROKER:
+      return l10n_util::GetStringUTF16(IDS_TASK_MANAGER_NACL_BROKER_PREFIX);
+    case PROCESS_TYPE_NACL_LOADER: {
+      auto* profile_manager = g_browser_process->profile_manager();
+      if (profile_manager) {
+        // TODO(afakhry): Fix the below looping by plumbing a way to get the
+        // profile or the profile path from the child process host if any.
+        auto loaded_profiles = profile_manager->GetLoadedProfiles();
+        for (auto* profile : loaded_profiles) {
+          const extensions::ExtensionSet& enabled_extensions =
+              extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
+          const extensions::Extension* extension =
+              enabled_extensions.GetExtensionOrAppByURL(GURL(result_title));
+          if (extension) {
+            result_title = base::UTF8ToUTF16(extension->name());
+            break;
+          }
+        }
+      }
+      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_NACL_PREFIX,
+                                        result_title);
+    }
+    // These types don't need display names or get them from elsewhere.
+    case content::PROCESS_TYPE_BROWSER:
+    case content::PROCESS_TYPE_RENDERER:
+    case content::PROCESS_TYPE_ZYGOTE:
+    case content::PROCESS_TYPE_SANDBOX_HELPER:
+    case content::PROCESS_TYPE_MAX:
+      break;
+    case content::PROCESS_TYPE_UNKNOWN:
+      NOTREACHED() << "Need localized name for child process type.";
+  }
+
+  return result_title;
+}
+
+// Connects the |resource_reporter| to the ServiceRegistry of the
+// BrowserChildProcessHost whose unique ID is |unique_child_process_id|.
+void ConnectResourceReporterOnIOThread(
+    int unique_child_process_id,
+    mojo::InterfaceRequest<mojom::ResourceUsageReporter> resource_reporter) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  content::BrowserChildProcessHost* host =
+      content::BrowserChildProcessHost::FromID(unique_child_process_id);
+  if (!host)
+    return;
+
+  shell::InterfaceProvider* interfaces = host->GetRemoteInterfaces();
+  if (interfaces)
+    interfaces->GetInterface(std::move(resource_reporter));
+}
+
+// Creates the Mojo service wrapper that will be used to sample the V8 memory
+// usage of the browser child process whose unique ID is
+// |unique_child_process_id|.
+ProcessResourceUsage* CreateProcessResourcesSampler(
+    int unique_child_process_id) {
+  mojom::ResourceUsageReporterPtr service;
+  mojo::InterfaceRequest<mojom::ResourceUsageReporter> usage_reporter =
+      mojo::GetProxy(&service);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO,
+      FROM_HERE,
+      base::Bind(&ConnectResourceReporterOnIOThread,
+                 unique_child_process_id,
+                 base::Passed(&usage_reporter)));
+
+  return new ProcessResourceUsage(std::move(service));
+}
+
+bool UsesV8Memory(int process_type) {
+  switch (process_type) {
+    case content::PROCESS_TYPE_UTILITY:
+    case content::PROCESS_TYPE_BROWSER:
+    case content::PROCESS_TYPE_RENDERER:
+      return true;
+
+    default:
+      return false;
+  }
+}
+
+}  // namespace
+
+ChildProcessTask::ChildProcessTask(const content::ChildProcessData& data)
+    : Task(GetLocalizedTitle(data.name, data.process_type),
+           base::UTF16ToUTF8(data.name),
+           GetDefaultIcon(),
+           data.handle),
+      process_resources_sampler_(CreateProcessResourcesSampler(data.id)),
+      v8_memory_allocated_(-1),
+      v8_memory_used_(-1),
+      unique_child_process_id_(data.id),
+      process_type_(data.process_type),
+      uses_v8_memory_(UsesV8Memory(process_type_)) {
+}
+
+ChildProcessTask::~ChildProcessTask() {
+}
+
+void ChildProcessTask::Refresh(const base::TimeDelta& update_interval,
+                               int64_t refresh_flags) {
+  Task::Refresh(update_interval, refresh_flags);
+
+  if ((refresh_flags & REFRESH_TYPE_V8_MEMORY) == 0)
+    return;
+
+  if (!uses_v8_memory_)
+    return;
+
+  // The child process resources refresh is performed asynchronously, we will
+  // invoke it and record the current values (which might be invalid at the
+  // moment. We can safely ignore that and count on future refresh cycles
+  // potentially having valid values).
+  process_resources_sampler_->Refresh(base::Closure());
+
+  v8_memory_allocated_ = base::saturated_cast<int64_t>(
+      process_resources_sampler_->GetV8MemoryAllocated());
+  v8_memory_used_ = base::saturated_cast<int64_t>(
+      process_resources_sampler_->GetV8MemoryUsed());
+}
+
+Task::Type ChildProcessTask::GetType() const {
+  // Convert |content::ProcessType| to |task_management::Task::Type|.
+  switch (process_type_) {
+    case content::PROCESS_TYPE_PPAPI_PLUGIN:
+    case content::PROCESS_TYPE_PPAPI_BROKER:
+      return Task::PLUGIN;
+    case content::PROCESS_TYPE_UTILITY:
+      return Task::UTILITY;
+    case content::PROCESS_TYPE_ZYGOTE:
+      return Task::ZYGOTE;
+    case content::PROCESS_TYPE_SANDBOX_HELPER:
+      return Task::SANDBOX_HELPER;
+    case content::PROCESS_TYPE_GPU:
+      return Task::GPU;
+    case PROCESS_TYPE_NACL_LOADER:
+    case PROCESS_TYPE_NACL_BROKER:
+      return Task::NACL;
+    default:
+      return Task::UNKNOWN;
+  }
+}
+
+int ChildProcessTask::GetChildProcessUniqueID() const {
+  return unique_child_process_id_;
+}
+
+bool ChildProcessTask::ReportsV8Memory() const {
+  return uses_v8_memory_ && process_resources_sampler_->ReportsV8MemoryStats();
+}
+
+int64_t ChildProcessTask::GetV8MemoryAllocated() const {
+  return v8_memory_allocated_;
+}
+
+int64_t ChildProcessTask::GetV8MemoryUsed() const {
+  return v8_memory_used_;
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/child_process_task.h b/chrome/browser/task_management/providers/child_process_task.h
new file mode 100644
index 0000000..e64be51
--- /dev/null
+++ b/chrome/browser/task_management/providers/child_process_task.h
@@ -0,0 +1,69 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task.h"
+
+class ProcessResourceUsage;
+
+namespace content {
+struct ChildProcessData;
+}  // namespace content
+
+namespace task_management {
+
+// Represents several types of the browser's child processes such as
+// a plugin or a GPU process, ... etc.
+class ChildProcessTask : public Task {
+ public:
+  // Creates a child process task given its |data| which is
+  // received from observing |content::BrowserChildProcessObserver|.
+  explicit ChildProcessTask(const content::ChildProcessData& data);
+
+  ~ChildProcessTask() override;
+
+  // task_management::Task:
+  void Refresh(const base::TimeDelta& update_interval,
+               int64_t refresh_flags) override;
+  Type GetType() const override;
+  int GetChildProcessUniqueID() const override;
+  bool ReportsV8Memory() const;
+  int64_t GetV8MemoryAllocated() const override;
+  int64_t GetV8MemoryUsed() const override;
+
+ private:
+  // The Mojo service wrapper that will provide us with the V8 memory usage of
+  // the browser child process represented by this object.
+  std::unique_ptr<ProcessResourceUsage> process_resources_sampler_;
+
+  // The allocated and used V8 memory (in bytes).
+  int64_t v8_memory_allocated_;
+  int64_t v8_memory_used_;
+
+  // The unique ID of the child process. It is not the PID of the process.
+  // See |content::ChildProcessData::id|.
+  const int unique_child_process_id_;
+
+  // The type of the child process. See |content::ProcessType| and
+  // |NaClTrustedProcessType|.
+  const int process_type_;
+
+  // Depending on the |process_type_|, determines whether this task uses V8
+  // memory or not.
+  const bool uses_v8_memory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ChildProcessTask);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_H_
diff --git a/chrome/browser/task_management/providers/child_process_task_provider.cc b/chrome/browser/task_management/providers/child_process_task_provider.cc
new file mode 100644
index 0000000..7bb07a4
--- /dev/null
+++ b/chrome/browser/task_management/providers/child_process_task_provider.cc
@@ -0,0 +1,163 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/child_process_task_provider.h"
+
+#include "base/process/process.h"
+#include "chrome/browser/task_management/providers/child_process_task.h"
+#include "content/public/browser/browser_child_process_host_iterator.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_data.h"
+
+using content::BrowserChildProcessHostIterator;
+using content::BrowserThread;
+using content::ChildProcessData;
+
+namespace task_management {
+
+namespace {
+
+// Collects and returns the child processes data on the IO thread to get all the
+// pre-existing child process before we start observing
+// |BrowserChildProcessObserver|.
+std::unique_ptr<std::vector<ChildProcessData>> CollectChildProcessData() {
+  // The |BrowserChildProcessHostIterator| must only be used on the IO thread.
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  std::unique_ptr<std::vector<ChildProcessData>> child_processes(
+      new std::vector<ChildProcessData>());
+  for (BrowserChildProcessHostIterator itr; !itr.Done(); ++itr) {
+    const ChildProcessData& process_data = itr.GetData();
+
+    // Only add processes that have already started, i.e. with valid handles.
+    if (process_data.handle == base::kNullProcessHandle)
+      continue;
+
+    child_processes->push_back(process_data);
+  }
+
+  return child_processes;
+}
+
+}  // namespace
+
+ChildProcessTaskProvider::ChildProcessTaskProvider()
+    : weak_ptr_factory_(this) {
+}
+
+ChildProcessTaskProvider::~ChildProcessTaskProvider() {
+}
+
+Task* ChildProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
+                                                    int child_id,
+                                                    int route_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  auto itr = tasks_by_pid_.find(static_cast<base::ProcessId>(origin_pid));
+  if (itr == tasks_by_pid_.end())
+    return nullptr;
+
+  return itr->second;
+}
+
+void ChildProcessTaskProvider::BrowserChildProcessLaunchedAndConnected(
+      const content::ChildProcessData& data) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (data.handle == base::kNullProcessHandle)
+    return;
+
+  CreateTask(data);
+}
+
+void ChildProcessTaskProvider::BrowserChildProcessHostDisconnected(
+    const content::ChildProcessData& data) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DeleteTask(data.handle);
+}
+
+void ChildProcessTaskProvider::StartUpdating() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK(tasks_by_handle_.empty());
+  DCHECK(tasks_by_pid_.empty());
+
+  // First, get the pre-existing child processes data.
+  BrowserThread::PostTaskAndReplyWithResult(
+      BrowserThread::IO,
+      FROM_HERE,
+      base::Bind(&CollectChildProcessData),
+      base::Bind(&ChildProcessTaskProvider::ChildProcessDataCollected,
+                 weak_ptr_factory_.GetWeakPtr()));
+}
+
+void ChildProcessTaskProvider::StopUpdating() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // ChildProcessDataCollected() should never be called after this, and hence
+  // we must invalidate the weak pointers.
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  // First, stop observing.
+  BrowserChildProcessObserver::Remove(this);
+
+  // Remember: You can't notify the observer of tasks removal here,
+  // StopUpdating() is called after the observer has been cleared.
+
+  // Then delete all tasks (if any).
+  tasks_by_handle_.clear();
+  tasks_by_pid_.clear();
+}
+
+void ChildProcessTaskProvider::ChildProcessDataCollected(
+    std::unique_ptr<const std::vector<content::ChildProcessData>>
+        child_processes) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  for (const auto& process_data : *child_processes)
+    CreateTask(process_data);
+
+  // Now start observing.
+  BrowserChildProcessObserver::Add(this);
+}
+
+void ChildProcessTaskProvider::CreateTask(
+    const content::ChildProcessData& data) {
+  std::unique_ptr<ChildProcessTask>& task = tasks_by_handle_[data.handle];
+  if (task) {
+    // This task is already known to us. This case can happen when some of the
+    // child process data we collect upon StartUpdating() might be of
+    // BrowserChildProcessHosts whose process hadn't launched yet. So we just
+    // return.
+    return;
+  }
+
+  // Create the task and notify the observer.
+  task.reset(new ChildProcessTask(data));
+  tasks_by_pid_[task->process_id()] = task.get();
+  NotifyObserverTaskAdded(task.get());
+}
+
+void ChildProcessTaskProvider::DeleteTask(base::ProcessHandle handle) {
+  auto itr = tasks_by_handle_.find(handle);
+
+  // The following case should never happen since we start observing
+  // |BrowserChildProcessObserver| only after we collect all pre-existing child
+  // processes and are notified (on the UI thread) that the collection is
+  // completed at |ChildProcessDataCollected()|.
+  if (itr == tasks_by_handle_.end()) {
+    // BUG(crbug.com/611067): Temporarily removing due to test flakes. The
+    // reason why this happens is well understood (see bug), but there's no
+    // quick and easy fix.
+    // NOTREACHED();
+    return;
+  }
+
+  NotifyObserverTaskRemoved(itr->second.get());
+
+  // Clear from the pid index.
+  tasks_by_pid_.erase(itr->second->process_id());
+
+  // Finally delete the task.
+  tasks_by_handle_.erase(itr);
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/child_process_task_provider.h b/chrome/browser/task_management/providers/child_process_task_provider.h
new file mode 100644
index 0000000..398c630
--- /dev/null
+++ b/chrome/browser/task_management/providers/child_process_task_provider.h
@@ -0,0 +1,94 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
+
+#include <map>
+#include <memory>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/task_management/providers/task_provider.h"
+#include "content/public/browser/browser_child_process_observer.h"
+
+namespace content {
+struct ChildProcessData;
+}
+
+namespace task_management {
+
+class ChildProcessTask;
+
+// Defines a provider to provide the tasks that represent various types of child
+// processes such as the GPU process or a plugin process ... etc.
+class ChildProcessTaskProvider
+    : public TaskProvider,
+      public content::BrowserChildProcessObserver {
+ public:
+  ChildProcessTaskProvider();
+  ~ChildProcessTaskProvider() override;
+
+  // task_management::TaskProvider:
+  Task* GetTaskOfUrlRequest(int origin_pid,
+                            int child_id,
+                            int route_id) override;
+
+  // content::BrowserChildProcessObserver:
+  void BrowserChildProcessLaunchedAndConnected(
+      const content::ChildProcessData& data) override;
+  void BrowserChildProcessHostDisconnected(
+      const content::ChildProcessData& data) override;
+
+ private:
+  friend class ChildProcessTaskTest;
+
+  // task_management::TaskProvider:
+  void StartUpdating() override;
+  void StopUpdating() override;
+
+  // The pre-existing child processes data will be collected on the IO thread.
+  // When that is done, we will be notified on the UI thread by receiving a call
+  // to this method.
+  void ChildProcessDataCollected(
+      std::unique_ptr<const std::vector<content::ChildProcessData>>
+          child_processes);
+
+  // Creates a ChildProcessTask from the given |data| and notifies the observer
+  // of its addition.
+  void CreateTask(const content::ChildProcessData& data);
+
+  // Deletes a ChildProcessTask whose |handle| is provided after notifying the
+  // observer of its deletion.
+  void DeleteTask(base::ProcessHandle handle);
+
+  // A map to track ChildProcessTask's by their handles.
+  std::map<base::ProcessHandle, std::unique_ptr<ChildProcessTask>>
+      tasks_by_handle_;
+
+  // A map to track ChildProcessTask's by their PIDs.
+  //
+  // Why have both |tasks_by_handle_| and |tasks_by_pid_|? On Windows, where
+  // handles are not the same as PIDs, |DeleteTask| gets only a handle, which
+  // may be closed, making it impossible to query the PID from the handle. So
+  // we need an index on the handle. Meanwhile, we also need an index on the
+  // PID so that we can efficiently implement |GetTaskOfUrlRequest()|, which
+  // gets only a PID.
+  //
+  // TODO(afakhry): Fix this either by keeping the handle open via
+  // |base::Process|, or amending the |BrowserChildProcessObserver| interface to
+  // supply the PID.
+  std::map<base::ProcessId, ChildProcessTask*> tasks_by_pid_;
+
+  // Always keep this the last member of this class to make sure it's the
+  // first thing to be destructed.
+  base::WeakPtrFactory<ChildProcessTaskProvider> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ChildProcessTaskProvider);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_management/providers/child_process_task_unittest.cc b/chrome/browser/task_management/providers/child_process_task_unittest.cc
new file mode 100644
index 0000000..bcfd93f
--- /dev/null
+++ b/chrome/browser/task_management/providers/child_process_task_unittest.cc
@@ -0,0 +1,185 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "base/run_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/task_management/providers/child_process_task.h"
+#include "chrome/browser/task_management/providers/child_process_task_provider.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/nacl/common/nacl_process_type.h"
+#include "content/public/browser/child_process_data.h"
+#include "content/public/common/process_type.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "content/public/test/test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/l10n/l10n_util.h"
+
+using content::ChildProcessData;
+
+namespace task_management {
+
+namespace {
+
+// Will be used to test the translation from |content::ProcessType| to
+// |task_management::Task::Type|.
+struct ProcessTypeTaskTypePair {
+  int process_type_;
+  Task::Type expected_task_type_;
+} process_task_types_pairs[] = {
+    { content::PROCESS_TYPE_PPAPI_PLUGIN, Task::PLUGIN },
+    { content::PROCESS_TYPE_PPAPI_BROKER, Task::PLUGIN },
+    { content::PROCESS_TYPE_UTILITY, Task::UTILITY },
+    { content::PROCESS_TYPE_ZYGOTE, Task::ZYGOTE },
+    { content::PROCESS_TYPE_SANDBOX_HELPER, Task::SANDBOX_HELPER },
+    { content::PROCESS_TYPE_GPU, Task::GPU },
+    { PROCESS_TYPE_NACL_LOADER, Task::NACL },
+    { PROCESS_TYPE_NACL_BROKER, Task::NACL },
+};
+
+}  // namespace
+
+// Defines a test for the child process task provider and the child process
+// tasks themselves.
+class ChildProcessTaskTest
+    : public testing::Test,
+      public TaskProviderObserver {
+ public:
+  ChildProcessTaskTest() {}
+
+  ~ChildProcessTaskTest() override {}
+
+  // task_management::TaskProviderObserver:
+  void TaskAdded(Task* task) override {
+    DCHECK(task);
+    if (provided_tasks_.find(task->process_handle()) != provided_tasks_.end())
+      FAIL() << "ChildProcessTaskProvider must never provide duplicate tasks";
+
+    provided_tasks_[task->process_handle()] = task;
+  }
+
+  void TaskRemoved(Task* task) override {
+    DCHECK(task);
+    provided_tasks_.erase(task->process_handle());
+  }
+
+  bool AreProviderContainersEmpty(
+      const ChildProcessTaskProvider& provider) const {
+    return provider.tasks_by_handle_.empty() && provider.tasks_by_pid_.empty();
+  }
+
+ protected:
+  std::map<base::ProcessHandle, Task*> provided_tasks_;
+
+ private:
+  content::TestBrowserThreadBundle thread_bundle_;
+
+  DISALLOW_COPY_AND_ASSIGN(ChildProcessTaskTest);
+};
+
+// Perfoms a basic test.
+TEST_F(ChildProcessTaskTest, BasicTest) {
+  ChildProcessTaskProvider provider;
+  EXPECT_TRUE(provided_tasks_.empty());
+  provider.SetObserver(this);
+  content::RunAllPendingInMessageLoop();
+  ASSERT_TRUE(provided_tasks_.empty()) <<
+      "unit tests don't have any browser child processes";
+  provider.ClearObserver();
+  EXPECT_TRUE(provided_tasks_.empty());
+  EXPECT_TRUE(AreProviderContainersEmpty(provider));
+}
+
+// Tests everything related to child process task providing.
+TEST_F(ChildProcessTaskTest, TestAll) {
+  ChildProcessTaskProvider provider;
+  EXPECT_TRUE(provided_tasks_.empty());
+  provider.SetObserver(this);
+  content::RunAllPendingInMessageLoop();
+  ASSERT_TRUE(provided_tasks_.empty());
+
+  // The following process which has handle = base::kNullProcessHandle, won't be
+  // added.
+  ChildProcessData data1(0);
+  ASSERT_EQ(base::kNullProcessHandle, data1.handle);
+  provider.BrowserChildProcessLaunchedAndConnected(data1);
+  EXPECT_TRUE(provided_tasks_.empty());
+
+  const int unique_id = 245;
+  const base::string16 name(base::UTF8ToUTF16("Test Task"));
+  const base::string16 expected_name(l10n_util::GetStringFUTF16(
+      IDS_TASK_MANAGER_PLUGIN_PREFIX, name));
+
+  ChildProcessData data2(content::PROCESS_TYPE_PPAPI_PLUGIN);
+  data2.handle = base::GetCurrentProcessHandle();
+  data2.name = name;
+  data2.id = unique_id;
+  provider.BrowserChildProcessLaunchedAndConnected(data2);
+  ASSERT_EQ(1U, provided_tasks_.size());
+
+  Task* task = provided_tasks_.begin()->second;
+  EXPECT_EQ(base::GetCurrentProcessHandle(), task->process_handle());
+  EXPECT_EQ(base::GetCurrentProcId(), task->process_id());
+  EXPECT_EQ(expected_name, task->title());
+  EXPECT_EQ(Task::PLUGIN, task->GetType());
+  EXPECT_EQ(unique_id, task->GetChildProcessUniqueID());
+  EXPECT_EQ(base::string16(), task->GetProfileName());
+  EXPECT_FALSE(task->ReportsSqliteMemory());
+  EXPECT_FALSE(task->ReportsV8Memory());
+  EXPECT_FALSE(task->ReportsWebCacheStats());
+  EXPECT_FALSE(task->ReportsNetworkUsage());
+
+  // Make sure that the conversion from PID to Handle inside
+  // |GetTaskOfUrlRequest()| is working properly.
+  Task* found_task =
+      provider.GetTaskOfUrlRequest(base::GetCurrentProcId(), 0, 0);
+  ASSERT_EQ(task, found_task);
+  const int64_t bytes_read = 1024;
+  found_task->OnNetworkBytesRead(bytes_read);
+  found_task->Refresh(base::TimeDelta::FromSeconds(1),
+                      REFRESH_TYPE_NETWORK_USAGE);
+
+  EXPECT_TRUE(task->ReportsNetworkUsage());
+  EXPECT_EQ(bytes_read, task->network_usage());
+
+  // Clearing the observer won't notify us of any tasks removals even though
+  // tasks will be actually deleted.
+  provider.ClearObserver();
+  EXPECT_FALSE(provided_tasks_.empty());
+  EXPECT_TRUE(AreProviderContainersEmpty(provider));
+}
+
+// Tests the translation of |content::ProcessType| to
+// |task_management::Task::Type|.
+TEST_F(ChildProcessTaskTest, ProcessTypeToTaskType) {
+  ChildProcessTaskProvider provider;
+  EXPECT_TRUE(provided_tasks_.empty());
+  provider.SetObserver(this);
+  content::RunAllPendingInMessageLoop();
+  ASSERT_TRUE(provided_tasks_.empty());
+
+  for (const auto& types_pair : process_task_types_pairs) {
+    // Add the task.
+    ChildProcessData data(types_pair.process_type_);
+    data.handle = base::GetCurrentProcessHandle();
+    provider.BrowserChildProcessLaunchedAndConnected(data);
+    ASSERT_EQ(1U, provided_tasks_.size());
+    Task* task = provided_tasks_.begin()->second;
+    EXPECT_EQ(base::GetCurrentProcessHandle(), task->process_handle());
+    EXPECT_EQ(types_pair.expected_task_type_, task->GetType());
+
+    // Remove the task.
+    provider.BrowserChildProcessHostDisconnected(data);
+    EXPECT_TRUE(provided_tasks_.empty());
+  }
+
+  provider.ClearObserver();
+  EXPECT_TRUE(AreProviderContainersEmpty(provider));
+}
+
+}  // namespace task_management
+
diff --git a/chrome/browser/task_management/providers/task.cc b/chrome/browser/task_management/providers/task.cc
new file mode 100644
index 0000000..59f75e3
--- /dev/null
+++ b/chrome/browser/task_management/providers/task.cc
@@ -0,0 +1,150 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/task.h"
+
+#include <stddef.h>
+
+#include "base/process/process.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_attributes_entry.h"
+#include "chrome/browser/profiles/profile_attributes_storage.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "content/public/common/result_codes.h"
+
+namespace task_management {
+
+namespace {
+
+// The last ID given to the previously created task.
+int64_t g_last_id = 0;
+
+}  // namespace
+
+Task::Task(const base::string16& title,
+           const std::string& rappor_sample,
+           const gfx::ImageSkia* icon,
+           base::ProcessHandle handle,
+           base::ProcessId process_id)
+    : task_id_(g_last_id++),
+      network_usage_(-1),
+      current_byte_count_(-1),
+      title_(title),
+      rappor_sample_name_(rappor_sample),
+      icon_(icon ? *icon : gfx::ImageSkia()),
+      process_handle_(handle),
+      process_id_(process_id != base::kNullProcessId
+                      ? process_id
+                      : base::GetProcId(handle)) {}
+
+Task::~Task() {}
+
+// static
+base::string16 Task::GetProfileNameFromProfile(Profile* profile) {
+  DCHECK(profile);
+  ProfileAttributesEntry* entry;
+  if (g_browser_process->profile_manager()->GetProfileAttributesStorage().
+      GetProfileAttributesWithPath(profile->GetOriginalProfile()->GetPath(),
+                                   &entry)) {
+    return entry->GetName();
+  }
+
+  return base::string16();
+}
+
+void Task::Activate() {
+}
+
+bool Task::IsKillable() {
+  return true;
+}
+
+void Task::Kill() {
+  DCHECK_NE(process_id(), base::GetCurrentProcId());
+  base::Process process = base::Process::Open(process_id());
+  process.Terminate(content::RESULT_CODE_KILLED, false);
+}
+
+void Task::Refresh(const base::TimeDelta& update_interval,
+                   int64_t refresh_flags) {
+  if ((refresh_flags & REFRESH_TYPE_NETWORK_USAGE) == 0)
+    return;
+
+  if (current_byte_count_ == -1)
+    return;
+
+  network_usage_ =
+      (current_byte_count_ * base::TimeDelta::FromSeconds(1)) / update_interval;
+
+  // Reset the current byte count for this task.
+  current_byte_count_ = 0;
+}
+
+void Task::OnNetworkBytesRead(int64_t bytes_read) {
+  if (current_byte_count_ == -1)
+    current_byte_count_ = 0;
+
+  current_byte_count_ += bytes_read;
+}
+
+void Task::GetTerminationStatus(base::TerminationStatus* out_status,
+                                int* out_error_code) const {
+  DCHECK(out_status);
+  DCHECK(out_error_code);
+
+  *out_status = base::TERMINATION_STATUS_STILL_RUNNING;
+  *out_error_code = 0;
+}
+
+base::string16 Task::GetProfileName() const {
+  return base::string16();
+}
+
+int Task::GetTabId() const {
+  return -1;
+}
+
+bool Task::HasParentTask() const {
+  return GetParentTask() != nullptr;
+}
+
+const Task* Task::GetParentTask() const {
+  return nullptr;
+}
+
+bool Task::ReportsSqliteMemory() const {
+  return GetSqliteMemoryUsed() != -1;
+}
+
+int64_t Task::GetSqliteMemoryUsed() const {
+  return -1;
+}
+
+bool Task::ReportsV8Memory() const {
+  return GetV8MemoryAllocated() != -1;
+}
+
+int64_t Task::GetV8MemoryAllocated() const {
+  return -1;
+}
+
+int64_t Task::GetV8MemoryUsed() const {
+  return -1;
+}
+
+bool Task::ReportsWebCacheStats() const {
+  return false;
+}
+
+blink::WebCache::ResourceTypeStats Task::GetWebCacheStats() const {
+  return blink::WebCache::ResourceTypeStats();
+}
+
+bool Task::ReportsNetworkUsage() const {
+  return network_usage_ != -1;
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/task.h b/chrome/browser/task_management/providers/task.h
new file mode 100644
index 0000000..bc5c3b2
--- /dev/null
+++ b/chrome/browser/task_management/providers/task.h
@@ -0,0 +1,190 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_H_
+
+#include <stdint.h>
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/process/kill.h"
+#include "base/process/process_handle.h"
+#include "base/strings/string16.h"
+#include "base/time/time.h"
+#include "third_party/WebKit/public/web/WebCache.h"
+#include "ui/gfx/image/image_skia.h"
+
+class Profile;
+
+namespace task_management {
+
+// Defines a task that corresponds to a tab, an app, an extension, ... etc. It
+// represents one row in the task manager table. Multiple tasks can share the
+// same process, in which case they're grouped together in the task manager
+// table. See |task_management::TaskGroup| which represents a process possibly
+// shared by multiple tasks.
+class Task {
+ public:
+  // Note that the declaration order here determines the default sort order
+  // in the task manager.
+  enum Type {
+    UNKNOWN = 0,
+
+    /* Singleton processes first that don't belong to a particular tab. */
+    BROWSER, /* The main browser process. */
+    GPU,     /* A graphics process. */
+    ARC,     /* An ARC process. */
+    ZYGOTE,  /* A Linux zygote process. */
+    UTILITY, /* A browser utility process. */
+
+    /* Per-Tab processes next. */
+    RENDERER,  /* A normal WebContents renderer process. */
+    EXTENSION, /* An extension or app process. */
+
+    /* Plugin processes last.*/
+    GUEST,          /* A browser plugin guest process. */
+    PLUGIN,         /* A plugin process. */
+    WORKER,         /* A web worker process. */
+    NACL,           /* A NativeClient loader or broker process. */
+    SANDBOX_HELPER, /* A sandbox helper process. */
+  };
+
+  // Create a task with the given |title| and the given favicon |icon|. This
+  // task runs on a process whose handle is |handle|. |rappor_sample| is the
+  // name of the sample to be recorded if this task needs to be reported by
+  // Rappor. If |process_id| is not supplied, it will be determined by |handle|.
+  Task(const base::string16& title,
+       const std::string& rappor_sample,
+       const gfx::ImageSkia* icon,
+       base::ProcessHandle handle,
+       base::ProcessId process_id = base::kNullProcessId);
+  virtual ~Task();
+
+  // Gets the name of the given |profile| from the ProfileAttributesStorage.
+  static base::string16 GetProfileNameFromProfile(Profile* profile);
+
+  // Activates this TaskManager's task by bringing its container to the front
+  // (if possible).
+  virtual void Activate();
+
+  // Returns if the task should be killable from the Task Manager UI.
+  virtual bool IsKillable();
+
+  // Kills this task.
+  virtual void Kill();
+
+  // Will be called to let the task refresh itself between refresh cycles.
+  // |update_interval| is the time since the last task manager refresh.
+  // the |refresh_flags| indicate which resources should be calculated on each
+  // refresh.
+  virtual void Refresh(const base::TimeDelta& update_interval,
+                       int64_t refresh_flags);
+
+  // Will receive this notification through the task manager from
+  // |ChromeNetworkDelegate::OnNetworkBytesReceived()|. The task will add to the
+  // |current_byte_count_| in this refresh cycle.
+  void OnNetworkBytesRead(int64_t bytes_read);
+
+  // Returns the task type.
+  virtual Type GetType() const = 0;
+
+  // This is the unique ID of the BrowserChildProcessHost/RenderProcessHost. It
+  // is not the PID nor the handle of the process.
+  // For a task that represents the browser process, the return value is 0. For
+  // other tasks that represent renderers and other child processes, the return
+  // value is whatever unique IDs of their hosts in the browser process.
+  virtual int GetChildProcessUniqueID() const = 0;
+
+  // If the process, in which this task is running, is terminated, this gets the
+  // termination status. Currently implemented only for Renderer processes.
+  virtual void GetTerminationStatus(base::TerminationStatus* out_status,
+                                    int* out_error_code) const;
+
+  // The name of the profile owning this task.
+  virtual base::string16 GetProfileName() const;
+
+  // Returns the unique ID of the tab if this task represents a renderer
+  // WebContents used for a tab. Returns -1 if this task does not represent
+  // a renderer, or a contents of a tab.
+  virtual int GetTabId() const;
+
+  // For Tasks that represent a subactivity of some other task (e.g. a plugin
+  // embedded in a page), this returns the Task representing the parent
+  // activity.
+  bool HasParentTask() const;
+  virtual const Task* GetParentTask() const;
+
+  // Getting the Sqlite used memory (in bytes). Not all tasks reports Sqlite
+  // memory, in this case a default invalid value of -1 will be returned.
+  // Check for whether the task reports it or not first.
+  bool ReportsSqliteMemory() const;
+  virtual int64_t GetSqliteMemoryUsed() const;
+
+  // Getting the allocated and used V8 memory (in bytes). Not all tasks reports
+  // V8 memory, in this case a default invalid value of -1 will be returned.
+  // Check for whether the task reports it or not first.
+  bool ReportsV8Memory() const;
+  virtual int64_t GetV8MemoryAllocated() const;
+  virtual int64_t GetV8MemoryUsed() const;
+
+  // Checking if the task reports Webkit resource cache statistics and getting
+  // them if it does.
+  virtual bool ReportsWebCacheStats() const;
+  virtual blink::WebCache::ResourceTypeStats GetWebCacheStats() const;
+
+  // Checking whether the task reports network usage.
+  bool ReportsNetworkUsage() const;
+
+  int64_t task_id() const { return task_id_; }
+  int64_t network_usage() const { return network_usage_; }
+  const base::string16& title() const { return title_; }
+  const std::string& rappor_sample_name() const { return rappor_sample_name_; }
+  const gfx::ImageSkia& icon() const { return icon_; }
+  const base::ProcessHandle& process_handle() const { return process_handle_; }
+  const base::ProcessId& process_id() const { return process_id_; }
+
+ protected:
+  void set_title(const base::string16& new_title) { title_ = new_title; }
+  void set_rappor_sample_name(const std::string& sample) {
+    rappor_sample_name_ = sample;
+  }
+  void set_icon(const gfx::ImageSkia& new_icon) { icon_ = new_icon; }
+
+ private:
+  // The unique ID of this task.
+  const int64_t task_id_;
+
+  // The task's network usage in the current refresh cycle measured in bytes per
+  // second. A value of -1 means this task doesn't report network usage data.
+  int64_t network_usage_;
+
+  // The current network bytes received by this task during the current refresh
+  // cycle. A value of -1 means this task has never been notified of any network
+  // usage.
+  int64_t current_byte_count_;
+
+  // The title of the task.
+  base::string16 title_;
+
+  // The name of the sample representing this task when a Rappor sample needs to
+  // be recorded for it.
+  std::string rappor_sample_name_;
+
+  // The favicon.
+  gfx::ImageSkia icon_;
+
+  // The handle of the process on which this task is running.
+  const base::ProcessHandle process_handle_;
+
+  // The PID of the process on which this task is running.
+  const base::ProcessId process_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(Task);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_H_
diff --git a/chrome/browser/task_management/providers/task_provider.cc b/chrome/browser/task_management/providers/task_provider.cc
new file mode 100644
index 0000000..8523942
--- /dev/null
+++ b/chrome/browser/task_management/providers/task_provider.cc
@@ -0,0 +1,44 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/task_provider.h"
+
+namespace task_management {
+
+TaskProvider::TaskProvider()
+    : observer_(nullptr) {
+}
+
+TaskProvider::~TaskProvider() {
+}
+
+void TaskProvider::SetObserver(TaskProviderObserver* observer) {
+  DCHECK(observer);
+  DCHECK(!observer_);
+  observer_ = observer;
+  StartUpdating();
+}
+
+void TaskProvider::ClearObserver() {
+  DCHECK(observer_);
+  observer_ = nullptr;
+  StopUpdating();
+}
+
+void TaskProvider::NotifyObserverTaskAdded(Task* task) const {
+  DCHECK(observer_);
+  observer_->TaskAdded(task);
+}
+
+void TaskProvider::NotifyObserverTaskRemoved(Task* task) const {
+  DCHECK(observer_);
+  observer_->TaskRemoved(task);
+}
+
+void TaskProvider::NotifyObserverTaskUnresponsive(Task* task) const {
+  DCHECK(observer_);
+  observer_->TaskUnresponsive(task);
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/task_provider.h b/chrome/browser/task_management/providers/task_provider.h
new file mode 100644
index 0000000..545e9a1
--- /dev/null
+++ b/chrome/browser/task_management/providers/task_provider.h
@@ -0,0 +1,74 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task_provider_observer.h"
+
+namespace task_management {
+
+// Defines the interface for task providers. A concrete task provider must be
+// able to collect all the tasks of a particular type which this provider
+// supports as well as track any tasks addition / removal. Once StartUpdating()
+// is called, the provider is responsible for notifying the observer about the
+// tasks it's tracking. The TaskProviders own the tasks they provide.
+class TaskProvider {
+ public:
+  TaskProvider();
+  virtual ~TaskProvider();
+
+  // Should return the task associated to the specified IDs from a
+  // |content::ResourceRequestInfo| that represents a |URLRequest|. A value of
+  // nullptr will be returned if the desired task does not belong to this
+  // provider.
+  //
+  // |origin_pid| is the PID of the originating process of the URLRequest, if
+  // the request is sent on behalf of another process. Otherwise it's 0.
+  // |child_id| is the unique ID of the host of the child process requestor.
+  // |route_id| is the ID of the IPC route for the URLRequest (this identifies
+  // the RenderView or like-thing in the renderer that the request gets routed
+  // to).
+  virtual Task* GetTaskOfUrlRequest(int origin_pid,
+                                    int child_id,
+                                    int route_id) = 0;
+
+  // Set the sole observer of this provider. It's an error to set an observer
+  // if there's already one there.
+  void SetObserver(TaskProviderObserver* observer);
+
+  // Clears the currently set observer for this provider. It's an error to clear
+  // the observer if there's no one set.
+  void ClearObserver();
+
+ protected:
+  // Used by concrete task providers to notify the observer of tasks addition/
+  // removal/renderer unresponsive. These methods should only be called after
+  // StartUpdating() has been called and before StopUpdating() is called.
+  void NotifyObserverTaskAdded(Task* task) const;
+  void NotifyObserverTaskRemoved(Task* task) const;
+  void NotifyObserverTaskUnresponsive(Task* task) const;
+
+ private:
+  // This will be called once an observer is set for this provider. When it is
+  // called, the concrete provider must notify the observer of all pre-existing
+  // tasks as well as track new addition and terminations and notify the
+  // observer of these changes.
+  virtual void StartUpdating() = 0;
+
+  // This will be called once the observer is cleared, at which point the
+  // provider can stop tracking tasks addition / removal and can clear its own
+  // resources.
+  virtual void StopUpdating() = 0;
+
+  // We support only one single obsever which will be the sampler in this case.
+  TaskProviderObserver* observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskProvider);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_management/providers/task_provider_observer.h b/chrome/browser/task_management/providers/task_provider_observer.h
new file mode 100644
index 0000000..db95bd2
--- /dev/null
+++ b/chrome/browser/task_management/providers/task_provider_observer.h
@@ -0,0 +1,37 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task.h"
+
+namespace task_management {
+
+// Defines an interface for observing tasks addition / removal.
+class TaskProviderObserver {
+ public:
+  TaskProviderObserver() {}
+  virtual ~TaskProviderObserver() {}
+
+  // This notifies of the event that a new |task| has been created.
+  virtual void TaskAdded(Task* task) = 0;
+
+  // This notifies of the event that a |task| is about to be removed. The task
+  // is still valid during this call, after that it may never be used again by
+  // the observer and references to it must not be kept.
+  virtual void TaskRemoved(Task* task) = 0;
+
+  // This notifies of the event that |task| has become unresponsive. This event
+  // is only for tasks representing renderer processes.
+  virtual void TaskUnresponsive(Task* task) {}
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TaskProviderObserver);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
diff --git a/chrome/browser/task_management/providers/web_contents/background_contents_tag.cc b/chrome/browser/task_management/providers/web_contents/background_contents_tag.cc
new file mode 100644
index 0000000..8a0d5a5
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/background_contents_tag.cc
@@ -0,0 +1,50 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/background_contents_tag.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/background/background_contents.h"
+#include "chrome/browser/background/background_contents_service.h"
+#include "chrome/browser/background/background_contents_service_factory.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/task_management/providers/web_contents/background_contents_task.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/extension_set.h"
+
+namespace task_management {
+
+BackgroundContentsTask* BackgroundContentsTag::CreateTask() const {
+  // Try to lookup the application name from the parent extension (if any).
+  Profile* profile = Profile::FromBrowserContext(
+      web_contents()->GetBrowserContext());
+  BackgroundContentsService* background_contents_service =
+      BackgroundContentsServiceFactory::GetForProfile(profile);
+  const base::string16& application_id =
+      background_contents_service->GetParentApplicationId(background_contents_);
+  const extensions::ExtensionSet& extensions_set =
+      extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
+  const extensions::Extension* extension =
+      extensions_set.GetByID(base::UTF16ToUTF8(application_id));
+  base::string16 application_name;
+  if (extension)
+    application_name = base::UTF8ToUTF16(extension->name());
+
+  return new BackgroundContentsTask(application_name, background_contents_);
+}
+
+BackgroundContentsTag::BackgroundContentsTag(
+    content::WebContents* web_contents,
+    BackgroundContents* background_contents)
+    : WebContentsTag(web_contents),
+      background_contents_(background_contents) {
+  DCHECK(background_contents);
+}
+
+BackgroundContentsTag::~BackgroundContentsTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/background_contents_tag.h b/chrome/browser/task_management/providers/web_contents/background_contents_tag.h
new file mode 100644
index 0000000..60b0437
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/background_contents_tag.h
@@ -0,0 +1,38 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/background_contents_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+class BackgroundContents;
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by BackgroundContents
+// service.
+class BackgroundContentsTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  BackgroundContentsTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  BackgroundContentsTag(content::WebContents* web_contents,
+                        BackgroundContents* background_contents);
+  ~BackgroundContentsTag() override;
+
+  // The owning BackgroundContents.
+  BackgroundContents* background_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/background_contents_tag_browsertest.cc b/chrome/browser/task_management/providers/web_contents/background_contents_tag_browsertest.cc
new file mode 100644
index 0000000..ecfacf0
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/background_contents_tag_browsertest.cc
@@ -0,0 +1,127 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/extensions/extension_browsertest.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/common/content_switches.h"
+#include "extensions/common/switches.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+// Defines a browser test for testing that BackgroundContents are tagged
+// properly and the TagsManager records these tags. It is also used to test that
+// the WebContentsTaskProvider will be able to provide the appropriate
+// BackgroundContentsTask.
+class BackgroundContentsTagTest : public ExtensionBrowserTest {
+ public:
+  BackgroundContentsTagTest() {}
+  ~BackgroundContentsTagTest() override {}
+
+  const extensions::Extension* LoadBackgroundExtension() {
+    auto* extension = LoadExtension(
+        test_data_dir_.AppendASCII("app_process_background_instances"));
+    return extension;
+  }
+
+  base::string16 GetBackgroundTaskExpectedName(
+      const extensions::Extension* extension) {
+    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_APP_PREFIX,
+                                      base::UTF8ToUTF16(extension->name()));
+  }
+
+  WebContentsTagsManager* tags_manager() const {
+    return WebContentsTagsManager::GetInstance();
+  }
+
+ protected:
+  // ExtensionBrowserTest:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    // Pass flags to make testing apps easier.
+    ExtensionBrowserTest::SetUpCommandLine(command_line);
+    test_data_dir_ = test_data_dir_.AppendASCII("api_test");
+    command_line->AppendSwitch(switches::kDisableRendererBackgrounding);
+    command_line->AppendSwitch(switches::kDisablePopupBlocking);
+    command_line->AppendSwitch(extensions::switches::kAllowHTTPBackgroundPage);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTagTest);
+};
+
+// Tests that loading an extension that has a background contents will result in
+// the tags manager recording a WebContentsTag.
+IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, TagsManagerRecordsATag) {
+  // Browser tests start with only one tab available.
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+  auto* extension = LoadBackgroundExtension();
+  ASSERT_NE(nullptr, extension);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+
+  // Unload the extension.
+  UnloadExtension(extension->id());
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+}
+
+// Tests that background contents creation while the provider is being observed
+// will also provide tasks.
+IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, TasksProvidedWhileObserving) {
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  // Browser tests start with only one tab available.
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+
+  task_manager.StartObserving();
+
+  // The pre-existing tab is provided.
+  EXPECT_EQ(1U, task_manager.tasks().size());
+
+  auto* extension = LoadBackgroundExtension();
+  ASSERT_NE(nullptr, extension);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+  ASSERT_EQ(2U, task_manager.tasks().size());
+
+  // Now check the newly provided task.
+  const Task* task = task_manager.tasks().back();
+  EXPECT_EQ(Task::RENDERER, task->GetType());
+  EXPECT_EQ(GetBackgroundTaskExpectedName(extension), task->title());
+
+  // Unload the extension.
+  UnloadExtension(extension->id());
+  EXPECT_EQ(1U, task_manager.tasks().size());
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+}
+
+// Tests providing a pre-existing background task to the observing operation.
+IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, PreExistingTasksAreProvided) {
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  // Browser tests start with only one tab available.
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+  auto* extension = LoadBackgroundExtension();
+  ASSERT_NE(nullptr, extension);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+
+  task_manager.StartObserving();
+
+  // Pre-existing task will be provided to us.
+  ASSERT_EQ(2U, task_manager.tasks().size());
+
+  // Now check the provided task.
+  const Task* task = task_manager.tasks().back();
+  EXPECT_EQ(Task::RENDERER, task->GetType());
+  EXPECT_EQ(GetBackgroundTaskExpectedName(extension), task->title());
+
+  // Unload the extension.
+  UnloadExtension(extension->id());
+  EXPECT_EQ(1U, task_manager.tasks().size());
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/background_contents_task.cc b/chrome/browser/task_management/providers/web_contents/background_contents_task.cc
new file mode 100644
index 0000000..f9b5939
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/background_contents_task.cc
@@ -0,0 +1,81 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/background_contents_task.h"
+
+#include "base/i18n/rtl.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/background/background_contents_service.h"
+#include "chrome/browser/background/background_contents_service_factory.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/view_type_utils.h"
+#include "extensions/common/extension_set.h"
+#include "grit/theme_resources.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace task_management {
+
+namespace {
+
+// The default icon for the background webcontents task.
+gfx::ImageSkia* g_default_icon = nullptr;
+
+gfx::ImageSkia* GetDefaultIcon() {
+  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
+    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
+        IDR_PLUGINS_FAVICON);
+  }
+
+  return g_default_icon;
+}
+
+base::string16 AdjustAndLocalizeTitle(const base::string16& title,
+                                      const std::string& url_spec) {
+  base::string16 localized_title(title);
+  if (localized_title.empty()) {
+    // No title (can't locate the parent app for some reason) so just display
+    // the URL (properly forced to be LTR).
+    localized_title = base::i18n::GetDisplayStringInLTRDirectionality(
+        base::UTF8ToUTF16(url_spec));
+  }
+
+  // Ensure that the string has the appropriate direction markers.
+  base::i18n::AdjustStringForLocaleDirection(&localized_title);
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_APP_PREFIX,
+                                    localized_title);
+}
+
+}  // namespace
+
+BackgroundContentsTask::BackgroundContentsTask(
+    const base::string16& title,
+    BackgroundContents* background_contents)
+    : RendererTask(
+        AdjustAndLocalizeTitle(title, background_contents->GetURL().spec()),
+        GetDefaultIcon(),
+        background_contents->web_contents(),
+        background_contents->web_contents()->GetRenderProcessHost()) {
+}
+
+BackgroundContentsTask::~BackgroundContentsTask() {
+}
+
+void BackgroundContentsTask::UpdateTitle() {
+  // TODO(afakhry): At the time of integration testing figure out whether we
+  // need to change the title of the task here.
+}
+
+void BackgroundContentsTask::UpdateFavicon() {
+  // We don't do anything here. For background contents we always use the
+  // default icon.
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/background_contents_task.h b/chrome/browser/task_management/providers/web_contents/background_contents_task.h
new file mode 100644
index 0000000..0607604
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/background_contents_task.h
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/background/background_contents.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace task_management {
+
+// Defines a RendererTask that represents background |WebContents|.
+class BackgroundContentsTask : public RendererTask {
+ public:
+  BackgroundContentsTask(const base::string16& title,
+                         BackgroundContents* background_contents);
+  ~BackgroundContentsTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/devtools_tag.cc b/chrome/browser/task_management/providers/web_contents/devtools_tag.cc
new file mode 100644
index 0000000..dec0fb1
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/devtools_tag.cc
@@ -0,0 +1,20 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/devtools_tag.h"
+
+namespace task_management {
+
+DevToolsTask* DevToolsTag::CreateTask() const {
+  return new DevToolsTask(web_contents());
+}
+
+DevToolsTag::DevToolsTag(content::WebContents* web_contents)
+    : WebContentsTag(web_contents) {
+}
+
+DevToolsTag::~DevToolsTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/devtools_tag.h b/chrome/browser/task_management/providers/web_contents/devtools_tag.h
new file mode 100644
index 0000000..f6c4cae
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/devtools_tag.h
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/devtools_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by DevToolsWindow.
+class DevToolsTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  DevToolsTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  explicit DevToolsTag(content::WebContents* web_contents);
+  ~DevToolsTag() override;
+
+  DISALLOW_COPY_AND_ASSIGN(DevToolsTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/devtools_tag_browsertest.cc b/chrome/browser/task_management/providers/web_contents/devtools_tag_browsertest.cc
new file mode 100644
index 0000000..b49366e
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/devtools_tag_browsertest.cc
@@ -0,0 +1,123 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/macros.h"
+#include "chrome/browser/devtools/devtools_window_testing.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace task_management {
+
+namespace {
+
+const char kTestPage1[] = "/devtools/debugger_test_page.html";
+const char kTestPage2[] = "/devtools/navigate_back.html";
+
+}  // namespace
+
+// Defines a browser test for testing that DevTools WebContents are being tagged
+// properly by a DevToolsTag and that the TagsManager records these tags. It
+// will also test that the WebContentsTaskProvider will be able to provide the
+// appropriate DevToolsTask.
+class DevToolsTagTest : public InProcessBrowserTest {
+ public:
+  DevToolsTagTest()
+      : devtools_window_(nullptr) {
+    CHECK(embedded_test_server()->Start());
+  }
+
+  ~DevToolsTagTest() override {}
+
+  void LoadTestPage(const std::string& test_page) {
+    GURL url = embedded_test_server()->GetURL(test_page);
+    ui_test_utils::NavigateToURL(browser(), url);
+  }
+
+  void OpenDevToolsWindow(bool is_docked) {
+    devtools_window_ = DevToolsWindowTesting::OpenDevToolsWindowSync(
+        browser()->tab_strip_model()->GetWebContentsAt(0), is_docked);
+  }
+
+  void CloseDevToolsWindow() {
+    DevToolsWindowTesting::CloseDevToolsWindowSync(devtools_window_);
+  }
+
+  WebContentsTagsManager* tags_manager() const {
+    return WebContentsTagsManager::GetInstance();
+  }
+
+ private:
+  DevToolsWindow* devtools_window_;
+
+  DISALLOW_COPY_AND_ASSIGN(DevToolsTagTest);
+};
+
+// Tests that opening a DevToolsWindow will result in tagging its main
+// WebContents and that tag will be recorded by the TagsManager.
+IN_PROC_BROWSER_TEST_F(DevToolsTagTest, TagsManagerRecordsATag) {
+  // Browser tests start with a single tab.
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+
+  // Navigating the same tab to the test page won't change the number of tracked
+  // tags. No devtools yet.
+  LoadTestPage(kTestPage1);
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+
+  // Test both docked and undocked devtools.
+  OpenDevToolsWindow(true);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+  CloseDevToolsWindow();
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+
+  // For the undocked devtools there will be two tags one for the main contents
+  // and one for the toolbox contents
+  OpenDevToolsWindow(false);
+  EXPECT_EQ(3U, tags_manager()->tracked_tags().size());
+  CloseDevToolsWindow();
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+}
+
+IN_PROC_BROWSER_TEST_F(DevToolsTagTest, DevToolsTaskIsProvided) {
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  // Browser tests start with a single tab.
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+
+  task_manager.StartObserving();
+
+  // The pre-existing tab is provided.
+  EXPECT_EQ(1U, task_manager.tasks().size());
+
+  LoadTestPage(kTestPage1);
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+  EXPECT_EQ(1U, task_manager.tasks().size());
+
+  OpenDevToolsWindow(true);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+  ASSERT_EQ(2U, task_manager.tasks().size());
+
+  const Task* task = task_manager.tasks().back();
+  EXPECT_EQ(Task::RENDERER, task->GetType());
+
+  // Navigating to a new page will not change the id of the devtools main
+  // WebContents (its js may update its title).
+  const int64_t task_id = task->task_id();
+  LoadTestPage(kTestPage2);
+  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
+  EXPECT_EQ(task_id,  task_manager.tasks().back()->task_id());
+  EXPECT_EQ(task, task_manager.tasks().back());
+  EXPECT_NE(task_manager.tasks()[0]->title(),
+            task_manager.tasks()[1]->title());
+
+  CloseDevToolsWindow();
+  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
+  EXPECT_EQ(1U, task_manager.tasks().size());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/devtools_task.cc b/chrome/browser/task_management/providers/web_contents/devtools_task.cc
new file mode 100644
index 0000000..3bafc76
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/devtools_task.cc
@@ -0,0 +1,18 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/devtools_task.h"
+
+#include "content/public/browser/web_contents.h"
+
+namespace task_management {
+
+DevToolsTask::DevToolsTask(content::WebContents* web_contents)
+    : TabContentsTask(web_contents) {
+}
+
+DevToolsTask::~DevToolsTask() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/devtools_task.h b/chrome/browser/task_management/providers/web_contents/devtools_task.h
new file mode 100644
index 0000000..e98967b
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/devtools_task.h
@@ -0,0 +1,25 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/tab_contents_task.h"
+
+namespace task_management {
+
+// Defines a task manager representation of the developer tools WebContents.
+class DevToolsTask : public TabContentsTask {
+ public:
+  explicit DevToolsTask(content::WebContents* web_contents);
+  ~DevToolsTask() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DevToolsTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/extension_tag.cc b/chrome/browser/task_management/providers/web_contents/extension_tag.cc
new file mode 100644
index 0000000..cf9879c
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/extension_tag.cc
@@ -0,0 +1,36 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/extension_tag.h"
+
+#include "content/public/browser/web_contents.h"
+
+#if defined(ENABLE_EXTENSIONS)
+#include "extensions/browser/process_manager.h"
+#endif
+
+namespace task_management {
+
+ExtensionTask* ExtensionTag::CreateTask() const {
+  // Upon being asked to create a task, it means that the site instance is ready
+  // and connected, and the render frames have been initialized.
+  // It's OK if the following returns nullptr, ExtensionTask will then get the
+  // title from the WebContents.
+  const extensions::Extension* extension =
+      extensions::ProcessManager::Get(web_contents()->GetBrowserContext())->
+          GetExtensionForWebContents(web_contents());
+
+  return new ExtensionTask(web_contents(), extension, view_type_);
+}
+
+ExtensionTag::ExtensionTag(content::WebContents* web_contents,
+                           const extensions::ViewType view_type)
+    : WebContentsTag(web_contents),
+      view_type_(view_type) {
+}
+
+ExtensionTag::~ExtensionTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/extension_tag.h b/chrome/browser/task_management/providers/web_contents/extension_tag.h
new file mode 100644
index 0000000..0b521e9
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/extension_tag.h
@@ -0,0 +1,39 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/extension_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace extensions {
+class Extension;
+}  // namespace extensions
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by extensions.
+class ExtensionTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  ExtensionTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  ExtensionTag(content::WebContents* web_contents,
+               const extensions::ViewType view_type);
+  ~ExtensionTag() override;
+
+  // The ViewType of the extension WebContents this tag is attached to.
+  const extensions::ViewType view_type_;
+
+  DISALLOW_COPY_AND_ASSIGN(ExtensionTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/extension_tag_browsertest.cc b/chrome/browser/task_management/providers/web_contents/extension_tag_browsertest.cc
new file mode 100644
index 0000000..924dd04
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/extension_tag_browsertest.cc
@@ -0,0 +1,117 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "build/build_config.h"
+#include "chrome/browser/extensions/extension_browsertest.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/common/chrome_switches.h"
+#include "extensions/browser/test_image_loader.h"
+#include "extensions/common/constants.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/skia_util.h"
+
+namespace task_management {
+
+class ExtensionTagsTest : public ExtensionBrowserTest {
+ public:
+  ExtensionTagsTest() {}
+  ~ExtensionTagsTest() override {}
+
+ protected:
+  // ExtensionBrowserTest:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    ExtensionBrowserTest::SetUpCommandLine(command_line);
+
+    // Do not launch device discovery process.
+    command_line->AppendSwitch(switches::kDisableDeviceDiscoveryNotifications);
+  }
+
+  const std::vector<WebContentsTag*>& tracked_tags() const {
+    return WebContentsTagsManager::GetInstance()->tracked_tags();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ExtensionTagsTest);
+};
+
+// Tests loading, disabling, enabling and unloading extensions and how that will
+// affect the recording of tags.
+IN_PROC_BROWSER_TEST_F(ExtensionTagsTest, Basic) {
+  // Browser tests start with a single tab.
+  EXPECT_EQ(1U, tracked_tags().size());
+
+  const extensions::Extension* extension = LoadExtension(
+      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
+          .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+          .AppendASCII("1.0.0.0"));
+  ASSERT_TRUE(extension);
+
+  EXPECT_EQ(2U, tracked_tags().size());
+
+  DisableExtension(extension->id());
+  EXPECT_EQ(1U, tracked_tags().size());
+
+  EnableExtension(extension->id());
+  EXPECT_EQ(2U, tracked_tags().size());
+
+  UnloadExtension(extension->id());
+  EXPECT_EQ(1U, tracked_tags().size());
+}
+
+// Test disabled due to flakiness. See bug: http://crbug.com/519333
+IN_PROC_BROWSER_TEST_F(ExtensionTagsTest,
+                       DISABLED_PreAndPostExistingTaskProviding) {
+  // Browser tests start with a single tab.
+  EXPECT_EQ(1U, tracked_tags().size());
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+
+  const extensions::Extension* extension = LoadExtension(
+      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
+          .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+          .AppendASCII("1.0.0.0"));
+  ASSERT_TRUE(extension);
+
+  EXPECT_EQ(2U, tracked_tags().size());
+  EXPECT_TRUE(task_manager.tasks().empty());
+
+  base::RunLoop run_loop;
+  run_loop.RunUntilIdle();
+
+  // Start observing, pre-existing tasks will be provided.
+  task_manager.StartObserving();
+  ASSERT_EQ(2U, task_manager.tasks().size());
+  const Task* extension_task = task_manager.tasks().back();
+  EXPECT_EQ(Task::EXTENSION, extension_task->GetType());
+
+  SkBitmap expected_bitmap =
+      extensions::TestImageLoader::LoadAndGetExtensionBitmap(
+          extension,
+          "icon_128.png",
+          extension_misc::EXTENSION_ICON_SMALL);
+  ASSERT_FALSE(expected_bitmap.empty());
+
+  EXPECT_TRUE(gfx::BitmapsAreEqual(*extension_task->icon().bitmap(),
+                                   expected_bitmap));
+
+  // Unload the extension and expect that the task manager now shows only the
+  // about:blank tab.
+  UnloadExtension(extension->id());
+  EXPECT_EQ(1U, tracked_tags().size());
+  ASSERT_EQ(1U, task_manager.tasks().size());
+  const Task* about_blank_task = task_manager.tasks().back();
+  EXPECT_EQ(Task::RENDERER, about_blank_task->GetType());
+  EXPECT_EQ(base::UTF8ToUTF16("Tab: about:blank"), about_blank_task->title());
+
+  // Reload the extension, the task manager should show it again.
+  ReloadExtension(extension->id());
+  EXPECT_EQ(2U, tracked_tags().size());
+  ASSERT_EQ(2U, task_manager.tasks().size());
+  EXPECT_EQ(Task::EXTENSION, task_manager.tasks().back()->GetType());
+}
+
+}  // namespace task_management
+
diff --git a/chrome/browser/task_management/providers/web_contents/extension_task.cc b/chrome/browser/task_management/providers/web_contents/extension_task.cc
new file mode 100644
index 0000000..f523a61
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/extension_task.cc
@@ -0,0 +1,141 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/extension_task.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/chrome_pages.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/process_manager.h"
+#include "extensions/browser/view_type_utils.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/manifest_handlers/icons_handler.h"
+#include "extensions/common/view_type.h"
+#include "grit/theme_resources.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace task_management {
+
+namespace {
+
+gfx::ImageSkia* g_default_icon = nullptr;
+
+gfx::ImageSkia* GetDefaultIcon() {
+  if (!ResourceBundle::HasSharedInstance())
+    return nullptr;
+
+  if (!g_default_icon) {
+    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
+        IDR_EXTENSIONS_FAVICON);
+  }
+
+  return g_default_icon;
+}
+
+}  // namespace
+
+ExtensionTask::ExtensionTask(content::WebContents* web_contents,
+                             const extensions::Extension* extension,
+                             extensions::ViewType view_type)
+    : RendererTask(GetExtensionTitle(web_contents, extension, view_type),
+                   GetDefaultIcon(),
+                   web_contents,
+                   web_contents->GetRenderProcessHost()) {
+  LoadExtensionIcon(extension);
+}
+
+ExtensionTask::~ExtensionTask() {
+}
+
+void ExtensionTask::UpdateTitle() {
+  // The title of the extension should not change as a result of title change
+  // in its WebContents, so we ignore this.
+}
+
+void ExtensionTask::UpdateFavicon() {
+  // We don't care about the favicon of the WebContents but rather of the
+  // extension.
+}
+
+void ExtensionTask::Activate() {
+  // This task represents the extension view of (for example) a background page
+  // or browser action button, so there is no top-level window to bring to the
+  // front. Instead, when this task is double-clicked, we bring up the
+  // chrome://extensions page in a tab, and highlight the details for this
+  // extension.
+  //
+  // TODO(nick): For extensions::VIEW_TYPE_APP_WINDOW, and maybe others, there
+  // may actually be a window we could focus. Special case those here as needed.
+  const extensions::Extension* extension =
+      extensions::ProcessManager::Get(web_contents()->GetBrowserContext())
+          ->GetExtensionForWebContents(web_contents());
+
+  if (!extension)
+    return;
+
+  Browser* browser = chrome::FindTabbedBrowser(
+      Profile::FromBrowserContext(web_contents()->GetBrowserContext()), true);
+
+  // If an existing browser isn't found, don't create a new one.
+  if (!browser)
+    return;
+
+  chrome::ShowExtensions(browser, extension->id());
+}
+
+Task::Type ExtensionTask::GetType() const {
+  return Task::EXTENSION;
+}
+
+void ExtensionTask::OnExtensionIconImageChanged(extensions::IconImage* image) {
+  DCHECK_EQ(extension_icon_.get(), image);
+
+  if (!image->image_skia().isNull())
+    set_icon(image->image_skia());
+}
+
+base::string16 ExtensionTask::GetExtensionTitle(
+    content::WebContents* web_contents,
+    const extensions::Extension* extension,
+    extensions::ViewType view_type) const {
+  DCHECK(web_contents);
+
+  base::string16 title = extension ?
+      base::UTF8ToUTF16(extension->name()) :
+      RendererTask::GetTitleFromWebContents(web_contents);
+
+  bool is_background =
+      view_type == extensions::VIEW_TYPE_EXTENSION_BACKGROUND_PAGE;
+
+  return RendererTask::PrefixRendererTitle(
+      title,
+      extension && extension->is_app(),
+      true,  // is_extension
+      web_contents->GetBrowserContext()->IsOffTheRecord(),
+      is_background);
+}
+
+void ExtensionTask::LoadExtensionIcon(const extensions::Extension* extension) {
+  if (!extension)
+    return;
+
+  extension_icon_.reset(
+      new extensions::IconImage(web_contents()->GetBrowserContext(),
+                                extension,
+                                extensions::IconsInfo::GetIcons(extension),
+                                extension_misc::EXTENSION_ICON_SMALL,
+                                icon(),
+                                this));
+
+  // Triggers actual image loading with 1x resources.
+  extension_icon_->image_skia().GetRepresentation(1.0f);
+  set_icon(extension_icon_->image_skia());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/extension_task.h b/chrome/browser/task_management/providers/web_contents/extension_task.h
new file mode 100644
index 0000000..a4ff3ac
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/extension_task.h
@@ -0,0 +1,60 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+#include "extensions/browser/extension_icon_image.h"
+#include "extensions/common/view_type.h"
+
+namespace extensions {
+class Extension;
+}  // namespace extensions
+
+namespace task_management {
+
+// Defines a task manager representation for extensions.
+class ExtensionTask
+    : public RendererTask,
+      public extensions::IconImage::Observer {
+ public:
+  ExtensionTask(content::WebContents* web_contents,
+                const extensions::Extension* extension,
+                extensions::ViewType view_type);
+  ~ExtensionTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+  void Activate() override;
+  Type GetType() const override;
+
+  // extensions::IconImage::Observer
+  void OnExtensionIconImageChanged(extensions::IconImage* image) override;
+
+ private:
+  // If |extension| is nullptr, this method will get the title from
+  // the |web_contents|.
+  base::string16 GetExtensionTitle(
+      content::WebContents* web_contents,
+      const extensions::Extension* extension,
+      extensions::ViewType view_type) const;
+
+  // This is called upon the creation of this task to load the extension icon
+  // for the first time if any.
+  void LoadExtensionIcon(const extensions::Extension* extension);
+
+  // The favicon of the extension represented by this task.
+  std::unique_ptr<extensions::IconImage> extension_icon_;
+
+  DISALLOW_COPY_AND_ASSIGN(ExtensionTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/guest_tag.cc b/chrome/browser/task_management/providers/web_contents/guest_tag.cc
new file mode 100644
index 0000000..75b73ce
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/guest_tag.cc
@@ -0,0 +1,20 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/guest_tag.h"
+
+namespace task_management {
+
+GuestTask* GuestTag::CreateTask() const {
+  return new GuestTask(web_contents());
+}
+
+GuestTag::GuestTag(content::WebContents* web_contents)
+    : WebContentsTag(web_contents) {
+}
+
+GuestTag::~GuestTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/guest_tag.h b/chrome/browser/task_management/providers/web_contents/guest_tag.h
new file mode 100644
index 0000000..bcdd8bf
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/guest_tag.h
@@ -0,0 +1,32 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/guest_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by the GuestViewBase,
+// which represents browser <*view> tag plugin guests.
+class GuestTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  GuestTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  explicit GuestTag(content::WebContents* web_contents);
+  ~GuestTag() override;
+
+  DISALLOW_COPY_AND_ASSIGN(GuestTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/guest_task.cc b/chrome/browser/task_management/providers/web_contents/guest_task.cc
new file mode 100644
index 0000000..7167c7d
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/guest_task.cc
@@ -0,0 +1,60 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/guest_task.h"
+
+#include "components/guest_view/browser/guest_view_base.h"
+#include "content/public/browser/web_contents.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+GuestTask::GuestTask(content::WebContents* web_contents)
+    : RendererTask(GetCurrentTitle(web_contents),
+                   GetFaviconFromWebContents(web_contents),
+                   web_contents,
+                   web_contents->GetRenderProcessHost()) {
+}
+
+GuestTask::~GuestTask() {
+}
+
+void GuestTask::UpdateTitle() {
+  set_title(GetCurrentTitle(web_contents()));
+}
+
+void GuestTask::UpdateFavicon() {
+  const gfx::ImageSkia* icon = GetFaviconFromWebContents(web_contents());
+  set_icon(icon ? *icon : gfx::ImageSkia());
+}
+
+Task::Type GuestTask::GetType() const {
+  return Task::GUEST;
+}
+
+base::string16 GuestTask::GetCurrentTitle(
+    content::WebContents* web_contents) const {
+  DCHECK(web_contents);
+
+  guest_view::GuestViewBase* guest =
+      guest_view::GuestViewBase::FromWebContents(web_contents);
+
+  if (!guest) {
+    // This can happen when an AppWindowContentsImpl is destroyed. It emits a
+    // DidFinishNavigation() events to the WebContentsObservers which triggers a
+    // title update in WebContentsTaskProvider. This happens before
+    // WebContentsDestroyed() is emitted.
+    return title();
+  }
+
+  base::string16 title =
+      l10n_util::GetStringFUTF16(guest->GetTaskPrefix(),
+                                 RendererTask::GetTitleFromWebContents(
+                                     web_contents));
+
+  return title;
+}
+
+}  // namespace task_management
+
diff --git a/chrome/browser/task_management/providers/web_contents/guest_task.h b/chrome/browser/task_management/providers/web_contents/guest_task.h
new file mode 100644
index 0000000..a114b11
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/guest_task.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace task_management {
+
+// Defines a concrete RendererTask that represents WebContents owned by the
+// GuestViewBase which represents a <*view> tag that is a browser plugin guest.
+class GuestTask : public RendererTask {
+ public:
+  explicit GuestTask(content::WebContents* web_contents);
+  ~GuestTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+  Type GetType() const override;
+
+ private:
+  base::string16 GetCurrentTitle(content::WebContents* web_contents) const;
+
+  DISALLOW_COPY_AND_ASSIGN(GuestTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/panel_tag.cc b/chrome/browser/task_management/providers/web_contents/panel_tag.cc
new file mode 100644
index 0000000..4d185fe
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/panel_tag.cc
@@ -0,0 +1,23 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/panel_tag.h"
+
+#include "chrome/browser/ui/panels/panel.h"
+
+namespace task_management {
+
+PanelTask* PanelTag::CreateTask() const {
+  return new PanelTask(panel_, web_contents());
+}
+
+PanelTag::PanelTag(content::WebContents* web_contents, Panel* panel)
+    : WebContentsTag(web_contents),
+      panel_(panel) {
+}
+
+PanelTag::~PanelTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/panel_tag.h b/chrome/browser/task_management/providers/web_contents/panel_tag.h
new file mode 100644
index 0000000..8bd0155
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/panel_tag.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/panel_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by the PanelManager.
+class PanelTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  PanelTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  PanelTag(content::WebContents* web_contents, Panel* panel);
+  ~PanelTag() override;
+
+  Panel* panel_;
+
+  DISALLOW_COPY_AND_ASSIGN(PanelTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/panel_task.cc b/chrome/browser/task_management/providers/web_contents/panel_task.cc
new file mode 100644
index 0000000..b310ad7
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/panel_task.cc
@@ -0,0 +1,68 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/panel_task.h"
+
+#include "base/i18n/rtl.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/panels/panel.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/extension_registry.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace task_management {
+
+namespace {
+
+const gfx::ImageSkia* GetPanelIcon(Panel* panel) {
+  const gfx::Image icon = panel->GetCurrentPageIcon();
+  return !icon.IsEmpty() ? icon.ToImageSkia() : nullptr;
+}
+
+}  // namespace
+
+PanelTask::PanelTask(Panel* panel, content::WebContents* web_contents)
+    : RendererTask(GetCurrentPanelTitle(panel),
+                   GetPanelIcon(panel),
+                   web_contents,
+                   web_contents->GetRenderProcessHost()),
+      panel_(panel) {
+}
+
+PanelTask::~PanelTask() {
+}
+
+void PanelTask::UpdateTitle() {
+  set_title(GetCurrentPanelTitle(panel_));
+}
+
+void PanelTask::UpdateFavicon() {
+  const gfx::ImageSkia* icon = GetPanelIcon(panel_);
+  set_icon(icon ? *icon : gfx::ImageSkia());
+}
+
+Task::Type PanelTask::GetType() const {
+  return Task::EXTENSION;
+}
+
+base::string16 PanelTask::GetCurrentPanelTitle(Panel* panel) const {
+  base::string16 title = panel->GetWindowTitle();
+  base::i18n::AdjustStringForLocaleDirection(&title);
+
+  extensions::ExtensionRegistry* registry =
+      extensions::ExtensionRegistry::Get(panel->profile());
+  const extensions::Extension* extension =
+      registry->enabled_extensions().GetByID(panel->extension_id());
+
+  const bool is_app = extension && extension->is_app();
+  const bool is_incognito = panel->profile()->IsOffTheRecord();
+
+  return PrefixRendererTitle(title,
+                             is_app,
+                             true,  // is_extension.
+                             is_incognito,
+                             false);  // is_background.
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/panel_task.h b/chrome/browser/task_management/providers/web_contents/panel_task.h
new file mode 100644
index 0000000..8c5100a
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/panel_task.h
@@ -0,0 +1,37 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+class Panel;
+
+namespace task_management {
+
+// Defines a task manager representation of WebContents owned by the
+// PanelManager.
+class PanelTask : public RendererTask {
+ public:
+  PanelTask(Panel* panel, content::WebContents* web_contents);
+  ~PanelTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+  Task::Type GetType() const override;
+
+ private:
+  base::string16 GetCurrentPanelTitle(Panel* panel) const;
+
+  Panel* panel_;
+
+  DISALLOW_COPY_AND_ASSIGN(PanelTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/prerender_tag.cc b/chrome/browser/task_management/providers/web_contents/prerender_tag.cc
new file mode 100644
index 0000000..499756c
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/prerender_tag.cc
@@ -0,0 +1,20 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/prerender_tag.h"
+
+namespace task_management {
+
+PrerenderTask* PrerenderTag::CreateTask() const {
+  return new PrerenderTask(web_contents());
+}
+
+PrerenderTag::PrerenderTag(content::WebContents* web_contents)
+    : WebContentsTag(web_contents) {
+}
+
+PrerenderTag::~PrerenderTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/prerender_tag.h b/chrome/browser/task_management/providers/web_contents/prerender_tag.h
new file mode 100644
index 0000000..48d0243
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/prerender_tag.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/prerender_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by the
+// PrerenderManager.
+class PrerenderTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  PrerenderTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  explicit PrerenderTag(content::WebContents* web_contents);
+  ~PrerenderTag() override;
+
+  DISALLOW_COPY_AND_ASSIGN(PrerenderTag);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/prerender_task.cc b/chrome/browser/task_management/providers/web_contents/prerender_task.cc
new file mode 100644
index 0000000..99b4813
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/prerender_task.cc
@@ -0,0 +1,61 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/prerender_task.h"
+
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/web_contents.h"
+#include "grit/theme_resources.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace task_management {
+
+namespace {
+
+gfx::ImageSkia* g_prerender_icon = nullptr;
+
+// Returns the prerender icon or |nullptr| if the |ResourceBundle| is not ready
+// yet.
+gfx::ImageSkia* GetPrerenderIcon() {
+  if (g_prerender_icon)
+    return g_prerender_icon;
+
+  if (!ResourceBundle::HasSharedInstance())
+    return nullptr;
+
+  g_prerender_icon =
+      ResourceBundle::GetSharedInstance().GetImageSkiaNamed(IDR_PRERENDER);
+  return g_prerender_icon;
+}
+
+base::string16 PrefixTitle(const base::string16& title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRERENDER_PREFIX, title);
+}
+
+}  // namespace
+
+PrerenderTask::PrerenderTask(content::WebContents* web_contents)
+    : RendererTask(
+          PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents)),
+          GetPrerenderIcon(),
+          web_contents,
+          web_contents->GetRenderProcessHost()) {
+}
+
+PrerenderTask::~PrerenderTask() {
+}
+
+void PrerenderTask::UpdateTitle() {
+  // As long as this task lives we keep prefixing its title with "Prerender:".
+  set_title(PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents())));
+}
+
+void PrerenderTask::UpdateFavicon() {
+  // As long as this task lives we keep using the prerender icon, so we ignore
+  // this event.
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/prerender_task.h b/chrome/browser/task_management/providers/web_contents/prerender_task.h
new file mode 100644
index 0000000..3a27521
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/prerender_task.h
@@ -0,0 +1,30 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace task_management {
+
+// Defines a task manager representation of WebContents owned by the
+// PrerenderManager.
+class PrerenderTask : public RendererTask {
+ public:
+  explicit PrerenderTask(content::WebContents* web_contents);
+  ~PrerenderTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PrerenderTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/printing_tag.cc b/chrome/browser/task_management/providers/web_contents/printing_tag.cc
new file mode 100644
index 0000000..235a33a
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/printing_tag.cc
@@ -0,0 +1,20 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/printing_tag.h"
+
+namespace task_management {
+
+PrintingTask* PrintingTag::CreateTask() const {
+  return new PrintingTask(web_contents());
+}
+
+PrintingTag::PrintingTag(content::WebContents* web_contents)
+    : WebContentsTag(web_contents) {
+}
+
+PrintingTag::~PrintingTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/printing_tag.h b/chrome/browser/task_management/providers/web_contents/printing_tag.h
new file mode 100644
index 0000000..1574028
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/printing_tag.h
@@ -0,0 +1,32 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/printing_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents created for print previews
+// and background printing.
+class PrintingTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  PrintingTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  explicit PrintingTag(content::WebContents* web_contents);
+  ~PrintingTag() override;
+
+  DISALLOW_COPY_AND_ASSIGN(PrintingTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/printing_task.cc b/chrome/browser/task_management/providers/web_contents/printing_task.cc
new file mode 100644
index 0000000..601b959
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/printing_task.cc
@@ -0,0 +1,42 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/printing_task.h"
+
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/web_contents.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+namespace {
+
+base::string16 PrefixTitle(const base::string16& title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRINT_PREFIX, title);
+}
+
+}  // namespace
+
+PrintingTask::PrintingTask(content::WebContents* web_contents)
+    : RendererTask(
+        PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents)),
+        RendererTask::GetFaviconFromWebContents(web_contents),
+        web_contents,
+        web_contents->GetRenderProcessHost()) {
+}
+
+PrintingTask::~PrintingTask() {
+}
+
+void PrintingTask::UpdateTitle() {
+  set_title(PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents())));
+}
+
+void PrintingTask::UpdateFavicon() {
+  const gfx::ImageSkia* icon =
+      RendererTask::GetFaviconFromWebContents(web_contents());
+  set_icon(icon ? *icon : gfx::ImageSkia());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/printing_task.h b/chrome/browser/task_management/providers/web_contents/printing_task.h
new file mode 100644
index 0000000..d8d6299
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/printing_task.h
@@ -0,0 +1,30 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace task_management {
+
+// Defines a task manager representation for WebContents that are created for
+// print previews and background printing.
+class PrintingTask : public RendererTask {
+ public:
+  explicit PrintingTask(content::WebContents* web_contents);
+  ~PrintingTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PrintingTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/renderer_task.cc b/chrome/browser/task_management/providers/web_contents/renderer_task.cc
new file mode 100644
index 0000000..08036fb
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/renderer_task.cc
@@ -0,0 +1,244 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+#include <utility>
+
+#include "base/i18n/rtl.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/favicon/favicon_utils.h"
+#include "chrome/browser/process_resource_usage.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_contents_delegate.h"
+#include "services/shell/public/cpp/interface_provider.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+namespace {
+
+// Creates the Mojo service wrapper that will be used to sample the V8 memory
+// usage and the the WebCache resource stats of the render process hosted by
+// |render_process_host|.
+ProcessResourceUsage* CreateRendererResourcesSampler(
+    content::RenderProcessHost* render_process_host) {
+  mojom::ResourceUsageReporterPtr service;
+  render_process_host->GetRemoteInterfaces()->GetInterface(&service);
+  return new ProcessResourceUsage(std::move(service));
+}
+
+// Gets the profile name associated with the browser context of the given
+// |render_process_host| from the profile info cache.
+base::string16 GetRendererProfileName(
+    const content::RenderProcessHost* render_process_host) {
+  Profile* profile =
+      Profile::FromBrowserContext(render_process_host->GetBrowserContext());
+  return Task::GetProfileNameFromProfile(profile);
+}
+
+bool IsRendererResourceSamplingDisabled(int64_t flags) {
+  return (flags & (REFRESH_TYPE_V8_MEMORY | REFRESH_TYPE_WEBCACHE_STATS)) == 0;
+}
+
+std::string GetRapporSampleName(content::WebContents* web_contents) {
+  return web_contents->GetVisibleURL().GetOrigin().spec();
+}
+
+}  // namespace
+
+RendererTask::RendererTask(const base::string16& title,
+                           const gfx::ImageSkia* icon,
+                           content::WebContents* web_contents,
+                           content::RenderProcessHost* render_process_host)
+    : Task(title,
+           GetRapporSampleName(web_contents),
+           icon,
+           render_process_host->GetHandle()),
+      web_contents_(web_contents),
+      render_process_host_(render_process_host),
+      renderer_resources_sampler_(
+          CreateRendererResourcesSampler(render_process_host_)),
+      render_process_id_(render_process_host_->GetID()),
+      v8_memory_allocated_(0),
+      v8_memory_used_(0),
+      webcache_stats_(blink::WebCache::ResourceTypeStats()),
+      profile_name_(GetRendererProfileName(render_process_host_)),
+      termination_status_(base::TERMINATION_STATUS_STILL_RUNNING),
+      termination_error_code_(0) {
+  // All renderer tasks are capable of reporting network usage, so the default
+  // invalid value of -1 doesn't apply here.
+  OnNetworkBytesRead(0);
+
+  // Tag the web_contents with a |ContentFaviconDriver| (if needed) so that
+  // we can use it to observe favicons changes.
+  favicon::CreateContentFaviconDriverForWebContents(web_contents);
+  favicon::ContentFaviconDriver::FromWebContents(web_contents)->AddObserver(
+      this);
+}
+
+RendererTask::~RendererTask() {
+  favicon::ContentFaviconDriver::FromWebContents(web_contents())->
+      RemoveObserver(this);
+}
+
+void RendererTask::UpdateRapporSampleName() {
+  set_rappor_sample_name(GetRapporSampleName(web_contents()));
+}
+
+void RendererTask::Activate() {
+  if (!web_contents_->GetDelegate())
+    return;
+
+  web_contents_->GetDelegate()->ActivateContents(web_contents_);
+}
+
+void RendererTask::Refresh(const base::TimeDelta& update_interval,
+                           int64_t refresh_flags) {
+  Task::Refresh(update_interval, refresh_flags);
+
+  if (IsRendererResourceSamplingDisabled(refresh_flags))
+    return;
+
+  // The renderer resources refresh is performed asynchronously, we will invoke
+  // it and record the current values (which might be invalid at the moment. We
+  // can safely ignore that and count on future refresh cycles potentially
+  // having valid values).
+  renderer_resources_sampler_->Refresh(base::Closure());
+
+  v8_memory_allocated_ = base::saturated_cast<int64_t>(
+      renderer_resources_sampler_->GetV8MemoryAllocated());
+  v8_memory_used_ = base::saturated_cast<int64_t>(
+      renderer_resources_sampler_->GetV8MemoryUsed());
+  webcache_stats_ = renderer_resources_sampler_->GetWebCoreCacheStats();
+}
+
+Task::Type RendererTask::GetType() const {
+  return Task::RENDERER;
+}
+
+int RendererTask::GetChildProcessUniqueID() const {
+  return render_process_id_;
+}
+
+void RendererTask::GetTerminationStatus(base::TerminationStatus* out_status,
+                                        int* out_error_code) const {
+  DCHECK(out_status);
+  DCHECK(out_error_code);
+
+  *out_status = termination_status_;
+  *out_error_code = termination_error_code_;
+}
+
+base::string16 RendererTask::GetProfileName() const {
+  return profile_name_;
+}
+
+int RendererTask::GetTabId() const {
+  return SessionTabHelper::IdForTab(web_contents_);
+}
+
+int64_t RendererTask::GetV8MemoryAllocated() const {
+  return v8_memory_allocated_;
+}
+
+int64_t RendererTask::GetV8MemoryUsed() const {
+  return v8_memory_used_;
+}
+
+bool RendererTask::ReportsWebCacheStats() const {
+  return true;
+}
+
+blink::WebCache::ResourceTypeStats RendererTask::GetWebCacheStats() const {
+  return webcache_stats_;
+}
+
+void RendererTask::OnFaviconUpdated(favicon::FaviconDriver* favicon_driver,
+                                    NotificationIconType notification_icon_type,
+                                    const GURL& icon_url,
+                                    bool icon_url_changed,
+                                    const gfx::Image& image) {
+  if (notification_icon_type == NON_TOUCH_16_DIP)
+    UpdateFavicon();
+}
+
+// static
+base::string16 RendererTask::GetTitleFromWebContents(
+    content::WebContents* web_contents) {
+  DCHECK(web_contents);
+  base::string16 title = web_contents->GetTitle();
+  if (title.empty()) {
+    GURL url = web_contents->GetURL();
+    title = base::UTF8ToUTF16(url.spec());
+    // Force URL to be LTR.
+    title = base::i18n::GetDisplayStringInLTRDirectionality(title);
+  } else {
+    // Since the title could later be concatenated with
+    // IDS_TASK_MANAGER_TAB_PREFIX (for example), we need to explicitly set the
+    // title to be LTR format if there is no strong RTL charater in it.
+    // Otherwise, if IDS_TASK_MANAGER_TAB_PREFIX is an RTL word, the
+    // concatenated result might be wrong. For example, http://mail.yahoo.com,
+    // whose title is "Yahoo! Mail: The best web-based Email!", without setting
+    // it explicitly as LTR format, the concatenated result will be "!Yahoo!
+    // Mail: The best web-based Email :BAT", in which the capital letters "BAT"
+    // stands for the Hebrew word for "tab".
+    base::i18n::AdjustStringForLocaleDirection(&title);
+  }
+  return title;
+}
+
+// static
+const gfx::ImageSkia* RendererTask::GetFaviconFromWebContents(
+    content::WebContents* web_contents) {
+  DCHECK(web_contents);
+
+  // Tag the web_contents with a |ContentFaviconDriver| (if needed) so that
+  // we can use it to retrieve the favicon if there is one.
+  favicon::CreateContentFaviconDriverForWebContents(web_contents);
+  gfx::Image image =
+      favicon::ContentFaviconDriver::FromWebContents(web_contents)->
+          GetFavicon();
+  if (image.IsEmpty())
+    return nullptr;
+
+  return image.ToImageSkia();
+}
+
+// static
+const base::string16 RendererTask::PrefixRendererTitle(
+    const base::string16& title,
+    bool is_app,
+    bool is_extension,
+    bool is_incognito,
+    bool is_background) {
+  int message_id = IDS_TASK_MANAGER_TAB_PREFIX;
+
+  if (is_incognito && !is_app && !is_extension) {
+    message_id = IDS_TASK_MANAGER_TAB_INCOGNITO_PREFIX;
+  } else if (is_app) {
+    if (is_background)
+      message_id = IDS_TASK_MANAGER_BACKGROUND_PREFIX;
+    else if (is_incognito)
+      message_id = IDS_TASK_MANAGER_APP_INCOGNITO_PREFIX;
+    else
+      message_id = IDS_TASK_MANAGER_APP_PREFIX;
+  } else if (is_extension) {
+    if (is_incognito)
+      message_id = IDS_TASK_MANAGER_EXTENSION_INCOGNITO_PREFIX;
+    else
+      message_id = IDS_TASK_MANAGER_EXTENSION_PREFIX;
+  }
+
+  return l10n_util::GetStringFUTF16(message_id, title);
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/renderer_task.h b/chrome/browser/task_management/providers/web_contents/renderer_task.h
new file mode 100644
index 0000000..71693b9
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/renderer_task.h
@@ -0,0 +1,138 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task.h"
+#include "components/favicon/core/favicon_driver_observer.h"
+#include "content/public/browser/navigation_entry.h"
+
+class ProcessResourceUsage;
+
+namespace content {
+class RenderProcessHost;
+class WebContents;
+}  // namespace content
+
+namespace task_management {
+
+// Defines an abstract base class for various types of renderer process tasks
+// such as background contents, tab contents, ... etc.
+class RendererTask : public Task,
+                     public favicon::FaviconDriverObserver {
+ public:
+  RendererTask(const base::string16& title,
+               const gfx::ImageSkia* icon,
+               content::WebContents* web_contents,
+               content::RenderProcessHost* render_process_host);
+  ~RendererTask() override;
+
+  // An abstract method that will be called when the event
+  // WebContentsObserver::DidNavigateMainFrame() occurs. This gives the
+  // freedom to concrete tasks to adjust the title however they need to before
+  // they set it.
+  virtual void UpdateTitle() = 0;
+
+  // An abstract method that will be called when the event
+  // FaviconDriverObserver::OnFaviconUpdated() occurs, so that concrete tasks
+  // can update their favicons.
+  virtual void UpdateFavicon() = 0;
+
+  // An overridable method that will be called when the event
+  // WebContentsObserver::DidNavigateMainFrame() occurs, so that we can update
+  // their Rappor sample name when a navigation takes place.
+  virtual void UpdateRapporSampleName();
+
+  // task_management::Task:
+  void Activate() override;
+  void Refresh(const base::TimeDelta& update_interval,
+               int64_t refresh_flags) override;
+  Type GetType() const override;
+  int GetChildProcessUniqueID() const override;
+  void GetTerminationStatus(base::TerminationStatus* out_status,
+                            int* out_error_code) const override;
+  base::string16 GetProfileName() const override;
+  int GetTabId() const override;
+  int64_t GetV8MemoryAllocated() const override;
+  int64_t GetV8MemoryUsed() const override;
+  bool ReportsWebCacheStats() const override;
+  blink::WebCache::ResourceTypeStats GetWebCacheStats() const override;
+
+  // favicon::FaviconDriverObserver:
+  void OnFaviconUpdated(favicon::FaviconDriver* driver,
+                        NotificationIconType notification_icon_type,
+                        const GURL& icon_url,
+                        bool icon_url_changed,
+                        const gfx::Image& image) override;
+
+  void set_termination_status(base::TerminationStatus status) {
+    termination_status_ = status;
+  }
+
+  void set_termination_error_code(int error_code) {
+    termination_error_code_ = error_code;
+  }
+
+ protected:
+  // Returns the title of the given |web_contents|.
+  static base::string16 GetTitleFromWebContents(
+      content::WebContents* web_contents);
+
+  // Returns the favicon of the given |web_contents| if any, and returns
+  // |nullptr| otherwise.
+  static const gfx::ImageSkia* GetFaviconFromWebContents(
+      content::WebContents* web_contents);
+
+  // Prefixes the given renderer |title| with the appropriate string based on
+  // whether it's an app, an extension, incognito or a background page or
+  // contents.
+  static const base::string16 PrefixRendererTitle(const base::string16& title,
+                                                  bool is_app,
+                                                  bool is_extension,
+                                                  bool is_incognito,
+                                                  bool is_background);
+
+  content::WebContents* web_contents() const { return web_contents_; }
+
+ private:
+  // The WebContents of the task this object represents.
+  content::WebContents* web_contents_;
+
+  // The render process host of the task this object represents.
+  content::RenderProcessHost* render_process_host_;
+
+  // The Mojo service wrapper that will provide us with the V8 memory usage and
+  // the WebCache resource stats of the render process represented by this
+  // object.
+  std::unique_ptr<ProcessResourceUsage> renderer_resources_sampler_;
+
+  // The unique ID of the RenderProcessHost.
+  const int render_process_id_;
+
+  // The allocated and used V8 memory (in bytes).
+  int64_t v8_memory_allocated_;
+  int64_t v8_memory_used_;
+
+  // The WebKit resource cache statistics for this renderer.
+  blink::WebCache::ResourceTypeStats webcache_stats_;
+
+  // The profile name associated with the browser context of the render view
+  // host.
+  const base::string16 profile_name_;
+
+  base::TerminationStatus termination_status_;
+  int termination_error_code_;
+
+  DISALLOW_COPY_AND_ASSIGN(RendererTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/subframe_task.cc b/chrome/browser/task_management/providers/web_contents/subframe_task.cc
new file mode 100644
index 0000000..51f4f51
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/subframe_task.cc
@@ -0,0 +1,86 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/subframe_task.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/extension_set.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+namespace {
+
+base::string16 AdjustTitle(const content::SiteInstance* site_instance) {
+  DCHECK(site_instance);
+
+  // By default, subframe rows display the site, like this:
+  //     "Subframe: http://example.com/"
+  const GURL& site_url = site_instance->GetSiteURL();
+  std::string name = site_url.spec();
+
+  // If |site_url| wraps a chrome extension id, we can display the extension
+  // name instead, which is more human-readable.
+  if (site_url.SchemeIs(extensions::kExtensionScheme)) {
+    const extensions::Extension* extension =
+        extensions::ExtensionRegistry::Get(site_instance->GetBrowserContext())
+            ->enabled_extensions()
+            .GetExtensionOrAppByURL(site_url);
+    if (extension)
+      name = extension->name();
+  }
+
+  int message_id = site_instance->GetBrowserContext()->IsOffTheRecord() ?
+      IDS_TASK_MANAGER_SUBFRAME_INCOGNITO_PREFIX :
+      IDS_TASK_MANAGER_SUBFRAME_PREFIX;
+  return l10n_util::GetStringFUTF16(message_id, base::UTF8ToUTF16(name));
+}
+
+}  // namespace
+
+SubframeTask::SubframeTask(content::RenderFrameHost* render_frame_host,
+                           content::WebContents* web_contents,
+                           RendererTask* main_task)
+    : RendererTask(AdjustTitle(render_frame_host->GetSiteInstance()),
+                   nullptr,
+                   web_contents,
+                   render_frame_host->GetProcess()),
+      main_task_(main_task) {
+  // Note that we didn't get the RenderProcessHost from the WebContents, but
+  // rather from the RenderFrameHost. Out-of-process iframes reside on
+  // different processes than that of their main frame.
+}
+
+SubframeTask::~SubframeTask() {
+}
+
+void SubframeTask::UpdateTitle() {
+  // This will be called when the title changes on the WebContents's main frame,
+  // but this Task represents other frames, so we don't care.
+}
+
+void SubframeTask::UpdateFavicon() {
+  // This will be called when the favicon changes on the WebContents's main
+  // frame, but this Task represents other frames, so we don't care.
+}
+
+Task* SubframeTask::GetParentTask() const {
+  return main_task_;
+}
+
+void SubframeTask::Activate() {
+  // Activate the root task.
+  main_task_->Activate();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/subframe_task.h b/chrome/browser/task_management/providers/web_contents/subframe_task.h
new file mode 100644
index 0000000..216b29a
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/subframe_task.h
@@ -0,0 +1,44 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace content {
+class RenderFrameHost;
+class WebContents;
+}  // namespace content
+
+namespace task_management {
+
+// Defines a concrete renderer task that can represent processes hosting
+// out-of-process iframes.
+class SubframeTask : public RendererTask {
+ public:
+  SubframeTask(content::RenderFrameHost* render_frame_host,
+               content::WebContents* web_contents,
+               RendererTask* main_task);
+  ~SubframeTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+  void Activate() override;
+
+  // task_management::Task:
+  Task* GetParentTask() const override;
+
+ private:
+  // The task for the main frame of this WebContents.
+  RendererTask* main_task_;
+  DISALLOW_COPY_AND_ASSIGN(SubframeTask);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/subframe_task_browsertest.cc b/chrome/browser/task_management/providers/web_contents/subframe_task_browsertest.cc
new file mode 100644
index 0000000..95f7fee
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/subframe_task_browsertest.cc
@@ -0,0 +1,129 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/test/browser_test_utils.h"
+#include "content/public/test/test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace task_management {
+
+namespace {
+
+// URL of a test page on a.com that has two cross-site iframes to b.com and
+// c.com.
+const char kCrossSitePageUrl[] = "/cross-site/a.com/iframe_cross_site.html";
+
+// URL of a test page on a.com that has no cross-site iframes.
+const char kSimplePageUrl[] = "/cross-site/a.com/title2.html";
+
+base::string16 GetExpectedSubframeTitlePrefix() {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_SUBFRAME_PREFIX,
+                                    base::string16());
+}
+
+base::string16 PrefixExpectedTabTitle(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
+                                    base::UTF8ToUTF16(title));
+}
+
+}  // namespace
+
+// A test for OOPIFs and how they show up in the task manager as
+// SubframeTasks.
+class SubframeTaskBrowserTest : public InProcessBrowserTest {
+ public:
+  SubframeTaskBrowserTest() {}
+  ~SubframeTaskBrowserTest() override {}
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    InProcessBrowserTest::SetUpCommandLine(command_line);
+    content::IsolateAllSitesForTesting(command_line);
+  }
+
+  void SetUpOnMainThread() override {
+    host_resolver()->AddRule("*", "127.0.0.1");
+    ASSERT_TRUE(embedded_test_server()->Start());
+    content::SetupCrossSiteRedirector(embedded_test_server());
+  }
+
+  void NavigateTo(const char* page_url) const {
+    ui_test_utils::NavigateToURL(browser(),
+                                 embedded_test_server()->GetURL(page_url));
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(SubframeTaskBrowserTest);
+};
+
+// Makes sure that, if sites are isolated, the task manager will show the
+// expected SubframeTasks, and they will be shown as running on different
+// processes as expected.
+IN_PROC_BROWSER_TEST_F(SubframeTaskBrowserTest, TaskManagerShowsSubframeTasks) {
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  task_manager.StartObserving();
+
+  // Currently only the about:blank page.
+  ASSERT_EQ(1U, task_manager.tasks().size());
+  const Task* about_blank_task = task_manager.tasks().front();
+  EXPECT_EQ(Task::RENDERER, about_blank_task->GetType());
+  EXPECT_EQ(PrefixExpectedTabTitle("about:blank"), about_blank_task->title());
+
+  NavigateTo(kCrossSitePageUrl);
+
+  // Whether sites are isolated or not, we expect to have at least one tab
+  // contents task.
+  ASSERT_GE(task_manager.tasks().size(), 1U);
+  const Task* cross_site_task = task_manager.tasks().front();
+  EXPECT_EQ(Task::RENDERER, cross_site_task->GetType());
+  EXPECT_EQ(PrefixExpectedTabTitle("cross-site iframe test"),
+            cross_site_task->title());
+
+  if (!content::AreAllSitesIsolatedForTesting()) {
+    // Sites are not isolated. No SubframeTasks are expected, just the above
+    // task.
+    ASSERT_EQ(1U, task_manager.tasks().size());
+  } else {
+    // Sites are isolated. We expect, in addition to the above task, two more
+    // SubframeTasks, one for b.com and another for c.com.
+    ASSERT_EQ(3U, task_manager.tasks().size());
+    const Task* subframe_task_1 = task_manager.tasks()[1];
+    const Task* subframe_task_2 = task_manager.tasks()[2];
+
+    EXPECT_EQ(Task::RENDERER, subframe_task_1->GetType());
+    EXPECT_EQ(Task::RENDERER, subframe_task_2->GetType());
+
+    EXPECT_TRUE(base::StartsWith(subframe_task_1->title(),
+                                 GetExpectedSubframeTitlePrefix(),
+                                 base::CompareCase::INSENSITIVE_ASCII));
+    EXPECT_TRUE(base::StartsWith(subframe_task_2->title(),
+                                 GetExpectedSubframeTitlePrefix(),
+                                 base::CompareCase::INSENSITIVE_ASCII));
+
+    // All tasks must be running on different processes.
+    EXPECT_NE(subframe_task_1->process_id(), subframe_task_2->process_id());
+    EXPECT_NE(subframe_task_1->process_id(), cross_site_task->process_id());
+    EXPECT_NE(subframe_task_2->process_id(), cross_site_task->process_id());
+  }
+
+  // If we navigate to the simple page on a.com which doesn't have cross-site
+  // iframes, we expect not to have any SubframeTasks.
+  NavigateTo(kSimplePageUrl);
+
+  ASSERT_EQ(1U, task_manager.tasks().size());
+  const Task* simple_page_task = task_manager.tasks().front();
+  EXPECT_EQ(Task::RENDERER, simple_page_task->GetType());
+  EXPECT_EQ(PrefixExpectedTabTitle("Title Of Awesomeness"),
+            simple_page_task->title());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/tab_contents_tag.cc b/chrome/browser/task_management/providers/web_contents/tab_contents_tag.cc
new file mode 100644
index 0000000..9ac341c
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/tab_contents_tag.cc
@@ -0,0 +1,20 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/tab_contents_tag.h"
+
+namespace task_management {
+
+TabContentsTask* TabContentsTag::CreateTask() const {
+  return new TabContentsTask(web_contents());
+}
+
+TabContentsTag::TabContentsTag(content::WebContents* web_contents)
+    : WebContentsTag(web_contents) {
+}
+
+TabContentsTag::~TabContentsTag() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/tab_contents_tag.h b/chrome/browser/task_management/providers/web_contents/tab_contents_tag.h
new file mode 100644
index 0000000..8af93d3
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/tab_contents_tag.h
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/tab_contents_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace task_management {
+
+// Defines a concrete UserData type for WebContents owned by the TabStripModel.
+class TabContentsTag : public WebContentsTag {
+ public:
+  // task_management::WebContentsTag:
+  TabContentsTask* CreateTask() const override;
+
+ private:
+  friend class WebContentsTags;
+
+  explicit TabContentsTag(content::WebContents* web_contents);
+  ~TabContentsTag() override;
+
+  DISALLOW_COPY_AND_ASSIGN(TabContentsTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/tab_contents_tag_browsertest.cc b/chrome/browser/task_management/providers/web_contents/tab_contents_tag_browsertest.cc
new file mode 100644
index 0000000..800d5b1
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/tab_contents_tag_browsertest.cc
@@ -0,0 +1,319 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "base/macros.h"
+#include "base/path_service.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/task_management/mock_web_contents_task_manager.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/favicon/content/content_favicon_driver.h"
+#include "components/favicon/core/favicon_driver.h"
+#include "components/favicon/core/favicon_driver_observer.h"
+#include "content/public/browser/favicon_status.h"
+#include "content/public/browser/navigation_entry.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/page_transition_types.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_unittest_util.h"
+#include "ui/resources/grit/ui_resources.h"
+
+namespace task_management {
+
+namespace {
+
+// Defines a test page file path along with its expected task manager reported
+// values.
+struct TestPageData {
+  const char* page_file;
+  const char* title;
+  Task::Type task_type;
+  int expected_prefix_message;
+};
+
+// The below test files are available in src/chrome/test/data/
+// TODO(afakhry): Add more test pages here as needed (e.g. pages that are hosted
+// in the tabs as apps or extensions).
+const TestPageData kTestPages[] = {
+    {
+        "/title1.html",
+        "",
+        Task::RENDERER,
+        IDS_TASK_MANAGER_TAB_PREFIX
+    },
+    {
+        "/title2.html",
+        "Title Of Awesomeness",
+        Task::RENDERER,
+        IDS_TASK_MANAGER_TAB_PREFIX
+    },
+    {
+        "/title3.html",
+        "Title Of More Awesomeness",
+        Task::RENDERER,
+        IDS_TASK_MANAGER_TAB_PREFIX
+    },
+};
+
+const size_t kTestPagesLength = arraysize(kTestPages);
+
+// Blocks till the current page uses a specific icon URL.
+class FaviconWaiter : public favicon::FaviconDriverObserver {
+ public:
+  explicit FaviconWaiter(favicon::ContentFaviconDriver* driver)
+      : driver_(driver) {
+    driver_->AddObserver(this);
+  }
+
+  void WaitForFaviconWithURL(const GURL& url) {
+    if (GetCurrentFaviconURL() == url) {
+      driver_->RemoveObserver(this);
+      return;
+    }
+
+    target_favicon_url_ = url;
+    base::RunLoop run_loop;
+    quit_closure_ = run_loop.QuitClosure();
+    run_loop.Run();
+  }
+
+ private:
+  GURL GetCurrentFaviconURL() {
+    const content::NavigationController& controller =
+        driver_->web_contents()->GetController();
+    content::NavigationEntry* entry = controller.GetLastCommittedEntry();
+    return entry ? entry->GetFavicon().url : GURL();
+  }
+
+  void OnFaviconUpdated(favicon::FaviconDriver* favicon_driver,
+                        NotificationIconType notification_icon_type,
+                        const GURL& icon_url,
+                        bool icon_url_changed,
+                        const gfx::Image& image) override {
+    if (notification_icon_type == NON_TOUCH_16_DIP &&
+        icon_url == target_favicon_url_) {
+      driver_->RemoveObserver(this);
+
+      if (!quit_closure_.is_null())
+        quit_closure_.Run();
+    }
+  }
+
+  favicon::ContentFaviconDriver* driver_;
+  GURL target_favicon_url_;
+  base::Closure quit_closure_;
+
+  DISALLOW_COPY_AND_ASSIGN(FaviconWaiter);
+};
+
+}  // namespace
+
+// Defines a browser test class for testing the task manager tracking of tab
+// contents.
+class TabContentsTagTest : public InProcessBrowserTest {
+ public:
+  TabContentsTagTest() { EXPECT_TRUE(embedded_test_server()->Start()); }
+  ~TabContentsTagTest() override {}
+
+  void AddNewTestTabAt(int index, const char* test_page_file) {
+    int tabs_count_before = tabs_count();
+    GURL url = GetUrlOfFile(test_page_file);
+    AddTabAtIndex(index, url, ui::PAGE_TRANSITION_TYPED);
+    EXPECT_EQ(++tabs_count_before, tabs_count());
+  }
+
+  void NavigateToUrl(const char* test_page_file) {
+    ui_test_utils::NavigateToURL(browser(), GetUrlOfFile(test_page_file));
+  }
+
+  void CloseTabAt(int index) {
+    browser()->tab_strip_model()->CloseWebContentsAt(index,
+                                                     TabStripModel::CLOSE_NONE);
+  }
+
+  base::string16 GetTestPageExpectedTitle(const TestPageData& page_data) const {
+    // Pages with no title should fall back to their URL.
+    base::string16 title = base::UTF8ToUTF16(page_data.title);
+    if (title.empty()) {
+      GURL url = GetUrlOfFile(page_data.page_file);
+      return GetDefaultTitleForUrl(url);
+    }
+    return l10n_util::GetStringFUTF16(page_data.expected_prefix_message, title);
+  }
+
+  // Returns the expected title for |url| if |url| does not specify a custom
+  // title (e.g. via the <title> tag).
+  base::string16 GetDefaultTitleForUrl(const GURL& url) const {
+    base::string16 title =
+        base::UTF8ToUTF16(url.host() + ":" + url.port() + url.path());
+    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX, title);
+  }
+
+  base::string16 GetAboutBlankExpectedTitle() const {
+    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
+                                      base::UTF8ToUTF16("about:blank"));
+  }
+
+  int tabs_count() const { return browser()->tab_strip_model()->count(); }
+
+  const std::vector<WebContentsTag*>& tracked_tags() const {
+    return WebContentsTagsManager::GetInstance()->tracked_tags();
+  }
+
+  GURL GetUrlOfFile(const char* test_page_file) const {
+    return embedded_test_server()->GetURL(test_page_file);
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TabContentsTagTest);
+};
+
+// Tests that TabContentsTags are being recorded correctly by the
+// WebContentsTagsManager.
+IN_PROC_BROWSER_TEST_F(TabContentsTagTest, BasicTagsTracking) {
+  // Browser tests start with a single tab.
+  EXPECT_EQ(1, tabs_count());
+  EXPECT_EQ(1U, tracked_tags().size());
+
+  // Add a bunch of tabs and make sure we're tracking them.
+  AddNewTestTabAt(0, kTestPages[0].page_file);
+  EXPECT_EQ(2, tabs_count());
+  EXPECT_EQ(2U, tracked_tags().size());
+
+  AddNewTestTabAt(1, kTestPages[1].page_file);
+  EXPECT_EQ(3, tabs_count());
+  EXPECT_EQ(3U, tracked_tags().size());
+
+  // Navigating the selected tab doesn't change the number of tabs nor the
+  // number of tags.
+  NavigateToUrl(kTestPages[2].page_file);
+  EXPECT_EQ(3, tabs_count());
+  EXPECT_EQ(3U, tracked_tags().size());
+
+  // Close a bunch of tabs and make sure we can notice that.
+  CloseTabAt(0);
+  CloseTabAt(0);
+  EXPECT_EQ(1, tabs_count());
+  EXPECT_EQ(1U, tracked_tags().size());
+}
+
+// Tests that the pre-task-manager-existing tabs are given to the task manager
+// once it starts observing.
+IN_PROC_BROWSER_TEST_F(TabContentsTagTest, PreExistingTaskProviding) {
+  // We start with the "about:blank" tab.
+  EXPECT_EQ(1, tabs_count());
+  EXPECT_EQ(1U, tracked_tags().size());
+
+  // Add a bunch of tabs and make sure when the task manager is created and
+  // starts observing sees those pre-existing tabs.
+  AddNewTestTabAt(0, kTestPages[0].page_file);
+  EXPECT_EQ(2, tabs_count());
+  EXPECT_EQ(2U, tracked_tags().size());
+  AddNewTestTabAt(1, kTestPages[1].page_file);
+  EXPECT_EQ(3, tabs_count());
+  EXPECT_EQ(3U, tracked_tags().size());
+
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  task_manager.StartObserving();
+  EXPECT_EQ(3U, task_manager.tasks().size());
+}
+
+// Tests that the task manager sees the correct tabs with their correct
+// corresponding tasks data.
+IN_PROC_BROWSER_TEST_F(TabContentsTagTest, PostExistingTaskProviding) {
+  // We start with the "about:blank" tab.
+  EXPECT_EQ(1, tabs_count());
+  EXPECT_EQ(1U, tracked_tags().size());
+
+  MockWebContentsTaskManager task_manager;
+  EXPECT_TRUE(task_manager.tasks().empty());
+  task_manager.StartObserving();
+  ASSERT_EQ(1U, task_manager.tasks().size());
+
+  const Task* first_tab_task = task_manager.tasks().front();
+  EXPECT_EQ(Task::RENDERER, first_tab_task->GetType());
+  EXPECT_EQ(GetAboutBlankExpectedTitle(), first_tab_task->title());
+
+  // Add the test pages in order and test the provided tasks.
+  for (const auto& test_page_data : kTestPages) {
+    AddNewTestTabAt(0, test_page_data.page_file);
+
+    const Task* task = task_manager.tasks().back();
+    EXPECT_EQ(test_page_data.task_type, task->GetType());
+    EXPECT_EQ(GetTestPageExpectedTitle(test_page_data), task->title());
+  }
+
+  EXPECT_EQ(1 + kTestPagesLength, task_manager.tasks().size());
+
+  // Close the last tab that was added. Make sure it doesn't show up in the
+  // task manager.
+  CloseTabAt(0);
+  EXPECT_EQ(kTestPagesLength, task_manager.tasks().size());
+  const base::string16 closed_tab_title =
+      GetTestPageExpectedTitle(kTestPages[kTestPagesLength - 1]);
+  for (const auto* task : task_manager.tasks())
+    EXPECT_NE(closed_tab_title, task->title());
+}
+
+// Test that the default favicon is shown in the task manager after navigating
+// from a page with a favicon to a page without a favicon. crbug.com/528924
+IN_PROC_BROWSER_TEST_F(TabContentsTagTest, NavigateToPageNoFavicon) {
+  // We start with the "about:blank" tab.
+  MockWebContentsTaskManager task_manager;
+  task_manager.StartObserving();
+  ASSERT_EQ(1, tabs_count());
+  ASSERT_EQ(1U, tracked_tags().size());
+
+  // Navigate to a page with a favicon.
+  GURL favicon_page_url = GetUrlOfFile("/favicon/page_with_favicon.html");
+  ui_test_utils::NavigateToURL(browser(), favicon_page_url);
+  ASSERT_GE(1U, task_manager.tasks().size());
+  Task* task = task_manager.tasks().back();
+  ASSERT_EQ(GetDefaultTitleForUrl(favicon_page_url), task->title());
+
+  // Wait for the browser to download the favicon.
+  favicon::ContentFaviconDriver* favicon_driver =
+      favicon::ContentFaviconDriver::FromWebContents(
+          browser()->tab_strip_model()->GetActiveWebContents());
+  FaviconWaiter waiter(favicon_driver);
+  waiter.WaitForFaviconWithURL(GetUrlOfFile("/favicon/icon.png"));
+
+  // Check that the task manager uses the specified favicon for the page.
+  base::FilePath test_dir;
+  PathService::Get(chrome::DIR_TEST_DATA, &test_dir);
+  std::string favicon_string;
+  base::ReadFileToString(
+      test_dir.AppendASCII("favicon").AppendASCII("icon.png"), &favicon_string);
+  SkBitmap favicon_bitmap;
+  gfx::PNGCodec::Decode(
+      reinterpret_cast<const unsigned char*>(favicon_string.data()),
+      favicon_string.length(), &favicon_bitmap);
+  ASSERT_TRUE(
+      gfx::test::AreBitmapsEqual(favicon_bitmap, *task->icon().bitmap()));
+
+  // Navigate to a page without a favicon.
+  GURL no_favicon_page_url = GetUrlOfFile("/title1.html");
+  ui_test_utils::NavigateToURL(browser(), no_favicon_page_url);
+  ASSERT_EQ(GetDefaultTitleForUrl(no_favicon_page_url), task->title());
+
+  // Check that the task manager uses the default favicon for the page.
+  gfx::Image default_favicon_image =
+      ResourceBundle::GetSharedInstance().GetNativeImageNamed(
+          IDR_DEFAULT_FAVICON);
+  EXPECT_TRUE(gfx::test::AreImagesEqual(default_favicon_image,
+                                        gfx::Image(task->icon())));
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/tab_contents_task.cc b/chrome/browser/task_management/providers/web_contents/tab_contents_task.cc
new file mode 100644
index 0000000..6168ac4
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/tab_contents_task.cc
@@ -0,0 +1,78 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/tab_contents_task.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/process_map.h"
+#include "extensions/common/constants.h"
+
+namespace task_management {
+
+namespace {
+
+bool HostsExtension(content::WebContents* web_contents) {
+  DCHECK(web_contents);
+  return web_contents->GetURL().SchemeIs(extensions::kExtensionScheme);
+}
+
+}  // namespace
+
+
+TabContentsTask::TabContentsTask(content::WebContents* web_contents)
+    : RendererTask(base::string16(),
+                   RendererTask::GetFaviconFromWebContents(web_contents),
+                   web_contents,
+                   web_contents->GetRenderProcessHost()) {
+  set_title(GetCurrentTitle());
+}
+
+TabContentsTask::~TabContentsTask() {
+}
+
+void TabContentsTask::UpdateTitle() {
+  set_title(GetCurrentTitle());
+}
+
+void TabContentsTask::UpdateFavicon() {
+  const gfx::ImageSkia* icon =
+      RendererTask::GetFaviconFromWebContents(web_contents());
+  set_icon(icon ? *icon : gfx::ImageSkia());
+}
+
+Task::Type TabContentsTask::GetType() const {
+  // A tab that loads an extension URL is considered to be an extension even
+  // though it's tracked as a TabContentsTask.
+  return HostsExtension(web_contents()) ? Task::EXTENSION : Task::RENDERER;
+}
+
+base::string16 TabContentsTask::GetCurrentTitle() const {
+  // Check if the URL is an app and if the tab is hoisting an extension.
+  Profile* profile =
+      Profile::FromBrowserContext(web_contents()->GetBrowserContext());
+  extensions::ProcessMap* process_map = extensions::ProcessMap::Get(profile);
+  extensions::ExtensionRegistry* extension_registry =
+      extensions::ExtensionRegistry::Get(profile);
+  GURL url = web_contents()->GetURL();
+
+  bool is_app = process_map->Contains(GetChildProcessUniqueID()) &&
+      extension_registry->enabled_extensions().GetAppByURL(url) != nullptr;
+  bool is_extension = HostsExtension(web_contents());
+  bool is_incognito = profile->IsOffTheRecord();
+
+  base::string16 tab_title =
+      RendererTask::GetTitleFromWebContents(web_contents());
+
+  // Fall back to the URL if the title is empty.
+  return PrefixRendererTitle(tab_title,
+                             is_app,
+                             is_extension,
+                             is_incognito,
+                             false);  // is_background.
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/tab_contents_task.h b/chrome/browser/task_management/providers/web_contents/tab_contents_task.h
new file mode 100644
index 0000000..6ad1d88
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/tab_contents_task.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/renderer_task.h"
+
+namespace task_management {
+
+// Defines a task manager representation of WebContents owned by the
+// TabStripModel.
+class TabContentsTask : public RendererTask {
+ public:
+  explicit TabContentsTask(content::WebContents* web_contents);
+  ~TabContentsTask() override;
+
+  // task_management::RendererTask:
+  void UpdateTitle() override;
+  void UpdateFavicon() override;
+  Type GetType() const override;
+
+ private:
+  base::string16 GetCurrentTitle() const;
+
+  DISALLOW_COPY_AND_ASSIGN(TabContentsTask);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_tag.cc b/chrome/browser/task_management/providers/web_contents/web_contents_tag.cc
new file mode 100644
index 0000000..dee861b
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_tag.cc
@@ -0,0 +1,34 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "content/public/browser/web_contents.h"
+
+namespace task_management {
+
+// static
+const WebContentsTag* WebContentsTag::FromWebContents(
+    const content::WebContents* contents) {
+  DCHECK(contents);
+  return static_cast<const WebContentsTag*>(contents->GetUserData(kTagKey));
+}
+
+WebContentsTag::WebContentsTag(content::WebContents* contents)
+    : web_contents_(contents) {
+  DCHECK(contents);
+  // You can't tag the |contents| here. The object creation is not complete yet.
+  // This will be done in the factory methods inside
+  // |task_management::WebContentsTags|.
+}
+
+WebContentsTag::~WebContentsTag() {
+  WebContentsTagsManager::GetInstance()->RemoveTag(this);
+}
+
+// static
+void* WebContentsTag::kTagKey = &WebContentsTag::kTagKey;
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_tag.h b/chrome/browser/task_management/providers/web_contents/web_contents_tag.h
new file mode 100644
index 0000000..300a20a
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_tag.h
@@ -0,0 +1,62 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
+
+#include "base/macros.h"
+#include "base/supports_user_data.h"
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+namespace task_management {
+
+class RendererTask;
+
+// Defines a TaskManager-specific UserData type for WebContents. This is an
+// abstract base class for all concrete UserData types. They all share the same
+// key. We have a concrete type for each WebContents owning service that the
+// task manager is interested in tracking.
+//
+// To instantiate a |WebContentsTag|, use the factory functions in
+// |task_management::WebContentsTags|.
+class WebContentsTag : public base::SupportsUserData::Data {
+ public:
+  // Retrieves the instance of the WebContentsTag that was attached to the
+  // specified WebContents and returns it. If no instance was attached, returns
+  // nullptr.
+  static const WebContentsTag* FromWebContents(
+      const content::WebContents* contents);
+
+  // The concrete Tags know how to instantiate a |RendererTask| that corresponds
+  // to the owning WebContents and Service. This will be used by the
+  // WebContentsTaskProvider to create the appropriate Tasks.
+  //
+  // The returned |RendererTask| is owned by the caller (in this case it will be
+  // the provider).
+  virtual RendererTask* CreateTask() const = 0;
+
+  content::WebContents* web_contents() const { return web_contents_; }
+
+ protected:
+  friend class WebContentsTags;
+
+  explicit WebContentsTag(content::WebContents* contents);
+  ~WebContentsTag() override;
+
+ private:
+  // The user data key.
+  static void* kTagKey;
+
+  // The owning WebContents.
+  content::WebContents* web_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsTag);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.cc b/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.cc
new file mode 100644
index 0000000..96800d9
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.cc
@@ -0,0 +1,66 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+
+#include <algorithm>
+
+#include "base/memory/singleton.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h"
+
+namespace task_management {
+
+// static
+WebContentsTagsManager* WebContentsTagsManager::GetInstance() {
+  return base::Singleton<WebContentsTagsManager>::get();
+}
+
+void WebContentsTagsManager::AddTag(WebContentsTag* tag) {
+  DCHECK(tag);
+  tracked_tags_.push_back(tag);
+
+  if (provider_)
+    provider_->OnWebContentsTagCreated(tag);
+}
+
+void WebContentsTagsManager::RemoveTag(WebContentsTag* tag) {
+  DCHECK(tag);
+  tracked_tags_.erase(std::find(tracked_tags_.begin(),
+                                tracked_tags_.end(),
+                                tag));
+
+  // No need to inform the provider here. The provider will create an entry
+  // for each WebContents it's tracking which is a WebContentsObserver and
+  // can be used to track the lifetime of the WebContents.
+
+  // We must however make sure that the provider has already forgotten about the
+  // tag and its associated web_contents.
+  if (provider_)
+    CHECK(!provider_->HasWebContents(tag->web_contents()));
+}
+
+void WebContentsTagsManager::SetProvider(WebContentsTaskProvider* provider) {
+  DCHECK(provider);
+  DCHECK(!provider_);
+  provider_ = provider;
+}
+
+void WebContentsTagsManager::ClearProvider() {
+  DCHECK(provider_);
+  provider_ = nullptr;
+}
+
+void WebContentsTagsManager::ClearFromProvider(const WebContentsTag* tag) {
+  if (provider_)
+    provider_->OnWebContentsTagRemoved(tag);
+}
+
+WebContentsTagsManager::WebContentsTagsManager()
+    : provider_(nullptr) {
+}
+
+WebContentsTagsManager::~WebContentsTagsManager() {
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h b/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h
new file mode 100644
index 0000000..89276d1
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h
@@ -0,0 +1,67 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
+
+#include <vector>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tag.h"
+
+namespace base {
+template<typename T>
+struct DefaultSingletonTraits;
+}  // namespace base
+
+namespace task_management {
+
+class WebContentsTaskProvider;
+
+// Defines a manager to track the various TaskManager-specific WebContents
+// UserData (task_management::WebContentsTags). This is used by the
+// WebContentsTaskProvider to get all the pre-existing WebContents once
+// WebContentsTaskProvider::StartUpdating() is called.
+class WebContentsTagsManager {
+ public:
+  static WebContentsTagsManager* GetInstance();
+
+  void AddTag(WebContentsTag* tag);
+  void RemoveTag(WebContentsTag* tag);
+
+  // This is how the WebContentsTaskProvider starts and stops observing the
+  // creation of WebContents.
+  // There must be no or only one given provider at any given time.
+  void SetProvider(WebContentsTaskProvider* provider);
+  void ClearProvider();
+
+  // This is called by WebContentsTags::ClearTag(). This is needed for Tags
+  // whose destruction does not correspond to the destruction of their
+  // WebContents. In this case the provider (if any) must be manually cleared,
+  // or else the corresponding task for the |tag| will continue to exist.
+  void ClearFromProvider(const WebContentsTag* tag);
+
+  const std::vector<WebContentsTag*>& tracked_tags() const {
+    return tracked_tags_;
+  }
+
+ private:
+  friend struct base::DefaultSingletonTraits<WebContentsTagsManager>;
+
+  WebContentsTagsManager();
+  ~WebContentsTagsManager();
+
+  // The provider that's currently observing the creation of WebContents.
+  WebContentsTaskProvider* provider_;
+
+  // A set of all the WebContentsTags seen so far.
+  std::vector<WebContentsTag*> tracked_tags_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsTagsManager);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc
new file mode 100644
index 0000000..b206752
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.cc
@@ -0,0 +1,385 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h"
+
+#include "base/bind.h"
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/web_contents/subframe_task.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_contents_observer.h"
+
+using content::RenderFrameHost;
+using content::RenderWidgetHost;
+using content::SiteInstance;
+using content::WebContents;
+
+namespace task_management {
+
+// Defines an entry for each WebContents that will be tracked by the provider.
+// The entry is used to observe certain events in its corresponding WebContents
+// and then it notifies the provider or the render task (representing the
+// WebContents) of these events.
+// The entry owns the created tasks representing the WebContents, and it is
+// itself owned by the provider.
+class WebContentsEntry : public content::WebContentsObserver {
+ public:
+  WebContentsEntry(content::WebContents* web_contents,
+                   WebContentsTaskProvider* provider);
+  ~WebContentsEntry() override;
+
+  // Creates all the tasks associated with each |RenderFrameHost| in this
+  // entry's WebContents.
+  void CreateAllTasks();
+
+  // Clears all the tasks in this entry. The provider's observer will be
+  // notified if |notify_observer| is true.
+  void ClearAllTasks(bool notify_observer);
+
+  // Returns the |RendererTask| that corresponds to the given
+  // |render_frame_host| or |nullptr| if the given frame is not tracked by this
+  // entry.
+  RendererTask* GetTaskForFrame(RenderFrameHost* render_frame_host) const;
+
+  // content::WebContentsObserver:
+  void RenderFrameDeleted(RenderFrameHost* render_frame_host) override;
+  void RenderFrameHostChanged(RenderFrameHost* old_host,
+                              RenderFrameHost* new_host) override;
+  void RenderViewReady() override;
+  void WebContentsDestroyed() override;
+  void RenderProcessGone(base::TerminationStatus status) override;
+  void OnRendererUnresponsive(RenderWidgetHost* render_widget_host) override;
+  void DidFinishNavigation(
+      content::NavigationHandle* navigation_handle) override;
+  void TitleWasSet(content::NavigationEntry* entry, bool explicit_set) override;
+
+ private:
+  // Defines a callback for WebContents::ForEachFrame() to create a
+  // corresponding task for the given |render_frame_host| and notifying the
+  // provider's observer of the new task.
+  void CreateTaskForFrame(RenderFrameHost* render_frame_host);
+
+  // Clears the task that corresponds to the given |render_frame_host| and
+  // notifies the provider's observer of the tasks removal.
+  void ClearTaskForFrame(RenderFrameHost* render_frame_host);
+
+  // The provider that owns this entry.
+  WebContentsTaskProvider* provider_;
+
+  // The RenderFrameHosts associated with this entry's WebContents that we're
+  // tracking mapped by their SiteInstances.
+  using FramesList = std::vector<RenderFrameHost*>;
+  using SiteInstanceToFramesMap = std::map<SiteInstance*, FramesList>;
+  SiteInstanceToFramesMap frames_by_site_instance_;
+
+  // The RendererTasks that we create for the task manager, mapped by their
+  // RenderFrameHosts.
+  using FramesToTasksMap = std::map<RenderFrameHost*, RendererTask*>;
+  FramesToTasksMap tasks_by_frames_;
+
+  // States whether we did record a main frame for this entry.
+  SiteInstance* main_frame_site_instance_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsEntry);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+WebContentsEntry::WebContentsEntry(content::WebContents* web_contents,
+                                   WebContentsTaskProvider* provider)
+    : WebContentsObserver(web_contents),
+      provider_(provider),
+      main_frame_site_instance_(nullptr) {
+}
+
+WebContentsEntry::~WebContentsEntry() {
+  ClearAllTasks(false);
+}
+
+void WebContentsEntry::CreateAllTasks() {
+  DCHECK(web_contents()->GetMainFrame());
+  web_contents()->ForEachFrame(base::Bind(&WebContentsEntry::CreateTaskForFrame,
+                                          base::Unretained(this)));
+}
+
+void WebContentsEntry::ClearAllTasks(bool notify_observer) {
+  for (const auto& pair : frames_by_site_instance_) {
+    const FramesList& frames_list = pair.second;
+    DCHECK(!frames_list.empty());
+    RendererTask* task = tasks_by_frames_[frames_list[0]];
+
+    task->set_termination_status(web_contents()->GetCrashedStatus());
+    task->set_termination_error_code(web_contents()->GetCrashedErrorCode());
+
+    if (notify_observer)
+      provider_->NotifyObserverTaskRemoved(task);
+    delete task;
+  }
+
+  frames_by_site_instance_.clear();
+  tasks_by_frames_.clear();
+  main_frame_site_instance_ = nullptr;
+}
+
+RendererTask* WebContentsEntry::GetTaskForFrame(
+    RenderFrameHost* render_frame_host) const {
+  auto itr = tasks_by_frames_.find(render_frame_host);
+  if (itr == tasks_by_frames_.end())
+    return nullptr;
+
+  return itr->second;
+}
+
+void WebContentsEntry::RenderFrameDeleted(RenderFrameHost* render_frame_host) {
+  ClearTaskForFrame(render_frame_host);
+}
+
+void WebContentsEntry::RenderFrameHostChanged(RenderFrameHost* old_host,
+                                              RenderFrameHost* new_host) {
+  ClearTaskForFrame(old_host);
+  CreateTaskForFrame(new_host);
+}
+
+void WebContentsEntry::RenderViewReady() {
+  ClearAllTasks(true);
+  CreateAllTasks();
+}
+
+void WebContentsEntry::WebContentsDestroyed() {
+  ClearAllTasks(true);
+  provider_->DeleteEntry(web_contents());
+}
+
+void WebContentsEntry::RenderProcessGone(base::TerminationStatus status) {
+  ClearAllTasks(true);
+}
+
+void WebContentsEntry::OnRendererUnresponsive(
+    RenderWidgetHost* render_widget_host) {
+  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
+  if (!task)
+    return;
+
+  DCHECK_EQ(render_widget_host->GetProcess(),
+            web_contents()->GetMainFrame()->GetProcess());
+
+  provider_->NotifyObserverTaskUnresponsive(task);
+}
+
+void WebContentsEntry::DidFinishNavigation(
+    content::NavigationHandle* navigation_handle) {
+  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
+  if (!task)
+    return;
+
+  // Listening to WebContentsObserver::TitleWasSet() only is not enough in
+  // some cases when the the webpage doesn't have a title. That's why we update
+  // the title here as well.
+  task->UpdateTitle();
+
+  // Call RendererTask::UpdateFavicon() to set the current favicon to the
+  // default favicon. If the page has a non-default favicon,
+  // RendererTask::OnFaviconUpdated() will update the current favicon once
+  // FaviconDriver figures out the correct favicon for the page.
+  task->UpdateFavicon();
+  task->UpdateRapporSampleName();
+}
+
+void WebContentsEntry::TitleWasSet(content::NavigationEntry* entry,
+                                   bool explicit_set) {
+  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
+  if (!task)
+    return;
+
+  task->UpdateTitle();
+  task->UpdateFavicon();
+}
+
+void WebContentsEntry::CreateTaskForFrame(RenderFrameHost* render_frame_host) {
+  DCHECK(!tasks_by_frames_.count(render_frame_host));
+
+  content::SiteInstance* site_instance = render_frame_host->GetSiteInstance();
+  if (!site_instance->GetProcess()->HasConnection())
+    return;
+
+  bool site_instance_exists =
+      frames_by_site_instance_.count(site_instance) != 0;
+  bool is_main_frame = (render_frame_host == web_contents()->GetMainFrame());
+  bool site_instance_is_main = (site_instance == main_frame_site_instance_);
+
+  RendererTask* new_task = nullptr;
+  // We don't create a task if there's one for this site_instance AND
+  // if this is not the main frame or we did record a main frame for the entry.
+  if (!site_instance_exists || (is_main_frame && !site_instance_is_main)) {
+    if (is_main_frame) {
+      const WebContentsTag* tag =
+          WebContentsTag::FromWebContents(web_contents());
+      new_task = tag->CreateTask();
+      main_frame_site_instance_ = site_instance;
+    } else {
+      new_task =
+          new SubframeTask(render_frame_host, web_contents(),
+                           GetTaskForFrame(web_contents()->GetMainFrame()));
+    }
+  }
+
+  if (site_instance_exists) {
+    // One of the existing frame hosts for this site instance.
+    FramesList& existing_frames_for_site_instance =
+        frames_by_site_instance_[site_instance];
+    RenderFrameHost* existing_rfh = existing_frames_for_site_instance[0];
+    RendererTask* old_task = tasks_by_frames_[existing_rfh];
+
+    if (!new_task) {
+      // We didn't create any new task, so we keep appending the old one.
+      tasks_by_frames_[render_frame_host] = old_task;
+    } else {
+      // Overwrite all the existing old tasks with the new one, and delete the
+      // old one.
+      for (RenderFrameHost* frame : existing_frames_for_site_instance)
+        tasks_by_frames_[frame] = new_task;
+
+      provider_->NotifyObserverTaskRemoved(old_task);
+      delete old_task;
+    }
+  }
+
+  frames_by_site_instance_[site_instance].push_back(render_frame_host);
+
+  if (new_task) {
+    tasks_by_frames_[render_frame_host] = new_task;
+    provider_->NotifyObserverTaskAdded(new_task);
+  }
+}
+
+void WebContentsEntry::ClearTaskForFrame(RenderFrameHost* render_frame_host) {
+  auto itr = tasks_by_frames_.find(render_frame_host);
+  if (itr == tasks_by_frames_.end())
+    return;
+
+  RendererTask* task = itr->second;
+  tasks_by_frames_.erase(itr);
+  content::SiteInstance* site_instance = render_frame_host->GetSiteInstance();
+  FramesList& frames = frames_by_site_instance_[site_instance];
+  frames.erase(std::find(frames.begin(), frames.end(), render_frame_host));
+
+  if (frames.empty()) {
+    frames_by_site_instance_.erase(site_instance);
+    provider_->NotifyObserverTaskRemoved(task);
+    delete task;
+
+    if (site_instance == main_frame_site_instance_)
+      main_frame_site_instance_ = nullptr;
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+WebContentsTaskProvider::WebContentsTaskProvider()
+    : is_updating_(false) {
+}
+
+WebContentsTaskProvider::~WebContentsTaskProvider() {
+  if (is_updating_) {
+    StopUpdating();
+  }
+}
+
+void WebContentsTaskProvider::OnWebContentsTagCreated(
+    const WebContentsTag* tag) {
+  DCHECK(tag);
+  content::WebContents* web_contents = tag->web_contents();
+  DCHECK(web_contents);
+
+  // TODO(afakhry): Check if we need this check. It seems that we no longer
+  // need it in the new implementation.
+  std::unique_ptr<WebContentsEntry>& entry = entries_map_[web_contents];
+  if (entry) {
+    // This case may happen if we added a WebContents while collecting all the
+    // pre-existing ones at the time |StartUpdating()| was called, but the
+    // notification of its connection hasn't been fired yet. In this case we
+    // ignore it since we're already tracking it.
+    return;
+  }
+
+  entry.reset(new WebContentsEntry(web_contents, this));
+  entry->CreateAllTasks();
+}
+
+void WebContentsTaskProvider::OnWebContentsTagRemoved(
+    const WebContentsTag* tag) {
+  DCHECK(tag);
+  content::WebContents* web_contents = tag->web_contents();
+  DCHECK(web_contents);
+
+  auto itr = entries_map_.find(web_contents);
+  DCHECK(itr != entries_map_.end());
+
+  // Must manually clear the tasks and notify the observer.
+  itr->second->ClearAllTasks(true);
+  entries_map_.erase(itr);  // Deletes the WebContentsEntry.
+}
+
+Task* WebContentsTaskProvider::GetTaskOfUrlRequest(int origin_pid,
+                                                   int child_id,
+                                                   int route_id) {
+  // If an origin PID was specified then the URL request originated in a plugin
+  // working on the WebContents' behalf, so ignore it.
+  if (origin_pid)
+    return nullptr;
+
+  content::RenderFrameHost* rfh =
+      content::RenderFrameHost::FromID(child_id, route_id);
+  content::WebContents* web_contents =
+      content::WebContents::FromRenderFrameHost(rfh);
+
+  auto itr = entries_map_.find(web_contents);
+  if (itr == entries_map_.end()) {
+    // Can happen if the tab was closed while a network request was being
+    // performed.
+    return nullptr;
+  }
+
+  return itr->second->GetTaskForFrame(rfh);
+}
+
+bool WebContentsTaskProvider::HasWebContents(
+    content::WebContents* web_contents) const {
+  return entries_map_.count(web_contents) != 0;
+}
+
+void WebContentsTaskProvider::StartUpdating() {
+  is_updating_ = true;
+
+  // 1- Collect all pre-existing WebContents from the WebContentsTagsManager.
+  WebContentsTagsManager* tags_manager = WebContentsTagsManager::GetInstance();
+  for (const auto* tag : tags_manager->tracked_tags())
+    OnWebContentsTagCreated(tag);
+
+  // 2- Start observing newly connected ones.
+  tags_manager->SetProvider(this);
+}
+
+void WebContentsTaskProvider::StopUpdating() {
+  is_updating_ = false;
+
+  // 1- Stop observing.
+  WebContentsTagsManager::GetInstance()->ClearProvider();
+
+  // 2- Clear storage.
+  entries_map_.clear();
+}
+
+void WebContentsTaskProvider::DeleteEntry(content::WebContents* web_contents) {
+  // This erase() will delete the WebContentsEntry, which is actually our
+  // caller, but it's expecting us to delete it.
+  bool success = entries_map_.erase(web_contents) != 0;
+  DCHECK(success);
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h
new file mode 100644
index 0000000..40251c1
--- /dev/null
+++ b/chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h
@@ -0,0 +1,71 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
+
+#include <map>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/providers/task_provider.h"
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+
+namespace task_management {
+
+class WebContentsEntry;
+class WebContentsTag;
+
+// Defines a provider to provide the renderer tasks that are associated with
+// various |WebContents| from various services.
+// There should be no or only one instance of this class at any time.
+class WebContentsTaskProvider : public TaskProvider {
+ public:
+  WebContentsTaskProvider();
+  ~WebContentsTaskProvider() override;
+
+  // This will be called every time we're notified that a new |WebContentsTag|
+  // has been created.
+  void OnWebContentsTagCreated(const WebContentsTag* tag);
+
+  // Manually remove |tag|'s corresponding Task.
+  void OnWebContentsTagRemoved(const WebContentsTag* tag);
+
+  // task_management::TaskProvider:
+  Task* GetTaskOfUrlRequest(int origin_pid,
+                            int child_id,
+                            int route_id) override;
+
+  // Checks if the given |web_contents| is tracked by the provider.
+  bool HasWebContents(content::WebContents* web_contents) const;
+
+ private:
+  friend class WebContentsEntry;
+
+  // task_management::TaskProvider:
+  void StartUpdating() override;
+  void StopUpdating() override;
+
+  // Called when the given |web_contents| are destroyed so that we can delete
+  // its associated entry.
+  void DeleteEntry(content::WebContents* web_contents);
+
+  // A map to associate a |WebContents| with its corresponding entry that we
+  // create for it to be able to track it.
+  std::map<content::WebContents*, std::unique_ptr<WebContentsEntry>>
+      entries_map_;
+
+  // True if this provider is listening to WebContentsTags and updating its
+  // observers, false otherwise.
+  bool is_updating_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsTaskProvider);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_management/sampling/shared_sampler.h b/chrome/browser/task_management/sampling/shared_sampler.h
new file mode 100644
index 0000000..5210ef8
--- /dev/null
+++ b/chrome/browser/task_management/sampling/shared_sampler.h
@@ -0,0 +1,144 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_SHARED_SAMPLER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_SHARED_SAMPLER_H_
+
+#include <map>
+#include <memory>
+#include <utility>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/process/process_handle.h"
+#include "base/sequence_checker.h"
+#include "base/sequenced_task_runner.h"
+#include "build/build_config.h"
+
+namespace task_management {
+
+struct ProcessDataSnapshot;
+
+// Defines sampler that will calculate resources for all processes all at once,
+// on the worker thread. Created by TaskManagerImpl on the UI thread, but used
+// mainly on a blocking pool thread.
+//
+// This exists because on Windows it is much faster to collect a group of
+// process metrics for all processes all at once using NtQuerySystemInformation
+// than to query the same data for for each process individually and because
+// some types like Idle Wakeups can only be collected this way.
+class SharedSampler : public base::RefCountedThreadSafe<SharedSampler> {
+ public:
+  explicit SharedSampler(
+      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner);
+
+  // Below are the types of callbacks that are invoked on the UI thread
+  // when the refresh is done on the worker thread.
+  // These callbacks are passed via RegisterCallbacks.
+  using OnIdleWakeupsCallback = base::Callback<void(int)>;
+
+  // Returns a combination of refresh flags supported by the shared sampler.
+  int64_t GetSupportedFlags() const;
+
+  // Registers task group specific callbacks.
+  void RegisterCallbacks(base::ProcessId process_id,
+                         const OnIdleWakeupsCallback& on_idle_wakeups);
+
+  // Unregisters task group specific callbacks.
+  void UnregisterCallbacks(base::ProcessId process_id);
+
+  // Refreshes the expensive process' stats (for now only idle wakeups per
+  // second) on the worker thread.
+  void Refresh(base::ProcessId process_id, int64_t refresh_flags);
+
+ private:
+  friend class base::RefCountedThreadSafe<SharedSampler>;
+  ~SharedSampler();
+
+#if defined(OS_WIN)
+  // The UI-thread callbacks in TaskGroup registered with RegisterCallbacks and
+  // to be called when refresh on the worker thread is done.
+  struct Callbacks {
+    Callbacks();
+    Callbacks(Callbacks&& other);
+    ~Callbacks();
+
+    OnIdleWakeupsCallback on_idle_wakeups;
+
+   private:
+    DISALLOW_COPY_AND_ASSIGN(Callbacks);
+  };
+
+  typedef std::map<base::ProcessId, Callbacks> CallbacksMap;
+
+  // Contains all results of refresh for a single process.
+  struct RefreshResult {
+    base::ProcessId process_id;
+    int idle_wakeups_per_second;
+  };
+
+  typedef std::vector<RefreshResult> RefreshResults;
+
+  // Posted on the worker thread to do the actual refresh.
+  std::unique_ptr<RefreshResults> RefreshOnWorkerThread();
+
+  // Called on UI thread when the refresh is done.
+  void OnRefreshDone(std::unique_ptr<RefreshResults> refresh_results);
+
+  // Clear cached data.
+  void ClearState();
+
+  // Used to filter process information.
+  static std::vector<base::FilePath> GetSupportedImageNames();
+  bool IsSupportedImageName(base::FilePath::StringPieceType image_name) const;
+
+  // Captures a snapshot of data for all chrome processes.
+  // Runs on the worker thread.
+  std::unique_ptr<ProcessDataSnapshot> CaptureSnapshot();
+
+  // Produce refresh results by diffing two snapshots.
+  static void MakeResultsFromTwoSnapshots(
+      const ProcessDataSnapshot& prev_snapshot,
+      const ProcessDataSnapshot& snapshot,
+      RefreshResults* results);
+
+  // Produce refresh results from one snapshot.
+  // This is used only the first time when only one snapshot is available.
+  static void MakeResultsFromSnapshot(
+      const ProcessDataSnapshot& snapshot,
+      RefreshResults* results);
+
+  // Accumulates callbacks passed from TaskGroup objects passed via
+  // RegisterCallbacks calls.
+  CallbacksMap callbacks_map_;
+
+  // Refresh flags passed via Refresh.
+  int64_t refresh_flags_;
+
+  // Snapshot of previously captured resources used to calculate the delta.
+  std::unique_ptr<ProcessDataSnapshot> previous_snapshot_;
+
+  // Size of the buffer previously used to query system information.
+  size_t previous_buffer_size_;
+
+  // Image names that CaptureSnapshot uses to filter processes.
+  const std::vector<base::FilePath> supported_image_names_;
+
+  // The specific blocking pool SequencedTaskRunner that will be used to post
+  // the refresh tasks onto serially.
+  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
+
+  // To assert we're running on the correct thread.
+  base::SequenceChecker worker_pool_sequenced_checker_;
+#endif  // defined(OS_WIN)
+
+  DISALLOW_COPY_AND_ASSIGN(SharedSampler);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_SHARED_SAMPLER_H_
diff --git a/chrome/browser/task_management/sampling/shared_sampler_posix.cc b/chrome/browser/task_management/sampling/shared_sampler_posix.cc
new file mode 100644
index 0000000..a159d7e
--- /dev/null
+++ b/chrome/browser/task_management/sampling/shared_sampler_posix.cc
@@ -0,0 +1,27 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/shared_sampler.h"
+
+#include "content/public/browser/browser_thread.h"
+
+namespace task_management {
+
+SharedSampler::SharedSampler(
+    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner) {}
+
+SharedSampler::~SharedSampler() {}
+
+int64_t SharedSampler::GetSupportedFlags() const { return 0; }
+
+void SharedSampler::RegisterCallbacks(
+    base::ProcessId process_id,
+    const OnIdleWakeupsCallback& on_idle_wakeups) {}
+
+void SharedSampler::UnregisterCallbacks(base::ProcessId process_id) {}
+
+void SharedSampler::Refresh(base::ProcessId process_id,
+                             int64_t refresh_flags) {}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/shared_sampler_win.cc b/chrome/browser/task_management/sampling/shared_sampler_win.cc
new file mode 100644
index 0000000..6ed9b06
--- /dev/null
+++ b/chrome/browser/task_management/sampling/shared_sampler_win.cc
@@ -0,0 +1,618 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/shared_sampler.h"
+
+#include <windows.h>
+#include <winternl.h>
+
+#include <algorithm>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/path_service.h"
+#include "base/time/time.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "chrome/common/chrome_constants.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace task_management {
+
+namespace {
+
+// From <wdm.h>
+typedef LONG KPRIORITY;
+typedef LONG KWAIT_REASON;  // Full definition is in wdm.h
+
+// From ntddk.h
+typedef struct _VM_COUNTERS {
+  SIZE_T PeakVirtualSize;
+  SIZE_T VirtualSize;
+  ULONG PageFaultCount;
+  // Padding here in 64-bit
+  SIZE_T PeakWorkingSetSize;
+  SIZE_T WorkingSetSize;
+  SIZE_T QuotaPeakPagedPoolUsage;
+  SIZE_T QuotaPagedPoolUsage;
+  SIZE_T QuotaPeakNonPagedPoolUsage;
+  SIZE_T QuotaNonPagedPoolUsage;
+  SIZE_T PagefileUsage;
+  SIZE_T PeakPagefileUsage;
+} VM_COUNTERS;
+
+// Two possibilities available from here:
+// http://stackoverflow.com/questions/28858849/where-is-system-information-class-defined
+
+typedef enum _SYSTEM_INFORMATION_CLASS {
+  SystemProcessInformation = 5,  // This is the number that we need.
+} SYSTEM_INFORMATION_CLASS;
+
+// https://msdn.microsoft.com/en-us/library/gg750647.aspx?f=255&MSPPError=-2147217396
+typedef struct {
+  HANDLE UniqueProcess;  // Actually process ID
+  HANDLE UniqueThread;   // Actually thread ID
+} CLIENT_ID;
+
+// From http://alax.info/blog/1182, with corrections and modifications
+// Originally from
+// http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FStructures%2FSYSTEM_THREAD.html
+struct SYSTEM_THREAD_INFORMATION {
+  ULONGLONG KernelTime;
+  ULONGLONG UserTime;
+  ULONGLONG CreateTime;
+  ULONG WaitTime;
+  // Padding here in 64-bit
+  PVOID StartAddress;
+  CLIENT_ID ClientId;
+  KPRIORITY Priority;
+  LONG BasePriority;
+  ULONG ContextSwitchCount;
+  ULONG State;
+  KWAIT_REASON WaitReason;
+};
+#if _M_X64
+static_assert(sizeof(SYSTEM_THREAD_INFORMATION) == 80,
+              "Structure size mismatch");
+#else
+static_assert(sizeof(SYSTEM_THREAD_INFORMATION) == 64,
+              "Structure size mismatch");
+#endif
+
+// From http://alax.info/blog/1182, with corrections and modifications
+// Originally from
+// http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FStructures%2FSYSTEM_THREAD.html
+struct SYSTEM_PROCESS_INFORMATION {
+  ULONG NextEntryOffset;
+  ULONG NumberOfThreads;
+  // http://processhacker.sourceforge.net/doc/struct___s_y_s_t_e_m___p_r_o_c_e_s_s___i_n_f_o_r_m_a_t_i_o_n.html
+  ULONGLONG WorkingSetPrivateSize;
+  ULONG HardFaultCount;
+  ULONG Reserved1;
+  ULONGLONG CycleTime;
+  ULONGLONG CreateTime;
+  ULONGLONG UserTime;
+  ULONGLONG KernelTime;
+  UNICODE_STRING ImageName;
+  KPRIORITY BasePriority;
+  HANDLE ProcessId;
+  HANDLE ParentProcessId;
+  ULONG HandleCount;
+  ULONG Reserved2[2];
+  // Padding here in 64-bit
+  VM_COUNTERS VirtualMemoryCounters;
+  size_t Reserved3;
+  IO_COUNTERS IoCounters;
+  SYSTEM_THREAD_INFORMATION Threads[1];
+};
+#if _M_X64
+static_assert(sizeof(SYSTEM_PROCESS_INFORMATION) == 336,
+              "Structure size mismatch");
+#else
+static_assert(sizeof(SYSTEM_PROCESS_INFORMATION) == 248,
+              "Structure size mismatch");
+#endif
+
+// ntstatus.h conflicts with windows.h so define this locally.
+#define STATUS_SUCCESS              ((NTSTATUS)0x00000000L)
+#define STATUS_BUFFER_TOO_SMALL     ((NTSTATUS)0xC0000023L)
+#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
+
+// Simple memory buffer wrapper for passing the data out of
+// QuerySystemProcessInformation.
+class ByteBuffer {
+ public:
+  explicit ByteBuffer(size_t capacity)
+      : size_(0), capacity_(0) {
+    if (capacity > 0)
+      grow(capacity);
+  }
+
+  ~ByteBuffer() {}
+
+  BYTE* data() { return data_.get(); }
+
+  size_t size() { return size_; }
+
+  void set_size(size_t new_size) {
+    DCHECK_LE(new_size, capacity_);
+    size_ = new_size;
+  }
+
+  size_t capacity() { return capacity_; }
+
+  void grow(size_t new_capacity) {
+    DCHECK_GT(new_capacity, capacity_);
+    capacity_ = new_capacity;
+    data_.reset(new BYTE[new_capacity]);
+  }
+
+ private:
+  std::unique_ptr<BYTE[]> data_;
+  size_t size_;
+  size_t capacity_;
+
+  DISALLOW_COPY_AND_ASSIGN(ByteBuffer);
+};
+
+// Wrapper for NtQuerySystemProcessInformation with buffer reallocation logic.
+bool QuerySystemProcessInformation(ByteBuffer* buffer) {
+  typedef NTSTATUS(WINAPI * NTQUERYSYSTEMINFORMATION)(
+      SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation,
+      ULONG SystemInformationLength, PULONG ReturnLength);
+
+  HMODULE ntdll = ::GetModuleHandle(L"ntdll.dll");
+  if (!ntdll) {
+    NOTREACHED();
+    return false;
+  }
+
+  NTQUERYSYSTEMINFORMATION nt_query_system_information_ptr =
+      reinterpret_cast<NTQUERYSYSTEMINFORMATION>(
+          ::GetProcAddress(ntdll, "NtQuerySystemInformation"));
+  if (!nt_query_system_information_ptr) {
+    NOTREACHED();
+    return false;
+  }
+
+  NTSTATUS result;
+
+  // There is a potential race condition between growing the buffer and new
+  // processes being created. Try a few times before giving up.
+  for (int i = 0; i < 10; i++) {
+    ULONG data_size = 0;
+    ULONG buffer_size = static_cast<ULONG>(buffer->capacity());
+    result = nt_query_system_information_ptr(
+        SystemProcessInformation,
+        buffer->data(), buffer_size, &data_size);
+
+    if (result == STATUS_SUCCESS) {
+      buffer->set_size(data_size);
+      break;
+    }
+
+    if (result == STATUS_INFO_LENGTH_MISMATCH ||
+        result == STATUS_BUFFER_TOO_SMALL) {
+      // Insufficient buffer. Grow to the returned |data_size| plus 10% extra
+      // to avoid frequent reallocations and try again.
+      DCHECK_GT(data_size, buffer_size);
+      buffer->grow(static_cast<ULONG>(data_size * 1.1));
+    } else {
+      // An error other than the two above.
+      break;
+    }
+  }
+
+  return result == STATUS_SUCCESS;
+}
+
+// Per-thread data extracted from SYSTEM_THREAD_INFORMATION and stored in a
+// snapshot. This structure is accessed only on the worker thread.
+struct ThreadData {
+  base::PlatformThreadId thread_id;
+  ULONG context_switches;
+};
+
+// Per-process data extracted from SYSTEM_PROCESS_INFORMATION and stored in a
+// snapshot. This structure is accessed only on the worker thread.
+struct ProcessData {
+  ProcessData() = default;
+  ProcessData(ProcessData&&) = default;
+
+  std::vector<ThreadData> threads;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ProcessData);
+};
+
+typedef std::map<base::ProcessId, ProcessData> ProcessDataMap;
+
+ULONG CountContextSwitchesDelta(const ProcessData& prev_process_data,
+  const ProcessData& new_process_data) {
+  // This one pass algorithm relies on the threads vectors to be
+  // ordered by thread_id.
+  ULONG delta = 0;
+  size_t prev_index = 0;
+
+  for (const auto& new_thread : new_process_data.threads) {
+    ULONG prev_thread_context_switches = 0;
+
+    // Iterate over the process threads from the previous snapshot skipping
+    // threads that don't exist anymore. Please note that this iteration starts
+    // from the last known prev_index and goes until a previous snapshot's
+    // thread ID >= the current snapshot's thread ID. So the overall algorithm
+    // is linear.
+    for (; prev_index < prev_process_data.threads.size(); ++prev_index) {
+      const auto& prev_thread = prev_process_data.threads[prev_index];
+      if (prev_thread.thread_id == new_thread.thread_id) {
+        // Threads match between two snapshots. Use the previous snapshot
+        // thread's context_switches to subtract from the delta.
+        prev_thread_context_switches = prev_thread.context_switches;
+        ++prev_index;
+        break;
+      }
+
+      if (prev_thread.thread_id > new_thread.thread_id) {
+        // This is due to a new thread that didn't exist in the previous
+        // snapshot. Keep the zero value of |prev_thread_context_switches| which
+        // essentially means the entire number of context switches of the new
+        // thread will be added to the delta.
+        break;
+      }
+    }
+
+    delta += new_thread.context_switches - prev_thread_context_switches;
+  }
+
+  return delta;
+}
+
+// Seeks a matching ProcessData by Process ID in a previous snapshot.
+// This uses the fact that ProcessDataMap entries are ordered by Process ID.
+const ProcessData* SeekInPreviousSnapshot(
+  base::ProcessId process_id, ProcessDataMap::const_iterator* iter_to_advance,
+  const ProcessDataMap::const_iterator& range_end) {
+  for (; *iter_to_advance != range_end; ++(*iter_to_advance)) {
+    if ((*iter_to_advance)->first == process_id) {
+      return &((*iter_to_advance)++)->second;
+    }
+    if ((*iter_to_advance)->first > process_id)
+      break;
+  }
+
+  return nullptr;
+}
+
+}  // namespace
+
+// ProcessDataSnapshot gets created and accessed only on the worker thread.
+// This is used to calculate metrics like Idle Wakeups / sec that require
+// a delta between two snapshots.
+// Please note that ProcessDataSnapshot has to be outside of anonymous namespace
+// in order to match the declaration in shared_sampler.h.
+struct ProcessDataSnapshot {
+  ProcessDataMap processes;
+  base::TimeTicks timestamp;
+};
+
+SharedSampler::SharedSampler(
+    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner)
+    : refresh_flags_(0), previous_buffer_size_(0),
+      supported_image_names_(GetSupportedImageNames()),
+      blocking_pool_runner_(blocking_pool_runner) {
+  DCHECK(blocking_pool_runner.get());
+
+  // This object will be created on the UI thread, however the sequenced checker
+  // will be used to assert we're running the expensive operations on one of the
+  // blocking pool threads.
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  worker_pool_sequenced_checker_.DetachFromSequence();
+}
+
+SharedSampler::~SharedSampler() {}
+
+int64_t SharedSampler::GetSupportedFlags() const {
+  return REFRESH_TYPE_IDLE_WAKEUPS;
+}
+
+SharedSampler::Callbacks::Callbacks() {}
+
+SharedSampler::Callbacks::~Callbacks() {}
+
+SharedSampler::Callbacks::Callbacks(Callbacks&& other) {
+  on_idle_wakeups = std::move(other.on_idle_wakeups);
+}
+
+void SharedSampler::RegisterCallbacks(
+    base::ProcessId process_id,
+    const OnIdleWakeupsCallback& on_idle_wakeups) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (process_id == 0)
+    return;
+
+  Callbacks callbacks;
+  callbacks.on_idle_wakeups = on_idle_wakeups;
+  bool result = callbacks_map_.insert(
+      std::make_pair(process_id, std::move(callbacks))).second;
+  DCHECK(result);
+}
+
+void SharedSampler::UnregisterCallbacks(base::ProcessId process_id) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (process_id == 0)
+    return;
+
+  callbacks_map_.erase(process_id);
+
+  if (callbacks_map_.empty())
+    ClearState();
+}
+
+void SharedSampler::Refresh(base::ProcessId process_id, int64_t refresh_flags) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(callbacks_map_.find(process_id) != callbacks_map_.end());
+  DCHECK_NE(0, refresh_flags & GetSupportedFlags());
+
+  if (process_id == 0)
+    return;
+
+  if (refresh_flags_ == 0) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(), FROM_HERE,
+        base::Bind(&SharedSampler::RefreshOnWorkerThread, this),
+        base::Bind(&SharedSampler::OnRefreshDone, this));
+  } else {
+    // A group of consecutive Refresh calls should all specify the same refresh
+    // flags.
+    DCHECK_EQ(refresh_flags, refresh_flags_);
+  }
+
+  refresh_flags_ |= refresh_flags;
+}
+
+void SharedSampler::ClearState() {
+  previous_snapshot_.reset();
+}
+
+std::unique_ptr<SharedSampler::RefreshResults>
+SharedSampler::RefreshOnWorkerThread() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  std::unique_ptr<RefreshResults> results(new RefreshResults);
+
+  std::unique_ptr<ProcessDataSnapshot> snapshot = CaptureSnapshot();
+  if (snapshot) {
+    if (previous_snapshot_) {
+      MakeResultsFromTwoSnapshots(
+          *previous_snapshot_, *snapshot, results.get());
+    } else {
+      MakeResultsFromSnapshot(*snapshot, results.get());
+    }
+
+    previous_snapshot_ = std::move(snapshot);
+  } else {
+    // Failed to get snapshot. This is unlikely.
+    ClearState();
+  }
+
+  return results;
+}
+
+/* static */
+std::vector<base::FilePath> SharedSampler::GetSupportedImageNames() {
+  const wchar_t kNacl64Exe[] = L"nacl64.exe";
+
+  std::vector<base::FilePath> supported_names;
+
+  base::FilePath current_exe;
+  if (PathService::Get(base::FILE_EXE, &current_exe))
+    supported_names.push_back(current_exe.BaseName());
+
+  supported_names.push_back(
+      base::FilePath(chrome::kBrowserProcessExecutableName));
+  supported_names.push_back(base::FilePath(kNacl64Exe));
+
+  return supported_names;
+}
+
+bool SharedSampler::IsSupportedImageName(
+    base::FilePath::StringPieceType image_name) const {
+  for (const base::FilePath supported_name : supported_image_names_) {
+    if (base::FilePath::CompareEqualIgnoreCase(image_name,
+                                               supported_name.value()))
+      return true;
+  }
+
+  return false;
+}
+
+std::unique_ptr<ProcessDataSnapshot> SharedSampler::CaptureSnapshot() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  // Preallocate the buffer with the size determined on the previous call to
+  // QuerySystemProcessInformation. This should be sufficient most of the time.
+  // QuerySystemProcessInformation will grow the buffer if necessary.
+  ByteBuffer data_buffer(previous_buffer_size_);
+
+  if (!QuerySystemProcessInformation(&data_buffer))
+    return std::unique_ptr<ProcessDataSnapshot>();
+
+  previous_buffer_size_ = data_buffer.capacity();
+
+  std::unique_ptr<ProcessDataSnapshot> snapshot(new ProcessDataSnapshot);
+  snapshot->timestamp = base::TimeTicks::Now();
+
+  for (size_t offset = 0; offset < data_buffer.size(); ) {
+    auto pi = reinterpret_cast<const SYSTEM_PROCESS_INFORMATION*>(
+      data_buffer.data() + offset);
+
+    // Validate that the offset is valid and all needed data is within
+    // the buffer boundary.
+    if (offset + sizeof(SYSTEM_PROCESS_INFORMATION) > data_buffer.size())
+      break;
+    if (offset + sizeof(SYSTEM_PROCESS_INFORMATION) +
+            (pi->NumberOfThreads - 1) * sizeof(SYSTEM_THREAD_INFORMATION) >
+      data_buffer.size())
+      break;
+
+    if (pi->ImageName.Buffer) {
+      // Validate that the image name is within the buffer boundary.
+      // ImageName.Length seems to be in bytes rather than characters.
+      ULONG image_name_offset =
+          reinterpret_cast<BYTE*>(pi->ImageName.Buffer) - data_buffer.data();
+      if (image_name_offset + pi->ImageName.Length > data_buffer.size())
+        break;
+
+      // Check if this is a chrome process. Ignore all other processes.
+      if (IsSupportedImageName(pi->ImageName.Buffer)) {
+        // Collect enough data to be able to do a diff between two snapshots.
+        // Some threads might stop or new threads might be created between two
+        // snapshots. If a thread with a large number of context switches gets
+        // terminated the total number of context switches for the process might
+        // go down and the delta would be negative.
+        // To avoid that we need to compare thread IDs between two snapshots and
+        // not count context switches for threads that are missing in the most
+        // recent snapshot.
+        ProcessData process_data;
+
+        // Iterate over threads and store each thread's ID and number of context
+        // switches.
+        for (ULONG thread_index = 0; thread_index < pi->NumberOfThreads;
+             ++thread_index) {
+          const SYSTEM_THREAD_INFORMATION* ti = &pi->Threads[thread_index];
+          if (ti->ClientId.UniqueProcess != pi->ProcessId)
+            continue;
+
+          ThreadData thread_data;
+          thread_data.thread_id = static_cast<base::PlatformThreadId>(
+              reinterpret_cast<uintptr_t>(ti->ClientId.UniqueThread));
+          thread_data.context_switches = ti->ContextSwitchCount;
+          process_data.threads.push_back(thread_data);
+        }
+
+        // Order thread data by thread ID to help diff two snapshots.
+        std::sort(process_data.threads.begin(), process_data.threads.end(),
+            [](const ThreadData& l, const ThreadData r) {
+              return l.thread_id < r.thread_id;
+            });
+
+        base::ProcessId process_id = static_cast<base::ProcessId>(
+            reinterpret_cast<uintptr_t>(pi->ProcessId));
+        bool inserted = snapshot->processes.insert(
+            std::make_pair(process_id, std::move(process_data))).second;
+        DCHECK(inserted);
+      }
+    }
+
+    // Check for end of the list.
+    if (!pi->NextEntryOffset)
+      break;
+
+    // Jump to the next entry.
+    offset += pi->NextEntryOffset;
+  }
+
+  return snapshot;
+}
+
+void SharedSampler::MakeResultsFromTwoSnapshots(
+    const ProcessDataSnapshot& prev_snapshot,
+    const ProcessDataSnapshot& snapshot,
+    RefreshResults* results) {
+  // Time delta in seconds.
+  double time_delta = (snapshot.timestamp - prev_snapshot.timestamp)
+      .InSecondsF();
+
+  // Iterate over processes in both snapshots in parallel. This algorithm relies
+  // on map entries being ordered by Process ID.
+  ProcessDataMap::const_iterator prev_iter = prev_snapshot.processes.begin();
+
+  for (const auto& current_entry : snapshot.processes) {
+    base::ProcessId process_id = current_entry.first;
+    const ProcessData& process = current_entry.second;
+
+    const ProcessData* prev_snapshot_process = SeekInPreviousSnapshot(
+        process_id, &prev_iter, prev_snapshot.processes.end());
+
+    // Delta between the old snapshot and the new snapshot.
+    int idle_wakeups_delta;
+
+    if (prev_snapshot_process) {
+      // Processes match between two snapshots. Diff context switches.
+      idle_wakeups_delta =
+          CountContextSwitchesDelta(*prev_snapshot_process, process);
+    } else {
+      // Process is missing in the previous snapshot.
+      // Use entire number of context switches of the current process.
+      idle_wakeups_delta = CountContextSwitchesDelta(ProcessData(), process);
+    }
+
+    RefreshResult result;
+    result.process_id = process_id;
+    result.idle_wakeups_per_second =
+        static_cast<int>(round(idle_wakeups_delta / time_delta));
+    results->push_back(result);
+  }
+}
+
+void SharedSampler::MakeResultsFromSnapshot(const ProcessDataSnapshot& snapshot,
+                                            RefreshResults* results) {
+  for (const auto& pair : snapshot.processes) {
+    RefreshResult result;
+    result.process_id = pair.first;
+    // Use 0 for Idle Wakeups / sec in this case. This is consistent with
+    // ProcessMetrics::CalculateIdleWakeupsPerSecond implementation.
+    result.idle_wakeups_per_second = 0;
+    results->push_back(result);
+  }
+}
+
+void SharedSampler::OnRefreshDone(
+    std::unique_ptr<RefreshResults> refresh_results) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK_NE(0, refresh_flags_);
+
+  size_t result_index = 0;
+
+  for (const auto& callback_entry : callbacks_map_) {
+    base::ProcessId process_id = callback_entry.first;
+    // A sentinel value of -1 is used when the result isn't available.
+    // Task manager will use this to display 'N/A'.
+    int idle_wakeups_per_second = -1;
+
+    // Match refresh result by |process_id|.
+    // This relies on refresh results being ordered by Process ID.
+    // Please note that |refresh_results| might contain some extra entries that
+    // don't exist in |callbacks_map_| if there is more than one instance of
+    // Chrome. It might be missing some entries too if there is a race condition
+    // between getting process information on the worker thread and adding a
+    // corresponding TaskGroup to the task manager.
+    for (; result_index < refresh_results->size(); ++result_index) {
+      const auto& result = (*refresh_results)[result_index];
+      if (result.process_id == process_id) {
+        // Data matched in |refresh_results|.
+        idle_wakeups_per_second = result.idle_wakeups_per_second;
+        ++result_index;
+        break;
+      }
+
+      if (result.process_id > process_id) {
+        // An entry corresponding to |process_id| is missing. See above.
+        break;
+      }
+    }
+
+    if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_IDLE_WAKEUPS,
+                                                      refresh_flags_)) {
+      callback_entry.second.on_idle_wakeups.Run(idle_wakeups_per_second);
+    }
+  }
+
+  // Reset refresh_results_ to trigger RefreshOnWorkerThread next time Refresh
+  // is called.
+  refresh_flags_ = 0;
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_group.cc b/chrome/browser/task_management/sampling/task_group.cc
new file mode 100644
index 0000000..de41155
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_group.cc
@@ -0,0 +1,292 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/task_group.h"
+
+#include <algorithm>
+#include <limits>
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "build/build_config.h"
+#include "chrome/browser/task_management/sampling/shared_sampler.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "components/nacl/browser/nacl_browser.h"
+#include "content/public/browser/browser_thread.h"
+#include "gpu/ipc/common/memory_stats.h"
+
+namespace task_management {
+
+namespace {
+
+// A mask for the refresh types that are done in the background thread.
+const int kBackgroundRefreshTypesMask =
+    REFRESH_TYPE_CPU |
+    REFRESH_TYPE_MEMORY |
+    REFRESH_TYPE_IDLE_WAKEUPS |
+#if defined(OS_LINUX)
+    REFRESH_TYPE_FD_COUNT |
+#endif  // defined(OS_LINUX)
+    REFRESH_TYPE_PRIORITY;
+
+#if defined(OS_WIN)
+// Gets the GDI and USER Handles on Windows at one shot.
+void GetWindowsHandles(base::ProcessHandle handle,
+                       int64_t* out_gdi_current,
+                       int64_t* out_gdi_peak,
+                       int64_t* out_user_current,
+                       int64_t* out_user_peak) {
+  *out_gdi_current = 0;
+  *out_gdi_peak = 0;
+  *out_user_current = 0;
+  *out_user_peak = 0;
+  // Get a handle to |process| that has PROCESS_QUERY_INFORMATION rights.
+  HANDLE current_process = GetCurrentProcess();
+  HANDLE process_with_query_rights;
+  if (DuplicateHandle(current_process, handle, current_process,
+                      &process_with_query_rights, PROCESS_QUERY_INFORMATION,
+                      false, 0)) {
+    *out_gdi_current = static_cast<int64_t>(
+        GetGuiResources(process_with_query_rights, GR_GDIOBJECTS));
+    *out_gdi_peak = static_cast<int64_t>(
+        GetGuiResources(process_with_query_rights, GR_GDIOBJECTS_PEAK));
+    *out_user_current = static_cast<int64_t>(
+        GetGuiResources(process_with_query_rights, GR_USEROBJECTS));
+    *out_user_peak = static_cast<int64_t>(
+        GetGuiResources(process_with_query_rights, GR_USEROBJECTS_PEAK));
+    CloseHandle(process_with_query_rights);
+  }
+}
+#endif  // defined(OS_WIN)
+
+}  // namespace
+
+TaskGroup::TaskGroup(
+    base::ProcessHandle proc_handle,
+    base::ProcessId proc_id,
+    const base::Closure& on_background_calculations_done,
+    const scoped_refptr<SharedSampler>& shared_sampler,
+    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner)
+    : process_handle_(proc_handle),
+      process_id_(proc_id),
+      on_background_calculations_done_(on_background_calculations_done),
+      worker_thread_sampler_(nullptr),
+      shared_sampler_(shared_sampler),
+      expected_on_bg_done_flags_(kBackgroundRefreshTypesMask),
+      current_on_bg_done_flags_(0),
+      cpu_usage_(0.0),
+      gpu_memory_(-1),
+      per_process_network_usage_(-1),
+#if defined(OS_WIN)
+      gdi_current_handles_(-1),
+      gdi_peak_handles_(-1),
+      user_current_handles_(-1),
+      user_peak_handles_(-1),
+#endif  // defined(OS_WIN)
+#if !defined(DISABLE_NACL)
+      nacl_debug_stub_port_(-1),
+#endif  // !defined(DISABLE_NACL)
+      idle_wakeups_per_second_(-1),
+#if defined(OS_LINUX)
+      open_fd_count_(-1),
+#endif  // defined(OS_LINUX)
+      gpu_memory_has_duplicates_(false),
+      is_backgrounded_(false),
+      weak_ptr_factory_(this) {
+  scoped_refptr<TaskGroupSampler> sampler(
+      new TaskGroupSampler(base::Process::Open(proc_id),
+                           blocking_pool_runner,
+                           base::Bind(&TaskGroup::OnCpuRefreshDone,
+                                      weak_ptr_factory_.GetWeakPtr()),
+                           base::Bind(&TaskGroup::OnMemoryUsageRefreshDone,
+                                      weak_ptr_factory_.GetWeakPtr()),
+                           base::Bind(&TaskGroup::OnIdleWakeupsRefreshDone,
+                                      weak_ptr_factory_.GetWeakPtr()),
+#if defined(OS_LINUX)
+                           base::Bind(&TaskGroup::OnOpenFdCountRefreshDone,
+                                      weak_ptr_factory_.GetWeakPtr()),
+#endif  // defined(OS_LINUX)
+                           base::Bind(&TaskGroup::OnProcessPriorityDone,
+                                      weak_ptr_factory_.GetWeakPtr())));
+  worker_thread_sampler_.swap(sampler);
+
+  shared_sampler_->RegisterCallbacks(
+      process_id_, base::Bind(&TaskGroup::OnIdleWakeupsRefreshDone,
+                              weak_ptr_factory_.GetWeakPtr()));
+}
+
+TaskGroup::~TaskGroup() {
+  shared_sampler_->UnregisterCallbacks(process_id_);
+}
+
+void TaskGroup::AddTask(Task* task) {
+  DCHECK(task);
+  tasks_.push_back(task);
+}
+
+void TaskGroup::RemoveTask(Task* task) {
+  DCHECK(task);
+  tasks_.erase(std::remove(tasks_.begin(), tasks_.end(), task), tasks_.end());
+}
+
+void TaskGroup::Refresh(const gpu::VideoMemoryUsageStats& gpu_memory_stats,
+                        base::TimeDelta update_interval,
+                        int64_t refresh_flags) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  expected_on_bg_done_flags_ = refresh_flags & kBackgroundRefreshTypesMask;
+  // If a refresh type was recently disabled, we need to account for that too.
+  current_on_bg_done_flags_ &= expected_on_bg_done_flags_;
+
+  // First refresh the enabled non-expensive resources usages on the UI thread.
+  // 1- Refresh all the tasks as well as the total network usage (if enabled).
+  const bool network_usage_refresh_enabled =
+      TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_NETWORK_USAGE,
+                                                    refresh_flags);
+  per_process_network_usage_ = network_usage_refresh_enabled ? 0 : -1;
+  for (Task* task : tasks_) {
+    task->Refresh(update_interval, refresh_flags);
+
+    if (network_usage_refresh_enabled && task->ReportsNetworkUsage())
+      per_process_network_usage_ += task->network_usage();
+  }
+
+  // 2- Refresh GPU memory (if enabled).
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_GPU_MEMORY,
+                                                    refresh_flags)) {
+    RefreshGpuMemory(gpu_memory_stats);
+  }
+
+  // 3- Refresh Windows handles (if enabled).
+#if defined(OS_WIN)
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_HANDLES,
+                                                    refresh_flags)) {
+    RefreshWindowsHandles();
+  }
+#endif  // defined(OS_WIN)
+
+  // 4- Refresh the NACL debug stub port (if enabled).
+#if !defined(DISABLE_NACL)
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_NACL,
+                                                    refresh_flags) &&
+      !tasks_.empty()) {
+    RefreshNaClDebugStubPort(tasks_[0]->GetChildProcessUniqueID());
+  }
+#endif  // !defined(DISABLE_NACL)
+
+  int64_t shared_refresh_flags =
+      refresh_flags & shared_sampler_->GetSupportedFlags();
+
+  // 5- Refresh resources via SharedSampler if the current platform
+  // implementation supports that. The actual work is done on the worker thread.
+  // At the moment this is supported only on OS_WIN.
+  if (shared_refresh_flags != 0) {
+    shared_sampler_->Refresh(process_id_, shared_refresh_flags);
+    refresh_flags &= ~shared_refresh_flags;
+  }
+
+  // The remaining resource refreshes are time consuming and cannot be done on
+  // the UI thread. Do them all on the worker thread using the TaskGroupSampler.
+  // 6-  CPU usage.
+  // 7-  Memory usage.
+  // 8-  Idle Wakeups per second.
+  // 9-  (Linux and ChromeOS only) The number of file descriptors current open.
+  // 10- Process priority (foreground vs. background).
+  worker_thread_sampler_->Refresh(refresh_flags);
+}
+
+Task* TaskGroup::GetTaskById(TaskId task_id) const {
+  for (Task* task : tasks_) {
+    if (task->task_id() == task_id)
+      return task;
+  }
+  NOTREACHED();
+  return nullptr;
+}
+
+void TaskGroup::ClearCurrentBackgroundCalculationsFlags() {
+  current_on_bg_done_flags_ = 0;
+}
+
+bool TaskGroup::AreBackgroundCalculationsDone() const {
+  return expected_on_bg_done_flags_ == current_on_bg_done_flags_;
+}
+
+void TaskGroup::RefreshGpuMemory(
+    const gpu::VideoMemoryUsageStats& gpu_memory_stats) {
+  auto itr = gpu_memory_stats.process_map.find(process_id_);
+  if (itr == gpu_memory_stats.process_map.end()) {
+    gpu_memory_ = -1;
+    gpu_memory_has_duplicates_ = false;
+    return;
+  }
+
+  gpu_memory_ = itr->second.video_memory;
+  gpu_memory_has_duplicates_ = itr->second.has_duplicates;
+}
+
+void TaskGroup::RefreshWindowsHandles() {
+#if defined(OS_WIN)
+  GetWindowsHandles(process_handle_,
+                    &gdi_current_handles_,
+                    &gdi_peak_handles_,
+                    &user_current_handles_,
+                    &user_peak_handles_);
+#endif  // defined(OS_WIN)
+}
+
+void TaskGroup::RefreshNaClDebugStubPort(int child_process_unique_id) {
+#if !defined(DISABLE_NACL)
+  nacl::NaClBrowser* nacl_browser = nacl::NaClBrowser::GetInstance();
+  nacl_debug_stub_port_ =
+      nacl_browser->GetProcessGdbDebugStubPort(child_process_unique_id);
+#endif  // !defined(DISABLE_NACL)
+}
+
+void TaskGroup::OnCpuRefreshDone(double cpu_usage) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  cpu_usage_ = cpu_usage;
+  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_CPU);
+}
+
+void TaskGroup::OnMemoryUsageRefreshDone(MemoryUsageStats memory_usage) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  memory_usage_ = memory_usage;
+  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_MEMORY);
+}
+
+void TaskGroup::OnIdleWakeupsRefreshDone(int idle_wakeups_per_second) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  idle_wakeups_per_second_ = idle_wakeups_per_second;
+  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_IDLE_WAKEUPS);
+}
+
+#if defined(OS_LINUX)
+void TaskGroup::OnOpenFdCountRefreshDone(int open_fd_count) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  open_fd_count_ = open_fd_count;
+  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_FD_COUNT);
+}
+#endif  // defined(OS_LINUX)
+
+void TaskGroup::OnProcessPriorityDone(bool is_backgrounded) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  is_backgrounded_ = is_backgrounded;
+  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_PRIORITY);
+}
+
+void TaskGroup::OnBackgroundRefreshTypeFinished(int64_t finished_refresh_type) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  current_on_bg_done_flags_ |= finished_refresh_type;
+  if (AreBackgroundCalculationsDone())
+    on_background_calculations_done_.Run();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_group.h b/chrome/browser/task_management/sampling/task_group.h
new file mode 100644
index 0000000..7922427
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_group.h
@@ -0,0 +1,178 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <map>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/process/process_handle.h"
+#include "build/build_config.h"
+#include "chrome/browser/task_management/providers/task.h"
+#include "chrome/browser/task_management/sampling/task_group_sampler.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+
+namespace gpu {
+struct VideoMemoryUsageStats;
+}
+
+namespace task_management {
+
+class SharedSampler;
+
+// Defines a group of tasks tracked by the task manager which belong to the same
+// process. This class lives on the UI thread.
+class TaskGroup {
+ public:
+  TaskGroup(
+      base::ProcessHandle proc_handle,
+      base::ProcessId proc_id,
+      const base::Closure& on_background_calculations_done,
+      const scoped_refptr<SharedSampler>& shared_sampler,
+      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner);
+  ~TaskGroup();
+
+  // Adds and removes the given |task| to this group. |task| must be running on
+  // the same process represented by this group.
+  void AddTask(Task* task);
+  void RemoveTask(Task* task);
+
+  void Refresh(const gpu::VideoMemoryUsageStats& gpu_memory_stats,
+               base::TimeDelta update_interval,
+               int64_t refresh_flags);
+
+  Task* GetTaskById(TaskId task_id) const;
+
+  // This is to be called after the task manager had informed its observers with
+  // OnTasksRefreshedWithBackgroundCalculations() to begin another cycle for
+  // this notification type.
+  void ClearCurrentBackgroundCalculationsFlags();
+
+  // True if all enabled background operations calculating resource usage of the
+  // process represented by this TaskGroup have completed.
+  bool AreBackgroundCalculationsDone() const;
+
+  const base::ProcessHandle& process_handle() const { return process_handle_; }
+  const base::ProcessId& process_id() const { return process_id_; }
+
+  const std::vector<Task*>& tasks() const { return tasks_; }
+  size_t num_tasks() const { return tasks().size(); }
+  bool empty() const { return tasks().empty(); }
+
+  double cpu_usage() const { return cpu_usage_; }
+  int64_t private_bytes() const { return memory_usage_.private_bytes; }
+  int64_t shared_bytes() const { return memory_usage_.shared_bytes; }
+  int64_t physical_bytes() const { return memory_usage_.physical_bytes; }
+#if defined(OS_CHROMEOS)
+  int64_t swapped_bytes() const { return memory_usage_.swapped_bytes; }
+#endif
+  int64_t gpu_memory() const { return gpu_memory_; }
+  bool gpu_memory_has_duplicates() const { return gpu_memory_has_duplicates_; }
+  int64_t per_process_network_usage() const {
+    return per_process_network_usage_;
+  }
+  bool is_backgrounded() const { return is_backgrounded_; }
+
+#if defined(OS_WIN)
+  int64_t gdi_current_handles() const { return gdi_current_handles_; }
+  int64_t gdi_peak_handles() const { return gdi_peak_handles_; }
+  int64_t user_current_handles() const { return user_current_handles_; }
+  int64_t user_peak_handles() const { return user_peak_handles_; }
+#endif  // defined(OS_WIN)
+
+#if !defined(DISABLE_NACL)
+  int nacl_debug_stub_port() const { return nacl_debug_stub_port_; }
+#endif  // !defined(DISABLE_NACL)
+
+#if defined(OS_LINUX)
+  int open_fd_count() const { return open_fd_count_; }
+#endif  // defined(OS_LINUX)
+
+  int idle_wakeups_per_second() const { return idle_wakeups_per_second_; }
+
+ private:
+  void RefreshGpuMemory(const gpu::VideoMemoryUsageStats& gpu_memory_stats);
+
+  void RefreshWindowsHandles();
+
+  // |child_process_unique_id| see Task::GetChildProcessUniqueID().
+  void RefreshNaClDebugStubPort(int child_process_unique_id);
+
+  void OnCpuRefreshDone(double cpu_usage);
+
+  void OnMemoryUsageRefreshDone(MemoryUsageStats memory_usage);
+
+  void OnIdleWakeupsRefreshDone(int idle_wakeups_per_second);
+
+#if defined(OS_LINUX)
+  void OnOpenFdCountRefreshDone(int open_fd_count);
+#endif  // defined(OS_LINUX)
+
+  void OnProcessPriorityDone(bool is_backgrounded);
+
+  void OnBackgroundRefreshTypeFinished(int64_t finished_refresh_type);
+
+  // The process' handle and ID.
+  base::ProcessHandle process_handle_;
+  base::ProcessId process_id_;
+
+  // This is a callback into the TaskManagerImpl to inform it that the
+  // background calculations for this TaskGroup has finished.
+  const base::Closure on_background_calculations_done_;
+
+  scoped_refptr<TaskGroupSampler> worker_thread_sampler_;
+
+  scoped_refptr<SharedSampler> shared_sampler_;
+
+  // Lists the Tasks in this TaskGroup.
+  // Tasks are not owned by the TaskGroup. They're owned by the TaskProviders.
+  std::vector<Task*> tasks_;
+
+  // Flags will be used to determine when the background calculations has
+  // completed for the enabled refresh types for this TaskGroup.
+  int64_t expected_on_bg_done_flags_;
+  int64_t current_on_bg_done_flags_;
+
+  // The per process resources usages.
+  double cpu_usage_;
+  MemoryUsageStats memory_usage_;
+  int64_t gpu_memory_;
+  // The network usage in bytes per second as the sum of all network usages of
+  // the individual tasks sharing the same process.
+  int64_t per_process_network_usage_;
+#if defined(OS_WIN)
+  // Windows GDI and USER Handles.
+  int64_t gdi_current_handles_;
+  int64_t gdi_peak_handles_;
+  int64_t user_current_handles_;
+  int64_t user_peak_handles_;
+#endif  // defined(OS_WIN)
+#if !defined(DISABLE_NACL)
+  int nacl_debug_stub_port_;
+#endif  // !defined(DISABLE_NACL)
+  int idle_wakeups_per_second_;
+#if defined(OS_LINUX)
+  // The number of file descriptors currently open by the process.
+  int open_fd_count_;
+#endif  // defined(OS_LINUX)
+  bool gpu_memory_has_duplicates_;
+  bool is_backgrounded_;
+
+  // Always keep this the last member of this class so that it's the first to be
+  // destroyed.
+  base::WeakPtrFactory<TaskGroup> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskGroup);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_H_
diff --git a/chrome/browser/task_management/sampling/task_group_sampler.cc b/chrome/browser/task_management/sampling/task_group_sampler.cc
new file mode 100644
index 0000000..4e7ee36
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_group_sampler.cc
@@ -0,0 +1,188 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/task_group_sampler.h"
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/process/process_metrics.h"
+#include "build/build_config.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "content/public/browser/browser_child_process_host.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace task_management {
+
+namespace {
+
+std::unique_ptr<base::ProcessMetrics> CreateProcessMetrics(
+    base::ProcessHandle handle) {
+#if !defined(OS_MACOSX)
+  return base::ProcessMetrics::CreateProcessMetrics(handle);
+#else
+  return base::ProcessMetrics::CreateProcessMetrics(
+      handle, content::BrowserChildProcessHost::GetPortProvider());
+#endif
+}
+
+}  // namespace
+
+TaskGroupSampler::TaskGroupSampler(
+    base::Process process,
+    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner,
+    const OnCpuRefreshCallback& on_cpu_refresh,
+    const OnMemoryRefreshCallback& on_memory_refresh,
+    const OnIdleWakeupsCallback& on_idle_wakeups,
+#if defined(OS_LINUX)
+    const OnOpenFdCountCallback& on_open_fd_count,
+#endif  // defined(OS_LINUX)
+    const OnProcessPriorityCallback& on_process_priority)
+    : process_(std::move(process)),
+      process_metrics_(CreateProcessMetrics(process_.Handle())),
+      blocking_pool_runner_(blocking_pool_runner),
+      on_cpu_refresh_callback_(on_cpu_refresh),
+      on_memory_refresh_callback_(on_memory_refresh),
+      on_idle_wakeups_callback_(on_idle_wakeups),
+#if defined(OS_LINUX)
+      on_open_fd_count_callback_(on_open_fd_count),
+#endif  // defined(OS_LINUX)
+      on_process_priority_callback_(on_process_priority) {
+  DCHECK(blocking_pool_runner.get());
+
+  // This object will be created on the UI thread, however the sequenced checker
+  // will be used to assert we're running the expensive operations on one of the
+  // blocking pool threads.
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  worker_pool_sequenced_checker_.DetachFromSequence();
+}
+
+void TaskGroupSampler::Refresh(int64_t refresh_flags) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_CPU,
+                                                    refresh_flags)) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(),
+        FROM_HERE,
+        base::Bind(&TaskGroupSampler::RefreshCpuUsage, this),
+        on_cpu_refresh_callback_);
+  }
+
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_MEMORY,
+                                                    refresh_flags)) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(),
+        FROM_HERE,
+        base::Bind(&TaskGroupSampler::RefreshMemoryUsage, this),
+        on_memory_refresh_callback_);
+  }
+
+#if defined(OS_MACOSX) || defined(OS_LINUX)
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_IDLE_WAKEUPS,
+                                                    refresh_flags)) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(),
+        FROM_HERE,
+        base::Bind(&TaskGroupSampler::RefreshIdleWakeupsPerSecond, this),
+        on_idle_wakeups_callback_);
+  }
+#endif  // defined(OS_MACOSX) || defined(OS_LINUX)
+
+#if defined(OS_LINUX)
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_FD_COUNT,
+                                                    refresh_flags)) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(),
+        FROM_HERE,
+        base::Bind(&TaskGroupSampler::RefreshOpenFdCount, this),
+        on_open_fd_count_callback_);
+  }
+#endif  // defined(OS_LINUX)
+
+  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_PRIORITY,
+                                                    refresh_flags)) {
+    base::PostTaskAndReplyWithResult(
+        blocking_pool_runner_.get(),
+        FROM_HERE,
+        base::Bind(&TaskGroupSampler::RefreshProcessPriority, this),
+        on_process_priority_callback_);
+  }
+}
+
+TaskGroupSampler::~TaskGroupSampler() {
+}
+
+double TaskGroupSampler::RefreshCpuUsage() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  return process_metrics_->GetCPUUsage();
+}
+
+MemoryUsageStats TaskGroupSampler::RefreshMemoryUsage() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  MemoryUsageStats memory_usage;
+#if defined(OS_MACOSX)
+  memory_usage.physical_bytes =
+      static_cast<int64_t>(process_metrics_->GetWorkingSetSize());
+
+  size_t private_bytes = 0;
+  size_t shared_bytes = 0;
+  if (process_metrics_->GetMemoryBytes(&private_bytes, &shared_bytes)) {
+    memory_usage.private_bytes = static_cast<int64_t>(private_bytes);
+    memory_usage.shared_bytes = static_cast<int64_t>(shared_bytes);
+  }
+#else
+  // Refreshing the physical/private/shared memory at one shot.
+  base::WorkingSetKBytes ws_usage;
+  if (process_metrics_->GetWorkingSetKBytes(&ws_usage)) {
+    memory_usage.private_bytes = static_cast<int64_t>(ws_usage.priv * 1024);
+    memory_usage.shared_bytes = static_cast<int64_t>(ws_usage.shared * 1024);
+#if defined(OS_LINUX)
+    // On Linux private memory is also resident. Just use it.
+    memory_usage.physical_bytes = memory_usage.private_bytes;
+#else
+    // Memory = working_set.private which is working set minus shareable. This
+    // avoids the unpredictable counting that occurs when calculating memory as
+    // working set minus shared (renderer code counted when one tab is open and
+    // not counted when two or more are open) and it is much more efficient to
+    // calculate on Windows.
+    memory_usage.physical_bytes =
+        static_cast<int64_t>(process_metrics_->GetWorkingSetSize());
+    memory_usage.physical_bytes -=
+        static_cast<int64_t>(ws_usage.shareable * 1024);
+#endif  // defined(OS_LINUX)
+
+#if defined(OS_CHROMEOS)
+    memory_usage.swapped_bytes = ws_usage.swapped * 1024;
+#endif  // defined(OS_CHROMEOS)
+  }
+#endif  // defined(OS_MACOSX)
+
+  return memory_usage;
+}
+
+int TaskGroupSampler::RefreshIdleWakeupsPerSecond() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  return process_metrics_->GetIdleWakeupsPerSecond();
+}
+
+#if defined(OS_LINUX)
+int TaskGroupSampler::RefreshOpenFdCount() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  return process_metrics_->GetOpenFdCount();
+}
+#endif  // defined(OS_LINUX)
+
+bool TaskGroupSampler::RefreshProcessPriority() {
+  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
+
+  return process_.IsProcessBackgrounded();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_group_sampler.h b/chrome/browser/task_management/sampling/task_group_sampler.h
new file mode 100644
index 0000000..b7c5f4f
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_group_sampler.h
@@ -0,0 +1,110 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_SAMPLER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_SAMPLER_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/process/process.h"
+#include "base/process/process_handle.h"
+#include "base/process/process_metrics.h"
+#include "base/sequence_checker.h"
+#include "base/sequenced_task_runner.h"
+#include "build/build_config.h"
+
+namespace task_management {
+
+// Wraps the memory usage stats values together so that it can be sent between
+// the UI and the worker threads.
+struct MemoryUsageStats {
+  int64_t private_bytes = -1;
+  int64_t shared_bytes = -1;
+  int64_t physical_bytes = -1;
+#if defined(OS_CHROMEOS)
+  int64_t swapped_bytes = -1;
+#endif
+
+  MemoryUsageStats() {}
+};
+
+// Defines the expensive process' stats sampler that will calculate these
+// resources on the worker thread. Objects of this class are created by the
+// TaskGroups on the UI thread, however it will be used mainly on a blocking
+// pool thread.
+class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
+ public:
+  // Below are the types of callbacks that are invoked on the UI thread upon
+  // completion of corresponding refresh tasks on the worker thread.
+  using OnCpuRefreshCallback = base::Callback<void(double)>;
+  using OnMemoryRefreshCallback = base::Callback<void(MemoryUsageStats)>;
+  using OnIdleWakeupsCallback = base::Callback<void(int)>;
+#if defined(OS_LINUX)
+  using OnOpenFdCountCallback = base::Callback<void(int)>;
+#endif  // defined(OS_LINUX)
+  using OnProcessPriorityCallback = base::Callback<void(bool)>;
+
+  TaskGroupSampler(
+      base::Process process,
+      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner,
+      const OnCpuRefreshCallback& on_cpu_refresh,
+      const OnMemoryRefreshCallback& on_memory_refresh,
+      const OnIdleWakeupsCallback& on_idle_wakeups,
+#if defined(OS_LINUX)
+      const OnOpenFdCountCallback& on_open_fd_count,
+#endif  // defined(OS_LINUX)
+      const OnProcessPriorityCallback& on_process_priority);
+
+  // Refreshes the expensive process' stats (CPU usage, memory usage, and idle
+  // wakeups per second) on the worker thread.
+  void Refresh(int64_t refresh_flags);
+
+ private:
+  friend class base::RefCountedThreadSafe<TaskGroupSampler>;
+  ~TaskGroupSampler();
+
+  // The refresh calls that will be done on the worker thread.
+  double RefreshCpuUsage();
+  MemoryUsageStats RefreshMemoryUsage();
+  int RefreshIdleWakeupsPerSecond();
+#if defined(OS_LINUX)
+  int RefreshOpenFdCount();
+#endif  // defined(OS_LINUX)
+  bool RefreshProcessPriority();
+
+  // The process that holds the handle that we own so that we can use it for
+  // creating the ProcessMetrics.
+  base::Process process_;
+
+  std::unique_ptr<base::ProcessMetrics> process_metrics_;
+
+  // The specific blocking pool SequencedTaskRunner that will be used to post
+  // the refresh tasks onto serially.
+  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
+
+  // The UI-thread callbacks in TaskGroup to be called when their corresponding
+  // refreshes on the worker thread are done.
+  const OnCpuRefreshCallback on_cpu_refresh_callback_;
+  const OnMemoryRefreshCallback on_memory_refresh_callback_;
+  const OnIdleWakeupsCallback on_idle_wakeups_callback_;
+#if defined(OS_LINUX)
+  const OnOpenFdCountCallback on_open_fd_count_callback_;
+#endif  // defined(OS_LINUX)
+  const OnProcessPriorityCallback on_process_priority_callback_;
+
+  // To assert we're running on the correct thread.
+  base::SequenceChecker worker_pool_sequenced_checker_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskGroupSampler);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_GROUP_SAMPLER_H_
diff --git a/chrome/browser/task_management/sampling/task_manager_impl.cc b/chrome/browser/task_management/sampling/task_manager_impl.cc
new file mode 100644
index 0000000..de495db
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_manager_impl.cc
@@ -0,0 +1,549 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/task_manager_impl.h"
+
+#include <algorithm>
+#include <string>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/containers/adapters.h"
+#include "build/build_config.h"
+#include "chrome/browser/task_management/providers/browser_process_task_provider.h"
+#include "chrome/browser/task_management/providers/child_process_task_provider.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_task_provider.h"
+#include "chrome/browser/task_management/sampling/shared_sampler.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/gpu_data_manager.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/web_contents.h"
+
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/task_management/providers/arc/arc_process_task_provider.h"
+#include "components/arc/arc_bridge_service.h"
+#endif  // defined(OS_CHROMEOS)
+
+namespace task_management {
+
+namespace {
+
+scoped_refptr<base::SequencedTaskRunner> GetBlockingPoolRunner() {
+  base::SequencedWorkerPool* blocking_pool =
+      content::BrowserThread::GetBlockingPool();
+  return blocking_pool->GetSequencedTaskRunner(
+      blocking_pool->GetSequenceToken());
+}
+
+base::LazyInstance<TaskManagerImpl> lazy_task_manager_instance =
+    LAZY_INSTANCE_INITIALIZER;
+
+}  // namespace
+
+TaskManagerImpl::TaskManagerImpl()
+    : on_background_data_ready_callback_(
+          base::Bind(&TaskManagerImpl::OnTaskGroupBackgroundCalculationsDone,
+                     base::Unretained(this))),
+      blocking_pool_runner_(GetBlockingPoolRunner()),
+      shared_sampler_(new SharedSampler(blocking_pool_runner_)),
+      is_running_(false) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  task_providers_.emplace_back(new BrowserProcessTaskProvider());
+  task_providers_.emplace_back(new ChildProcessTaskProvider());
+  task_providers_.emplace_back(new WebContentsTaskProvider());
+#if defined(OS_CHROMEOS)
+  if (arc::ArcBridgeService::GetEnabled(
+          base::CommandLine::ForCurrentProcess())) {
+    task_providers_.emplace_back(new ArcProcessTaskProvider());
+  }
+#endif  // defined(OS_CHROMEOS)
+
+  content::GpuDataManager::GetInstance()->AddObserver(this);
+}
+
+TaskManagerImpl::~TaskManagerImpl() {
+  content::GpuDataManager::GetInstance()->RemoveObserver(this);
+}
+
+// static
+TaskManagerImpl* TaskManagerImpl::GetInstance() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  return lazy_task_manager_instance.Pointer();
+}
+
+void TaskManagerImpl::ActivateTask(TaskId task_id) {
+  GetTaskByTaskId(task_id)->Activate();
+}
+
+bool TaskManagerImpl::IsTaskKillable(TaskId task_id) {
+  return GetTaskByTaskId(task_id)->IsKillable();
+}
+
+void TaskManagerImpl::KillTask(TaskId task_id) {
+  GetTaskByTaskId(task_id)->Kill();
+}
+
+double TaskManagerImpl::GetCpuUsage(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->cpu_usage();
+}
+
+int64_t TaskManagerImpl::GetPhysicalMemoryUsage(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->physical_bytes();
+}
+
+int64_t TaskManagerImpl::GetPrivateMemoryUsage(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->private_bytes();
+}
+
+int64_t TaskManagerImpl::GetSharedMemoryUsage(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->shared_bytes();
+}
+
+int64_t TaskManagerImpl::GetSwappedMemoryUsage(TaskId task_id) const {
+#if defined(OS_CHROMEOS)
+  return GetTaskGroupByTaskId(task_id)->swapped_bytes();
+#else
+  return -1;
+#endif
+}
+
+int64_t TaskManagerImpl::GetGpuMemoryUsage(TaskId task_id,
+                                           bool* has_duplicates) const {
+  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
+  if (has_duplicates)
+    *has_duplicates = task_group->gpu_memory_has_duplicates();
+  return task_group->gpu_memory();
+}
+
+int TaskManagerImpl::GetIdleWakeupsPerSecond(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->idle_wakeups_per_second();
+}
+
+int TaskManagerImpl::GetNaClDebugStubPort(TaskId task_id) const {
+#if !defined(DISABLE_NACL)
+  return GetTaskGroupByTaskId(task_id)->nacl_debug_stub_port();
+#else
+  return -2;
+#endif  // !defined(DISABLE_NACL)
+}
+
+void TaskManagerImpl::GetGDIHandles(TaskId task_id,
+                                    int64_t* current,
+                                    int64_t* peak) const {
+#if defined(OS_WIN)
+  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
+  *current = task_group->gdi_current_handles();
+  *peak = task_group->gdi_peak_handles();
+#else
+  *current = -1;
+  *peak = -1;
+#endif  // defined(OS_WIN)
+}
+
+void TaskManagerImpl::GetUSERHandles(TaskId task_id,
+                                     int64_t* current,
+                                     int64_t* peak) const {
+#if defined(OS_WIN)
+  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
+  *current = task_group->user_current_handles();
+  *peak = task_group->user_peak_handles();
+#else
+  *current = -1;
+  *peak = -1;
+#endif  // defined(OS_WIN)
+}
+
+int TaskManagerImpl::GetOpenFdCount(TaskId task_id) const {
+#if defined(OS_LINUX)
+  return GetTaskGroupByTaskId(task_id)->open_fd_count();
+#else
+  return -1;
+#endif  // defined(OS_LINUX)
+}
+
+bool TaskManagerImpl::IsTaskOnBackgroundedProcess(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->is_backgrounded();
+}
+
+const base::string16& TaskManagerImpl::GetTitle(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->title();
+}
+
+const std::string& TaskManagerImpl::GetTaskNameForRappor(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->rappor_sample_name();
+}
+
+base::string16 TaskManagerImpl::GetProfileName(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->GetProfileName();
+}
+
+const gfx::ImageSkia& TaskManagerImpl::GetIcon(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->icon();
+}
+
+const base::ProcessHandle& TaskManagerImpl::GetProcessHandle(
+    TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->process_handle();
+}
+
+const base::ProcessId& TaskManagerImpl::GetProcessId(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->process_id();
+}
+
+Task::Type TaskManagerImpl::GetType(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->GetType();
+}
+
+int TaskManagerImpl::GetTabId(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->GetTabId();
+}
+
+int TaskManagerImpl::GetChildProcessUniqueId(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->GetChildProcessUniqueID();
+}
+
+void TaskManagerImpl::GetTerminationStatus(TaskId task_id,
+                                           base::TerminationStatus* out_status,
+                                           int* out_error_code) const {
+  GetTaskByTaskId(task_id)->GetTerminationStatus(out_status, out_error_code);
+}
+
+int64_t TaskManagerImpl::GetNetworkUsage(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->network_usage();
+}
+
+int64_t TaskManagerImpl::GetProcessTotalNetworkUsage(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->per_process_network_usage();
+}
+
+int64_t TaskManagerImpl::GetSqliteMemoryUsed(TaskId task_id) const {
+  return GetTaskByTaskId(task_id)->GetSqliteMemoryUsed();
+}
+
+bool TaskManagerImpl::GetV8Memory(TaskId task_id,
+                                  int64_t* allocated,
+                                  int64_t* used) const {
+  const Task* task = GetTaskByTaskId(task_id);
+  if (!task->ReportsV8Memory())
+    return false;
+
+  *allocated = task->GetV8MemoryAllocated();
+  *used = task->GetV8MemoryUsed();
+
+  return true;
+}
+
+bool TaskManagerImpl::GetWebCacheStats(
+    TaskId task_id,
+    blink::WebCache::ResourceTypeStats* stats) const {
+  const Task* task = GetTaskByTaskId(task_id);
+  if (!task->ReportsWebCacheStats())
+    return false;
+
+  *stats = task->GetWebCacheStats();
+
+  return true;
+}
+
+const TaskIdList& TaskManagerImpl::GetTaskIdsList() const {
+  DCHECK(is_running_) << "Task manager is not running. You must observe the "
+      "task manager for it to start running";
+
+  if (sorted_task_ids_.empty()) {
+    // |comparator| groups and sorts by subtask-ness (to push all subtasks to be
+    // last), then by process type (e.g. the browser process should be first;
+    // renderer processes should be together), then tab id (processes used by
+    // the same tab should be kept together, and a tab should have a stable
+    // position in the list as it cycles through processes, and tab creation
+    // order is meaningful), and finally by task id (when all else is equal, put
+    // the oldest tasks first).
+    auto comparator = [](const Task* a, const Task* b) -> bool {
+      return std::make_tuple(a->HasParentTask(), a->GetType(), a->GetTabId(),
+                             a->task_id()) <
+             std::make_tuple(b->HasParentTask(), b->GetType(), b->GetTabId(),
+                             b->task_id());
+    };
+
+    const size_t num_groups = task_groups_by_proc_id_.size();
+    const size_t num_tasks = task_groups_by_task_id_.size();
+
+    // Populate |tasks_to_visit| with one task from each group.
+    std::vector<const Task*> tasks_to_visit;
+    tasks_to_visit.reserve(num_groups);
+    std::unordered_map<const Task*, std::vector<const Task*>> children;
+    for (const auto& groups_pair : task_groups_by_proc_id_) {
+      // The first task in the group (per |comparator|) is the one used for
+      // sorting the group relative to other groups.
+      const std::vector<Task*>& tasks = groups_pair.second->tasks();
+      Task* group_task =
+          *std::min_element(tasks.begin(), tasks.end(), comparator);
+      tasks_to_visit.push_back(group_task);
+
+      // Build the parent-to-child map, for use later.
+      for (const Task* task : tasks) {
+        if (task->HasParentTask())
+          children[task->GetParentTask()].push_back(task);
+        else
+          DCHECK(!group_task->HasParentTask());
+      }
+    }
+
+    // Now sort |tasks_to_visit| in reverse order (putting the browser process
+    // at back()). We will treat it as a stack from now on.
+    std::sort(tasks_to_visit.rbegin(), tasks_to_visit.rend(), comparator);
+    DCHECK_EQ(Task::BROWSER, tasks_to_visit.back()->GetType());
+
+    // Using |tasks_to_visit| as a stack, and |visited_groups| to track which
+    // groups we've already added, add groups to |sorted_task_ids_| until all
+    // groups have been added.
+    sorted_task_ids_.reserve(num_tasks);
+    std::unordered_set<TaskGroup*> visited_groups;
+    visited_groups.reserve(num_groups);
+    std::vector<Task*> current_group_tasks;  // Outside loop for fewer mallocs.
+    while (visited_groups.size() < num_groups) {
+      DCHECK(!tasks_to_visit.empty());
+      TaskGroup* current_group =
+          GetTaskGroupByTaskId(tasks_to_visit.back()->task_id());
+      tasks_to_visit.pop_back();
+
+      // Mark |current_group| as visited. If this fails, we've already added
+      // the group, and should skip over it.
+      if (!visited_groups.insert(current_group).second)
+        continue;
+
+      // Make a copy of |current_group->tasks()|, sort it, and append the ids.
+      current_group_tasks = current_group->tasks();
+      std::sort(current_group_tasks.begin(), current_group_tasks.end(),
+                comparator);
+      for (Task* task : current_group_tasks)
+        sorted_task_ids_.push_back(task->task_id());
+
+      // Find the children of the tasks we just added, and push them into
+      // |tasks_to_visit|, so that we visit them soon. Work in reverse order,
+      // so that we visit them in forward order.
+      for (Task* parent : base::Reversed(current_group_tasks)) {
+        auto children_of_parent = children.find(parent);
+        if (children_of_parent != children.end()) {
+          // Sort children[parent], and then append in reversed order.
+          std::sort(children_of_parent->second.begin(),
+                    children_of_parent->second.end(), comparator);
+          tasks_to_visit.insert(tasks_to_visit.end(),
+                                children_of_parent->second.rbegin(),
+                                children_of_parent->second.rend());
+        }
+      }
+    }
+    DCHECK_EQ(num_tasks, sorted_task_ids_.size());
+  }
+
+  return sorted_task_ids_;
+}
+
+TaskIdList TaskManagerImpl::GetIdsOfTasksSharingSameProcess(
+    TaskId task_id) const {
+  DCHECK(is_running_) << "Task manager is not running. You must observe the "
+      "task manager for it to start running";
+
+  TaskIdList result;
+  TaskGroup* group = GetTaskGroupByTaskId(task_id);
+  if (group) {
+    result.reserve(group->tasks().size());
+    for (Task* task : group->tasks())
+      result.push_back(task->task_id());
+  }
+  return result;
+}
+
+size_t TaskManagerImpl::GetNumberOfTasksOnSameProcess(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->num_tasks();
+}
+
+TaskId TaskManagerImpl::GetTaskIdForWebContents(
+    content::WebContents* web_contents) const {
+  if (!web_contents)
+    return -1;
+  content::RenderFrameHost* rfh = web_contents->GetMainFrame();
+  Task* task =
+      GetTaskByPidOrRoute(0, rfh->GetProcess()->GetID(), rfh->GetRoutingID());
+  if (!task)
+    return -1;
+  return task->task_id();
+}
+
+void TaskManagerImpl::TaskAdded(Task* task) {
+  DCHECK(task);
+
+  const base::ProcessId proc_id = task->process_id();
+  const TaskId task_id = task->task_id();
+
+  std::unique_ptr<TaskGroup>& task_group = task_groups_by_proc_id_[proc_id];
+  if (!task_group)
+    task_group.reset(new TaskGroup(task->process_handle(), proc_id,
+                                   on_background_data_ready_callback_,
+                                   shared_sampler_, blocking_pool_runner_));
+
+  task_group->AddTask(task);
+
+  task_groups_by_task_id_[task_id] = task_group.get();
+
+  // Invalidate the cached sorted IDs by clearing the list.
+  sorted_task_ids_.clear();
+
+  NotifyObserversOnTaskAdded(task_id);
+}
+
+void TaskManagerImpl::TaskRemoved(Task* task) {
+  DCHECK(task);
+
+  const base::ProcessId proc_id = task->process_id();
+  const TaskId task_id = task->task_id();
+
+  DCHECK(task_groups_by_proc_id_.count(proc_id));
+
+  NotifyObserversOnTaskToBeRemoved(task_id);
+
+  TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
+  task_group->RemoveTask(task);
+  task_groups_by_task_id_.erase(task_id);
+
+  if (task_group->empty())
+    task_groups_by_proc_id_.erase(proc_id);  // Deletes |task_group|.
+
+  // Invalidate the cached sorted IDs by clearing the list.
+  sorted_task_ids_.clear();
+}
+
+void TaskManagerImpl::TaskUnresponsive(Task* task) {
+  DCHECK(task);
+  NotifyObserversOnTaskUnresponsive(task->task_id());
+}
+
+void TaskManagerImpl::OnVideoMemoryUsageStatsUpdate(
+    const gpu::VideoMemoryUsageStats& gpu_memory_stats) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  gpu_memory_stats_ = gpu_memory_stats;
+}
+
+// static
+void TaskManagerImpl::OnMultipleBytesReadUI(
+    std::vector<BytesReadParam>* params) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  DCHECK(params);
+
+  for (BytesReadParam& param : *params) {
+    if (!GetInstance()->UpdateTasksWithBytesRead(param)) {
+      // We can't match a task to the notification.  That might mean the
+      // tab that started a download was closed, or the request may have had
+      // no originating task associated with it in the first place.
+      // We attribute orphaned/unaccounted activity to the Browser process.
+      DCHECK(param.origin_pid || (param.child_id != -1));
+
+      param.origin_pid = 0;
+      param.child_id = param.route_id = -1;
+
+      GetInstance()->UpdateTasksWithBytesRead(param);
+    }
+  }
+}
+
+void TaskManagerImpl::Refresh() {
+  if (IsResourceRefreshEnabled(REFRESH_TYPE_GPU_MEMORY)) {
+    content::GpuDataManager::GetInstance()->
+        RequestVideoMemoryUsageStatsUpdate();
+  }
+
+  for (auto& groups_itr : task_groups_by_proc_id_) {
+    groups_itr.second->Refresh(gpu_memory_stats_,
+                               GetCurrentRefreshTime(),
+                               enabled_resources_flags());
+  }
+
+  NotifyObserversOnRefresh(GetTaskIdsList());
+}
+
+void TaskManagerImpl::StartUpdating() {
+  if (is_running_)
+    return;
+
+  is_running_ = true;
+
+  for (const auto& provider : task_providers_)
+    provider->SetObserver(this);
+
+  io_thread_helper_manager_.reset(new IoThreadHelperManager);
+}
+
+void TaskManagerImpl::StopUpdating() {
+  if (!is_running_)
+    return;
+
+  is_running_ = false;
+
+  io_thread_helper_manager_.reset();
+
+  for (const auto& provider : task_providers_)
+    provider->ClearObserver();
+
+  task_groups_by_proc_id_.clear();
+  task_groups_by_task_id_.clear();
+  sorted_task_ids_.clear();
+}
+
+Task* TaskManagerImpl::GetTaskByPidOrRoute(int origin_pid,
+                                           int child_id,
+                                           int route_id) const {
+  for (const auto& task_provider : task_providers_) {
+    Task* task =
+        task_provider->GetTaskOfUrlRequest(origin_pid, child_id, route_id);
+    if (task)
+      return task;
+  }
+  return nullptr;
+}
+
+bool TaskManagerImpl::UpdateTasksWithBytesRead(const BytesReadParam& param) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  Task* task =
+      GetTaskByPidOrRoute(param.origin_pid, param.child_id, param.route_id);
+  if (task) {
+    task->OnNetworkBytesRead(param.byte_count);
+    return true;
+  }
+
+  // Couldn't match the bytes to any existing task.
+  return false;
+}
+
+TaskGroup* TaskManagerImpl::GetTaskGroupByTaskId(TaskId task_id) const {
+  auto it = task_groups_by_task_id_.find(task_id);
+  DCHECK(it != task_groups_by_task_id_.end());
+  return it->second;
+}
+
+Task* TaskManagerImpl::GetTaskByTaskId(TaskId task_id) const {
+  return GetTaskGroupByTaskId(task_id)->GetTaskById(task_id);
+}
+
+void TaskManagerImpl::OnTaskGroupBackgroundCalculationsDone() {
+  // TODO(afakhry): There should be a better way for doing this!
+  bool are_all_processes_data_ready = true;
+  for (const auto& groups_itr : task_groups_by_proc_id_) {
+    are_all_processes_data_ready &=
+        groups_itr.second->AreBackgroundCalculationsDone();
+  }
+  if (are_all_processes_data_ready) {
+    NotifyObserversOnRefreshWithBackgroundCalculations(GetTaskIdsList());
+    for (const auto& groups_itr : task_groups_by_proc_id_)
+      groups_itr.second->ClearCurrentBackgroundCalculationsFlags();
+  }
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_manager_impl.h b/chrome/browser/task_management/sampling/task_manager_impl.h
new file mode 100644
index 0000000..14a940a
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_manager_impl.h
@@ -0,0 +1,173 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IMPL_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IMPL_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/lazy_instance.h"
+#include "base/macros.h"
+#include "base/memory/scoped_vector.h"
+#include "base/sequenced_task_runner.h"
+#include "chrome/browser/task_management/providers/task_provider.h"
+#include "chrome/browser/task_management/providers/task_provider_observer.h"
+#include "chrome/browser/task_management/sampling/task_group.h"
+#include "chrome/browser/task_management/sampling/task_manager_io_thread_helper.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
+#include "content/public/browser/gpu_data_manager_observer.h"
+#include "gpu/ipc/common/memory_stats.h"
+
+namespace task_management {
+
+class SharedSampler;
+
+// Defines a concrete implementation of the TaskManagerInterface.
+class TaskManagerImpl :
+    public TaskManagerInterface,
+    public TaskProviderObserver,
+    content::GpuDataManagerObserver {
+ public:
+  ~TaskManagerImpl() override;
+
+  static TaskManagerImpl* GetInstance();
+
+  // task_management::TaskManagerInterface:
+  void ActivateTask(TaskId task_id) override;
+  bool IsTaskKillable(TaskId task_id) override;
+  void KillTask(TaskId task_id) override;
+  double GetCpuUsage(TaskId task_id) const override;
+  int64_t GetPhysicalMemoryUsage(TaskId task_id) const override;
+  int64_t GetPrivateMemoryUsage(TaskId task_id) const override;
+  int64_t GetSharedMemoryUsage(TaskId task_id) const override;
+  int64_t GetSwappedMemoryUsage(TaskId task_id) const override;
+  int64_t GetGpuMemoryUsage(TaskId task_id,
+                            bool* has_duplicates) const override;
+  int GetIdleWakeupsPerSecond(TaskId task_id) const override;
+  int GetNaClDebugStubPort(TaskId task_id) const override;
+  void GetGDIHandles(TaskId task_id,
+                     int64_t* current,
+                     int64_t* peak) const override;
+  void GetUSERHandles(TaskId task_id,
+                      int64_t* current,
+                      int64_t* peak) const override;
+  int GetOpenFdCount(TaskId task_id) const override;
+  bool IsTaskOnBackgroundedProcess(TaskId task_id) const override;
+  const base::string16& GetTitle(TaskId task_id) const override;
+  const std::string& GetTaskNameForRappor(TaskId task_id) const override;
+  base::string16 GetProfileName(TaskId task_id) const override;
+  const gfx::ImageSkia& GetIcon(TaskId task_id) const override;
+  const base::ProcessHandle& GetProcessHandle(TaskId task_id) const override;
+  const base::ProcessId& GetProcessId(TaskId task_id) const override;
+  Task::Type GetType(TaskId task_id) const override;
+  int GetTabId(TaskId task_id) const override;
+  int GetChildProcessUniqueId(TaskId task_id) const override;
+  void GetTerminationStatus(TaskId task_id,
+                            base::TerminationStatus* out_status,
+                            int* out_error_code) const override;
+  int64_t GetNetworkUsage(TaskId task_id) const override;
+  int64_t GetProcessTotalNetworkUsage(TaskId task_id) const override;
+  int64_t GetSqliteMemoryUsed(TaskId task_id) const override;
+  bool GetV8Memory(TaskId task_id,
+                   int64_t* allocated,
+                   int64_t* used) const override;
+  bool GetWebCacheStats(
+      TaskId task_id,
+      blink::WebCache::ResourceTypeStats* stats) const override;
+  const TaskIdList& GetTaskIdsList() const override;
+  TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const override;
+  size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const override;
+  TaskId GetTaskIdForWebContents(
+      content::WebContents* web_contents) const override;
+
+  // task_management::TaskProviderObserver:
+  void TaskAdded(Task* task) override;
+  void TaskRemoved(Task* task) override;
+  void TaskUnresponsive(Task* task) override;
+
+  // content::GpuDataManagerObserver:
+  void OnVideoMemoryUsageStatsUpdate(
+      const gpu::VideoMemoryUsageStats& gpu_memory_stats) override;
+
+  // The notification method on the UI thread when multiple bytes are read
+  // from URLRequests. This will be called by the |io_thread_helper_|
+  static void OnMultipleBytesReadUI(std::vector<BytesReadParam>* params);
+
+ private:
+  friend struct base::DefaultLazyInstanceTraits<TaskManagerImpl>;
+
+  TaskManagerImpl();
+
+  // task_management::TaskManagerInterface:
+  void Refresh() override;
+  void StartUpdating() override;
+  void StopUpdating() override;
+
+  // Lookup a task by its pid, child_id and possibly route_id.
+  Task* GetTaskByPidOrRoute(int pid, int child_id, int route_id) const;
+
+  // Based on |param| the appropriate task will be updated by its network usage.
+  // Returns true if it was able to match |param| to an existing task, returns
+  // false otherwise, at which point the caller must explicitly match these
+  // bytes to the browser process by calling this method again with
+  // |param.origin_pid = 0| and |param.child_id = param.route_id = -1|.
+  bool UpdateTasksWithBytesRead(const BytesReadParam& param);
+
+  TaskGroup* GetTaskGroupByTaskId(TaskId task_id) const;
+  Task* GetTaskByTaskId(TaskId task_id) const;
+
+  // Called back by a TaskGroup when the resource calculations done on the
+  // background thread has completed.
+  void OnTaskGroupBackgroundCalculationsDone();
+
+  const base::Closure on_background_data_ready_callback_;
+
+  // Map TaskGroups by the IDs of the processes they represent.
+  std::map<base::ProcessId, std::unique_ptr<TaskGroup>> task_groups_by_proc_id_;
+
+  // Map each task by its ID to the TaskGroup on which it resides.
+  // Keys are unique but values will have duplicates (i.e. multiple tasks
+  // running on the same process represented by a single TaskGroup).
+  std::map<TaskId, TaskGroup*> task_groups_by_task_id_;
+
+  // A cached sorted list of the task IDs.
+  mutable std::vector<TaskId> sorted_task_ids_;
+
+  // The manager of the IO thread helper used to handle network bytes
+  // notifications on IO thread. The manager itself lives on the UI thread, but
+  // the IO thread helper lives entirely on the IO thread.
+  std::unique_ptr<IoThreadHelperManager> io_thread_helper_manager_;
+
+  // The list of the task providers that are owned and observed by this task
+  // manager implementation.
+  std::vector<std::unique_ptr<TaskProvider>> task_providers_;
+
+  // The current GPU memory usage stats that was last received from the
+  // GpuDataManager.
+  gpu::VideoMemoryUsageStats gpu_memory_stats_;
+
+  // The specific blocking pool SequencedTaskRunner that will be used to make
+  // sure TaskGroupSampler posts their refreshes serially.
+  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
+
+  // A special sampler shared with all instances of TaskGroup that calculates a
+  // subset of resources for all processes at once.
+  scoped_refptr<SharedSampler> shared_sampler_;
+
+  // This will be set to true while there are observers and the task manager is
+  // running.
+  bool is_running_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerImpl);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IMPL_H_
diff --git a/chrome/browser/task_management/sampling/task_manager_impl_unittest.cc b/chrome/browser/task_management/sampling/task_manager_impl_unittest.cc
new file mode 100644
index 0000000..59c27f7
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_manager_impl_unittest.cc
@@ -0,0 +1,214 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/task_management/providers/task.h"
+#include "chrome/browser/task_management/sampling/task_manager_impl.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "content/public/test/test_browser_thread_bundle.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace task_management {
+
+namespace {
+
+// A Task for unittests, not backed by a real process, that can report any given
+// value.
+class FakeTask : public Task {
+ public:
+  FakeTask(base::ProcessId process_id,
+           Type type,
+           const std::string& title,
+           int tab_id)
+      : Task(base::ASCIIToUTF16(title),
+             "FakeTask",
+             nullptr,
+             base::kNullProcessHandle,
+             process_id),
+        type_(type),
+        parent_(nullptr),
+        tab_id_(tab_id) {
+    TaskManagerImpl::GetInstance()->TaskAdded(this);
+  }
+
+  ~FakeTask() override { TaskManagerImpl::GetInstance()->TaskRemoved(this); }
+
+  Type GetType() const override { return type_; }
+
+  int GetChildProcessUniqueID() const override { return 0; }
+
+  const Task* GetParentTask() const override { return parent_; }
+
+  int GetTabId() const override { return tab_id_; }
+
+  void SetParent(Task* parent) { parent_ = parent; }
+
+ private:
+  Type type_;
+  Task* parent_;
+  int tab_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeTask);
+};
+
+}  // namespace
+
+class TaskManagerImplTest : public testing::Test, public TaskManagerObserver {
+ public:
+  TaskManagerImplTest()
+      : TaskManagerObserver(base::TimeDelta::FromSeconds(1),
+                            REFRESH_TYPE_NONE) {
+    TaskManagerImpl::GetInstance()->AddObserver(this);
+  }
+  ~TaskManagerImplTest() override {
+    tasks_.clear();
+    observed_task_manager()->RemoveObserver(this);
+  }
+
+  FakeTask* AddTask(int pid_offset,
+                    Task::Type type,
+                    const std::string& title,
+                    int tab_id) {
+    // Offset based on the current process id, to avoid collisions with the
+    // browser process task.
+    base::ProcessId process_id = base::GetCurrentProcId() + pid_offset;
+    tasks_.emplace_back(new FakeTask(process_id, type, title, tab_id));
+    return tasks_.back().get();
+  }
+
+  std::string DumpSortedTasks() {
+    std::string result;
+    for (TaskId task_id : observed_task_manager()->GetTaskIdsList()) {
+      result += base::UTF16ToUTF8(observed_task_manager()->GetTitle(task_id));
+      result += "\n";
+    }
+    return result;
+  }
+
+ private:
+  content::TestBrowserThreadBundle thread_bundle_;
+  std::vector<std::unique_ptr<FakeTask>> tasks_;
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerImplTest);
+};
+
+TEST_F(TaskManagerImplTest, SortingTypes) {
+  AddTask(100, Task::GPU, "Gpu Process", -1);
+
+  Task* tab1 = AddTask(200, Task::RENDERER, "Tab One", 10);
+  AddTask(400, Task::EXTENSION, "Extension Subframe: Tab One", 10)
+      ->SetParent(tab1);
+  AddTask(300, Task::RENDERER, "Subframe: Tab One", 10)->SetParent(tab1);
+
+  Task* tab2 =
+      AddTask(200, Task::RENDERER, "Tab Two: sharing process with Tab One", 20);
+
+  AddTask(301, Task::RENDERER, "Subframe: Tab Two", 20)->SetParent(tab2);
+  AddTask(400, Task::EXTENSION, "Extension Subframe: Tab Two", 20)
+      ->SetParent(tab2);
+
+  AddTask(600, Task::ARC, "ARC", -1);
+  AddTask(800, Task::UTILITY, "Utility One", -1);
+  AddTask(700, Task::UTILITY, "Utility Two", -1);
+  AddTask(1000, Task::GUEST, "Guest", 20);
+  AddTask(900, Task::WORKER, "Worker", -1);
+  AddTask(500, Task::ZYGOTE, "Zygote", -1);
+
+  AddTask(300, Task::RENDERER, "Subframe: Tab One (2)", 10)->SetParent(tab1);
+  AddTask(300, Task::RENDERER, "Subframe: Tab One (third)", 10)
+      ->SetParent(tab1);
+  AddTask(300, Task::RENDERER, "Subframe: Tab One (4)", 10)->SetParent(tab1);
+
+  EXPECT_EQ(
+      "Browser\n"
+      "Gpu Process\n"
+      "ARC\n"
+      "Zygote\n"
+      "Utility One\n"
+      "Utility Two\n"
+      "Tab One\n"
+      "Tab Two: sharing process with Tab One\n"
+      "Subframe: Tab One\n"
+      "Subframe: Tab One (2)\n"
+      "Subframe: Tab One (third)\n"
+      "Subframe: Tab One (4)\n"
+      "Extension Subframe: Tab One\n"
+      "Extension Subframe: Tab Two\n"
+      "Subframe: Tab Two\n"
+      "Guest\n"
+      "Worker\n",
+      DumpSortedTasks());
+}
+
+TEST_F(TaskManagerImplTest, SortingCycles) {
+  // Two tabs, with subframes in the other's process. This induces a cycle in
+  // the TaskGroup dependencies, without being a cycle in the Tasks. This can
+  // happen in practice.
+  Task* tab1 = AddTask(200, Task::RENDERER, "Tab 1: Process 200", 10);
+  AddTask(300, Task::RENDERER, "Subframe in Tab 1: Process 300", 10)
+      ->SetParent(tab1);
+  Task* tab2 = AddTask(300, Task::RENDERER, "Tab 2: Process 300", 20);
+  AddTask(200, Task::RENDERER, "Subframe in Tab 2: Process 200", 20)
+      ->SetParent(tab2);
+
+  // Simulated GPU process.
+  AddTask(100, Task::GPU, "Gpu Process", -1);
+
+  // Two subframes that list each other as a parent (a true cycle). This
+  // shouldn't happen in practice, but we want the sorting code to handle it
+  // gracefully.
+  FakeTask* cycle1 = AddTask(501, Task::SANDBOX_HELPER, "Cycle 1", -1);
+  FakeTask* cycle2 = AddTask(500, Task::ARC, "Cycle 2", -1);
+  cycle1->SetParent(cycle2);
+  cycle2->SetParent(cycle1);
+
+  // A cycle where both elements are in the same group.
+  FakeTask* cycle3 = AddTask(600, Task::SANDBOX_HELPER, "Cycle 3", -1);
+  FakeTask* cycle4 = AddTask(600, Task::ARC, "Cycle 4", -1);
+  cycle3->SetParent(cycle4);
+  cycle4->SetParent(cycle3);
+
+  // Tasks listing a cycle as their parent.
+  FakeTask* lollipop5 = AddTask(701, Task::EXTENSION, "Child of Cycle 3", -1);
+  lollipop5->SetParent(cycle3);
+  FakeTask* lollipop6 = AddTask(700, Task::PLUGIN, "Child of Cycle 4", -1);
+  lollipop6->SetParent(cycle4);
+
+  // A task listing itself as parent.
+  FakeTask* self_cycle = AddTask(800, Task::RENDERER, "Self Cycle", 5);
+  self_cycle->SetParent(self_cycle);
+
+  // Add a plugin child to tab1 and tab2.
+  AddTask(900, Task::PLUGIN, "Plugin: Tab 2", 20)->SetParent(tab1);
+  AddTask(901, Task::PLUGIN, "Plugin: Tab 1", 10)->SetParent(tab1);
+
+  // Finish with a normal renderer task.
+  AddTask(903, Task::RENDERER, "Tab: Normal Renderer", 30);
+
+  // Cycles should wind up on the bottom of the list.
+  EXPECT_EQ(
+      "Browser\n"
+      "Gpu Process\n"
+      "Tab 1: Process 200\n"
+      "Subframe in Tab 2: Process 200\n"
+      "Tab 2: Process 300\n"
+      "Subframe in Tab 1: Process 300\n"
+      "Plugin: Tab 1\n"
+      "Plugin: Tab 2\n"
+      "Tab: Normal Renderer\n"
+      "Cycle 2\n"           // ARC
+      "Cycle 1\n"           // Child of 2
+      "Cycle 4\n"           // ARC; task_id > Cycle 2's
+      "Cycle 3\n"           // Same-process child of 4 (SANDBOX_HELPER > ARC)
+      "Child of Cycle 4\n"  // Child of 4
+      "Child of Cycle 3\n"  // Child of 3
+      "Self Cycle\n",       // RENDERER (> ARC)
+      DumpSortedTasks());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_manager_io_thread_helper.cc b/chrome/browser/task_management/sampling/task_manager_io_thread_helper.cc
new file mode 100644
index 0000000..aadade4
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_manager_io_thread_helper.cc
@@ -0,0 +1,127 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/sampling/task_manager_io_thread_helper.h"
+
+#include "chrome/browser/task_management/sampling/task_manager_impl.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+
+namespace task_management {
+
+namespace {
+
+TaskManagerIoThreadHelper* g_io_thread_helper = nullptr;
+
+}  // namespace
+
+IoThreadHelperManager::IoThreadHelperManager() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO,
+      FROM_HERE,
+      base::Bind(&TaskManagerIoThreadHelper::CreateInstance));
+}
+
+IoThreadHelperManager::~IoThreadHelperManager() {
+  // This may be called at exit time when the main thread is no longer
+  // registered as the UI thread.
+  DCHECK(
+      content::BrowserThread::CurrentlyOn(content::BrowserThread::UI) ||
+      !content::BrowserThread::IsMessageLoopValid(content::BrowserThread::UI));
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO,
+      FROM_HERE,
+      base::Bind(&TaskManagerIoThreadHelper::DeleteInstance));
+}
+
+// static
+void TaskManagerIoThreadHelper::CreateInstance() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  DCHECK(!g_io_thread_helper);
+
+  g_io_thread_helper = new TaskManagerIoThreadHelper;
+}
+
+// static
+void TaskManagerIoThreadHelper::DeleteInstance() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  delete g_io_thread_helper;
+  g_io_thread_helper = nullptr;
+}
+
+// static
+void TaskManagerIoThreadHelper::OnRawBytesRead(const net::URLRequest& request,
+                                               int64_t bytes_read) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  if (g_io_thread_helper)
+    g_io_thread_helper->OnNetworkBytesRead(request, bytes_read);
+}
+
+TaskManagerIoThreadHelper::TaskManagerIoThreadHelper() : weak_factory_(this) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+}
+
+TaskManagerIoThreadHelper::~TaskManagerIoThreadHelper() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+}
+
+void TaskManagerIoThreadHelper::OnMultipleBytesReadIO() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  DCHECK(!bytes_read_buffer_.empty());
+
+  std::vector<BytesReadParam>* bytes_read_buffer =
+      new std::vector<BytesReadParam>();
+  bytes_read_buffer_.swap(*bytes_read_buffer);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI,
+      FROM_HERE,
+      base::Bind(&TaskManagerImpl::OnMultipleBytesReadUI,
+                 base::Owned(bytes_read_buffer)));
+}
+
+void TaskManagerIoThreadHelper::OnNetworkBytesRead(
+    const net::URLRequest& request, int64_t bytes_read) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  // Only net::URLRequestJob instances created by the ResourceDispatcherHost
+  // have an associated ResourceRequestInfo and a render frame associated.
+  // All other jobs will have -1 returned for the render process child and
+  // routing ids - the jobs may still match a resource based on their origin id,
+  // otherwise BytesRead() will attribute the activity to the Browser resource.
+  const content::ResourceRequestInfo* info =
+      content::ResourceRequestInfo::ForRequest(&request);
+  int child_id = -1;
+  int route_id = -1;
+  if (info)
+    info->GetAssociatedRenderFrame(&child_id, &route_id);
+
+  // Get the origin PID of the request's originator.  This will only be set for
+  // plugins - for renderer or browser initiated requests it will be zero.
+  int origin_pid = info ? info->GetOriginPID() : 0;
+
+  if (bytes_read_buffer_.empty()) {
+    // Schedule a task to process the received bytes requests a second from now.
+    // We're trying to calculate the tasks' network usage speed as bytes per
+    // second so we collect as many requests during one seconds before the below
+    // delayed TaskManagerIoThreadHelper::OnMultipleBytesReadIO() process them
+    // after one second from now.
+    content::BrowserThread::PostDelayedTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&TaskManagerIoThreadHelper::OnMultipleBytesReadIO,
+                   weak_factory_.GetWeakPtr()),
+        base::TimeDelta::FromSeconds(1));
+  }
+
+  bytes_read_buffer_.push_back(
+      BytesReadParam(origin_pid, child_id, route_id, bytes_read));
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/sampling/task_manager_io_thread_helper.h b/chrome/browser/task_management/sampling/task_manager_io_thread_helper.h
new file mode 100644
index 0000000..6cdbb4c
--- /dev/null
+++ b/chrome/browser/task_management/sampling/task_manager_io_thread_helper.h
@@ -0,0 +1,98 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
+
+#include <stdint.h>
+
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+
+namespace net {
+class URLRequest;
+}  // namespace net
+
+namespace task_management {
+
+// Defines a wrapper of values that will be sent from IO to UI thread upon
+// reception of bytes read notifications.
+struct BytesReadParam {
+  // The PID of the originating process of the URLRequest, if the request is
+  // sent on behalf of another process. Otherwise it's 0.
+  int origin_pid;
+
+  // The unique ID of the host of the child process requestor.
+  int child_id;
+
+  // The ID of the IPC route for the URLRequest (this identifies the
+  // RenderView or like-thing in the renderer that the request gets routed
+  // to).
+  int route_id;
+
+  // The number of bytes read.
+  int64_t byte_count;
+
+  BytesReadParam(int origin_pid,
+                 int child_id,
+                 int route_id,
+                 int64_t byte_count)
+      : origin_pid(origin_pid),
+        child_id(child_id),
+        route_id(route_id),
+        byte_count(byte_count) {
+  }
+};
+
+// Defines a utility class used to schedule the creation and removal of the
+// TaskManagerIoThreadHelper on the IO thread.
+class IoThreadHelperManager {
+ public:
+  IoThreadHelperManager();
+  ~IoThreadHelperManager();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(IoThreadHelperManager);
+};
+
+// Defines a class used by the task manager to receive notifications of the
+// network bytes read by the various tasks.
+// This object lives entirely only on the IO thread.
+class TaskManagerIoThreadHelper {
+ public:
+  // Create and delete the instance of this class. They must be called on the IO
+  // thread.
+  static void CreateInstance();
+  static void DeleteInstance();
+
+  // This is used to forward the call to update the network bytes from the
+  // TaskManagerInterface if the new task manager is enabled.
+  static void OnRawBytesRead(const net::URLRequest& request,
+                             int64_t bytes_read);
+
+ private:
+  TaskManagerIoThreadHelper();
+  ~TaskManagerIoThreadHelper();
+
+  // We gather multiple notifications on the IO thread in one second before a
+  // call is made to the following function to start the processing.
+  void OnMultipleBytesReadIO();
+
+  // This will update the task manager with the network bytes read.
+  void OnNetworkBytesRead(const net::URLRequest& request, int64_t bytes_read);
+
+  // This buffer will be filled on IO thread with information about the number
+  // of bytes read from URLRequests.
+  std::vector<BytesReadParam> bytes_read_buffer_;
+
+  base::WeakPtrFactory<TaskManagerIoThreadHelper> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerIoThreadHelper);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
diff --git a/chrome/browser/task_management/task_manager_browsertest.cc b/chrome/browser/task_management/task_manager_browsertest.cc
new file mode 100644
index 0000000..45bf23a
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_browsertest.cc
@@ -0,0 +1,1295 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/path_service.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "build/build_config.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/devtools/devtools_window_testing.h"
+#include "chrome/browser/extensions/extension_browsertest.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/infobars/infobar_service.h"
+#include "chrome/browser/notifications/notification.h"
+#include "chrome/browser/notifications/notification_test_util.h"
+#include "chrome/browser/notifications/notification_ui_manager.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_tester.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_commands.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/panels/panel.h"
+#include "chrome/browser/ui/panels/panel_manager.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/web_applications/web_app.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/infobars/core/confirm_infobar_delegate.h"
+#include "components/infobars/core/infobar.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/page_navigator.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/test/browser_test_utils.h"
+#include "content/public/test/content_browser_test_utils.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/common/extension.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/page_transition_types.h"
+
+using content::WebContents;
+using task_management::browsertest_util::ColumnSpecifier;
+using task_management::browsertest_util::MatchAboutBlankTab;
+using task_management::browsertest_util::MatchAnyApp;
+using task_management::browsertest_util::MatchAnyExtension;
+using task_management::browsertest_util::MatchAnySubframe;
+using task_management::browsertest_util::MatchAnyTab;
+using task_management::browsertest_util::MatchAnyUtility;
+using task_management::browsertest_util::MatchApp;
+using task_management::browsertest_util::MatchExtension;
+using task_management::browsertest_util::MatchSubframe;
+using task_management::browsertest_util::MatchTab;
+using task_management::browsertest_util::MatchUtility;
+using task_management::browsertest_util::WaitForTaskManagerRows;
+using task_management::browsertest_util::WaitForTaskManagerStatToExceed;
+
+namespace {
+
+const base::FilePath::CharType* kTitle1File = FILE_PATH_LITERAL("title1.html");
+
+}  // namespace
+
+class TaskManagerBrowserTest : public ExtensionBrowserTest {
+ public:
+  TaskManagerBrowserTest() {}
+  ~TaskManagerBrowserTest() override {}
+
+  task_management::TaskManagerTester* model() { return model_.get(); }
+
+  void ShowTaskManager() {
+    // Show the task manager. This populates the model, and helps with debugging
+    // (you see the task manager).
+    chrome::ShowTaskManager(browser());
+    model_ = task_management::TaskManagerTester::Create(
+        base::Bind(&TaskManagerBrowserTest::TaskManagerTableModelSanityCheck,
+                   base::Unretained(this)));
+  }
+
+  void HideTaskManager() {
+    model_.reset();
+
+    // Hide the task manager, and wait for it to go.
+    chrome::HideTaskManager();
+    base::RunLoop().RunUntilIdle();  // OnWindowClosed happens asynchronously.
+  }
+
+  GURL GetTestURL() {
+    return ui_test_utils::GetTestUrl(
+        base::FilePath(base::FilePath::kCurrentDirectory),
+        base::FilePath(kTitle1File));
+  }
+
+  int FindResourceIndex(const base::string16& title) {
+    for (int i = 0; i < model_->GetRowCount(); ++i) {
+      if (title == model_->GetRowTitle(i))
+        return i;
+    }
+    return -1;
+  }
+
+ protected:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    ExtensionBrowserTest::SetUpCommandLine(command_line);
+
+    // Do not launch device discovery process.
+    command_line->AppendSwitch(switches::kDisableDeviceDiscoveryNotifications);
+  }
+
+  void TearDownOnMainThread() override { model_.reset(); }
+
+  void SetUpOnMainThread() override {
+    host_resolver()->AddRule("*", "127.0.0.1");
+
+    // Add content/test/data so we can use cross_site_iframe_factory.html
+    base::FilePath test_data_dir;
+    ASSERT_TRUE(base::PathService::Get(base::DIR_SOURCE_ROOT, &test_data_dir));
+    embedded_test_server()->ServeFilesFromDirectory(
+        test_data_dir.AppendASCII("content/test/data/"));
+    ASSERT_TRUE(embedded_test_server()->Start());
+    content::SetupCrossSiteRedirector(embedded_test_server());
+  }
+
+ private:
+  void TaskManagerTableModelSanityCheck() {
+    // Ensure the groups are self-consistent.
+    for (int i = 0; i < model()->GetRowCount(); ++i) {
+      int start, length;
+      model()->GetRowsGroupRange(i, &start, &length);
+      for (int j = 0; j < length; ++j) {
+        int start2, length2;
+        model()->GetRowsGroupRange(start + j, &start2, &length2);
+        EXPECT_EQ(start, start2);
+        EXPECT_EQ(length, length2);
+      }
+    }
+  }
+
+  std::unique_ptr<task_management::TaskManagerTester> model_;
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerBrowserTest);
+};
+
+class TaskManagerUtilityProcessBrowserTest : public TaskManagerBrowserTest {
+ public:
+  TaskManagerUtilityProcessBrowserTest() {}
+
+ protected:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    TaskManagerBrowserTest::SetUpCommandLine(command_line);
+
+    // Enable out-of-process proxy resolver. Use a trivial PAC script to ensure
+    // that some javascript is being executed.
+    command_line->AppendSwitch(switches::kV8PacMojoOutOfProcess);
+    command_line->AppendSwitchASCII(
+        switches::kProxyPacUrl,
+        "data:,function FindProxyForURL(url, host){return \"DIRECT;\";}");
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerUtilityProcessBrowserTest);
+};
+
+// Parameterized variant of TaskManagerBrowserTest which runs with/without
+// --site-per-process, which enables out of process iframes (OOPIFs).
+class TaskManagerOOPIFBrowserTest : public TaskManagerBrowserTest,
+                                    public testing::WithParamInterface<bool> {
+ public:
+  TaskManagerOOPIFBrowserTest() {}
+
+ protected:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    TaskManagerBrowserTest::SetUpCommandLine(command_line);
+    if (GetParam())
+      content::IsolateAllSitesForTesting(command_line);
+  }
+
+  bool ShouldExpectSubframes() {
+    return content::AreAllSitesIsolatedForTesting();
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerOOPIFBrowserTest);
+};
+
+INSTANTIATE_TEST_CASE_P(, TaskManagerOOPIFBrowserTest, ::testing::Bool());
+
+#if defined(OS_MACOSX) || defined(OS_LINUX)
+#define MAYBE_ShutdownWhileOpen DISABLED_ShutdownWhileOpen
+#else
+#define MAYBE_ShutdownWhileOpen ShutdownWhileOpen
+#endif
+
+// Regression test for http://crbug.com/13361
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, MAYBE_ShutdownWhileOpen) {
+  ShowTaskManager();
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeTabContentsChanges) {
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
+
+  // Open a new tab and make sure the task manager notices it.
+  AddTabAtIndex(0, GetTestURL(), ui::PAGE_TRANSITION_TYPED);
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+
+  // Close the tab and verify that we notice.
+  browser()->tab_strip_model()->CloseWebContentsAt(0,
+                                                   TabStripModel::CLOSE_NONE);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillTab) {
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
+
+  // Open a new tab and make sure the task manager notices it.
+  AddTabAtIndex(0, GetTestURL(), ui::PAGE_TRANSITION_TYPED);
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+
+  // Killing the tab via task manager should remove the row.
+  int tab = FindResourceIndex(MatchTab("title1.html"));
+  ASSERT_NE(-1, tab);
+  ASSERT_NE(-1, model()->GetTabId(tab));
+  model()->Kill(tab);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Tab should reappear in task manager upon reload.
+  chrome::Reload(browser(), CURRENT_TAB);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+}
+
+// Regression test for http://crbug.com/444945.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NavigateAwayFromHungRenderer) {
+  ShowTaskManager();
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  GURL url1(embedded_test_server()->GetURL("/title2.html"));
+  GURL url3(embedded_test_server()->GetURL("a.com", "/iframe.html"));
+
+  // Open a new tab and make sure the task manager notices it.
+  AddTabAtIndex(0, url1, ui::PAGE_TRANSITION_TYPED);
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  WebContents* tab1 = browser()->tab_strip_model()->GetActiveWebContents();
+
+  // Initiate a navigation that will create a new WebContents in the same
+  // SiteInstance. Then immediately hang the renderer so that title3.html can't
+  // load in this process.
+  content::WebContentsAddedObserver web_contents_added_observer;
+  int dummy_value = 0;
+  ASSERT_TRUE(content::ExecuteScriptAndExtractInt(
+      tab1->GetMainFrame(),
+      "window.open('title3.html', '_blank');\n"
+      "window.domAutomationController.send(55);\n"
+      "while(1);",
+      &dummy_value));
+
+  // Blocks until a new WebContents appears as a result of window.open().
+  WebContents* tab2 = web_contents_added_observer.GetWebContents();
+
+  // Make sure the new WebContents is in tab1's hung renderer process.
+  ASSERT_NE(nullptr, tab2);
+  ASSERT_NE(tab1, tab2);
+  ASSERT_EQ(tab1->GetMainFrame()->GetProcess(),
+            tab2->GetMainFrame()->GetProcess())
+      << "New WebContents must be in the same process as the old WebContents, "
+      << "so that the new tab doesn't finish loading (what this test is all "
+      << "about)";
+  ASSERT_EQ(tab1->GetSiteInstance(), tab2->GetSiteInstance())
+      << "New WebContents must initially be in the same site instance as the "
+      << "old WebContents";
+
+  // Now navigate this tab to a different site. This should wind up in a
+  // different renderer process, so it should complete and show up in the task
+  // manager.
+  tab2->OpenURL(content::OpenURLParams(url3, content::Referrer(), CURRENT_TAB,
+                                       ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticePanel) {
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
+                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                    .AppendASCII("1.0.0.0")));
+
+  // Open a new panel to an extension url.
+  GURL url(
+    "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/french_sentence.html");
+  Panel* docked_panel = PanelManager::GetInstance()->CreatePanel(
+      web_app::GenerateApplicationNameFromExtensionId(
+          last_loaded_extension_id()),
+      browser()->profile(), url, nullptr, gfx::Rect(300, 400),
+      PanelManager::CREATE_AS_DOCKED);
+  docked_panel->Show();
+
+  // Make sure that a task manager model created after the panel shows the
+  // existence of the panel and the extension.
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      1,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Create a second, detached panel.
+  Panel* detached_panel = PanelManager::GetInstance()->CreatePanel(
+      web_app::GenerateApplicationNameFromExtensionId(
+          last_loaded_extension_id()),
+      browser()->profile(), url, nullptr, gfx::Rect(150, 150),
+      PanelManager::CREATE_AS_DETACHED);
+  detached_panel->ShowInactive();
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      2, MatchExtension("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+                        "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyExtension()));
+
+  // Close the panels and verify that we notice.
+  docked_panel->Close();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      1, MatchExtension("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+                        "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+
+  detached_panel->Close();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      0,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticePanelChanges) {
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
+                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                    .AppendASCII("1.0.0.0")));
+
+  // Browser, the New Tab Page and Extension background page.
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Open a new panel to an extension url and make sure we notice that.
+  GURL url(
+    "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/french_sentence.html");
+  Panel* panel = PanelManager::GetInstance()->CreatePanel(
+      web_app::GenerateApplicationNameFromExtensionId(
+          last_loaded_extension_id()),
+      browser()->profile(),
+      url,
+      nullptr,
+      gfx::Rect(300, 400),
+      PanelManager::CREATE_AS_DOCKED);
+  panel->ShowInactive();
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      1,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Close the panel and verify that we notice.
+  panel->Close();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      0,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+
+  // Unload extension.
+  UnloadExtension(last_loaded_extension_id());
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+}
+
+// Kills a process that has more than one task manager entry.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillPanelViaExtensionResource) {
+  ShowTaskManager();
+  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
+                                .AppendASCII("Extensions")
+                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                                .AppendASCII("1.0.0.0")));
+
+  // Open a new panel to an extension url.
+  GURL url(
+      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+      "french_sentence.html");
+  Panel* panel = PanelManager::GetInstance()->CreatePanel(
+      web_app::GenerateApplicationNameFromExtensionId(
+          last_loaded_extension_id()),
+      browser()->profile(),
+      url,
+      nullptr,
+      gfx::Rect(300, 400),
+      PanelManager::CREATE_AS_DETACHED);
+  panel->Show();
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      1,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Kill the process via the BACKGROUND PAGE (not the panel). Verify that both
+  // the background page and the panel go away from the task manager.
+  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
+  ASSERT_NE(-1, background_page);
+  ASSERT_EQ(-1, model()->GetTabId(background_page));
+  model()->Kill(background_page);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+}
+
+// Kills a process that has more than one task manager entry. This test is the
+// same as KillPanelViaExtensionResource except it does the kill via the other
+// entry.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillPanelViaPanelResource) {
+  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
+                                .AppendASCII("Extensions")
+                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                                .AppendASCII("1.0.0.0")));
+
+  // Open a new panel to an extension url.
+  GURL url(
+      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+      "french_sentence.html");
+  Panel* panel = PanelManager::GetInstance()->CreatePanel(
+      web_app::GenerateApplicationNameFromExtensionId(
+          last_loaded_extension_id()),
+      browser()->profile(),
+      url,
+      nullptr,
+      gfx::Rect(300, 400),
+      PanelManager::CREATE_AS_DETACHED);
+  panel->ShowInactive();
+
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
+      1,
+      MatchExtension(
+          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+          "french_sentence.html")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
+  ASSERT_NE(-1, background_page);
+  ASSERT_EQ(-1, model()->GetTabId(background_page));
+
+  // Kill the process via the PANEL RESOURCE (not the background page). Verify
+  // that both the background page and the panel go away from the task manager.
+  int panel_index = FindResourceIndex(MatchExtension(
+      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
+      "french_sentence.html"));
+  ASSERT_NE(-1, panel_index);
+  ASSERT_NE(-1, model()->GetTabId(panel_index));
+  model()->Kill(panel_index);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeExtensionTabChanges) {
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
+                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                    .AppendASCII("1.0.0.0")));
+
+  // Browser, Extension background page, and the New Tab Page.
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  // Open a new tab to an extension URL. Afterwards, the third entry (background
+  // page) should be an extension resource whose title starts with "Extension:".
+  // The fourth entry (page.html) is also of type extension and has both a
+  // WebContents and an extension. The title should start with "Extension:".
+  GURL url("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/page.html");
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchExtension("Foobar")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  int extension_tab = FindResourceIndex(MatchExtension("Foobar"));
+  ASSERT_NE(-1, extension_tab);
+  ASSERT_NE(-1, model()->GetTabId(extension_tab));
+
+  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
+  ASSERT_NE(-1, background_page);
+  ASSERT_EQ(-1, model()->GetTabId(background_page));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeExtensionTab) {
+  // With the task manager closed, open a new tab to an extension URL.
+  // Afterwards, when we open the task manager, the third entry (background
+  // page) should be an extension resource whose title starts with "Extension:".
+  // The fourth entry (page.html) is also of type extension and has both a
+  // WebContents and an extension. The title should start with "Extension:".
+  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
+                                .AppendASCII("Extensions")
+                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
+                                .AppendASCII("1.0.0.0")));
+  GURL url("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/page.html");
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchExtension("Foobar")));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  int extension_tab = FindResourceIndex(MatchExtension("Foobar"));
+  ASSERT_NE(-1, extension_tab);
+  ASSERT_NE(-1, model()->GetTabId(extension_tab));
+
+  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
+  ASSERT_NE(-1, background_page);
+  ASSERT_EQ(-1, model()->GetTabId(background_page));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeAppTabChanges) {
+  ShowTaskManager();
+
+  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("packaged_app")));
+  ExtensionService* service = extensions::ExtensionSystem::Get(
+                                  browser()->profile())->extension_service();
+  const extensions::Extension* extension =
+      service->GetExtensionById(last_loaded_extension_id(), false);
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
+
+  // Open a new tab to the app's launch URL and make sure we notice that.
+  GURL url(extension->GetResourceURL("main.html"));
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+
+  // There should be 1 "App: " tab and the original new tab page.
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchApp("Packaged App Test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+
+  // Check that the third entry (main.html) is of type extension and has both
+  // a tab contents and an extension.
+  int app_tab = FindResourceIndex(MatchApp("Packaged App Test"));
+  ASSERT_NE(-1, app_tab);
+  ASSERT_NE(-1, model()->GetTabId(app_tab));
+  ASSERT_EQ(2, browser()->tab_strip_model()->count());
+
+  // Unload extension to make sure the tab goes away.
+  UnloadExtension(last_loaded_extension_id());
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_EQ(1, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeAppTab) {
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("packaged_app")));
+  ExtensionService* service = extensions::ExtensionSystem::Get(
+      browser()->profile())->extension_service();
+  const extensions::Extension* extension =
+      service->GetExtensionById(last_loaded_extension_id(), false);
+
+  // Open a new tab to the app's launch URL and make sure we notice that.
+  GURL url(extension->GetResourceURL("main.html"));
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+
+  ShowTaskManager();
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchApp("Packaged App Test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
+
+  // Check that the third entry (main.html) is of type extension and has both
+  // a tab contents and an extension.
+  int app_tab = FindResourceIndex(MatchApp("Packaged App Test"));
+  ASSERT_NE(-1, app_tab);
+  ASSERT_NE(-1, model()->GetTabId(app_tab));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabChanges) {
+  ShowTaskManager();
+
+  // The app under test acts on URLs whose host is "localhost",
+  // so the URLs we navigate to must have host "localhost".
+  GURL::Replacements replace_host;
+  replace_host.SetHostStr("localhost");
+  GURL base_url = embedded_test_server()->GetURL(
+      "/extensions/api_test/app_process/");
+  base_url = base_url.ReplaceComponents(replace_host);
+
+  // Open a new tab to an app URL before the app is loaded.
+  GURL url(base_url.Resolve("path1/empty.html"));
+  content::WindowedNotificationObserver observer(
+      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
+      content::NotificationService::AllSources());
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+  observer.Wait();
+
+  // Check that the new entry's title starts with "Tab:".
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+
+  // Load the hosted app and make sure it still starts with "Tab:",
+  // since it hasn't changed to an app process yet.
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
+  // Force the TaskManager to query the title.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("Unmodified")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+
+  // Now reload and check that the last entry's title now starts with "App:".
+  ui_test_utils::NavigateToURL(browser(), url);
+
+  // Force the TaskManager to query the title.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchApp("Unmodified")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+
+  // Disable extension and reload.
+  DisableExtension(last_loaded_extension_id());
+  ui_test_utils::NavigateToURL(browser(), url);
+
+  // The hosted app should now show up as a normal "Tab: ".
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("Unmodified")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabAfterReload) {
+  // The app under test acts on URLs whose host is "localhost",
+  // so the URLs we navigate to must have host "localhost".
+  GURL base_url = embedded_test_server()->GetURL(
+      "localhost", "/extensions/api_test/app_process/");
+
+  // Open a new tab to an app URL before the app is loaded.
+  GURL url(base_url.Resolve("path1/empty.html"));
+  content::WindowedNotificationObserver observer(
+      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
+      content::NotificationService::AllSources());
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+  observer.Wait();
+
+  // Load the hosted app and make sure it still starts with "Tab:",
+  // since it hasn't changed to an app process yet.
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
+
+  // Now reload, which should transition this tab to being an App.
+  ui_test_utils::NavigateToURL(browser(), url);
+
+  ShowTaskManager();
+
+  // The TaskManager should show this as an "App: "
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabBeforeReload) {
+  // The app under test acts on URLs whose host is "localhost",
+  // so the URLs we navigate to must have host "localhost".
+  GURL base_url = embedded_test_server()->GetURL(
+      "localhost", "/extensions/api_test/app_process/");
+
+  // Open a new tab to an app URL before the app is loaded.
+  GURL url(base_url.Resolve("path1/empty.html"));
+  content::WindowedNotificationObserver observer(
+      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
+      content::NotificationService::AllSources());
+  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
+  observer.Wait();
+
+  // Load the hosted app and make sure it still starts with "Tab:",
+  // since it hasn't changed to an app process yet.
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
+
+  ShowTaskManager();
+
+  // The TaskManager should show this as a "Tab: " because the page hasn't been
+  // reloaded since the hosted app was installed.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
+}
+
+// Regression test for http://crbug.com/18693.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, ReloadExtension) {
+  ShowTaskManager();
+  ASSERT_TRUE(LoadExtension(
+      test_data_dir_.AppendASCII("common").AppendASCII("background_page")));
+
+  // Wait until we see the loaded extension in the task manager (the three
+  // resources are: the browser process, New Tab Page, and the extension).
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchExtension("background_page")));
+
+  // Reload the extension a few times and make sure our resource count doesn't
+  // increase.
+  std::string extension_id = last_loaded_extension_id();
+  for (int i = 1; i <= 5; i++) {
+    SCOPED_TRACE(testing::Message() << "Reloading extension for the " << i
+                                    << "th time.");
+    ReloadExtension(extension_id);
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchExtension("background_page")));
+  }
+}
+
+// Checks that task manager counts a worker thread JS heap size.
+// http://crbug.com/241066
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, WebWorkerJSHeapMemory) {
+  ShowTaskManager();
+  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
+  ui_test_utils::NavigateToURL(browser(), GetTestURL());
+  size_t minimal_heap_size = 4 * 1024 * 1024 * sizeof(void*);
+  std::string test_js = base::StringPrintf(
+      "var blob = new Blob([\n"
+      "    'mem = new Array(%lu);',\n"
+      "    'for (var i = 0; i < mem.length; i += 16)',"
+      "    '  mem[i] = i;',\n"
+      "    'postMessage(\"okay\");']);\n"
+      "blobURL = window.URL.createObjectURL(blob);\n"
+      "var worker = new Worker(blobURL);\n"
+      "worker.addEventListener('message', function(e) {\n"
+      "  window.domAutomationController.send(e.data);\n"  // e.data == "okay"
+      "});\n"
+      "worker.postMessage('go');\n",
+      static_cast<unsigned long>(minimal_heap_size));
+  std::string ok;
+  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
+      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
+  ASSERT_EQ("okay", ok);
+
+  // The worker has allocated objects of at least |minimal_heap_size| bytes.
+  // Wait for the heap stats to reflect this.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY, minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY_USED,
+      minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+}
+
+// Checks that task manager counts renderer JS heap size.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, JSHeapMemory) {
+  ShowTaskManager();
+  ui_test_utils::NavigateToURL(browser(), GetTestURL());
+  size_t minimal_heap_size = 4 * 1024 * 1024 * sizeof(void*);
+  std::string test_js = base::StringPrintf(
+      "mem = new Array(%lu);\n"
+      "for (var i = 0; i < mem.length; i += 16)\n"
+      "  mem[i] = i;\n"
+      "window.domAutomationController.send(\"okay\");\n",
+      static_cast<unsigned long>(minimal_heap_size));
+  std::string ok;
+  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
+      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
+  ASSERT_EQ("okay", ok);
+
+  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
+
+  // The page's js has allocated objects of at least |minimal_heap_size| bytes.
+  // Wait for the heap stats to reflect this.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY, minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY_USED,
+      minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+}
+
+// Checks that task manager counts idle wakeups.
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest,
+                       IdleWakeups) {
+  ShowTaskManager();
+  model()->ToggleColumnVisibility(ColumnSpecifier::IDLE_WAKEUPS);
+
+  ui_test_utils::NavigateToURL(browser(), GetTestURL());
+
+  std::string test_js =
+    "function myWait() {\n"
+    "  setTimeout(function() { myWait(); }, 1)\n"
+    "}\n"
+    "myWait();\n"
+    "window.domAutomationController.send(\"okay\");\n";
+
+  std::string ok;
+  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
+      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
+  ASSERT_EQ("okay", ok);
+
+  // The script above should trigger a lot of idle wakeups - up to 1000 per
+  // second. Let's make sure we get at least 100 (in case the test runs slow).
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchTab("title1.html"), ColumnSpecifier::IDLE_WAKEUPS, 100));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
+}
+
+// Checks that task manager counts utility process JS heap size.
+IN_PROC_BROWSER_TEST_F(TaskManagerUtilityProcessBrowserTest,
+                       UtilityJSHeapMemory) {
+  ShowTaskManager();
+  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
+
+  auto proxy_resolver_name =
+      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PROXY_RESOLVER_NAME);
+  ui_test_utils::NavigateToURL(browser(), GetTestURL());
+  // The PAC script is trivial, so don't expect a large heap.
+  size_t minimal_heap_size = 1024;
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchUtility(proxy_resolver_name), ColumnSpecifier::V8_MEMORY,
+      minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
+      MatchUtility(proxy_resolver_name), ColumnSpecifier::V8_MEMORY_USED,
+      minimal_heap_size));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyUtility()));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchUtility(proxy_resolver_name)));
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsNewDockedWindow) {
+  ShowTaskManager();  // Task manager shown BEFORE dev tools window.
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  DevToolsWindow* devtools =
+      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), true);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsNewUndockedWindow) {
+  ShowTaskManager();  // Task manager shown BEFORE dev tools window.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  DevToolsWindow* devtools =
+      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), false);
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
+  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsOldDockedWindow) {
+  DevToolsWindow* devtools =
+      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), true);
+  ShowTaskManager();  // Task manager shown AFTER dev tools window.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
+  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
+}
+
+IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsOldUndockedWindow) {
+  DevToolsWindow* devtools =
+      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), false);
+  ShowTaskManager();  // Task manager shown AFTER dev tools window.
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
+  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
+}
+
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, KillSubframe) {
+  ShowTaskManager();
+
+  GURL main_url(embedded_test_server()->GetURL(
+      "/cross-site/a.com/iframe_cross_site.html"));
+  browser()->OpenURL(content::OpenURLParams(main_url, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+    int subframe_b = FindResourceIndex(MatchSubframe("http://b.com/"));
+    ASSERT_NE(-1, subframe_b);
+    ASSERT_NE(-1, model()->GetTabId(subframe_b));
+
+    model()->Kill(subframe_b);
+
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  }
+
+  HideTaskManager();
+  ShowTaskManager();
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  }
+}
+
+// Tests what happens when a tab navigates to a site (a.com) that it previously
+// has a cross-process subframe into (b.com).
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, NavigateToSubframeProcess) {
+  ShowTaskManager();
+
+  // Navigate the tab to a page on a.com with cross-process subframes to
+  // b.com and c.com.
+  GURL a_dotcom(embedded_test_server()->GetURL(
+      "/cross-site/a.com/iframe_cross_site.html"));
+  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+  }
+
+  // Now navigate to a page on b.com with a simple (same-site) iframe.
+  // This should not show any subframe resources in the task manager.
+  GURL b_dotcom(
+      embedded_test_server()->GetURL("/cross-site/b.com/iframe.html"));
+
+  browser()->OpenURL(content::OpenURLParams(b_dotcom, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  HideTaskManager();
+  ShowTaskManager();
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+}
+
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
+                       NavigateToSiteWithSubframeToOriginalSite) {
+  ShowTaskManager();
+
+  // Navigate to a page on b.com with a simple (same-site) iframe.
+  // This should not show any subframe resources in the task manager.
+  GURL b_dotcom(
+      embedded_test_server()->GetURL("/cross-site/b.com/iframe.html"));
+
+  browser()->OpenURL(content::OpenURLParams(b_dotcom, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+
+  // Now navigate the tab to a page on a.com with cross-process subframes to
+  // b.com and c.com.
+  GURL a_dotcom(embedded_test_server()->GetURL(
+      "/cross-site/a.com/iframe_cross_site.html"));
+  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+  }
+
+  HideTaskManager();
+  ShowTaskManager();
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+  }
+}
+
+// Tests what happens when a tab navigates a cross-frame iframe (to b.com)
+// back to the site of the parent document (a.com).
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
+                       CrossSiteIframeBecomesSameSite) {
+  ShowTaskManager();
+
+  // Navigate the tab to a page on a.com with cross-process subframes to
+  // b.com and c.com.
+  GURL a_dotcom(embedded_test_server()->GetURL(
+      "/cross-site/a.com/iframe_cross_site.html"));
+  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+  }
+
+  // Navigate the b.com frame back to a.com. It is no longer a cross-site iframe
+  ASSERT_TRUE(content::ExecuteScript(
+      browser()->tab_strip_model()->GetActiveWebContents()->GetMainFrame(),
+      "document.getElementById('frame1').src='/title1.html';"
+      "document.title='aac';"));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
+  }
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  HideTaskManager();
+  ShowTaskManager();
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
+  }
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+}
+
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
+                       LeavePageWithCrossSiteIframes) {
+  ShowTaskManager();
+
+  // Navigate the tab to a page on a.com with cross-process subframes.
+  GURL a_dotcom_with_iframes(embedded_test_server()->GetURL(
+      "/cross-site/a.com/iframe_cross_site.html"));
+  browser()->OpenURL(content::OpenURLParams(a_dotcom_with_iframes,
+                                            content::Referrer(), CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
+
+  if (!ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
+  }
+
+  // Navigate the tab to a page on a.com without cross-process subframes, and
+  // the subframe processes should disappear.
+  GURL a_dotcom_simple(
+      embedded_test_server()->GetURL("/cross-site/a.com/title2.html"));
+  browser()->OpenURL(content::OpenURLParams(a_dotcom_simple,
+                                            content::Referrer(), CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+
+  HideTaskManager();
+  ShowTaskManager();
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
+  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+}
+
+IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, OrderingOfDependentRows) {
+  ShowTaskManager();
+
+  GURL a_with_frames(embedded_test_server()->GetURL(
+      "a.com", "/cross_site_iframe_factory.html?a(b,b,c(d,a,b,c))"));
+  browser()->OpenURL(content::OpenURLParams(a_with_frames, content::Referrer(),
+                                            CURRENT_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  if (ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://d.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnySubframe()));
+  }
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(1, MatchTab("Cross-site iframe factory")));
+
+  int index = FindResourceIndex(MatchTab("Cross-site iframe factory"));
+  std::vector<int> subframe_offsets;
+  if (ShouldExpectSubframes()) {
+    subframe_offsets = {
+        FindResourceIndex(MatchSubframe("http://b.com/")) - index,
+        FindResourceIndex(MatchSubframe("http://c.com/")) - index,
+        FindResourceIndex(MatchSubframe("http://d.com/")) - index};
+    EXPECT_THAT(subframe_offsets, testing::UnorderedElementsAre(1, 2, 3));
+  }
+
+  // Opening a new tab should appear below the existing tab.
+  GURL other_tab_url(embedded_test_server()->GetURL(
+      "d.com", "/cross_site_iframe_factory.html?d(a(c(b)))"));
+  browser()->OpenURL(content::OpenURLParams(other_tab_url, content::Referrer(),
+                                            NEW_FOREGROUND_TAB,
+                                            ui::PAGE_TRANSITION_TYPED, false));
+
+  ASSERT_NO_FATAL_FAILURE(
+      WaitForTaskManagerRows(2, MatchTab("Cross-site iframe factory")));
+  if (ShouldExpectSubframes()) {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(6, MatchAnySubframe()));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(2, MatchSubframe("http://b.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(2, MatchSubframe("http://c.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://d.com/")));
+    ASSERT_NO_FATAL_FAILURE(
+        WaitForTaskManagerRows(1, MatchSubframe("http://a.com/")));
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(6, MatchAnySubframe()));
+  } else {
+    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
+  }
+
+  // The first tab may have moved in absolute position in the list (due to
+  // random e.g. zygote or gpu activity).
+  index = FindResourceIndex(MatchTab("Cross-site iframe factory"));
+
+  // Tab 2's rows should immediately follow tab 1.
+  int tab2_start = index + static_cast<int>(subframe_offsets.size()) + 1;
+  int tab2_count = ShouldExpectSubframes() ? 4 : 1;
+  ASSERT_LE(tab2_start + tab2_count, model()->GetRowCount());
+
+  EXPECT_EQ("Tab: Cross-site iframe factory",
+            base::UTF16ToUTF8(model()->GetRowTitle(tab2_start)));
+  if (ShouldExpectSubframes()) {
+    // The relative ordering of tab1's subframe rows shall be the same as what
+    // was observed previously.
+    ASSERT_EQ(subframe_offsets[0],
+              FindResourceIndex(MatchSubframe("http://b.com/")) - index);
+    ASSERT_EQ(subframe_offsets[1],
+              FindResourceIndex(MatchSubframe("http://c.com/")) - index);
+    ASSERT_EQ(subframe_offsets[2],
+              FindResourceIndex(MatchSubframe("http://d.com/")) - index);
+
+    // Because the subframes for tab 2 are nested, their order is deterministic.
+    EXPECT_EQ("Subframe: http://a.com/",
+              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 1)));
+    EXPECT_EQ("Subframe: http://c.com/",
+              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 2)));
+    EXPECT_EQ("Subframe: http://b.com/",
+              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 3)));
+  }
+}
diff --git a/chrome/browser/task_management/task_manager_browsertest_util.cc b/chrome/browser/task_management/task_manager_browsertest_util.cc
new file mode 100644
index 0000000..e33e4a2
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_browsertest_util.cc
@@ -0,0 +1,256 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
+
+#include "base/bind_helpers.h"
+#include "base/command_line.h"
+#include "base/location.h"
+#include "base/run_loop.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/pattern.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/test/test_timeouts.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/timer/timer.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/task_management/task_manager_tester.h"
+#include "chrome/grit/generated_resources.h"
+#include "extensions/strings/grit/extensions_strings.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/models/table_model_observer.h"
+
+namespace task_management {
+namespace browsertest_util {
+
+namespace {
+
+// Helper class to run a message loop until a TaskManagerTester is in an
+// expected state. If timeout occurs, an ASCII version of the task manager's
+// contents, along with a summary of the expected state, are dumped to test
+// output, to assist debugging.
+class ResourceChangeObserver {
+ public:
+  ResourceChangeObserver(int required_count,
+                         const base::string16& title_pattern,
+                         ColumnSpecifier column_specifier,
+                         size_t min_column_value)
+      : required_count_(required_count),
+        title_pattern_(title_pattern),
+        column_specifier_(column_specifier),
+        min_column_value_(min_column_value) {
+    task_manager_tester_ = TaskManagerTester::Create(base::Bind(
+        &ResourceChangeObserver::OnResourceChange, base::Unretained(this)));
+  }
+
+  void RunUntilSatisfied() {
+    // See if the condition is satisfied without having to run the loop. This
+    // check has to be placed after the installation of the
+    // TaskManagerModelObserver, because resources may change before that.
+    if (IsSatisfied())
+      return;
+
+    timer_.Start(FROM_HERE, TestTimeouts::action_timeout(), this,
+                 &ResourceChangeObserver::OnTimeout);
+
+    run_loop_.Run();
+
+    // If we succeeded normally (no timeout), check our post condition again
+    // before returning control to the test. If it is no longer satisfied, the
+    // test is likely flaky: we were waiting for a state that was only achieved
+    // emphemerally), so treat this as a failure.
+    if (!IsSatisfied() && timer_.IsRunning()) {
+      FAIL() << "Wait condition satisfied only emphemerally. Likely test "
+             << "problem. Maybe wait instead for the state below?\n"
+             << DumpTaskManagerModel();
+    }
+
+    timer_.Stop();
+  }
+
+ private:
+  void OnResourceChange() {
+    if (!IsSatisfied())
+      return;
+
+    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
+                                                  run_loop_.QuitClosure());
+  }
+
+  bool IsSatisfied() { return CountMatches() == required_count_; }
+
+  int CountMatches() {
+    int match_count = 0;
+    for (int i = 0; i < task_manager_tester_->GetRowCount(); i++) {
+      if (!base::MatchPattern(task_manager_tester_->GetRowTitle(i),
+                              title_pattern_))
+        continue;
+
+      if (GetColumnValue(i) < min_column_value_)
+        continue;
+
+      match_count++;
+    }
+    return match_count;
+  }
+
+  int64_t GetColumnValue(int index) {
+    return task_manager_tester_->GetColumnValue(column_specifier_, index);
+  }
+
+  const char* GetColumnName() {
+    switch (column_specifier_) {
+      case ColumnSpecifier::COLUMN_NONE:
+        return "N/A";
+      case ColumnSpecifier::V8_MEMORY:
+        return "V8 Memory";
+      case ColumnSpecifier::V8_MEMORY_USED:
+        return "V8 Memory Used";
+      case ColumnSpecifier::SQLITE_MEMORY_USED:
+        return "SQLite Memory Used";
+      case ColumnSpecifier::IDLE_WAKEUPS:
+        return "Idle wake ups";
+    }
+    return "N/A";
+  }
+
+  void OnTimeout() {
+    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
+                                                  run_loop_.QuitClosure());
+    FAIL() << "Timed out.\n" << DumpTaskManagerModel();
+  }
+
+  testing::Message DumpTaskManagerModel() {
+    testing::Message task_manager_state_dump;
+    task_manager_state_dump << "Waiting for exactly " << required_count_
+                            << " matches of wildcard pattern \""
+                            << base::UTF16ToASCII(title_pattern_) << "\"";
+    if (min_column_value_ > 0) {
+      task_manager_state_dump << " && [" << GetColumnName()
+                              << " >= " << min_column_value_ << "]";
+    }
+    task_manager_state_dump << "\nCurrently there are " << CountMatches()
+                            << " matches.";
+    task_manager_state_dump << "\nCurrent Task Manager Model is:";
+    for (int i = 0; i < task_manager_tester_->GetRowCount(); i++) {
+      task_manager_state_dump
+          << "\n  > " << std::setw(40) << std::left
+          << base::UTF16ToASCII(task_manager_tester_->GetRowTitle(i));
+      if (min_column_value_ > 0) {
+        task_manager_state_dump << " [" << GetColumnName()
+                                << " == " << GetColumnValue(i) << "]";
+      }
+    }
+    return task_manager_state_dump;
+  }
+
+  std::unique_ptr<TaskManagerTester> task_manager_tester_;
+  const int required_count_;
+  const base::string16 title_pattern_;
+  const ColumnSpecifier column_specifier_;
+  const int64_t min_column_value_;
+  base::RunLoop run_loop_;
+  base::OneShotTimer timer_;
+};
+
+}  // namespace
+
+void WaitForTaskManagerRows(int required_count,
+                            const base::string16& title_pattern) {
+  const int column_value_dont_care = 0;
+  ResourceChangeObserver observer(required_count, title_pattern,
+                                  ColumnSpecifier::COLUMN_NONE,
+                                  column_value_dont_care);
+  observer.RunUntilSatisfied();
+}
+
+void WaitForTaskManagerStatToExceed(const base::string16& title_pattern,
+                                    ColumnSpecifier column_getter,
+                                    size_t min_column_value) {
+  const int wait_for_one_match = 1;
+  ResourceChangeObserver observer(wait_for_one_match, title_pattern,
+                                  column_getter, min_column_value);
+  observer.RunUntilSatisfied();
+}
+
+base::string16 MatchTab(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyTab() {
+  return MatchTab("*");
+}
+
+base::string16 MatchAboutBlankTab() {
+  return MatchTab("about:blank");
+}
+
+base::string16 MatchExtension(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_EXTENSION_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyExtension() {
+  return MatchExtension("*");
+}
+
+base::string16 MatchApp(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_APP_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyApp() {
+  return MatchApp("*");
+}
+
+base::string16 MatchWebView(const char* title) {
+  return l10n_util::GetStringFUTF16(
+      IDS_EXTENSION_TASK_MANAGER_WEBVIEW_TAG_PREFIX, base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyWebView() {
+  return MatchWebView("*");
+}
+
+base::string16 MatchBackground(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyBackground() {
+  return MatchBackground("*");
+}
+
+base::string16 MatchPrint(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRINT_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnyPrint() {
+  return MatchPrint("*");
+}
+
+base::string16 MatchSubframe(const char* title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_SUBFRAME_PREFIX,
+                                    base::ASCIIToUTF16(title));
+}
+
+base::string16 MatchAnySubframe() {
+  return MatchSubframe("*");
+}
+
+base::string16 MatchUtility(const base::string16& title) {
+  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_UTILITY_PREFIX, title);
+}
+
+base::string16 MatchAnyUtility() {
+  return MatchUtility(base::ASCIIToUTF16("*"));
+}
+
+}  // namespace browsertest_util
+}  // namespace task_management
diff --git a/chrome/browser/task_management/task_manager_browsertest_util.h b/chrome/browser/task_management/task_manager_browsertest_util.h
new file mode 100644
index 0000000..010632d
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_browsertest_util.h
@@ -0,0 +1,80 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// These "task_management::browsertest_util" functions allow you to wait for a
+// task manager to show a particular state, enabling tests of the form "do
+// something that ought to create a process, then wait for that process to show
+// up in the Task Manager." They are intended to abstract away the details of
+// the platform's TaskManager UI.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_BROWSERTEST_UTIL_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_BROWSERTEST_UTIL_H_
+
+#include <stddef.h>
+
+#include "base/strings/string16.h"
+
+namespace task_management {
+namespace browsertest_util {
+
+// Specifies some integer-valued column of numeric data reported by the task
+// manager model. Please add more here as needed by tests.
+enum class ColumnSpecifier {
+  V8_MEMORY,
+  V8_MEMORY_USED,
+  SQLITE_MEMORY_USED,
+  IDLE_WAKEUPS,
+
+  COLUMN_NONE,  // Default value.
+};
+
+// Runs the message loop, observing the task manager, until there are exactly
+// |resource_count| many resources whose titles match the pattern
+// |title_pattern|. The match is done via string_util's base::MatchPattern, so
+// |title_pattern| may contain wildcards like "*".
+//
+// If the wait times out, this test will trigger a gtest failure. To get
+// meaningful errors, tests should wrap invocations of this function with
+// ASSERT_NO_FATAL_FAILURE().
+void WaitForTaskManagerRows(int resource_count,
+                            const base::string16& title_pattern);
+
+// Make the indicated TaskManager column be visible.
+void ShowColumn(ColumnSpecifier column_specifier);
+
+// Waits for the row identified by |title_pattern| to be showing a numeric data
+// value of at least |min_column_value| in the task manager column identified by
+// |column_specifier|. As with WaitForTaskManagerRows(), |title_pattern| is
+// meant to be a string returned by MatchTab() or similar.
+//
+// To get meaningful errors, tests should wrap invocations of this function with
+// ASSERT_NO_FATAL_FAILURE().
+void WaitForTaskManagerStatToExceed(const base::string16& title_pattern,
+                                    ColumnSpecifier column_specifier,
+                                    size_t min_column_value);
+
+// ASCII matcher convenience functions for use with WaitForTaskManagerRows()
+base::string16 MatchTab(const char* title);         // "Tab: " + title
+base::string16 MatchAnyTab();                       // "Tab: *"
+base::string16 MatchAboutBlankTab();                // "Tab: about:blank"
+base::string16 MatchExtension(const char* title);   // "Extension: " + title
+base::string16 MatchAnyExtension();                 // "Extension: *"
+base::string16 MatchApp(const char* title);         // "App: " + title
+base::string16 MatchAnyApp();                       // "App: *"
+base::string16 MatchWebView(const char* title);     // "WebView: " + title
+base::string16 MatchAnyWebView();                   // "WebView: *"
+base::string16 MatchBackground(const char* title);  // "Background: " + title
+base::string16 MatchAnyBackground();                // "Background: *"
+base::string16 MatchPrint(const char* title);       // "Print: " + title
+base::string16 MatchAnyPrint();                     // "Print: *"
+base::string16 MatchSubframe(const char* title);    // "Subframe: " + title
+base::string16 MatchAnySubframe();                  // "Subframe: *"
+// "Utility: " + title
+base::string16 MatchUtility(const base::string16& title);
+base::string16 MatchAnyUtility();                   // "Utility: *"
+
+}  // namespace browsertest_util
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_BROWSERTEST_UTIL_H_
diff --git a/chrome/browser/task_management/task_manager_interface.cc b/chrome/browser/task_management/task_manager_interface.cc
new file mode 100644
index 0000000..3ce8962
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_interface.cc
@@ -0,0 +1,165 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/task_manager_interface.h"
+
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/task_management/sampling/task_manager_impl.h"
+#include "chrome/browser/task_management/sampling/task_manager_io_thread_helper.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/pref_names.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/browser_thread.h"
+
+#if defined(OS_MACOSX)
+#include "chrome/browser/ui/browser_dialogs.h"
+#endif  // defined(OS_MACOSX)
+
+namespace task_management {
+
+// static
+void TaskManagerInterface::RegisterPrefs(PrefRegistrySimple* registry) {
+  registry->RegisterDictionaryPref(prefs::kTaskManagerWindowPlacement);
+  registry->RegisterDictionaryPref(prefs::kTaskManagerColumnVisibility);
+  registry->RegisterBooleanPref(prefs::kTaskManagerEndProcessEnabled, true);
+}
+
+// static
+bool TaskManagerInterface::IsEndProcessEnabled() {
+  PrefService* state = g_browser_process->local_state();
+  return !state || state->GetBoolean(prefs::kTaskManagerEndProcessEnabled);
+}
+
+// static
+TaskManagerInterface* TaskManagerInterface::GetTaskManager() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  return TaskManagerImpl::GetInstance();
+}
+
+// static
+void TaskManagerInterface::OnRawBytesRead(const net::URLRequest& request,
+                                          int64_t bytes_read) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+  TaskManagerIoThreadHelper::OnRawBytesRead(request, bytes_read);
+}
+
+void TaskManagerInterface::AddObserver(TaskManagerObserver* observer) {
+  observers_.AddObserver(observer);
+  observer->observed_task_manager_ = this;
+
+  ResourceFlagsAdded(observer->desired_resources_flags());
+
+  base::TimeDelta current_refresh_time = GetCurrentRefreshTime();
+  if (current_refresh_time == base::TimeDelta::Max()) {
+    // This is the first observer to be added. Start updating.
+    StartUpdating();
+  }
+
+  if (observer->desired_refresh_time() > current_refresh_time)
+    return;
+
+  // Reached here, then this is EITHER (not the first observer to be added AND
+  // it requires a more frequent refresh rate) OR (it's the very first observer
+  // to be added).
+  // Reset the refresh timer.
+  ScheduleRefresh(observer->desired_refresh_time());
+}
+
+void TaskManagerInterface::RemoveObserver(TaskManagerObserver* observer) {
+  observers_.RemoveObserver(observer);
+  observer->observed_task_manager_ = nullptr;
+
+  // Recalculate the minimum refresh rate and the enabled resource flags.
+  int64_t flags = 0;
+  base::TimeDelta min_time = base::TimeDelta::Max();
+  base::ObserverList<TaskManagerObserver>::Iterator itr(&observers_);
+  while (TaskManagerObserver* obs = itr.GetNext()) {
+    if (obs->desired_refresh_time() < min_time)
+      min_time = obs->desired_refresh_time();
+
+    flags |= obs->desired_resources_flags();
+  }
+
+  if (min_time == base::TimeDelta::Max()) {
+    // This is the last observer to be removed. Stop updating.
+    SetEnabledResourceFlags(0);
+    refresh_timer_->Stop();
+    StopUpdating();
+  } else {
+    SetEnabledResourceFlags(flags);
+    ScheduleRefresh(min_time);
+  }
+}
+
+void TaskManagerInterface::RecalculateRefreshFlags() {
+  int64_t flags = 0;
+  base::ObserverList<TaskManagerObserver>::Iterator itr(&observers_);
+  while (TaskManagerObserver* obs = itr.GetNext())
+    flags |= obs->desired_resources_flags();
+
+  SetEnabledResourceFlags(flags);
+}
+
+bool TaskManagerInterface::IsResourceRefreshEnabled(RefreshType type) const {
+  return (enabled_resources_flags_ & type) != 0;
+}
+
+TaskManagerInterface::TaskManagerInterface()
+    : refresh_timer_(new base::Timer(true, true)),
+      enabled_resources_flags_(0) {
+}
+
+TaskManagerInterface::~TaskManagerInterface() {
+}
+
+void TaskManagerInterface::NotifyObserversOnTaskAdded(TaskId id) {
+  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskAdded(id));
+}
+
+void TaskManagerInterface::NotifyObserversOnTaskToBeRemoved(TaskId id) {
+  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskToBeRemoved(id));
+}
+
+void TaskManagerInterface::NotifyObserversOnRefresh(
+    const TaskIdList& task_ids) {
+  FOR_EACH_OBSERVER(TaskManagerObserver,
+                    observers_,
+                    OnTasksRefreshed(task_ids));
+}
+
+void TaskManagerInterface::NotifyObserversOnRefreshWithBackgroundCalculations(
+      const TaskIdList& task_ids) {
+  FOR_EACH_OBSERVER(TaskManagerObserver,
+                    observers_,
+                    OnTasksRefreshedWithBackgroundCalculations(task_ids));
+}
+
+void TaskManagerInterface::NotifyObserversOnTaskUnresponsive(TaskId id) {
+  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskUnresponsive(id));
+}
+
+base::TimeDelta TaskManagerInterface::GetCurrentRefreshTime() const {
+  return refresh_timer_->IsRunning() ? refresh_timer_->GetCurrentDelay()
+                                     : base::TimeDelta::Max();
+}
+
+void TaskManagerInterface::ResourceFlagsAdded(int64_t flags) {
+  enabled_resources_flags_ |= flags;
+}
+
+void TaskManagerInterface::SetEnabledResourceFlags(int64_t flags) {
+  enabled_resources_flags_ = flags;
+}
+
+void TaskManagerInterface::ScheduleRefresh(base::TimeDelta refresh_time) {
+  refresh_timer_->Start(FROM_HERE,
+                        refresh_time,
+                        base::Bind(&TaskManagerInterface::Refresh,
+                                   base::Unretained(this)));
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/task_manager_interface.h b/chrome/browser/task_management/task_manager_interface.h
new file mode 100644
index 0000000..92c4833
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_interface.h
@@ -0,0 +1,279 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_INTERFACE_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_INTERFACE_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/macros.h"
+#include "base/observer_list.h"
+#include "base/process/kill.h"
+#include "base/process/process_handle.h"
+#include "base/time/time.h"
+#include "base/timer/timer.h"
+#include "chrome/browser/task_management/providers/task.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
+#include "third_party/WebKit/public/web/WebCache.h"
+#include "ui/gfx/image/image_skia.h"
+
+class PrefRegistrySimple;
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+namespace net {
+class URLRequest;
+}  // namespace net
+
+namespace task_management {
+
+// Defines the interface for any implementation of the task manager.
+// Concrete implementations have no control over the refresh rate nor the
+// enabled calculations of the usage of the various resources.
+class TaskManagerInterface {
+ public:
+  // Registers the task manager related prefs.
+  static void RegisterPrefs(PrefRegistrySimple* registry);
+
+  // Returns true if the user is allowed to end processes.
+  static bool IsEndProcessEnabled();
+
+  // Gets the existing instance of the task manager if any, otherwise it will
+  // create it first. Must be called on the UI thread.
+  static TaskManagerInterface* GetTaskManager();
+
+  // This notification will be received on the IO thread from
+  // ChromeNetworkDelegate to update the task manager with network usage.
+  static void OnRawBytesRead(const net::URLRequest& request,
+                             int64_t bytes_read);
+
+  void AddObserver(TaskManagerObserver* observer);
+  void RemoveObserver(TaskManagerObserver* observer);
+
+  // Activates the task with |task_id| by bringing its container to the front if
+  // possible.
+  virtual void ActivateTask(TaskId task_id) = 0;
+
+  // Returns if the task is killable.
+  virtual bool IsTaskKillable(TaskId task_id) = 0;
+
+  // Kills the task with |task_id|.
+  virtual void KillTask(TaskId task_id) = 0;
+
+  // returns the CPU usage in percent for the process on which the task with
+  // |task_id| is running during the current refresh cycle.
+  virtual double GetCpuUsage(TaskId task_id) const = 0;
+
+  // Returns the current physical/private/shared memory usage of the task with
+  // |task_id| in bytes. A value of -1 means no valid value is currently
+  // available.
+  virtual int64_t GetPhysicalMemoryUsage(TaskId task_id) const = 0;
+  virtual int64_t GetPrivateMemoryUsage(TaskId task_id) const = 0;
+  virtual int64_t GetSharedMemoryUsage(TaskId task_id) const = 0;
+  virtual int64_t GetSwappedMemoryUsage(TaskId task_id) const = 0;
+
+  // Returns the GPU memory usage of the task with |task_id| in bytes. A value
+  // of -1 means no valid value is currently available.
+  // |has_duplicates| will be set to true if this process' GPU resource count is
+  // inflated because it is counting other processes' resources.
+  virtual int64_t GetGpuMemoryUsage(TaskId task_id,
+                                    bool* has_duplicates) const = 0;
+
+  // Returns the number of average idle CPU wakeups per second since the last
+  // refresh cycle. A value of -1 means no valid value is currently available.
+  virtual int GetIdleWakeupsPerSecond(TaskId task_id) const = 0;
+
+  // Returns the NaCl GDB debug stub port. A value of
+  // |nacl::kGdbDebugStubPortUnknown| means no valid value is currently
+  // available. A value of -2 means NaCl is not enabled for this build.
+  virtual int GetNaClDebugStubPort(TaskId task_id) const = 0;
+
+  // On Windows, gets the current and peak number of GDI and USER handles in
+  // use. A value of -1 means no valid value is currently available.
+  virtual void GetGDIHandles(TaskId task_id,
+                             int64_t* current,
+                             int64_t* peak) const = 0;
+  virtual void GetUSERHandles(TaskId task_id,
+                              int64_t* current,
+                              int64_t* peak) const = 0;
+
+  // On Linux and ChromeOS, gets the number of file descriptors currently open
+  // by the process on which the task with |task_id| is running, or -1 if no
+  // valid value is currently available.
+  virtual int GetOpenFdCount(TaskId task_id) const = 0;
+
+  // Returns whether the task with |task_id| is running on a backgrounded
+  // process.
+  virtual bool IsTaskOnBackgroundedProcess(TaskId task_id) const = 0;
+
+  // Returns the title of the task with |task_id|.
+  virtual const base::string16& GetTitle(TaskId task_id) const = 0;
+
+  // Returns the canonicalized name of the task with |task_id| that can be used
+  // to represent this task in a Rappor sample via RapporService.
+  virtual const std::string& GetTaskNameForRappor(TaskId task_id) const = 0;
+
+  // Returns the name of the profile associated with the browser context of the
+  // render view host that the task with |task_id| represents (if that task
+  // represents a renderer).
+  virtual base::string16 GetProfileName(TaskId task_id) const = 0;
+
+  // Returns the favicon of the task with |task_id|.
+  virtual const gfx::ImageSkia& GetIcon(TaskId task_id) const = 0;
+
+  // Returns the ID and handle of the process on which the task with |task_id|
+  // is running.
+  virtual const base::ProcessHandle& GetProcessHandle(TaskId task_id) const = 0;
+  virtual const base::ProcessId& GetProcessId(TaskId task_id) const = 0;
+
+  // Returns the type of the task with |task_id|.
+  virtual Task::Type GetType(TaskId task_id) const = 0;
+
+  // Gets the unique ID of the tab if the task with |task_id| represents a
+  // WebContents of a tab. Returns -1 otherwise.
+  virtual int GetTabId(TaskId task_id) const = 0;
+
+  // Returns the unique ID of the BrowserChildProcessHost/RenderProcessHost on
+  // which the task with |task_id| is running. It is not the PID nor the handle
+  // of the process.
+  // For a task that represents the browser process, the return value is 0.
+  // For a task that doesn't have a host on the browser process, the return
+  // value is also 0. For other tasks that represent renderers and other child
+  // processes, the return value is whatever unique IDs of their hosts in the
+  // browser process.
+  virtual int GetChildProcessUniqueId(TaskId task_id) const = 0;
+
+  // If the process, in which the task with |task_id| is running, is terminated
+  // this gets the termination status. Currently implemented only for Renderer
+  // processes. The values will only be valid if the process has actually
+  // terminated.
+  virtual void GetTerminationStatus(TaskId task_id,
+                                    base::TerminationStatus* out_status,
+                                    int* out_error_code) const = 0;
+
+  // Returns the network usage (in bytes per second) during the current refresh
+  // cycle for the task with |task_id|. A value of -1 means no valid value is
+  // currently available or that task has never been notified of any network
+  // usage.
+  virtual int64_t GetNetworkUsage(TaskId task_id) const = 0;
+
+  // Returns the total network usage (in bytes per second) during the current
+  // refresh cycle for the process on which the task with |task_id| is running.
+  // This is the sum of all the network usage of the individual tasks (that
+  // can be gotten by the above GetNetworkUsage()). A value of -1 means network
+  // usage calculation refresh is currently not available.
+  virtual int64_t GetProcessTotalNetworkUsage(TaskId task_id) const = 0;
+
+  // Returns the Sqlite used memory (in bytes) for the task with |task_id|.
+  // A value of -1 means no valid value is currently available.
+  virtual int64_t GetSqliteMemoryUsed(TaskId task_id) const = 0;
+
+  // Returns the allocated and used V8 memory (in bytes) for the task with
+  // |task_id|. A return value of false means no valid value is currently
+  // available.
+  virtual bool GetV8Memory(TaskId task_id,
+                           int64_t* allocated,
+                           int64_t* used) const = 0;
+
+  // Gets the Webkit resource cache stats for the task with |task_id|.
+  // A return value of false means that task does NOT report WebCache stats.
+  virtual bool GetWebCacheStats(
+      TaskId task_id,
+      blink::WebCache::ResourceTypeStats* stats) const = 0;
+
+  // Gets the list of task IDs currently tracked by the task manager. Tasks that
+  // share the same process id will always be consecutive. The list will be
+  // sorted in a way that reflects the process tree: the browser process will be
+  // first, followed by the gpu process if it exists. Related processes (e.g., a
+  // subframe process and its parent) will be kept together if possible. Callers
+  // can expect this ordering to be stable when a process is added or removed.
+  virtual const TaskIdList& GetTaskIdsList() const = 0;
+
+  // Gets the list of task IDs of the tasks that run on the same process as the
+  // task with |task_id|. The returned list will at least include |task_id|.
+  virtual TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const = 0;
+
+  // Gets the number of task-manager tasks running on the same process on which
+  // the Task with |task_id| is running.
+  virtual size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const = 0;
+
+  // Returns the TaskId associated with the main task for |web_contents|.
+  // Returns -1 if |web_contents| is nullptr or does not currently have an
+  // associated Task.
+  virtual TaskId GetTaskIdForWebContents(
+      content::WebContents* web_contents) const = 0;
+
+  // Returns true if the resource |type| usage calculation is enabled and
+  // the implementation should refresh its value (this means that at least one
+  // of the observers require this value). False otherwise.
+  bool IsResourceRefreshEnabled(RefreshType type) const;
+
+ protected:
+  TaskManagerInterface();
+  virtual ~TaskManagerInterface();
+
+  // Notifying observers of various events.
+  void NotifyObserversOnTaskAdded(TaskId id);
+  void NotifyObserversOnTaskToBeRemoved(TaskId id);
+  void NotifyObserversOnRefresh(const TaskIdList& task_ids);
+  void NotifyObserversOnRefreshWithBackgroundCalculations(
+      const TaskIdList& task_ids);
+  void NotifyObserversOnTaskUnresponsive(TaskId id);
+
+  // Refresh all the enabled resources usage of all the available tasks.
+  virtual void Refresh() = 0;
+
+  // StartUpdating will be called once an observer is added, and StopUpdating
+  // will be called when the last observer is removed.
+  virtual void StartUpdating() = 0;
+  virtual void StopUpdating() = 0;
+
+  // Returns the current refresh time that this task manager is running at. It
+  // will return base::TimeDelta::Max() if the task manager is not running.
+  base::TimeDelta GetCurrentRefreshTime() const;
+
+  int64_t enabled_resources_flags() const { return enabled_resources_flags_; }
+
+  void set_timer_for_testing(std::unique_ptr<base::Timer> timer) {
+    refresh_timer_ = std::move(timer);
+  }
+
+ private:
+  friend class TaskManagerObserver;
+
+  // This should be called after each time an observer changes its own desired
+  // resources refresh flags.
+  void RecalculateRefreshFlags();
+
+  // Appends |flags| to the |enabled_resources_flags_|.
+  void ResourceFlagsAdded(int64_t flags);
+
+  // Sets |enabled_resources_flags_| to |flags|.
+  void SetEnabledResourceFlags(int64_t flags);
+
+  // Schedules the task manager refresh cycles using the given |refresh_time|.
+  // It stops any existing refresh schedule.
+  void ScheduleRefresh(base::TimeDelta refresh_time);
+
+  // The list of observers.
+  base::ObserverList<TaskManagerObserver> observers_;
+
+  // The timer that will be used to schedule the successive refreshes.
+  std::unique_ptr<base::Timer> refresh_timer_;
+
+  // The flags containing the enabled resources types calculations.
+  int64_t enabled_resources_flags_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerInterface);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_INTERFACE_H_
diff --git a/chrome/browser/task_management/task_manager_observer.cc b/chrome/browser/task_management/task_manager_observer.cc
new file mode 100644
index 0000000..1263f1d
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_observer.cc
@@ -0,0 +1,51 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/task_manager_observer.h"
+
+#include "chrome/browser/task_management/task_manager_interface.h"
+
+namespace task_management {
+
+// static
+bool TaskManagerObserver::IsResourceRefreshEnabled(RefreshType refresh_type,
+                                                   int refresh_flags) {
+  return (refresh_flags & refresh_type) != 0;
+}
+
+TaskManagerObserver::TaskManagerObserver(base::TimeDelta refresh_time,
+                                         int64_t resources_flags)
+    : observed_task_manager_(nullptr),
+      desired_refresh_time_(refresh_time < base::TimeDelta::FromSeconds(1)
+                                ? base::TimeDelta::FromSeconds(1)
+                                : refresh_time),
+      desired_resources_flags_(resources_flags) {}
+
+TaskManagerObserver::~TaskManagerObserver() {
+  if (observed_task_manager())
+    observed_task_manager()->RemoveObserver(this);
+}
+
+void TaskManagerObserver::AddRefreshType(RefreshType type) {
+  desired_resources_flags_ |= type;
+
+  if (observed_task_manager_)
+    observed_task_manager_->RecalculateRefreshFlags();
+}
+
+void TaskManagerObserver::RemoveRefreshType(RefreshType type) {
+  desired_resources_flags_ &= ~type;
+
+  if (observed_task_manager_)
+    observed_task_manager_->RecalculateRefreshFlags();
+}
+
+void TaskManagerObserver::SetRefreshTypesFlags(int64_t flags) {
+  desired_resources_flags_ = flags;
+
+  if (observed_task_manager_)
+    observed_task_manager_->RecalculateRefreshFlags();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/task_manager_observer.h b/chrome/browser/task_management/task_manager_observer.h
new file mode 100644
index 0000000..04d8047
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_observer.h
@@ -0,0 +1,144 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_OBSERVER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_OBSERVER_H_
+
+#include <stdint.h>
+
+#include <vector>
+
+#include "base/macros.h"
+#include "base/time/time.h"
+#include "build/build_config.h"
+
+namespace task_management {
+
+class TaskManagerInterface;
+
+using TaskId = int64_t;
+using TaskIdList = std::vector<TaskId>;
+
+// Defines a list of types of resources that an observer needs to be refreshed
+// on every task manager refresh cycle.
+enum RefreshType {
+  REFRESH_TYPE_NONE              = 0,
+  REFRESH_TYPE_CPU               = 1,
+  REFRESH_TYPE_MEMORY            = 1 << 1,
+  REFRESH_TYPE_GPU_MEMORY        = 1 << 2,
+  REFRESH_TYPE_V8_MEMORY         = 1 << 3,
+  REFRESH_TYPE_SQLITE_MEMORY     = 1 << 4,
+  REFRESH_TYPE_WEBCACHE_STATS    = 1 << 5,
+  REFRESH_TYPE_NETWORK_USAGE     = 1 << 6,
+  REFRESH_TYPE_NACL              = 1 << 7,
+  REFRESH_TYPE_IDLE_WAKEUPS      = 1 << 8,
+  REFRESH_TYPE_HANDLES           = 1 << 9,
+
+  // Whether an observer is interested in knowing if a process is foregrounded
+  // or backgrounded.
+  REFRESH_TYPE_PRIORITY          = 1 << 10,
+
+#if defined(OS_LINUX)
+  // For observers interested in getting the number of open file descriptors of
+  // processes.
+  REFRESH_TYPE_FD_COUNT          = 1 << 11,
+#endif  // defined(OS_LINUX)
+};
+
+// Defines the interface for observers of the task manager.
+class TaskManagerObserver {
+ public:
+  static bool IsResourceRefreshEnabled(RefreshType refresh_type,
+                                       int refresh_flags);
+
+  // Constructs a TaskManagerObserver given the minimum |refresh_time| that it
+  // it requires the task manager to be refreshing the values at, along with the
+  // |resources_flags| that it needs to be calculated on each refresh cycle of
+  // the task manager (use the above flags in |ResourceType|).
+  //
+  // Notes:
+  // 1- The task manager will refresh at least once every |refresh_time| as
+  // long as this observer is added to it. There might be other observers that
+  // require more frequent refreshes.
+  // 2- Refresh time values less than 1 second will be considered as 1 second.
+  // 3- Depending on the other observers, the task manager may refresh more
+  // resources than those defined in |resources_flags|.
+  // 4- Upon the removal of the observer from the task manager, the task manager
+  // will update its refresh time and the calculated resources to be the minimum
+  // required value of all the remaining observers.
+  TaskManagerObserver(base::TimeDelta refresh_time, int64_t resources_flags);
+  virtual ~TaskManagerObserver();
+
+  // Notifies the observer that a chrome task with |id| has started and the task
+  // manager is now monitoring it. The resource usage of this newly-added task
+  // will remain invalid until the next refresh cycle of the task manager.
+  virtual void OnTaskAdded(TaskId id) {}
+
+  // Notifies the observer that a chrome task with |id| is about to be destroyed
+  // and removed from the task manager right after this call. Observers which
+  // are interested in doing some calculations related to the resource usage of
+  // this task upon its removal may do so inside this call.
+  virtual void OnTaskToBeRemoved(TaskId id) {}
+
+  // Notifies the observer that the task manager has just finished a refresh
+  // cycle to calculate the resources usage of all tasks whose IDs are given in
+  // |task_ids|. |task_ids| will be sorted such that the task representing the
+  // browser process is at the top of the list and the rest of the IDs will be
+  // sorted by the process IDs on which the tasks are running, then by the task
+  // IDs themselves.
+  virtual void OnTasksRefreshed(const TaskIdList& task_ids) {}
+
+  // Notifies the observer that the task manager has just finished a refresh
+  // cycle that calculated all the resource usage of all tasks whose IDs are in
+  // |task_ids| including the resource usages that are calculated in the
+  // background such CPU and memory (If those refresh types are enabled).
+  // This event can take longer to be fired, and can miss some changes that may
+  // happen to non-background calculations in-between two successive
+  // invocations. Listen to this ONLY if you must know when all the background
+  // resource calculations to be valid for all the available processes.
+  // |task_ids| will be sorted as specified in OnTasksRefreshed() above.
+  virtual void OnTasksRefreshedWithBackgroundCalculations(
+      const TaskIdList& task_ids) {}
+
+  // Notifies the observer that the task with |id| is running on a renderer that
+  // has become unresponsive.
+  virtual void OnTaskUnresponsive(TaskId id) {}
+
+  const base::TimeDelta& desired_refresh_time() const {
+    return desired_refresh_time_;
+  }
+
+  int64_t desired_resources_flags() const { return desired_resources_flags_; }
+
+ protected:
+  TaskManagerInterface* observed_task_manager() const {
+    return observed_task_manager_;
+  }
+
+  // Add or Remove a refresh |type|.
+  void AddRefreshType(RefreshType type);
+  void RemoveRefreshType(RefreshType type);
+  void SetRefreshTypesFlags(int64_t flags);
+
+ private:
+  friend class TaskManagerInterface;
+
+  // The currently observed task Manager.
+  TaskManagerInterface* observed_task_manager_;
+
+  // The minimum update time of the task manager that this observer needs to
+  // do its job.
+  base::TimeDelta desired_refresh_time_;
+
+  // The flags that contain the resources that this observer needs to be
+  // calculated on each refresh.
+  int64_t desired_resources_flags_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerObserver);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_OBSERVER_H_
diff --git a/chrome/browser/task_management/task_manager_observer_unittest.cc b/chrome/browser/task_management/task_manager_observer_unittest.cc
new file mode 100644
index 0000000..6595fa2
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_observer_unittest.cc
@@ -0,0 +1,119 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "chrome/browser/task_management/test_task_manager.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace task_management {
+
+namespace {
+
+// Defines a concrete observer that will be used for testing.
+class TestObserver : public TaskManagerObserver {
+ public:
+  TestObserver(base::TimeDelta refresh_time, int64_t resources_flags)
+      : TaskManagerObserver(refresh_time, resources_flags) {}
+
+  ~TestObserver() override {}
+
+  // task_management::TaskManagerObserver:
+  void OnTaskAdded(TaskId id) override {}
+  void OnTaskToBeRemoved(TaskId id) override {}
+  void OnTasksRefreshed(const TaskIdList& task_ids) override {}
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TestObserver);
+};
+
+// Defines a test to validate the behavior of the task manager in response to
+// adding and removing different kind of observers.
+class TaskManagerObserverTest : public testing::Test {
+ public:
+  TaskManagerObserverTest() {}
+  ~TaskManagerObserverTest() override {}
+
+  TestTaskManager& task_manager() { return task_manager_; }
+
+ private:
+  TestTaskManager task_manager_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskManagerObserverTest);
+};
+
+}  // namespace
+
+// Validates that the minimum refresh time to be requested is one second. Also
+// validates the desired resource flags.
+TEST_F(TaskManagerObserverTest, Basic) {
+  base::TimeDelta refresh_time1 = base::TimeDelta::FromSeconds(2);
+  base::TimeDelta refresh_time2 = base::TimeDelta::FromMilliseconds(999);
+  int64_t flags1 = RefreshType::REFRESH_TYPE_CPU |
+                   RefreshType::REFRESH_TYPE_WEBCACHE_STATS |
+                   RefreshType::REFRESH_TYPE_HANDLES;
+  int64_t flags2 =
+      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_NACL;
+
+  TestObserver observer1(refresh_time1, flags1);
+  TestObserver observer2(refresh_time2, flags2);
+
+  EXPECT_EQ(refresh_time1, observer1.desired_refresh_time());
+  EXPECT_EQ(base::TimeDelta::FromSeconds(1), observer2.desired_refresh_time());
+  EXPECT_EQ(flags1, observer1.desired_resources_flags());
+  EXPECT_EQ(flags2, observer2.desired_resources_flags());
+}
+
+// Validates the behavior of the task manager in response to adding and
+// removing observers.
+TEST_F(TaskManagerObserverTest, TaskManagerResponseToObservers) {
+  EXPECT_EQ(base::TimeDelta::Max(), task_manager().GetRefreshTime());
+  EXPECT_EQ(0, task_manager().GetEnabledFlags());
+
+  // Add a bunch of observers and make sure the task manager responds correctly.
+  base::TimeDelta refresh_time1 = base::TimeDelta::FromSeconds(3);
+  base::TimeDelta refresh_time2 = base::TimeDelta::FromSeconds(10);
+  base::TimeDelta refresh_time3 = base::TimeDelta::FromSeconds(3);
+  base::TimeDelta refresh_time4 = base::TimeDelta::FromSeconds(2);
+  int64_t flags1 = RefreshType::REFRESH_TYPE_CPU |
+                   RefreshType::REFRESH_TYPE_WEBCACHE_STATS |
+                   RefreshType::REFRESH_TYPE_HANDLES;
+  int64_t flags2 =
+      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_NACL;
+  int64_t flags3 =
+      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_CPU;
+  int64_t flags4 = RefreshType::REFRESH_TYPE_GPU_MEMORY;
+
+  TestObserver observer1(refresh_time1, flags1);
+  TestObserver observer2(refresh_time2, flags2);
+  TestObserver observer3(refresh_time3, flags3);
+  TestObserver observer4(refresh_time4, flags4);
+
+  task_manager().AddObserver(&observer1);
+  task_manager().AddObserver(&observer2);
+  task_manager().AddObserver(&observer3);
+  task_manager().AddObserver(&observer4);
+
+  EXPECT_EQ(refresh_time4, task_manager().GetRefreshTime());
+  EXPECT_EQ(flags1 | flags2 | flags3 | flags4,
+            task_manager().GetEnabledFlags());
+
+  // Removing observers should also reflect on the refresh time and resource
+  // flags.
+  task_manager().RemoveObserver(&observer4);
+  EXPECT_EQ(refresh_time3, task_manager().GetRefreshTime());
+  EXPECT_EQ(flags1 | flags2 | flags3, task_manager().GetEnabledFlags());
+  task_manager().RemoveObserver(&observer3);
+  EXPECT_EQ(refresh_time1, task_manager().GetRefreshTime());
+  EXPECT_EQ(flags1 | flags2, task_manager().GetEnabledFlags());
+  task_manager().RemoveObserver(&observer2);
+  EXPECT_EQ(refresh_time1, task_manager().GetRefreshTime());
+  EXPECT_EQ(flags1, task_manager().GetEnabledFlags());
+  task_manager().RemoveObserver(&observer1);
+  EXPECT_EQ(base::TimeDelta::Max(), task_manager().GetRefreshTime());
+  EXPECT_EQ(0, task_manager().GetEnabledFlags());
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/task_manager_tester.cc b/chrome/browser/task_management/task_manager_tester.cc
new file mode 100644
index 0000000..fda98e8
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_tester.cc
@@ -0,0 +1,170 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/task_manager_tester.h"
+
+#include "base/memory/ptr_util.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/browser/ui/task_manager/task_manager_table_model.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/grit/generated_resources.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/models/table_model_observer.h"
+
+namespace task_management {
+
+// Temporarily intercepts the calls between a TableModel and its Observer,
+// running |callback| whenever anything happens.
+class ScopedInterceptTableModelObserver : public ui::TableModelObserver {
+ public:
+  ScopedInterceptTableModelObserver(
+      ui::TableModel* model_to_intercept,
+      ui::TableModelObserver* real_table_model_observer,
+      const base::Closure& callback)
+      : model_to_intercept_(model_to_intercept),
+        real_table_model_observer_(real_table_model_observer),
+        callback_(callback) {
+    model_to_intercept_->SetObserver(this);
+  }
+
+  ~ScopedInterceptTableModelObserver() override {
+    model_to_intercept_->SetObserver(real_table_model_observer_);
+  }
+
+  // ui::TableModelObserver:
+  void OnModelChanged() override {
+    real_table_model_observer_->OnModelChanged();
+    callback_.Run();
+  }
+  void OnItemsChanged(int start, int length) override {
+    real_table_model_observer_->OnItemsChanged(start, length);
+    callback_.Run();
+  }
+  void OnItemsAdded(int start, int length) override {
+    real_table_model_observer_->OnItemsAdded(start, length);
+    callback_.Run();
+  }
+  void OnItemsRemoved(int start, int length) override {
+    real_table_model_observer_->OnItemsRemoved(start, length);
+    callback_.Run();
+  }
+
+ private:
+  ui::TableModel* model_to_intercept_;
+  ui::TableModelObserver* real_table_model_observer_;
+  base::Closure callback_;
+};
+
+namespace {
+
+// Returns the TaskManagerTableModel for the the visible NewTaskManagerView.
+TaskManagerTableModel* GetRealModel() {
+  return chrome::ShowTaskManager(nullptr);
+}
+
+}  // namespace
+
+TaskManagerTester::TaskManagerTester(const base::Closure& on_resource_change)
+    : model_(GetRealModel()) {
+  // Eavesdrop the model->view conversation, since the model only supports
+  // single observation.
+  if (!on_resource_change.is_null()) {
+    interceptor_.reset(new ScopedInterceptTableModelObserver(
+        model_, model_->table_model_observer_, on_resource_change));
+  }
+}
+
+TaskManagerTester::~TaskManagerTester() {
+  CHECK_EQ(GetRealModel(), model_) << "Task Manager should not be hidden "
+                                      "while TaskManagerTester is alive. "
+                                      "This indicates a test bug.";
+}
+
+// TaskManagerTester:
+int TaskManagerTester::GetRowCount() {
+  return model_->RowCount();
+}
+
+base::string16 TaskManagerTester::GetRowTitle(int row) {
+  return model_->GetText(row, IDS_TASK_MANAGER_TASK_COLUMN);
+}
+
+void TaskManagerTester::ToggleColumnVisibility(ColumnSpecifier column) {
+  int column_id = 0;
+  switch (column) {
+    case ColumnSpecifier::COLUMN_NONE:
+      return;
+    case ColumnSpecifier::SQLITE_MEMORY_USED:
+      column_id = IDS_TASK_MANAGER_SQLITE_MEMORY_USED_COLUMN;
+      break;
+    case ColumnSpecifier::V8_MEMORY_USED:
+    case ColumnSpecifier::V8_MEMORY:
+      column_id = IDS_TASK_MANAGER_JAVASCRIPT_MEMORY_ALLOCATED_COLUMN;
+      break;
+    case ColumnSpecifier::IDLE_WAKEUPS:
+      column_id = IDS_TASK_MANAGER_IDLE_WAKEUPS_COLUMN;
+      break;
+  }
+  model_->ToggleColumnVisibility(column_id);
+}
+
+int64_t TaskManagerTester::GetColumnValue(ColumnSpecifier column, int row) {
+  TaskId task_id = model_->tasks_[row];
+  int64_t value = 0;
+  int64_t ignored = 0;
+  bool success = false;
+
+  switch (column) {
+    case ColumnSpecifier::COLUMN_NONE:
+      break;
+    case ColumnSpecifier::V8_MEMORY:
+      success = task_manager()->GetV8Memory(task_id, &value, &ignored);
+      break;
+    case ColumnSpecifier::V8_MEMORY_USED:
+      success = task_manager()->GetV8Memory(task_id, &ignored, &value);
+      break;
+    case ColumnSpecifier::SQLITE_MEMORY_USED:
+      value = task_manager()->GetSqliteMemoryUsed(task_id);
+      success = true;
+      break;
+    case ColumnSpecifier::IDLE_WAKEUPS:
+      value = task_manager()->GetIdleWakeupsPerSecond(task_id);
+      success = true;
+      break;
+  }
+  if (!success)
+    return 0;
+  return value;
+}
+
+int32_t TaskManagerTester::GetTabId(int row) {
+  TaskId task_id = model_->tasks_[row];
+  return task_manager()->GetTabId(task_id);
+}
+
+void TaskManagerTester::Kill(int row) {
+  model_->KillTask(row);
+}
+
+void TaskManagerTester::GetRowsGroupRange(int row,
+                                          int* out_start,
+                                          int* out_length) {
+  return model_->GetRowsGroupRange(row, out_start, out_length);
+}
+
+TaskManagerInterface* TaskManagerTester::task_manager() {
+  return model_->observed_task_manager();
+}
+
+// static
+std::unique_ptr<TaskManagerTester> TaskManagerTester::Create(
+    const base::Closure& callback) {
+  return base::WrapUnique(new TaskManagerTester(callback));
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/task_manager_tester.h b/chrome/browser/task_management/task_manager_tester.h
new file mode 100644
index 0000000..2a7c21d
--- /dev/null
+++ b/chrome/browser/task_management/task_manager_tester.h
@@ -0,0 +1,71 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_TESTER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_TESTER_H_
+
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/callback_forward.h"
+#include "base/strings/string16.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
+
+namespace task_management {
+
+class ScopedInterceptTableModelObserver;
+class TaskManagerInterface;
+class TaskManagerTableModel;
+
+// An adapter to simplify testing the task manager.
+class TaskManagerTester {
+ public:
+  using ColumnSpecifier = browsertest_util::ColumnSpecifier;
+
+  ~TaskManagerTester();
+
+  // Creates a TaskManagerTester backed by the current task manager. The task
+  // manager should already be visible when you call this function.
+  // |on_resource_change|, if not a null callback, will be invoked when the
+  // underlying model changes.
+  static std::unique_ptr<TaskManagerTester> Create(
+      const base::Closure& on_resource_change);
+
+  // Get the number of rows currently in the task manager.
+  int GetRowCount();
+
+  // Get the title text of a particular |row|.
+  base::string16 GetRowTitle(int row);
+
+  // Hide or show a column. If a column is not visible its stats are not
+  // necessarily gathered.
+  void ToggleColumnVisibility(ColumnSpecifier column);
+
+  // Get the value of a column as an int64. Memory values are in bytes.
+  int64_t GetColumnValue(ColumnSpecifier column, int row);
+
+  // If |row| is associated with a WebContents, return its SessionID. Otherwise,
+  // return -1.
+  int32_t GetTabId(int row);
+
+  // Kill the process of |row|.
+  void Kill(int row);
+
+  // Gets the start index and length of the group to which the task at
+  // |row_index| belongs.
+  void GetRowsGroupRange(int row, int* out_start, int* out_length);
+
+ private:
+  explicit TaskManagerTester(const base::Closure& on_resource_change);
+
+  TaskManagerInterface* task_manager();
+
+  TaskManagerTableModel* model_;
+  std::unique_ptr<ScopedInterceptTableModelObserver> interceptor_;
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_TASK_MANAGER_TESTER_H_
diff --git a/chrome/browser/task_management/test_task_manager.cc b/chrome/browser/task_management/test_task_manager.cc
new file mode 100644
index 0000000..5dc9e53
--- /dev/null
+++ b/chrome/browser/task_management/test_task_manager.cc
@@ -0,0 +1,177 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/test_task_manager.h"
+
+namespace task_management {
+
+TestTaskManager::TestTaskManager()
+    : handle_(base::kNullProcessHandle),
+      pid_(base::kNullProcessId) {
+  set_timer_for_testing(
+      std::unique_ptr<base::Timer>(new base::MockTimer(true, true)));
+}
+
+TestTaskManager::~TestTaskManager() {
+}
+
+void TestTaskManager::ActivateTask(TaskId task_id) {
+}
+
+bool TestTaskManager::IsTaskKillable(TaskId task_id) {
+  return true;
+}
+
+void TestTaskManager::KillTask(TaskId task_id) {
+}
+
+double TestTaskManager::GetCpuUsage(TaskId task_id) const {
+  return 0.0;
+}
+
+int64_t TestTaskManager::GetPhysicalMemoryUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetPrivateMemoryUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetSharedMemoryUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetSwappedMemoryUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetGpuMemoryUsage(TaskId task_id,
+                                           bool* has_duplicates) const {
+  return -1;
+}
+
+int TestTaskManager::GetIdleWakeupsPerSecond(TaskId task_id) const {
+  return -1;
+}
+
+int TestTaskManager::GetNaClDebugStubPort(TaskId task_id) const {
+  return -1;
+}
+
+void TestTaskManager::GetGDIHandles(TaskId task_id,
+                                    int64_t* current,
+                                    int64_t* peak) const {}
+
+void TestTaskManager::GetUSERHandles(TaskId task_id,
+                                     int64_t* current,
+                                     int64_t* peak) const {}
+
+int TestTaskManager::GetOpenFdCount(TaskId task_id) const {
+  return -1;
+}
+
+bool TestTaskManager::IsTaskOnBackgroundedProcess(TaskId task_id) const {
+  return false;
+}
+
+const base::string16& TestTaskManager::GetTitle(TaskId task_id) const {
+  return title_;
+}
+
+const std::string& TestTaskManager::GetTaskNameForRappor(TaskId task_id) const {
+  return rappor_sample_;
+}
+
+base::string16 TestTaskManager::GetProfileName(TaskId task_id) const {
+  return base::string16();
+}
+
+const gfx::ImageSkia& TestTaskManager::GetIcon(TaskId task_id) const {
+  return icon_;
+}
+
+const base::ProcessHandle& TestTaskManager::GetProcessHandle(
+    TaskId task_id) const {
+  return handle_;
+}
+
+const base::ProcessId& TestTaskManager::GetProcessId(TaskId task_id) const {
+  return pid_;
+}
+
+Task::Type TestTaskManager::GetType(TaskId task_id) const {
+  return Task::UNKNOWN;
+}
+
+int TestTaskManager::GetTabId(TaskId task_id) const {
+  return -1;
+}
+
+int TestTaskManager::GetChildProcessUniqueId(TaskId task_id) const {
+  return 0;
+}
+
+void TestTaskManager::GetTerminationStatus(TaskId task_id,
+                                           base::TerminationStatus* out_status,
+                                           int* out_error_code) const {
+  DCHECK(out_status);
+  DCHECK(out_error_code);
+
+  *out_status = base::TERMINATION_STATUS_STILL_RUNNING;
+  *out_error_code = 0;
+}
+
+int64_t TestTaskManager::GetNetworkUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetProcessTotalNetworkUsage(TaskId task_id) const {
+  return -1;
+}
+
+int64_t TestTaskManager::GetSqliteMemoryUsed(TaskId task_id) const {
+  return -1;
+}
+
+bool TestTaskManager::GetV8Memory(TaskId task_id,
+                                  int64_t* allocated,
+                                  int64_t* used) const {
+  return false;
+}
+
+bool TestTaskManager::GetWebCacheStats(
+    TaskId task_id,
+    blink::WebCache::ResourceTypeStats* stats) const {
+  return false;
+}
+
+const TaskIdList& TestTaskManager::GetTaskIdsList() const {
+  return ids_;
+}
+
+TaskIdList TestTaskManager::GetIdsOfTasksSharingSameProcess(
+    TaskId task_id) const {
+  TaskIdList result;
+  result.push_back(task_id);
+  return result;
+}
+
+size_t TestTaskManager::GetNumberOfTasksOnSameProcess(TaskId task_id) const {
+  return 1;
+}
+
+TaskId TestTaskManager::GetTaskIdForWebContents(
+    content::WebContents* web_contents) const {
+  return -1;
+}
+
+base::TimeDelta TestTaskManager::GetRefreshTime() {
+  return GetCurrentRefreshTime();
+}
+
+int64_t TestTaskManager::GetEnabledFlags() {
+  return enabled_resources_flags();
+}
+
+}  // namespace task_management
diff --git a/chrome/browser/task_management/test_task_manager.h b/chrome/browser/task_management/test_task_manager.h
new file mode 100644
index 0000000..7b45696
--- /dev/null
+++ b/chrome/browser/task_management/test_task_manager.h
@@ -0,0 +1,94 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_TEST_TASK_MANAGER_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_TEST_TASK_MANAGER_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "base/timer/mock_timer.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
+
+namespace task_management {
+
+// This is a partial stub implementation that can be used as a base class for
+// implementations of the task manager used in unit tests.
+class TestTaskManager : public TaskManagerInterface {
+ public:
+  TestTaskManager();
+  ~TestTaskManager() override;
+
+  // task_management::TaskManagerInterface:
+  void ActivateTask(TaskId task_id) override;
+  bool IsTaskKillable(TaskId task_id) override;
+  void KillTask(TaskId task_id) override;
+  double GetCpuUsage(TaskId task_id) const override;
+  int64_t GetPhysicalMemoryUsage(TaskId task_id) const override;
+  int64_t GetPrivateMemoryUsage(TaskId task_id) const override;
+  int64_t GetSharedMemoryUsage(TaskId task_id) const override;
+  int64_t GetSwappedMemoryUsage(TaskId task_id) const override;
+  int64_t GetGpuMemoryUsage(TaskId task_id,
+                            bool* has_duplicates) const override;
+  int GetIdleWakeupsPerSecond(TaskId task_id) const override;
+  int GetNaClDebugStubPort(TaskId task_id) const override;
+  void GetGDIHandles(TaskId task_id,
+                     int64_t* current,
+                     int64_t* peak) const override;
+  void GetUSERHandles(TaskId task_id,
+                      int64_t* current,
+                      int64_t* peak) const override;
+  int GetOpenFdCount(TaskId task_id) const override;
+  bool IsTaskOnBackgroundedProcess(TaskId task_id) const override;
+  const base::string16& GetTitle(TaskId task_id) const override;
+  const std::string& GetTaskNameForRappor(TaskId task_id) const override;
+  base::string16 GetProfileName(TaskId task_id) const override;
+  const gfx::ImageSkia& GetIcon(TaskId task_id) const override;
+  const base::ProcessHandle& GetProcessHandle(TaskId task_id) const override;
+  const base::ProcessId& GetProcessId(TaskId task_id) const override;
+  Task::Type GetType(TaskId task_id) const override;
+  int GetTabId(TaskId task_id) const override;
+  int GetChildProcessUniqueId(TaskId task_id) const override;
+  void GetTerminationStatus(TaskId task_id,
+                            base::TerminationStatus* out_status,
+                            int* out_error_code) const override;
+  int64_t GetNetworkUsage(TaskId task_id) const override;
+  int64_t GetProcessTotalNetworkUsage(TaskId task_id) const override;
+  int64_t GetSqliteMemoryUsed(TaskId task_id) const override;
+  bool GetV8Memory(TaskId task_id,
+                   int64_t* allocated,
+                   int64_t* used) const override;
+  bool GetWebCacheStats(
+      TaskId task_id,
+      blink::WebCache::ResourceTypeStats* stats) const override;
+  const TaskIdList& GetTaskIdsList() const override;
+  TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const override;
+  size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const override;
+  TaskId GetTaskIdForWebContents(
+      content::WebContents* web_contents) const override;
+
+  base::TimeDelta GetRefreshTime();
+  int64_t GetEnabledFlags();
+
+ protected:
+  // task_management::TaskManager:
+  void Refresh() override {}
+  void StartUpdating() override {}
+  void StopUpdating() override {}
+
+  base::ProcessHandle handle_;
+  base::ProcessId pid_;
+  base::string16 title_;
+  std::string rappor_sample_;
+  gfx::ImageSkia icon_;
+  TaskIdList ids_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(TestTaskManager);
+};
+
+}  // namespace task_management
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_TEST_TASK_MANAGER_H_
diff --git a/chrome/browser/task_management/web_contents_tags.cc b/chrome/browser/task_management/web_contents_tags.cc
new file mode 100644
index 0000000..678923f
--- /dev/null
+++ b/chrome/browser/task_management/web_contents_tags.cc
@@ -0,0 +1,176 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/task_management/web_contents_tags.h"
+
+#include "chrome/browser/task_management/providers/web_contents/background_contents_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/devtools_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/extension_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/guest_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/panel_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/prerender_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/printing_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/tab_contents_tag.h"
+#include "chrome/browser/task_management/providers/web_contents/web_contents_tags_manager.h"
+#include "components/guest_view/browser/guest_view_base.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/browser/view_type_utils.h"
+
+#if defined(ENABLE_EXTENSIONS)
+#include "chrome/browser/ui/panels/panel.h"
+#include "extensions/browser/process_manager.h"
+#endif
+
+namespace task_management {
+
+#if defined(ENABLE_TASK_MANAGER)
+namespace {
+
+// Adds the |tag| to |contents|. It also adds the |tag| to the
+// |WebContentsTagsManager|.
+// Note: This will fail if |contents| is already tagged by |tag|.
+void TagWebContents(content::WebContents* contents,
+                    WebContentsTag* tag,
+                    void* tag_key) {
+  DCHECK(contents);
+  DCHECK(tag);
+  DCHECK(WebContentsTag::FromWebContents(contents) == nullptr);
+  contents->SetUserData(tag_key, tag);
+  WebContentsTagsManager::GetInstance()->AddTag(tag);
+}
+
+#if defined(ENABLE_EXTENSIONS)
+
+bool IsExtensionWebContents(content::WebContents* contents) {
+  DCHECK(contents);
+
+  if (guest_view::GuestViewBase::IsGuest(contents))
+    return false;
+
+  extensions::ViewType view_type = extensions::GetViewType(contents);
+  return (view_type != extensions::VIEW_TYPE_INVALID &&
+          view_type != extensions::VIEW_TYPE_TAB_CONTENTS &&
+          view_type != extensions::VIEW_TYPE_BACKGROUND_CONTENTS &&
+          view_type != extensions::VIEW_TYPE_PANEL);
+}
+
+#endif  // defined(ENABLE_EXTENSIONS)
+
+}  // namespace
+#endif  // defined(ENABLE_TASK_MANAGER)
+
+// static
+void WebContentsTags::CreateForBackgroundContents(
+    content::WebContents* web_contents,
+    BackgroundContents* background_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(
+        web_contents,
+        new BackgroundContentsTag(web_contents, background_contents),
+        WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+// static
+void WebContentsTags::CreateForDevToolsContents(
+    content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new DevToolsTag(web_contents),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+// static
+void WebContentsTags::CreateForPrerenderContents(
+    content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new PrerenderTag(web_contents),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+// static
+void WebContentsTags::CreateForTabContents(content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new TabContentsTag(web_contents),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+// static
+void WebContentsTags::CreateForPanel(content::WebContents* web_contents,
+                                     Panel* panel) {
+#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
+  DCHECK(panel);
+  DCHECK_EQ(web_contents, panel->GetWebContents());
+
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new PanelTag(web_contents, panel),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
+}
+
+// static
+void WebContentsTags::CreateForPrintingContents(
+    content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_PRINT_PREVIEW)
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new PrintingTag(web_contents),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_PRINT_PREVIEW)
+}
+
+// static
+void WebContentsTags::CreateForGuestContents(
+    content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  DCHECK(guest_view::GuestViewBase::IsGuest(web_contents));
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new GuestTag(web_contents),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+// static
+void WebContentsTags::CreateForExtension(content::WebContents* web_contents,
+                                         extensions::ViewType view_type) {
+#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
+  DCHECK(IsExtensionWebContents(web_contents));
+
+  if (!WebContentsTag::FromWebContents(web_contents)) {
+    TagWebContents(web_contents,
+                   new ExtensionTag(web_contents, view_type),
+                   WebContentsTag::kTagKey);
+  }
+#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
+}
+
+// static
+void WebContentsTags::ClearTag(content::WebContents* web_contents) {
+#if defined(ENABLE_TASK_MANAGER)
+  const WebContentsTag* tag = WebContentsTag::FromWebContents(web_contents);
+  WebContentsTagsManager::GetInstance()->ClearFromProvider(tag);
+  web_contents->RemoveUserData(WebContentsTag::kTagKey);
+#endif  // defined(ENABLE_TASK_MANAGER)
+}
+
+}  // namespace task_management
+
diff --git a/chrome/browser/task_management/web_contents_tags.h b/chrome/browser/task_management/web_contents_tags.h
new file mode 100644
index 0000000..e170f26
--- /dev/null
+++ b/chrome/browser/task_management/web_contents_tags.h
@@ -0,0 +1,103 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_TASK_MANAGEMENT_WEB_CONTENTS_TAGS_H_
+#define CHROME_BROWSER_TASK_MANAGEMENT_WEB_CONTENTS_TAGS_H_
+
+#include "base/macros.h"
+#include "extensions/common/view_type.h"
+
+class BackgroundContents;
+class Panel;
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+namespace task_management {
+
+// Defines a factory class for creating the TaskManager-specific Tags for the
+// WebContents that are owned by various types of services.
+//
+// Any service or feature that creates WebContents instances (via
+// WebContents::Create) needs to make sure that they are tagged using this
+// mechanism, otherwise the associated render processes will not show up in the
+// task manager.
+class WebContentsTags {
+ public:
+  // Tag a BackgroundContents so that it shows up in the task manager. Calling
+  // this function creates a BackgroundContentsTag, and attaches it to
+  // |web_contents|. If an instance is already attached, this does nothing. The
+  // resulting tag does not have to be cleaned up by the caller, as it is owned
+  // by |web_contents|.
+  static void CreateForBackgroundContents(
+      content::WebContents* web_contents,
+      BackgroundContents* background_contents);
+
+  // Tag a DevTools WebContents so that it shows up in the task manager. Calling
+  // this function creates a DevToolsTag, and attaches it to |web_contents|. If
+  // an instance is already attached, this does nothing. The resulting tag does
+  // not have to be cleaned up by the caller, as it is owned by |web_contents|.
+  static void CreateForDevToolsContents(content::WebContents* web_contents);
+
+  // Tag a WebContents owned by the PrerenderManager so that it shows up in the
+  // task manager. Calling this function creates a PrerenderTag, and attaches it
+  // to |web_contents|. If an instance is already attached, this does nothing.
+  // The resulting tag does not have to be cleaned up by the caller, as it is
+  // owned by |web_contents|.
+  static void CreateForPrerenderContents(content::WebContents* web_contents);
+
+  // Tag a WebContents owned by the TabStripModel so that it shows up in the
+  // task manager. Calling this function creates a TabContentsTag, and attaches
+  // it to |web_contents|. If an instance is already attached, this does
+  // nothing. The resulting tag does not have to be cleaned up by the caller, as
+  // it is owned by |web_contents|.
+  static void CreateForTabContents(content::WebContents* web_contents);
+
+  // Tag a WebContents owned by a |panel| in the PanelManager so that it shows
+  // up in the task manager. Calling this function creates a PanelTag, and
+  // attaches it to |web_contents|. If an instance is already attached, this
+  // does nothing. The resulting tag does not have to be cleaned up by the
+  // caller, as it is owned by |web_contents|.
+  // Note: |web_contents| must be equal to |panel->GetWebContents()|.
+  static void CreateForPanel(content::WebContents* web_contents, Panel* panel);
+
+  // Tag a WebContents created for a print preview or background printing so
+  // that it shows up in the task manager. Calling this function creates a
+  // PrintingTag, and attaches it to |web_contents|. If an instance is already
+  // attached, this does nothing. The resulting tag does not have to be cleaned
+  // up by the caller, as it is owned by |web_contents|.
+  static void CreateForPrintingContents(content::WebContents* web_contents);
+
+  // Tag a WebContents owned by a GuestViewBase so that it shows up in the
+  // task manager. Calling this function creates a GuestTag, and attaches it to
+  // |web_contents|. If an instance is already attached, this does nothing. The
+  // resulting tag does not have to be cleaned up by the caller, as it is owned
+  // by |web_contents|.
+  static void CreateForGuestContents(content::WebContents* web_contents);
+
+  // Tag a WebContents that belongs to |extension| so that it shows up in the
+  // task manager. Calling this function creates a ExtensionTag, and attaches
+  // it to |web_contents|. If an instance is already attached, this does
+  // nothing. The resulting tag does not have to be cleaned up by the caller,
+  // as it is owned by |web_contents|.
+  // |web_contents| must be of a non-tab, non-guest view, non-panel, or
+  // non-background contents Extension.
+  static void CreateForExtension(content::WebContents* web_contents,
+                                 extensions::ViewType view_type);
+
+  // Clears the task-manager tag, created by any of the above functions, from
+  // the given |web_contents| if any.
+  // Clearing the tag is necessary only when you need to re-tag an existing
+  // WebContents, to indicate a change in ownership.
+  static void ClearTag(content::WebContents* web_contents);
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WebContentsTags);
+};
+
+}  // namespace task_management
+
+
+#endif  // CHROME_BROWSER_TASK_MANAGEMENT_WEB_CONTENTS_TAGS_H_
diff --git a/chrome/browser/task_manager/DEPS b/chrome/browser/task_manager/DEPS
deleted file mode 100644
index de9193f..0000000
--- a/chrome/browser/task_manager/DEPS
+++ /dev/null
@@ -1,3 +0,0 @@
-include_rules = [
-  "+extensions/strings/grit/extensions_strings.h"
-]
diff --git a/chrome/browser/task_manager/OWNERS b/chrome/browser/task_manager/OWNERS
deleted file mode 100644
index 422a446..0000000
--- a/chrome/browser/task_manager/OWNERS
+++ /dev/null
@@ -1,2 +0,0 @@
-afakhry@chromium.org
-nick@chromium.org
diff --git a/chrome/browser/task_manager/mock_web_contents_task_manager.cc b/chrome/browser/task_manager/mock_web_contents_task_manager.cc
deleted file mode 100644
index b322d1a..0000000
--- a/chrome/browser/task_manager/mock_web_contents_task_manager.cc
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-
-#include "base/stl_util.h"
-#include "build/build_config.h"
-
-#if defined(OS_CHROMEOS)
-#include "chrome/browser/chromeos/resource_reporter/resource_reporter.h"
-#endif  // defined(OS_CHROMEOS)
-
-namespace task_manager {
-
-MockWebContentsTaskManager::MockWebContentsTaskManager() {}
-
-MockWebContentsTaskManager::~MockWebContentsTaskManager() {}
-
-void MockWebContentsTaskManager::TaskAdded(Task* task) {
-  DCHECK(task);
-  DCHECK(!ContainsValue(tasks_, task));
-  tasks_.push_back(task);
-}
-
-void MockWebContentsTaskManager::TaskRemoved(Task* task) {
-  DCHECK(task);
-  DCHECK(ContainsValue(tasks_, task));
-  tasks_.erase(std::find(tasks_.begin(), tasks_.end(), task));
-}
-
-void MockWebContentsTaskManager::StartObserving() {
-#if defined(OS_CHROMEOS)
-  // On ChromeOS, the ResourceReporter needs to be turned off so as not to
-  // interfere with the tests.
-  chromeos::ResourceReporter::GetInstance()->StopMonitoring();
-#endif  // defined(OS_CHROMEOS)
-
-  provider_.SetObserver(this);
-}
-
-void MockWebContentsTaskManager::StopObserving() {
-  provider_.ClearObserver();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/mock_web_contents_task_manager.h b/chrome/browser/task_manager/mock_web_contents_task_manager.h
deleted file mode 100644
index f55edf0..0000000
--- a/chrome/browser/task_manager/mock_web_contents_task_manager.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
-#define CHROME_BROWSER_TASK_MANAGER_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task_provider_observer.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h"
-
-namespace task_manager {
-
-// Defines a test class that will act as a task manager that is designed to
-// only observe the WebContents-based tasks.
-class MockWebContentsTaskManager : public TaskProviderObserver {
- public:
-  MockWebContentsTaskManager();
-  ~MockWebContentsTaskManager() override;
-
-  // task_manager::TaskProviderObserver:
-  void TaskAdded(Task* task) override;
-  void TaskRemoved(Task* task) override;
-
-  // Start / Stop observing the WebContentsTaskProvider.
-  void StartObserving();
-  void StopObserving();
-
-  const std::vector<Task*>& tasks() const { return tasks_; }
-
- private:
-  std::vector<Task*> tasks_;
-  WebContentsTaskProvider provider_;
-
-  DISALLOW_COPY_AND_ASSIGN(MockWebContentsTaskManager);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_MOCK_WEB_CONTENTS_TASK_MANAGER_H_
diff --git a/chrome/browser/task_manager/providers/arc/arc_process_task.cc b/chrome/browser/task_manager/providers/arc/arc_process_task.cc
deleted file mode 100644
index 4db749c..0000000
--- a/chrome/browser/task_manager/providers/arc/arc_process_task.cc
+++ /dev/null
@@ -1,174 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/arc/arc_process_task.h"
-
-#include "base/bind.h"
-#include "base/i18n/rtl.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/grit/generated_resources.h"
-#include "components/arc/arc_service_manager.h"
-#include "components/arc/common/process.mojom.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/common/child_process_host.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/gfx/image/image.h"
-
-namespace task_manager {
-
-namespace {
-
-base::string16 MakeTitle(const std::string& process_name,
-                         arc::mojom::ProcessState process_state) {
-  int name_template = IDS_TASK_MANAGER_ARC_PREFIX;
-  switch (process_state) {
-    case arc::mojom::ProcessState::PERSISTENT:
-    case arc::mojom::ProcessState::PERSISTENT_UI:
-    case arc::mojom::ProcessState::TOP:
-      name_template = IDS_TASK_MANAGER_ARC_SYSTEM;
-      break;
-    case arc::mojom::ProcessState::BOUND_FOREGROUND_SERVICE:
-    case arc::mojom::ProcessState::FOREGROUND_SERVICE:
-    case arc::mojom::ProcessState::SERVICE:
-    case arc::mojom::ProcessState::IMPORTANT_FOREGROUND:
-    case arc::mojom::ProcessState::IMPORTANT_BACKGROUND:
-      name_template = IDS_TASK_MANAGER_ARC_PREFIX_BACKGROUND_SERVICE;
-      break;
-    case arc::mojom::ProcessState::RECEIVER:
-      name_template = IDS_TASK_MANAGER_ARC_PREFIX_RECEIVER;
-      break;
-    default:
-      break;
-  }
-  base::string16 title = l10n_util::GetStringFUTF16(
-      name_template, base::UTF8ToUTF16(process_name));
-  base::i18n::AdjustStringForLocaleDirection(&title);
-  return title;
-}
-
-scoped_refptr<arc::ActivityIconLoader> GetIconLoader() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  arc::ArcServiceManager* arc_service_manager = arc::ArcServiceManager::Get();
-  if (!arc_service_manager)
-    return nullptr;
-  return arc_service_manager->icon_loader();
-}
-
-// An activity name for retrieving the package's default icon without
-// specifying an activity name.
-constexpr char kEmptyActivityName[] = "";
-
-}  // namespace
-
-ArcProcessTask::ArcProcessTask(base::ProcessId pid,
-                               base::ProcessId nspid,
-                               const std::string& process_name,
-                               arc::mojom::ProcessState process_state,
-                               const std::vector<std::string>& packages)
-    : Task(MakeTitle(process_name, process_state),
-           process_name,
-           nullptr /* icon */,
-           pid),
-      nspid_(nspid),
-      process_name_(process_name),
-      process_state_(process_state),
-      // |packages| contains an alphabetically-sorted list of package names the
-      // process has. Since the Task class can hold only one icon per process,
-      // and there is no reliable way to pick the most important process from
-      // the |packages| list, just use the first item in the list.
-      package_name_(packages.empty() ? "" : packages.at(0)),
-      weak_ptr_factory_(this) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  StartIconLoading();
-}
-
-void ArcProcessTask::StartIconLoading() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (package_name_.empty())
-    return;
-
-  scoped_refptr<arc::ActivityIconLoader> icon_loader = GetIconLoader();
-  arc::ActivityIconLoader::GetResult result =
-      arc::ActivityIconLoader::GetResult::FAILED_ARC_NOT_READY;
-  if (icon_loader) {
-    std::vector<arc::ActivityIconLoader::ActivityName> activities = {
-        {package_name_, kEmptyActivityName}};
-    result = icon_loader->GetActivityIcons(
-        activities, base::Bind(&ArcProcessTask::OnIconLoaded,
-                               weak_ptr_factory_.GetWeakPtr()));
-  }
-
-  if (result == arc::ActivityIconLoader::GetResult::FAILED_ARC_NOT_READY) {
-    // Need to retry loading the icon.
-    arc::ArcBridgeService::Get()->intent_helper()->AddObserver(this);
-  }
-}
-
-ArcProcessTask::~ArcProcessTask() {
-  arc::ArcBridgeService::Get()->intent_helper()->RemoveObserver(this);
-}
-
-Task::Type ArcProcessTask::GetType() const {
-  return Task::ARC;
-}
-
-int ArcProcessTask::GetChildProcessUniqueID() const {
-  // ARC process is not a child process of the browser.
-  return content::ChildProcessHost::kInvalidUniqueID;
-}
-
-bool ArcProcessTask::IsKillable() {
-  // Do not kill persistent processes.
-  return process_state_ > arc::mojom::ProcessState::PERSISTENT_UI;
-}
-
-void ArcProcessTask::Kill() {
-  arc::mojom::ProcessInstance* arc_process_instance =
-      arc::ArcBridgeService::Get()->process()->instance();
-  if (!arc_process_instance) {
-    LOG(ERROR) << "ARC process instance is not ready.";
-    return;
-  }
-  if (arc::ArcBridgeService::Get()->process()->version() < 1) {
-    LOG(ERROR) << "ARC KillProcess IPC is unavailable.";
-    return;
-  }
-  arc_process_instance->KillProcess(nspid_,
-                                    "Killed manually from Task Manager");
-}
-
-void ArcProcessTask::OnInstanceReady() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  VLOG(2) << "intent_helper instance is ready. Fetching the icon for "
-          << package_name_;
-  arc::ArcBridgeService::Get()->intent_helper()->RemoveObserver(this);
-
-  // Instead of calling into StartIconLoading() directly, return to the main
-  // loop first to make sure other ArcBridgeService observers are notified.
-  // Otherwise, arc::ActivityIconLoader::GetActivityIcon() may fail again.
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                                   base::Bind(&ArcProcessTask::StartIconLoading,
-                                              weak_ptr_factory_.GetWeakPtr()));
-}
-
-void ArcProcessTask::SetProcessState(arc::mojom::ProcessState process_state) {
-  process_state_ = process_state;
-}
-
-void ArcProcessTask::OnIconLoaded(
-    std::unique_ptr<arc::ActivityIconLoader::ActivityToIconsMap> icons) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  for (const auto& kv : *icons) {
-    const gfx::Image& icon = kv.second.icon16;
-    if (icon.IsEmpty())
-      continue;
-    set_icon(*icon.ToImageSkia());
-    break;  // Since the parent class can hold only one icon, break here.
-  }
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/arc/arc_process_task.h b/chrome/browser/task_manager/providers/arc/arc_process_task.h
deleted file mode 100644
index 6fce2ed..0000000
--- a/chrome/browser/task_manager/providers/arc/arc_process_task.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "chrome/browser/task_manager/providers/task.h"
-#include "components/arc/arc_bridge_service.h"
-#include "components/arc/common/process.mojom.h"
-#include "components/arc/instance_holder.h"
-#include "components/arc/intent_helper/activity_icon_loader.h"
-
-namespace task_manager {
-
-// Defines a task that represents an ARC process.
-class ArcProcessTask
-    : public Task,
-      public arc::InstanceHolder<arc::mojom::IntentHelperInstance>::Observer {
- public:
-  ArcProcessTask(base::ProcessId pid,
-                 base::ProcessId nspid,
-                 const std::string& process_name,
-                 arc::mojom::ProcessState process_state,
-                 const std::vector<std::string>& packages);
-  ~ArcProcessTask() override;
-
-  // task_manager::Task:
-  Type GetType() const override;
-  int GetChildProcessUniqueID() const override;
-  bool IsKillable() override;
-  void Kill() override;
-
-  // arc::InstanceHolder<arc::mojom::IntentHelperInstance>::Observer:
-  void OnInstanceReady() override;
-
-  void SetProcessState(arc::mojom::ProcessState process_state);
-
-  base::ProcessId nspid() const { return nspid_; }
-  const std::string& process_name() const { return process_name_; }
-
- private:
-  void StartIconLoading();
-  void OnIconLoaded(
-      std::unique_ptr<arc::ActivityIconLoader::ActivityToIconsMap> icons);
-
-  const base::ProcessId nspid_;
-  const std::string process_name_;
-  arc::mojom::ProcessState process_state_;
-  const std::string package_name_;
-
-  // Note: This should remain the last member so it'll be destroyed and
-  // invalidate the weak pointers before any other members are destroyed.
-  base::WeakPtrFactory<ArcProcessTask> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ArcProcessTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/arc/arc_process_task_provider.cc b/chrome/browser/task_manager/providers/arc/arc_process_task_provider.cc
deleted file mode 100644
index 23b545e..0000000
--- a/chrome/browser/task_manager/providers/arc/arc_process_task_provider.cc
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/arc/arc_process_task_provider.h"
-
-#include <stddef.h>
-
-#include <queue>
-#include <set>
-#include <utility>
-#include <vector>
-
-#include "base/logging.h"
-#include "base/process/process.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/trace_event/trace_event.h"
-#include "chrome/browser/chromeos/arc/arc_process.h"
-#include "chrome/browser/chromeos/arc/arc_process_service.h"
-#include "components/arc/common/process.mojom.h"
-
-namespace task_manager {
-
-namespace {
-
-const int kUpdateProcessListDelaySeconds = 1;
-
-}  // namespace
-
-using std::set;
-using arc::ArcProcess;
-using base::Process;
-using base::ProcessId;
-
-ArcProcessTaskProvider::ArcProcessTaskProvider()
-    : is_updating_(false), weak_ptr_factory_(this) {}
-
-ArcProcessTaskProvider::~ArcProcessTaskProvider() {}
-
-Task* ArcProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
-                                                  int child_id,
-                                                  int route_id) {
-  // ARC tasks are not associated with any URL request.
-  return nullptr;
-}
-
-void ArcProcessTaskProvider::OnUpdateProcessList(
-    const std::vector<ArcProcess>& processes) {
-  TRACE_EVENT0("browser", "ArcProcessTaskProvider::OnUpdateProcessList");
-
-  if (!is_updating_)
-    return;
-
-  // NB: |processes| can be already stale here because it is sent via IPC, and
-  // we can never avoid that. See also the comment at the declaration of
-  // ArcProcessTaskProvider.
-
-  set<ProcessId> nspid_to_remove;
-  for (const auto& entry : nspid_to_task_)
-    nspid_to_remove.insert(entry.first);
-
-  for (const auto& entry : processes) {
-    if (nspid_to_remove.erase(entry.nspid()) == 0) {
-      // New arc process.
-      std::unique_ptr<ArcProcessTask>& task = nspid_to_task_[entry.nspid()];
-      // After calling NotifyObserverTaskAdded(), the raw pointer of |task| is
-      // remebered somewhere else. One should not (implicitly) delete the
-      // referenced object before calling NotifyObserverTaskRemoved() first
-      // (crbug.com/587707).
-      DCHECK(!task.get()) <<
-          "Task with the same pid should not be added twice.";
-      task.reset(new ArcProcessTask(entry.pid(), entry.nspid(),
-                                    entry.process_name(), entry.process_state(),
-                                    entry.packages()));
-      NotifyObserverTaskAdded(task.get());
-    } else {
-      // Update process state of existing process.
-      std::unique_ptr<ArcProcessTask>& task = nspid_to_task_[entry.nspid()];
-      DCHECK(task.get());
-      task->SetProcessState(entry.process_state());
-    }
-  }
-
-  for (const auto& entry : nspid_to_remove) {
-    // Stale arc process.
-    NotifyObserverTaskRemoved(nspid_to_task_[entry].get());
-    nspid_to_task_.erase(entry);
-  }
-  ScheduleNextRequest();
-}
-
-void ArcProcessTaskProvider::RequestProcessList() {
-  arc::ArcProcessService* arc_process_service =
-      arc::ArcProcessService::Get();
-  auto callback = base::Bind(&ArcProcessTaskProvider::OnUpdateProcessList,
-                             weak_ptr_factory_.GetWeakPtr());
-  if (!arc_process_service ||
-      !arc_process_service->RequestProcessList(callback)) {
-    VLOG(2) << "ARC process instance is not ready.";
-    // Update with the empty ARC process list.
-    // Note that this can happen in the middle of the session if the user has
-    // just opted out from ARC.
-    callback.Run(std::vector<ArcProcess>());
-  }
-}
-
-void ArcProcessTaskProvider::StartUpdating() {
-  is_updating_ = true;
-  RequestProcessList();
-}
-
-void ArcProcessTaskProvider::StopUpdating() {
-  is_updating_ = false;
-  nspid_to_task_.clear();
-}
-
-void ArcProcessTaskProvider::ScheduleNextRequest() {
-  if (!is_updating_)
-    return;
-  // TODO(nya): Remove this timer once ARC starts to send us UpdateProcessList
-  // message when the process list changed. As of today, ARC does not send
-  // the process list unless we request it by RequestProcessList message.
-  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
-      FROM_HERE,
-      base::Bind(&ArcProcessTaskProvider::RequestProcessList,
-                 weak_ptr_factory_.GetWeakPtr()),
-      base::TimeDelta::FromSeconds(kUpdateProcessListDelaySeconds));
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/arc/arc_process_task_provider.h b/chrome/browser/task_manager/providers/arc/arc_process_task_provider.h
deleted file mode 100644
index c87bb0b..0000000
--- a/chrome/browser/task_manager/providers/arc/arc_process_task_provider.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
-
-#include <map>
-#include <memory>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/process/process.h"
-#include "chrome/browser/chromeos/arc/arc_process.h"
-#include "chrome/browser/task_manager/providers/arc/arc_process_task.h"
-#include "chrome/browser/task_manager/providers/task_provider.h"
-
-namespace task_manager {
-
-// This provides the ARC process tasks.
-//
-// Since this provider obtains ARC process information via IPC and procfs,
-// it can never avoid race conditions. For example, in an extreme case such as
-// fork(2) is called millions of times in a second, this provider can return
-// wrong results. However, its chance is very low, and even if we hit the case,
-// the worst outcome is just that an app (non-system) process which
-// the user did not intend to choose is killed. Since apps are designed
-// to be killed at any time, it sounds acceptable.
-class ArcProcessTaskProvider : public TaskProvider {
- public:
-  ArcProcessTaskProvider();
-  ~ArcProcessTaskProvider() override;
-
-  // task_manager::TaskProvider:
-  Task* GetTaskOfUrlRequest(int origin_pid,
-                            int child_id,
-                            int route_id) override;
-
- private:
-  // Auto-retry if ARC bridge service is not ready.
-  void RequestProcessList();
-
-  void OnUpdateProcessList(const std::vector<arc::ArcProcess>& processes);
-
-  // task_manager::TaskProvider:
-  void StartUpdating() override;
-  void StopUpdating() override;
-
-  void ScheduleNextRequest();
-
-  std::map<base::ProcessId, std::unique_ptr<ArcProcessTask>> nspid_to_task_;
-
-  // Whether to continue the periodical polling.
-  bool is_updating_;
-
-  // Always keep this the last member of this class to make sure it's the
-  // first thing to be destructed.
-  base::WeakPtrFactory<ArcProcessTaskProvider> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ArcProcessTaskProvider);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_ARC_ARC_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_manager/providers/browser_process_task.cc b/chrome/browser/task_manager/providers/browser_process_task.cc
deleted file mode 100644
index a266f4e..0000000
--- a/chrome/browser/task_manager/providers/browser_process_task.cc
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/browser_process_task.h"
-
-#include "base/command_line.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/common/chrome_switches.h"
-#include "chrome/grit/generated_resources.h"
-#include "content/public/common/content_switches.h"
-#include "grit/theme_resources.h"
-#include "net/proxy/proxy_resolver_v8.h"
-#include "third_party/sqlite/sqlite3.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-
-namespace task_manager {
-
-namespace {
-
-gfx::ImageSkia* g_default_icon = nullptr;
-
-gfx::ImageSkia* GetDefaultIcon() {
-  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
-    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
-        IDR_PRODUCT_LOGO_16);
-    if (g_default_icon)
-      g_default_icon->MakeThreadSafe();
-  }
-
-  return g_default_icon;
-}
-
-bool ReportsV8Stats() {
-  const base::CommandLine* command_line =
-      base::CommandLine::ForCurrentProcess();
-  return !command_line->HasSwitch(switches::kWinHttpProxyResolver) &&
-      !command_line->HasSwitch(switches::kSingleProcess);
-}
-
-}  // namespace
-
-BrowserProcessTask::BrowserProcessTask()
-    : Task(l10n_util::GetStringUTF16(IDS_TASK_MANAGER_WEB_BROWSER_CELL_TEXT),
-           "Browser Process",
-           GetDefaultIcon(),
-           base::GetCurrentProcessHandle()),
-       allocated_v8_memory_(-1),
-       used_v8_memory_(-1),
-       used_sqlite_memory_(-1),
-       reports_v8_stats_(ReportsV8Stats()) {
-}
-
-BrowserProcessTask::~BrowserProcessTask() {
-}
-
-bool BrowserProcessTask::IsKillable() {
-  // Never kill the browser process.
-  return false;
-}
-
-void BrowserProcessTask::Kill() {
-  // Never kill the browser process.
-}
-
-void BrowserProcessTask::Refresh(const base::TimeDelta& update_interval,
-                                 int64_t refresh_flags) {
-  Task::Refresh(update_interval, refresh_flags);
-
-  if (reports_v8_stats_ && (refresh_flags & REFRESH_TYPE_V8_MEMORY) != 0) {
-    allocated_v8_memory_ =
-        static_cast<int64_t>(net::ProxyResolverV8::GetTotalHeapSize());
-    used_v8_memory_ =
-        static_cast<int64_t>(net::ProxyResolverV8::GetUsedHeapSize());
-  }
-
-  if ((refresh_flags & REFRESH_TYPE_SQLITE_MEMORY) != 0)
-    used_sqlite_memory_ = static_cast<int64_t>(sqlite3_memory_used());
-}
-
-Task::Type BrowserProcessTask::GetType() const {
-  return Task::BROWSER;
-}
-
-int BrowserProcessTask::GetChildProcessUniqueID() const {
-  return 0;
-}
-
-int64_t BrowserProcessTask::GetSqliteMemoryUsed() const {
-  return used_sqlite_memory_;
-}
-
-int64_t BrowserProcessTask::GetV8MemoryAllocated() const {
-  return allocated_v8_memory_;
-}
-
-int64_t BrowserProcessTask::GetV8MemoryUsed() const {
-  return used_v8_memory_;
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/browser_process_task.h b/chrome/browser/task_manager/providers/browser_process_task.h
deleted file mode 100644
index 0d0653f..0000000
--- a/chrome/browser/task_manager/providers/browser_process_task.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_H_
-
-#include <stdint.h>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task.h"
-
-namespace task_manager {
-
-// Defines the task that represents the one and only browser main process.
-class BrowserProcessTask : public Task {
- public:
-  BrowserProcessTask();
-  ~BrowserProcessTask() override;
-
-  // task_manager::Task:
-  bool IsKillable() override;
-  void Kill() override;
-  void Refresh(const base::TimeDelta& update_interval,
-               int64_t refresh_flags) override;
-  Type GetType() const override;
-  int GetChildProcessUniqueID() const override;
-  int64_t GetSqliteMemoryUsed() const override;
-  int64_t GetV8MemoryAllocated() const override;
-  int64_t GetV8MemoryUsed() const override;
-
- private:
-  int64_t allocated_v8_memory_;
-  int64_t used_v8_memory_;
-  int64_t used_sqlite_memory_;
-  bool reports_v8_stats_;
-
-  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/browser_process_task_provider.cc b/chrome/browser/task_manager/providers/browser_process_task_provider.cc
deleted file mode 100644
index fb5e8f5..0000000
--- a/chrome/browser/task_manager/providers/browser_process_task_provider.cc
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/browser_process_task_provider.h"
-
-namespace task_manager {
-
-BrowserProcessTaskProvider::BrowserProcessTaskProvider() {
-}
-
-BrowserProcessTaskProvider::~BrowserProcessTaskProvider() {
-}
-
-Task* BrowserProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
-                                                      int child_id,
-                                                      int route_id) {
-  if (origin_pid == 0 && child_id == -1)
-    return &browser_process_task_;
-
-  return nullptr;
-}
-
-void BrowserProcessTaskProvider::StartUpdating() {
-  NotifyObserverTaskAdded(&browser_process_task_);
-}
-
-void BrowserProcessTaskProvider::StopUpdating() {
-  // There's nothing to do here. The browser process task live as long as the
-  // browser lives and when StopUpdating() is called the |observer_| has already
-  // been cleared.
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/browser_process_task_provider.h b/chrome/browser/task_manager/providers/browser_process_task_provider.h
deleted file mode 100644
index 75a9511..0000000
--- a/chrome/browser/task_manager/providers/browser_process_task_provider.h
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/browser_process_task.h"
-#include "chrome/browser/task_manager/providers/task_provider.h"
-
-namespace task_manager {
-
-// This provides the browser process task which lives as long as the browser
-// lives.
-class BrowserProcessTaskProvider : public TaskProvider {
- public:
-  BrowserProcessTaskProvider();
-  ~BrowserProcessTaskProvider() override;
-
-  // task_manager::TaskProvider:
-  Task* GetTaskOfUrlRequest(int origin_pid,
-                            int child_id,
-                            int route_id) override;
-
- private:
-  // task_manager::TaskProvider:
-  void StartUpdating() override;
-  void StopUpdating() override;
-
-  // This is the task that represents the one and only main browser process. It
-  // lives as long as the browser lives.
-  BrowserProcessTask browser_process_task_;
-
-  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTaskProvider);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_BROWSER_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_manager/providers/browser_process_task_unittest.cc b/chrome/browser/task_manager/providers/browser_process_task_unittest.cc
deleted file mode 100644
index 15fbc67..0000000
--- a/chrome/browser/task_manager/providers/browser_process_task_unittest.cc
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/browser_process_task_provider.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/grit/generated_resources.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-class BrowserProcessTaskProviderTest
-    : public testing::Test,
-      public TaskProviderObserver {
- public:
-  BrowserProcessTaskProviderTest()
-      : provided_task_(nullptr) {
-  }
-
-  ~BrowserProcessTaskProviderTest() override {}
-
-  // task_manager::TaskProviderObserver:
-  void TaskAdded(Task* task) override {
-    provided_task_ = task;
-  }
-  void TaskRemoved(Task* task) override {
-    // This will never be called in the case of a browser process task provider.
-    FAIL();
-  }
-
- protected:
-  Task* provided_task_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(BrowserProcessTaskProviderTest);
-};
-
-// Tests the browser process task provider and browser process task itself.
-TEST_F(BrowserProcessTaskProviderTest, TestObserving) {
-  BrowserProcessTaskProvider provider;
-  EXPECT_EQ(nullptr, provided_task_);
-  provider.SetObserver(this);
-  EXPECT_NE(nullptr, provided_task_);
-  provider.ClearObserver();
-  EXPECT_NE(nullptr, provided_task_);
-}
-
-// Testing retrieving the task from the provider using the ids of a URL request.
-TEST_F(BrowserProcessTaskProviderTest, GetTaskOfUrlRequest) {
-  BrowserProcessTaskProvider provider;
-  EXPECT_EQ(nullptr, provided_task_);
-  provider.SetObserver(this);
-  EXPECT_NE(nullptr, provided_task_);
-
-  Task* result = provider.GetTaskOfUrlRequest(1, 0, 0);
-  EXPECT_EQ(nullptr, result);
-  result = provider.GetTaskOfUrlRequest(0, -1, 0);
-  EXPECT_EQ(provided_task_, result);
-}
-
-// Test the provided browser process task itself.
-TEST_F(BrowserProcessTaskProviderTest, TestProvidedTask) {
-  BrowserProcessTaskProvider provider;
-  EXPECT_EQ(nullptr, provided_task_);
-  provider.SetObserver(this);
-  ASSERT_NE(nullptr, provided_task_);
-
-  EXPECT_EQ(base::GetCurrentProcessHandle(), provided_task_->process_handle());
-  EXPECT_EQ(base::GetCurrentProcId(), provided_task_->process_id());
-  EXPECT_FALSE(provided_task_->ReportsWebCacheStats());
-  EXPECT_EQ(l10n_util::GetStringUTF16(IDS_TASK_MANAGER_WEB_BROWSER_CELL_TEXT),
-            provided_task_->title());
-  EXPECT_EQ(Task::BROWSER, provided_task_->GetType());
-  EXPECT_EQ(0, provided_task_->GetChildProcessUniqueID());
-  const int received_bytes = 1024;
-  EXPECT_FALSE(provided_task_->ReportsNetworkUsage());
-  EXPECT_EQ(-1, provided_task_->network_usage());
-  provided_task_->OnNetworkBytesRead(received_bytes);
-  // Do a refresh with a 1-second update time.
-  provided_task_->Refresh(base::TimeDelta::FromSeconds(1),
-                          REFRESH_TYPE_NETWORK_USAGE);
-  EXPECT_TRUE(provided_task_->ReportsNetworkUsage());
-  EXPECT_EQ(received_bytes, provided_task_->network_usage());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/child_process_task.cc b/chrome/browser/task_manager/providers/child_process_task.cc
deleted file mode 100644
index cbb16e2..0000000
--- a/chrome/browser/task_manager/providers/child_process_task.cc
+++ /dev/null
@@ -1,240 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/child_process_task.h"
-
-#include <utility>
-
-#include "base/i18n/rtl.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/process_resource_usage.h"
-#include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/grit/generated_resources.h"
-#include "components/nacl/common/nacl_process_type.h"
-#include "content/public/browser/browser_child_process_host.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/child_process_data.h"
-#include "content/public/common/process_type.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension_set.h"
-#include "grit/theme_resources.h"
-#include "services/shell/public/cpp/interface_provider.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-
-namespace task_manager {
-
-namespace {
-
-gfx::ImageSkia* g_default_icon = nullptr;
-
-gfx::ImageSkia* GetDefaultIcon() {
-  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
-    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
-        IDR_PLUGINS_FAVICON);
-  }
-
-  return g_default_icon;
-}
-
-base::string16 GetLocalizedTitle(const base::string16& title,
-                                 int process_type) {
-  base::string16 result_title = title;
-  if (result_title.empty()) {
-    switch (process_type) {
-      case content::PROCESS_TYPE_PPAPI_PLUGIN:
-      case content::PROCESS_TYPE_PPAPI_BROKER:
-        result_title = l10n_util::GetStringUTF16(
-            IDS_TASK_MANAGER_UNKNOWN_PLUGIN_NAME);
-        break;
-      default:
-        // Nothing to do for non-plugin processes.
-        break;
-    }
-  }
-
-  // Explicitly mark name as LTR if there is no strong RTL character,
-  // to avoid the wrong concatenation result similar to "!Yahoo Mail: the
-  // best web-based Email: NIGULP", in which "NIGULP" stands for the Hebrew
-  // or Arabic word for "plugin".
-  base::i18n::AdjustStringForLocaleDirection(&result_title);
-
-  switch (process_type) {
-    case content::PROCESS_TYPE_UTILITY:
-      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_UTILITY_PREFIX,
-                                        result_title);
-    case content::PROCESS_TYPE_GPU:
-      return l10n_util::GetStringUTF16(IDS_TASK_MANAGER_GPU_PREFIX);
-    case content::PROCESS_TYPE_PPAPI_PLUGIN:
-      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PLUGIN_PREFIX,
-                                        result_title);
-    case content::PROCESS_TYPE_PPAPI_BROKER:
-      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PLUGIN_BROKER_PREFIX,
-                                        result_title);
-    case PROCESS_TYPE_NACL_BROKER:
-      return l10n_util::GetStringUTF16(IDS_TASK_MANAGER_NACL_BROKER_PREFIX);
-    case PROCESS_TYPE_NACL_LOADER: {
-      auto* profile_manager = g_browser_process->profile_manager();
-      if (profile_manager) {
-        // TODO(afakhry): Fix the below looping by plumbing a way to get the
-        // profile or the profile path from the child process host if any.
-        auto loaded_profiles = profile_manager->GetLoadedProfiles();
-        for (auto* profile : loaded_profiles) {
-          const extensions::ExtensionSet& enabled_extensions =
-              extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
-          const extensions::Extension* extension =
-              enabled_extensions.GetExtensionOrAppByURL(GURL(result_title));
-          if (extension) {
-            result_title = base::UTF8ToUTF16(extension->name());
-            break;
-          }
-        }
-      }
-      return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_NACL_PREFIX,
-                                        result_title);
-    }
-    // These types don't need display names or get them from elsewhere.
-    case content::PROCESS_TYPE_BROWSER:
-    case content::PROCESS_TYPE_RENDERER:
-    case content::PROCESS_TYPE_ZYGOTE:
-    case content::PROCESS_TYPE_SANDBOX_HELPER:
-    case content::PROCESS_TYPE_MAX:
-      break;
-    case content::PROCESS_TYPE_UNKNOWN:
-      NOTREACHED() << "Need localized name for child process type.";
-  }
-
-  return result_title;
-}
-
-// Connects the |resource_reporter| to the ServiceRegistry of the
-// BrowserChildProcessHost whose unique ID is |unique_child_process_id|.
-void ConnectResourceReporterOnIOThread(
-    int unique_child_process_id,
-    mojo::InterfaceRequest<mojom::ResourceUsageReporter> resource_reporter) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  content::BrowserChildProcessHost* host =
-      content::BrowserChildProcessHost::FromID(unique_child_process_id);
-  if (!host)
-    return;
-
-  shell::InterfaceProvider* interfaces = host->GetRemoteInterfaces();
-  if (interfaces)
-    interfaces->GetInterface(std::move(resource_reporter));
-}
-
-// Creates the Mojo service wrapper that will be used to sample the V8 memory
-// usage of the browser child process whose unique ID is
-// |unique_child_process_id|.
-ProcessResourceUsage* CreateProcessResourcesSampler(
-    int unique_child_process_id) {
-  mojom::ResourceUsageReporterPtr service;
-  mojo::InterfaceRequest<mojom::ResourceUsageReporter> usage_reporter =
-      mojo::GetProxy(&service);
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO,
-      FROM_HERE,
-      base::Bind(&ConnectResourceReporterOnIOThread,
-                 unique_child_process_id,
-                 base::Passed(&usage_reporter)));
-
-  return new ProcessResourceUsage(std::move(service));
-}
-
-bool UsesV8Memory(int process_type) {
-  switch (process_type) {
-    case content::PROCESS_TYPE_UTILITY:
-    case content::PROCESS_TYPE_BROWSER:
-    case content::PROCESS_TYPE_RENDERER:
-      return true;
-
-    default:
-      return false;
-  }
-}
-
-}  // namespace
-
-ChildProcessTask::ChildProcessTask(const content::ChildProcessData& data)
-    : Task(GetLocalizedTitle(data.name, data.process_type),
-           base::UTF16ToUTF8(data.name),
-           GetDefaultIcon(),
-           data.handle),
-      process_resources_sampler_(CreateProcessResourcesSampler(data.id)),
-      v8_memory_allocated_(-1),
-      v8_memory_used_(-1),
-      unique_child_process_id_(data.id),
-      process_type_(data.process_type),
-      uses_v8_memory_(UsesV8Memory(process_type_)) {
-}
-
-ChildProcessTask::~ChildProcessTask() {
-}
-
-void ChildProcessTask::Refresh(const base::TimeDelta& update_interval,
-                               int64_t refresh_flags) {
-  Task::Refresh(update_interval, refresh_flags);
-
-  if ((refresh_flags & REFRESH_TYPE_V8_MEMORY) == 0)
-    return;
-
-  if (!uses_v8_memory_)
-    return;
-
-  // The child process resources refresh is performed asynchronously, we will
-  // invoke it and record the current values (which might be invalid at the
-  // moment. We can safely ignore that and count on future refresh cycles
-  // potentially having valid values).
-  process_resources_sampler_->Refresh(base::Closure());
-
-  v8_memory_allocated_ = base::saturated_cast<int64_t>(
-      process_resources_sampler_->GetV8MemoryAllocated());
-  v8_memory_used_ = base::saturated_cast<int64_t>(
-      process_resources_sampler_->GetV8MemoryUsed());
-}
-
-Task::Type ChildProcessTask::GetType() const {
-  // Convert |content::ProcessType| to |task_manager::Task::Type|.
-  switch (process_type_) {
-    case content::PROCESS_TYPE_PPAPI_PLUGIN:
-    case content::PROCESS_TYPE_PPAPI_BROKER:
-      return Task::PLUGIN;
-    case content::PROCESS_TYPE_UTILITY:
-      return Task::UTILITY;
-    case content::PROCESS_TYPE_ZYGOTE:
-      return Task::ZYGOTE;
-    case content::PROCESS_TYPE_SANDBOX_HELPER:
-      return Task::SANDBOX_HELPER;
-    case content::PROCESS_TYPE_GPU:
-      return Task::GPU;
-    case PROCESS_TYPE_NACL_LOADER:
-    case PROCESS_TYPE_NACL_BROKER:
-      return Task::NACL;
-    default:
-      return Task::UNKNOWN;
-  }
-}
-
-int ChildProcessTask::GetChildProcessUniqueID() const {
-  return unique_child_process_id_;
-}
-
-bool ChildProcessTask::ReportsV8Memory() const {
-  return uses_v8_memory_ && process_resources_sampler_->ReportsV8MemoryStats();
-}
-
-int64_t ChildProcessTask::GetV8MemoryAllocated() const {
-  return v8_memory_allocated_;
-}
-
-int64_t ChildProcessTask::GetV8MemoryUsed() const {
-  return v8_memory_used_;
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/child_process_task.h b/chrome/browser/task_manager/providers/child_process_task.h
deleted file mode 100644
index 877b243..0000000
--- a/chrome/browser/task_manager/providers/child_process_task.h
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_H_
-
-#include <stdint.h>
-
-#include <memory>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task.h"
-
-class ProcessResourceUsage;
-
-namespace content {
-struct ChildProcessData;
-}  // namespace content
-
-namespace task_manager {
-
-// Represents several types of the browser's child processes such as
-// a plugin or a GPU process, ... etc.
-class ChildProcessTask : public Task {
- public:
-  // Creates a child process task given its |data| which is
-  // received from observing |content::BrowserChildProcessObserver|.
-  explicit ChildProcessTask(const content::ChildProcessData& data);
-
-  ~ChildProcessTask() override;
-
-  // task_manager::Task:
-  void Refresh(const base::TimeDelta& update_interval,
-               int64_t refresh_flags) override;
-  Type GetType() const override;
-  int GetChildProcessUniqueID() const override;
-  bool ReportsV8Memory() const;
-  int64_t GetV8MemoryAllocated() const override;
-  int64_t GetV8MemoryUsed() const override;
-
- private:
-  // The Mojo service wrapper that will provide us with the V8 memory usage of
-  // the browser child process represented by this object.
-  std::unique_ptr<ProcessResourceUsage> process_resources_sampler_;
-
-  // The allocated and used V8 memory (in bytes).
-  int64_t v8_memory_allocated_;
-  int64_t v8_memory_used_;
-
-  // The unique ID of the child process. It is not the PID of the process.
-  // See |content::ChildProcessData::id|.
-  const int unique_child_process_id_;
-
-  // The type of the child process. See |content::ProcessType| and
-  // |NaClTrustedProcessType|.
-  const int process_type_;
-
-  // Depending on the |process_type_|, determines whether this task uses V8
-  // memory or not.
-  const bool uses_v8_memory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ChildProcessTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/child_process_task_provider.cc b/chrome/browser/task_manager/providers/child_process_task_provider.cc
deleted file mode 100644
index d7d05d2..0000000
--- a/chrome/browser/task_manager/providers/child_process_task_provider.cc
+++ /dev/null
@@ -1,163 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/child_process_task_provider.h"
-
-#include "base/process/process.h"
-#include "chrome/browser/task_manager/providers/child_process_task.h"
-#include "content/public/browser/browser_child_process_host_iterator.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/child_process_data.h"
-
-using content::BrowserChildProcessHostIterator;
-using content::BrowserThread;
-using content::ChildProcessData;
-
-namespace task_manager {
-
-namespace {
-
-// Collects and returns the child processes data on the IO thread to get all the
-// pre-existing child process before we start observing
-// |BrowserChildProcessObserver|.
-std::unique_ptr<std::vector<ChildProcessData>> CollectChildProcessData() {
-  // The |BrowserChildProcessHostIterator| must only be used on the IO thread.
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  std::unique_ptr<std::vector<ChildProcessData>> child_processes(
-      new std::vector<ChildProcessData>());
-  for (BrowserChildProcessHostIterator itr; !itr.Done(); ++itr) {
-    const ChildProcessData& process_data = itr.GetData();
-
-    // Only add processes that have already started, i.e. with valid handles.
-    if (process_data.handle == base::kNullProcessHandle)
-      continue;
-
-    child_processes->push_back(process_data);
-  }
-
-  return child_processes;
-}
-
-}  // namespace
-
-ChildProcessTaskProvider::ChildProcessTaskProvider()
-    : weak_ptr_factory_(this) {
-}
-
-ChildProcessTaskProvider::~ChildProcessTaskProvider() {
-}
-
-Task* ChildProcessTaskProvider::GetTaskOfUrlRequest(int origin_pid,
-                                                    int child_id,
-                                                    int route_id) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  auto itr = tasks_by_pid_.find(static_cast<base::ProcessId>(origin_pid));
-  if (itr == tasks_by_pid_.end())
-    return nullptr;
-
-  return itr->second;
-}
-
-void ChildProcessTaskProvider::BrowserChildProcessLaunchedAndConnected(
-    const content::ChildProcessData& data) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (data.handle == base::kNullProcessHandle)
-    return;
-
-  CreateTask(data);
-}
-
-void ChildProcessTaskProvider::BrowserChildProcessHostDisconnected(
-    const content::ChildProcessData& data) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DeleteTask(data.handle);
-}
-
-void ChildProcessTaskProvider::StartUpdating() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(tasks_by_handle_.empty());
-  DCHECK(tasks_by_pid_.empty());
-
-  // First, get the pre-existing child processes data.
-  BrowserThread::PostTaskAndReplyWithResult(
-      BrowserThread::IO,
-      FROM_HERE,
-      base::Bind(&CollectChildProcessData),
-      base::Bind(&ChildProcessTaskProvider::ChildProcessDataCollected,
-                 weak_ptr_factory_.GetWeakPtr()));
-}
-
-void ChildProcessTaskProvider::StopUpdating() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  // ChildProcessDataCollected() should never be called after this, and hence
-  // we must invalidate the weak pointers.
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  // First, stop observing.
-  BrowserChildProcessObserver::Remove(this);
-
-  // Remember: You can't notify the observer of tasks removal here,
-  // StopUpdating() is called after the observer has been cleared.
-
-  // Then delete all tasks (if any).
-  tasks_by_handle_.clear();
-  tasks_by_pid_.clear();
-}
-
-void ChildProcessTaskProvider::ChildProcessDataCollected(
-    std::unique_ptr<const std::vector<content::ChildProcessData>>
-        child_processes) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  for (const auto& process_data : *child_processes)
-    CreateTask(process_data);
-
-  // Now start observing.
-  BrowserChildProcessObserver::Add(this);
-}
-
-void ChildProcessTaskProvider::CreateTask(
-    const content::ChildProcessData& data) {
-  std::unique_ptr<ChildProcessTask>& task = tasks_by_handle_[data.handle];
-  if (task) {
-    // This task is already known to us. This case can happen when some of the
-    // child process data we collect upon StartUpdating() might be of
-    // BrowserChildProcessHosts whose process hadn't launched yet. So we just
-    // return.
-    return;
-  }
-
-  // Create the task and notify the observer.
-  task.reset(new ChildProcessTask(data));
-  tasks_by_pid_[task->process_id()] = task.get();
-  NotifyObserverTaskAdded(task.get());
-}
-
-void ChildProcessTaskProvider::DeleteTask(base::ProcessHandle handle) {
-  auto itr = tasks_by_handle_.find(handle);
-
-  // The following case should never happen since we start observing
-  // |BrowserChildProcessObserver| only after we collect all pre-existing child
-  // processes and are notified (on the UI thread) that the collection is
-  // completed at |ChildProcessDataCollected()|.
-  if (itr == tasks_by_handle_.end()) {
-    // BUG(crbug.com/611067): Temporarily removing due to test flakes. The
-    // reason why this happens is well understood (see bug), but there's no
-    // quick and easy fix.
-    // NOTREACHED();
-    return;
-  }
-
-  NotifyObserverTaskRemoved(itr->second.get());
-
-  // Clear from the pid index.
-  tasks_by_pid_.erase(itr->second->process_id());
-
-  // Finally delete the task.
-  tasks_by_handle_.erase(itr);
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/child_process_task_provider.h b/chrome/browser/task_manager/providers/child_process_task_provider.h
deleted file mode 100644
index 6dab934..0000000
--- a/chrome/browser/task_manager/providers/child_process_task_provider.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
-
-#include <map>
-#include <memory>
-#include <vector>
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "chrome/browser/task_manager/providers/task_provider.h"
-#include "content/public/browser/browser_child_process_observer.h"
-
-namespace content {
-struct ChildProcessData;
-}
-
-namespace task_manager {
-
-class ChildProcessTask;
-
-// Defines a provider to provide the tasks that represent various types of child
-// processes such as the GPU process or a plugin process ... etc.
-class ChildProcessTaskProvider
-    : public TaskProvider,
-      public content::BrowserChildProcessObserver {
- public:
-  ChildProcessTaskProvider();
-  ~ChildProcessTaskProvider() override;
-
-  // task_manager::TaskProvider:
-  Task* GetTaskOfUrlRequest(int origin_pid,
-                            int child_id,
-                            int route_id) override;
-
-  // content::BrowserChildProcessObserver:
-  void BrowserChildProcessLaunchedAndConnected(
-      const content::ChildProcessData& data) override;
-  void BrowserChildProcessHostDisconnected(
-      const content::ChildProcessData& data) override;
-
- private:
-  friend class ChildProcessTaskTest;
-
-  // task_manager::TaskProvider:
-  void StartUpdating() override;
-  void StopUpdating() override;
-
-  // The pre-existing child processes data will be collected on the IO thread.
-  // When that is done, we will be notified on the UI thread by receiving a call
-  // to this method.
-  void ChildProcessDataCollected(
-      std::unique_ptr<const std::vector<content::ChildProcessData>>
-          child_processes);
-
-  // Creates a ChildProcessTask from the given |data| and notifies the observer
-  // of its addition.
-  void CreateTask(const content::ChildProcessData& data);
-
-  // Deletes a ChildProcessTask whose |handle| is provided after notifying the
-  // observer of its deletion.
-  void DeleteTask(base::ProcessHandle handle);
-
-  // A map to track ChildProcessTask's by their handles.
-  std::map<base::ProcessHandle, std::unique_ptr<ChildProcessTask>>
-      tasks_by_handle_;
-
-  // A map to track ChildProcessTask's by their PIDs.
-  //
-  // Why have both |tasks_by_handle_| and |tasks_by_pid_|? On Windows, where
-  // handles are not the same as PIDs, |DeleteTask| gets only a handle, which
-  // may be closed, making it impossible to query the PID from the handle. So
-  // we need an index on the handle. Meanwhile, we also need an index on the
-  // PID so that we can efficiently implement |GetTaskOfUrlRequest()|, which
-  // gets only a PID.
-  //
-  // TODO(afakhry): Fix this either by keeping the handle open via
-  // |base::Process|, or amending the |BrowserChildProcessObserver| interface to
-  // supply the PID.
-  std::map<base::ProcessId, ChildProcessTask*> tasks_by_pid_;
-
-  // Always keep this the last member of this class to make sure it's the
-  // first thing to be destructed.
-  base::WeakPtrFactory<ChildProcessTaskProvider> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ChildProcessTaskProvider);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_CHILD_PROCESS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_manager/providers/child_process_task_unittest.cc b/chrome/browser/task_manager/providers/child_process_task_unittest.cc
deleted file mode 100644
index e055753..0000000
--- a/chrome/browser/task_manager/providers/child_process_task_unittest.cc
+++ /dev/null
@@ -1,185 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <stdint.h>
-
-#include "base/macros.h"
-#include "base/run_loop.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/task_manager/providers/child_process_task.h"
-#include "chrome/browser/task_manager/providers/child_process_task_provider.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/grit/generated_resources.h"
-#include "components/nacl/common/nacl_process_type.h"
-#include "content/public/browser/child_process_data.h"
-#include "content/public/common/process_type.h"
-#include "content/public/test/test_browser_thread_bundle.h"
-#include "content/public/test/test_utils.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/l10n/l10n_util.h"
-
-using content::ChildProcessData;
-
-namespace task_manager {
-
-namespace {
-
-// Will be used to test the translation from |content::ProcessType| to
-// |task_manager::Task::Type|.
-struct ProcessTypeTaskTypePair {
-  int process_type_;
-  Task::Type expected_task_type_;
-} process_task_types_pairs[] = {
-    { content::PROCESS_TYPE_PPAPI_PLUGIN, Task::PLUGIN },
-    { content::PROCESS_TYPE_PPAPI_BROKER, Task::PLUGIN },
-    { content::PROCESS_TYPE_UTILITY, Task::UTILITY },
-    { content::PROCESS_TYPE_ZYGOTE, Task::ZYGOTE },
-    { content::PROCESS_TYPE_SANDBOX_HELPER, Task::SANDBOX_HELPER },
-    { content::PROCESS_TYPE_GPU, Task::GPU },
-    { PROCESS_TYPE_NACL_LOADER, Task::NACL },
-    { PROCESS_TYPE_NACL_BROKER, Task::NACL },
-};
-
-}  // namespace
-
-// Defines a test for the child process task provider and the child process
-// tasks themselves.
-class ChildProcessTaskTest
-    : public testing::Test,
-      public TaskProviderObserver {
- public:
-  ChildProcessTaskTest() {}
-
-  ~ChildProcessTaskTest() override {}
-
-  // task_manager::TaskProviderObserver:
-  void TaskAdded(Task* task) override {
-    DCHECK(task);
-    if (provided_tasks_.find(task->process_handle()) != provided_tasks_.end())
-      FAIL() << "ChildProcessTaskProvider must never provide duplicate tasks";
-
-    provided_tasks_[task->process_handle()] = task;
-  }
-
-  void TaskRemoved(Task* task) override {
-    DCHECK(task);
-    provided_tasks_.erase(task->process_handle());
-  }
-
-  bool AreProviderContainersEmpty(
-      const ChildProcessTaskProvider& provider) const {
-    return provider.tasks_by_handle_.empty() && provider.tasks_by_pid_.empty();
-  }
-
- protected:
-  std::map<base::ProcessHandle, Task*> provided_tasks_;
-
- private:
-  content::TestBrowserThreadBundle thread_bundle_;
-
-  DISALLOW_COPY_AND_ASSIGN(ChildProcessTaskTest);
-};
-
-// Perfoms a basic test.
-TEST_F(ChildProcessTaskTest, BasicTest) {
-  ChildProcessTaskProvider provider;
-  EXPECT_TRUE(provided_tasks_.empty());
-  provider.SetObserver(this);
-  content::RunAllPendingInMessageLoop();
-  ASSERT_TRUE(provided_tasks_.empty()) <<
-      "unit tests don't have any browser child processes";
-  provider.ClearObserver();
-  EXPECT_TRUE(provided_tasks_.empty());
-  EXPECT_TRUE(AreProviderContainersEmpty(provider));
-}
-
-// Tests everything related to child process task providing.
-TEST_F(ChildProcessTaskTest, TestAll) {
-  ChildProcessTaskProvider provider;
-  EXPECT_TRUE(provided_tasks_.empty());
-  provider.SetObserver(this);
-  content::RunAllPendingInMessageLoop();
-  ASSERT_TRUE(provided_tasks_.empty());
-
-  // The following process which has handle = base::kNullProcessHandle, won't be
-  // added.
-  ChildProcessData data1(0);
-  ASSERT_EQ(base::kNullProcessHandle, data1.handle);
-  provider.BrowserChildProcessLaunchedAndConnected(data1);
-  EXPECT_TRUE(provided_tasks_.empty());
-
-  const int unique_id = 245;
-  const base::string16 name(base::UTF8ToUTF16("Test Task"));
-  const base::string16 expected_name(l10n_util::GetStringFUTF16(
-      IDS_TASK_MANAGER_PLUGIN_PREFIX, name));
-
-  ChildProcessData data2(content::PROCESS_TYPE_PPAPI_PLUGIN);
-  data2.handle = base::GetCurrentProcessHandle();
-  data2.name = name;
-  data2.id = unique_id;
-  provider.BrowserChildProcessLaunchedAndConnected(data2);
-  ASSERT_EQ(1U, provided_tasks_.size());
-
-  Task* task = provided_tasks_.begin()->second;
-  EXPECT_EQ(base::GetCurrentProcessHandle(), task->process_handle());
-  EXPECT_EQ(base::GetCurrentProcId(), task->process_id());
-  EXPECT_EQ(expected_name, task->title());
-  EXPECT_EQ(Task::PLUGIN, task->GetType());
-  EXPECT_EQ(unique_id, task->GetChildProcessUniqueID());
-  EXPECT_EQ(base::string16(), task->GetProfileName());
-  EXPECT_FALSE(task->ReportsSqliteMemory());
-  EXPECT_FALSE(task->ReportsV8Memory());
-  EXPECT_FALSE(task->ReportsWebCacheStats());
-  EXPECT_FALSE(task->ReportsNetworkUsage());
-
-  // Make sure that the conversion from PID to Handle inside
-  // |GetTaskOfUrlRequest()| is working properly.
-  Task* found_task =
-      provider.GetTaskOfUrlRequest(base::GetCurrentProcId(), 0, 0);
-  ASSERT_EQ(task, found_task);
-  const int64_t bytes_read = 1024;
-  found_task->OnNetworkBytesRead(bytes_read);
-  found_task->Refresh(base::TimeDelta::FromSeconds(1),
-                      REFRESH_TYPE_NETWORK_USAGE);
-
-  EXPECT_TRUE(task->ReportsNetworkUsage());
-  EXPECT_EQ(bytes_read, task->network_usage());
-
-  // Clearing the observer won't notify us of any tasks removals even though
-  // tasks will be actually deleted.
-  provider.ClearObserver();
-  EXPECT_FALSE(provided_tasks_.empty());
-  EXPECT_TRUE(AreProviderContainersEmpty(provider));
-}
-
-// Tests the translation of |content::ProcessType| to
-// |task_manager::Task::Type|.
-TEST_F(ChildProcessTaskTest, ProcessTypeToTaskType) {
-  ChildProcessTaskProvider provider;
-  EXPECT_TRUE(provided_tasks_.empty());
-  provider.SetObserver(this);
-  content::RunAllPendingInMessageLoop();
-  ASSERT_TRUE(provided_tasks_.empty());
-
-  for (const auto& types_pair : process_task_types_pairs) {
-    // Add the task.
-    ChildProcessData data(types_pair.process_type_);
-    data.handle = base::GetCurrentProcessHandle();
-    provider.BrowserChildProcessLaunchedAndConnected(data);
-    ASSERT_EQ(1U, provided_tasks_.size());
-    Task* task = provided_tasks_.begin()->second;
-    EXPECT_EQ(base::GetCurrentProcessHandle(), task->process_handle());
-    EXPECT_EQ(types_pair.expected_task_type_, task->GetType());
-
-    // Remove the task.
-    provider.BrowserChildProcessHostDisconnected(data);
-    EXPECT_TRUE(provided_tasks_.empty());
-  }
-
-  provider.ClearObserver();
-  EXPECT_TRUE(AreProviderContainersEmpty(provider));
-}
-
-}  // namespace task_manager
-
diff --git a/chrome/browser/task_manager/providers/task.cc b/chrome/browser/task_manager/providers/task.cc
deleted file mode 100644
index 82d8656..0000000
--- a/chrome/browser/task_manager/providers/task.cc
+++ /dev/null
@@ -1,150 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/task.h"
-
-#include <stddef.h>
-
-#include "base/process/process.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/profiles/profile_attributes_entry.h"
-#include "chrome/browser/profiles/profile_attributes_storage.h"
-#include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "content/public/common/result_codes.h"
-
-namespace task_manager {
-
-namespace {
-
-// The last ID given to the previously created task.
-int64_t g_last_id = 0;
-
-}  // namespace
-
-Task::Task(const base::string16& title,
-           const std::string& rappor_sample,
-           const gfx::ImageSkia* icon,
-           base::ProcessHandle handle,
-           base::ProcessId process_id)
-    : task_id_(g_last_id++),
-      network_usage_(-1),
-      current_byte_count_(-1),
-      title_(title),
-      rappor_sample_name_(rappor_sample),
-      icon_(icon ? *icon : gfx::ImageSkia()),
-      process_handle_(handle),
-      process_id_(process_id != base::kNullProcessId
-                      ? process_id
-                      : base::GetProcId(handle)) {}
-
-Task::~Task() {}
-
-// static
-base::string16 Task::GetProfileNameFromProfile(Profile* profile) {
-  DCHECK(profile);
-  ProfileAttributesEntry* entry;
-  if (g_browser_process->profile_manager()->GetProfileAttributesStorage().
-      GetProfileAttributesWithPath(profile->GetOriginalProfile()->GetPath(),
-                                   &entry)) {
-    return entry->GetName();
-  }
-
-  return base::string16();
-}
-
-void Task::Activate() {
-}
-
-bool Task::IsKillable() {
-  return true;
-}
-
-void Task::Kill() {
-  DCHECK_NE(process_id(), base::GetCurrentProcId());
-  base::Process process = base::Process::Open(process_id());
-  process.Terminate(content::RESULT_CODE_KILLED, false);
-}
-
-void Task::Refresh(const base::TimeDelta& update_interval,
-                   int64_t refresh_flags) {
-  if ((refresh_flags & REFRESH_TYPE_NETWORK_USAGE) == 0)
-    return;
-
-  if (current_byte_count_ == -1)
-    return;
-
-  network_usage_ =
-      (current_byte_count_ * base::TimeDelta::FromSeconds(1)) / update_interval;
-
-  // Reset the current byte count for this task.
-  current_byte_count_ = 0;
-}
-
-void Task::OnNetworkBytesRead(int64_t bytes_read) {
-  if (current_byte_count_ == -1)
-    current_byte_count_ = 0;
-
-  current_byte_count_ += bytes_read;
-}
-
-void Task::GetTerminationStatus(base::TerminationStatus* out_status,
-                                int* out_error_code) const {
-  DCHECK(out_status);
-  DCHECK(out_error_code);
-
-  *out_status = base::TERMINATION_STATUS_STILL_RUNNING;
-  *out_error_code = 0;
-}
-
-base::string16 Task::GetProfileName() const {
-  return base::string16();
-}
-
-int Task::GetTabId() const {
-  return -1;
-}
-
-bool Task::HasParentTask() const {
-  return GetParentTask() != nullptr;
-}
-
-const Task* Task::GetParentTask() const {
-  return nullptr;
-}
-
-bool Task::ReportsSqliteMemory() const {
-  return GetSqliteMemoryUsed() != -1;
-}
-
-int64_t Task::GetSqliteMemoryUsed() const {
-  return -1;
-}
-
-bool Task::ReportsV8Memory() const {
-  return GetV8MemoryAllocated() != -1;
-}
-
-int64_t Task::GetV8MemoryAllocated() const {
-  return -1;
-}
-
-int64_t Task::GetV8MemoryUsed() const {
-  return -1;
-}
-
-bool Task::ReportsWebCacheStats() const {
-  return false;
-}
-
-blink::WebCache::ResourceTypeStats Task::GetWebCacheStats() const {
-  return blink::WebCache::ResourceTypeStats();
-}
-
-bool Task::ReportsNetworkUsage() const {
-  return network_usage_ != -1;
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/task.h b/chrome/browser/task_manager/providers/task.h
deleted file mode 100644
index 0c04857..0000000
--- a/chrome/browser/task_manager/providers/task.h
+++ /dev/null
@@ -1,190 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_H_
-
-#include <stdint.h>
-
-#include <string>
-
-#include "base/macros.h"
-#include "base/process/kill.h"
-#include "base/process/process_handle.h"
-#include "base/strings/string16.h"
-#include "base/time/time.h"
-#include "third_party/WebKit/public/web/WebCache.h"
-#include "ui/gfx/image/image_skia.h"
-
-class Profile;
-
-namespace task_manager {
-
-// Defines a task that corresponds to a tab, an app, an extension, ... etc. It
-// represents one row in the task manager table. Multiple tasks can share the
-// same process, in which case they're grouped together in the task manager
-// table. See |task_manager::TaskGroup| which represents a process possibly
-// shared by multiple tasks.
-class Task {
- public:
-  // Note that the declaration order here determines the default sort order
-  // in the task manager.
-  enum Type {
-    UNKNOWN = 0,
-
-    /* Singleton processes first that don't belong to a particular tab. */
-    BROWSER, /* The main browser process. */
-    GPU,     /* A graphics process. */
-    ARC,     /* An ARC process. */
-    ZYGOTE,  /* A Linux zygote process. */
-    UTILITY, /* A browser utility process. */
-
-    /* Per-Tab processes next. */
-    RENDERER,  /* A normal WebContents renderer process. */
-    EXTENSION, /* An extension or app process. */
-
-    /* Plugin processes last.*/
-    GUEST,          /* A browser plugin guest process. */
-    PLUGIN,         /* A plugin process. */
-    WORKER,         /* A web worker process. */
-    NACL,           /* A NativeClient loader or broker process. */
-    SANDBOX_HELPER, /* A sandbox helper process. */
-  };
-
-  // Create a task with the given |title| and the given favicon |icon|. This
-  // task runs on a process whose handle is |handle|. |rappor_sample| is the
-  // name of the sample to be recorded if this task needs to be reported by
-  // Rappor. If |process_id| is not supplied, it will be determined by |handle|.
-  Task(const base::string16& title,
-       const std::string& rappor_sample,
-       const gfx::ImageSkia* icon,
-       base::ProcessHandle handle,
-       base::ProcessId process_id = base::kNullProcessId);
-  virtual ~Task();
-
-  // Gets the name of the given |profile| from the ProfileAttributesStorage.
-  static base::string16 GetProfileNameFromProfile(Profile* profile);
-
-  // Activates this TaskManager's task by bringing its container to the front
-  // (if possible).
-  virtual void Activate();
-
-  // Returns if the task should be killable from the Task Manager UI.
-  virtual bool IsKillable();
-
-  // Kills this task.
-  virtual void Kill();
-
-  // Will be called to let the task refresh itself between refresh cycles.
-  // |update_interval| is the time since the last task manager refresh.
-  // the |refresh_flags| indicate which resources should be calculated on each
-  // refresh.
-  virtual void Refresh(const base::TimeDelta& update_interval,
-                       int64_t refresh_flags);
-
-  // Will receive this notification through the task manager from
-  // |ChromeNetworkDelegate::OnNetworkBytesReceived()|. The task will add to the
-  // |current_byte_count_| in this refresh cycle.
-  void OnNetworkBytesRead(int64_t bytes_read);
-
-  // Returns the task type.
-  virtual Type GetType() const = 0;
-
-  // This is the unique ID of the BrowserChildProcessHost/RenderProcessHost. It
-  // is not the PID nor the handle of the process.
-  // For a task that represents the browser process, the return value is 0. For
-  // other tasks that represent renderers and other child processes, the return
-  // value is whatever unique IDs of their hosts in the browser process.
-  virtual int GetChildProcessUniqueID() const = 0;
-
-  // If the process, in which this task is running, is terminated, this gets the
-  // termination status. Currently implemented only for Renderer processes.
-  virtual void GetTerminationStatus(base::TerminationStatus* out_status,
-                                    int* out_error_code) const;
-
-  // The name of the profile owning this task.
-  virtual base::string16 GetProfileName() const;
-
-  // Returns the unique ID of the tab if this task represents a renderer
-  // WebContents used for a tab. Returns -1 if this task does not represent
-  // a renderer, or a contents of a tab.
-  virtual int GetTabId() const;
-
-  // For Tasks that represent a subactivity of some other task (e.g. a plugin
-  // embedded in a page), this returns the Task representing the parent
-  // activity.
-  bool HasParentTask() const;
-  virtual const Task* GetParentTask() const;
-
-  // Getting the Sqlite used memory (in bytes). Not all tasks reports Sqlite
-  // memory, in this case a default invalid value of -1 will be returned.
-  // Check for whether the task reports it or not first.
-  bool ReportsSqliteMemory() const;
-  virtual int64_t GetSqliteMemoryUsed() const;
-
-  // Getting the allocated and used V8 memory (in bytes). Not all tasks reports
-  // V8 memory, in this case a default invalid value of -1 will be returned.
-  // Check for whether the task reports it or not first.
-  bool ReportsV8Memory() const;
-  virtual int64_t GetV8MemoryAllocated() const;
-  virtual int64_t GetV8MemoryUsed() const;
-
-  // Checking if the task reports Webkit resource cache statistics and getting
-  // them if it does.
-  virtual bool ReportsWebCacheStats() const;
-  virtual blink::WebCache::ResourceTypeStats GetWebCacheStats() const;
-
-  // Checking whether the task reports network usage.
-  bool ReportsNetworkUsage() const;
-
-  int64_t task_id() const { return task_id_; }
-  int64_t network_usage() const { return network_usage_; }
-  const base::string16& title() const { return title_; }
-  const std::string& rappor_sample_name() const { return rappor_sample_name_; }
-  const gfx::ImageSkia& icon() const { return icon_; }
-  const base::ProcessHandle& process_handle() const { return process_handle_; }
-  const base::ProcessId& process_id() const { return process_id_; }
-
- protected:
-  void set_title(const base::string16& new_title) { title_ = new_title; }
-  void set_rappor_sample_name(const std::string& sample) {
-    rappor_sample_name_ = sample;
-  }
-  void set_icon(const gfx::ImageSkia& new_icon) { icon_ = new_icon; }
-
- private:
-  // The unique ID of this task.
-  const int64_t task_id_;
-
-  // The task's network usage in the current refresh cycle measured in bytes per
-  // second. A value of -1 means this task doesn't report network usage data.
-  int64_t network_usage_;
-
-  // The current network bytes received by this task during the current refresh
-  // cycle. A value of -1 means this task has never been notified of any network
-  // usage.
-  int64_t current_byte_count_;
-
-  // The title of the task.
-  base::string16 title_;
-
-  // The name of the sample representing this task when a Rappor sample needs to
-  // be recorded for it.
-  std::string rappor_sample_name_;
-
-  // The favicon.
-  gfx::ImageSkia icon_;
-
-  // The handle of the process on which this task is running.
-  const base::ProcessHandle process_handle_;
-
-  // The PID of the process on which this task is running.
-  const base::ProcessId process_id_;
-
-  DISALLOW_COPY_AND_ASSIGN(Task);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/task_provider.cc b/chrome/browser/task_manager/providers/task_provider.cc
deleted file mode 100644
index 9f309aa..0000000
--- a/chrome/browser/task_manager/providers/task_provider.cc
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/task_provider.h"
-
-namespace task_manager {
-
-TaskProvider::TaskProvider()
-    : observer_(nullptr) {
-}
-
-TaskProvider::~TaskProvider() {
-}
-
-void TaskProvider::SetObserver(TaskProviderObserver* observer) {
-  DCHECK(observer);
-  DCHECK(!observer_);
-  observer_ = observer;
-  StartUpdating();
-}
-
-void TaskProvider::ClearObserver() {
-  DCHECK(observer_);
-  observer_ = nullptr;
-  StopUpdating();
-}
-
-void TaskProvider::NotifyObserverTaskAdded(Task* task) const {
-  DCHECK(observer_);
-  observer_->TaskAdded(task);
-}
-
-void TaskProvider::NotifyObserverTaskRemoved(Task* task) const {
-  DCHECK(observer_);
-  observer_->TaskRemoved(task);
-}
-
-void TaskProvider::NotifyObserverTaskUnresponsive(Task* task) const {
-  DCHECK(observer_);
-  observer_->TaskUnresponsive(task);
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/task_provider.h b/chrome/browser/task_manager/providers/task_provider.h
deleted file mode 100644
index cbe41da..0000000
--- a/chrome/browser/task_manager/providers/task_provider.h
+++ /dev/null
@@ -1,74 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task_provider_observer.h"
-
-namespace task_manager {
-
-// Defines the interface for task providers. A concrete task provider must be
-// able to collect all the tasks of a particular type which this provider
-// supports as well as track any tasks addition / removal. Once StartUpdating()
-// is called, the provider is responsible for notifying the observer about the
-// tasks it's tracking. The TaskProviders own the tasks they provide.
-class TaskProvider {
- public:
-  TaskProvider();
-  virtual ~TaskProvider();
-
-  // Should return the task associated to the specified IDs from a
-  // |content::ResourceRequestInfo| that represents a |URLRequest|. A value of
-  // nullptr will be returned if the desired task does not belong to this
-  // provider.
-  //
-  // |origin_pid| is the PID of the originating process of the URLRequest, if
-  // the request is sent on behalf of another process. Otherwise it's 0.
-  // |child_id| is the unique ID of the host of the child process requestor.
-  // |route_id| is the ID of the IPC route for the URLRequest (this identifies
-  // the RenderView or like-thing in the renderer that the request gets routed
-  // to).
-  virtual Task* GetTaskOfUrlRequest(int origin_pid,
-                                    int child_id,
-                                    int route_id) = 0;
-
-  // Set the sole observer of this provider. It's an error to set an observer
-  // if there's already one there.
-  void SetObserver(TaskProviderObserver* observer);
-
-  // Clears the currently set observer for this provider. It's an error to clear
-  // the observer if there's no one set.
-  void ClearObserver();
-
- protected:
-  // Used by concrete task providers to notify the observer of tasks addition/
-  // removal/renderer unresponsive. These methods should only be called after
-  // StartUpdating() has been called and before StopUpdating() is called.
-  void NotifyObserverTaskAdded(Task* task) const;
-  void NotifyObserverTaskRemoved(Task* task) const;
-  void NotifyObserverTaskUnresponsive(Task* task) const;
-
- private:
-  // This will be called once an observer is set for this provider. When it is
-  // called, the concrete provider must notify the observer of all pre-existing
-  // tasks as well as track new addition and terminations and notify the
-  // observer of these changes.
-  virtual void StartUpdating() = 0;
-
-  // This will be called once the observer is cleared, at which point the
-  // provider can stop tracking tasks addition / removal and can clear its own
-  // resources.
-  virtual void StopUpdating() = 0;
-
-  // We support only one single obsever which will be the sampler in this case.
-  TaskProviderObserver* observer_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskProvider);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_manager/providers/task_provider_observer.h b/chrome/browser/task_manager/providers/task_provider_observer.h
deleted file mode 100644
index 5cc85ae..0000000
--- a/chrome/browser/task_manager/providers/task_provider_observer.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task.h"
-
-namespace task_manager {
-
-// Defines an interface for observing tasks addition / removal.
-class TaskProviderObserver {
- public:
-  TaskProviderObserver() {}
-  virtual ~TaskProviderObserver() {}
-
-  // This notifies of the event that a new |task| has been created.
-  virtual void TaskAdded(Task* task) = 0;
-
-  // This notifies of the event that a |task| is about to be removed. The task
-  // is still valid during this call, after that it may never be used again by
-  // the observer and references to it must not be kept.
-  virtual void TaskRemoved(Task* task) = 0;
-
-  // This notifies of the event that |task| has become unresponsive. This event
-  // is only for tasks representing renderer processes.
-  virtual void TaskUnresponsive(Task* task) {}
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TaskProviderObserver);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_TASK_PROVIDER_OBSERVER_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/background_contents_tag.cc b/chrome/browser/task_manager/providers/web_contents/background_contents_tag.cc
deleted file mode 100644
index a088fd8..0000000
--- a/chrome/browser/task_manager/providers/web_contents/background_contents_tag.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/background_contents_tag.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/background/background_contents.h"
-#include "chrome/browser/background/background_contents_service.h"
-#include "chrome/browser/background/background_contents_service_factory.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/providers/web_contents/background_contents_task.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/common/extension_set.h"
-
-namespace task_manager {
-
-BackgroundContentsTask* BackgroundContentsTag::CreateTask() const {
-  // Try to lookup the application name from the parent extension (if any).
-  Profile* profile = Profile::FromBrowserContext(
-      web_contents()->GetBrowserContext());
-  BackgroundContentsService* background_contents_service =
-      BackgroundContentsServiceFactory::GetForProfile(profile);
-  const base::string16& application_id =
-      background_contents_service->GetParentApplicationId(background_contents_);
-  const extensions::ExtensionSet& extensions_set =
-      extensions::ExtensionRegistry::Get(profile)->enabled_extensions();
-  const extensions::Extension* extension =
-      extensions_set.GetByID(base::UTF16ToUTF8(application_id));
-  base::string16 application_name;
-  if (extension)
-    application_name = base::UTF8ToUTF16(extension->name());
-
-  return new BackgroundContentsTask(application_name, background_contents_);
-}
-
-BackgroundContentsTag::BackgroundContentsTag(
-    content::WebContents* web_contents,
-    BackgroundContents* background_contents)
-    : WebContentsTag(web_contents),
-      background_contents_(background_contents) {
-  DCHECK(background_contents);
-}
-
-BackgroundContentsTag::~BackgroundContentsTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/background_contents_tag.h b/chrome/browser/task_manager/providers/web_contents/background_contents_tag.h
deleted file mode 100644
index 33b3990..0000000
--- a/chrome/browser/task_manager/providers/web_contents/background_contents_tag.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/background_contents_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-class BackgroundContents;
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by BackgroundContents
-// service.
-class BackgroundContentsTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  BackgroundContentsTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  BackgroundContentsTag(content::WebContents* web_contents,
-                        BackgroundContents* background_contents);
-  ~BackgroundContentsTag() override;
-
-  // The owning BackgroundContents.
-  BackgroundContents* background_contents_;
-
-  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/background_contents_tag_browsertest.cc b/chrome/browser/task_manager/providers/web_contents/background_contents_tag_browsertest.cc
deleted file mode 100644
index bc00df6..0000000
--- a/chrome/browser/task_manager/providers/web_contents/background_contents_tag_browsertest.cc
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/macros.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/extensions/extension_browsertest.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "chrome/common/chrome_switches.h"
-#include "chrome/grit/generated_resources.h"
-#include "content/public/common/content_switches.h"
-#include "extensions/common/switches.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-// Defines a browser test for testing that BackgroundContents are tagged
-// properly and the TagsManager records these tags. It is also used to test that
-// the WebContentsTaskProvider will be able to provide the appropriate
-// BackgroundContentsTask.
-class BackgroundContentsTagTest : public ExtensionBrowserTest {
- public:
-  BackgroundContentsTagTest() {}
-  ~BackgroundContentsTagTest() override {}
-
-  const extensions::Extension* LoadBackgroundExtension() {
-    auto* extension = LoadExtension(
-        test_data_dir_.AppendASCII("app_process_background_instances"));
-    return extension;
-  }
-
-  base::string16 GetBackgroundTaskExpectedName(
-      const extensions::Extension* extension) {
-    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_APP_PREFIX,
-                                      base::UTF8ToUTF16(extension->name()));
-  }
-
-  WebContentsTagsManager* tags_manager() const {
-    return WebContentsTagsManager::GetInstance();
-  }
-
- protected:
-  // ExtensionBrowserTest:
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    // Pass flags to make testing apps easier.
-    ExtensionBrowserTest::SetUpCommandLine(command_line);
-    test_data_dir_ = test_data_dir_.AppendASCII("api_test");
-    command_line->AppendSwitch(switches::kDisableRendererBackgrounding);
-    command_line->AppendSwitch(switches::kDisablePopupBlocking);
-    command_line->AppendSwitch(extensions::switches::kAllowHTTPBackgroundPage);
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTagTest);
-};
-
-// Tests that loading an extension that has a background contents will result in
-// the tags manager recording a WebContentsTag.
-IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, TagsManagerRecordsATag) {
-  // Browser tests start with only one tab available.
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-  auto* extension = LoadBackgroundExtension();
-  ASSERT_NE(nullptr, extension);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-
-  // Unload the extension.
-  UnloadExtension(extension->id());
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-}
-
-// Tests that background contents creation while the provider is being observed
-// will also provide tasks.
-IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, TasksProvidedWhileObserving) {
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  // Browser tests start with only one tab available.
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-
-  task_manager.StartObserving();
-
-  // The pre-existing tab is provided.
-  EXPECT_EQ(1U, task_manager.tasks().size());
-
-  auto* extension = LoadBackgroundExtension();
-  ASSERT_NE(nullptr, extension);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-  ASSERT_EQ(2U, task_manager.tasks().size());
-
-  // Now check the newly provided task.
-  const Task* task = task_manager.tasks().back();
-  EXPECT_EQ(Task::RENDERER, task->GetType());
-  EXPECT_EQ(GetBackgroundTaskExpectedName(extension), task->title());
-
-  // Unload the extension.
-  UnloadExtension(extension->id());
-  EXPECT_EQ(1U, task_manager.tasks().size());
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-}
-
-// Tests providing a pre-existing background task to the observing operation.
-IN_PROC_BROWSER_TEST_F(BackgroundContentsTagTest, PreExistingTasksAreProvided) {
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  // Browser tests start with only one tab available.
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-  auto* extension = LoadBackgroundExtension();
-  ASSERT_NE(nullptr, extension);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-
-  task_manager.StartObserving();
-
-  // Pre-existing task will be provided to us.
-  ASSERT_EQ(2U, task_manager.tasks().size());
-
-  // Now check the provided task.
-  const Task* task = task_manager.tasks().back();
-  EXPECT_EQ(Task::RENDERER, task->GetType());
-  EXPECT_EQ(GetBackgroundTaskExpectedName(extension), task->title());
-
-  // Unload the extension.
-  UnloadExtension(extension->id());
-  EXPECT_EQ(1U, task_manager.tasks().size());
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/background_contents_task.cc b/chrome/browser/task_manager/providers/web_contents/background_contents_task.cc
deleted file mode 100644
index f849a5a..0000000
--- a/chrome/browser/task_manager/providers/web_contents/background_contents_task.cc
+++ /dev/null
@@ -1,81 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/background_contents_task.h"
-
-#include "base/i18n/rtl.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/background/background_contents_service.h"
-#include "chrome/browser/background/background_contents_service_factory.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/profiles/profile_manager.h"
-#include "chrome/grit/generated_resources.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/browser/view_type_utils.h"
-#include "extensions/common/extension_set.h"
-#include "grit/theme_resources.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace task_manager {
-
-namespace {
-
-// The default icon for the background webcontents task.
-gfx::ImageSkia* g_default_icon = nullptr;
-
-gfx::ImageSkia* GetDefaultIcon() {
-  if (!g_default_icon && ResourceBundle::HasSharedInstance()) {
-    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
-        IDR_PLUGINS_FAVICON);
-  }
-
-  return g_default_icon;
-}
-
-base::string16 AdjustAndLocalizeTitle(const base::string16& title,
-                                      const std::string& url_spec) {
-  base::string16 localized_title(title);
-  if (localized_title.empty()) {
-    // No title (can't locate the parent app for some reason) so just display
-    // the URL (properly forced to be LTR).
-    localized_title = base::i18n::GetDisplayStringInLTRDirectionality(
-        base::UTF8ToUTF16(url_spec));
-  }
-
-  // Ensure that the string has the appropriate direction markers.
-  base::i18n::AdjustStringForLocaleDirection(&localized_title);
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_APP_PREFIX,
-                                    localized_title);
-}
-
-}  // namespace
-
-BackgroundContentsTask::BackgroundContentsTask(
-    const base::string16& title,
-    BackgroundContents* background_contents)
-    : RendererTask(
-        AdjustAndLocalizeTitle(title, background_contents->GetURL().spec()),
-        GetDefaultIcon(),
-        background_contents->web_contents(),
-        background_contents->web_contents()->GetRenderProcessHost()) {
-}
-
-BackgroundContentsTask::~BackgroundContentsTask() {
-}
-
-void BackgroundContentsTask::UpdateTitle() {
-  // TODO(afakhry): At the time of integration testing figure out whether we
-  // need to change the title of the task here.
-}
-
-void BackgroundContentsTask::UpdateFavicon() {
-  // We don't do anything here. For background contents we always use the
-  // default icon.
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/background_contents_task.h b/chrome/browser/task_manager/providers/web_contents/background_contents_task.h
deleted file mode 100644
index 74fdbba..0000000
--- a/chrome/browser/task_manager/providers/web_contents/background_contents_task.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/background/background_contents.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace task_manager {
-
-// Defines a RendererTask that represents background |WebContents|.
-class BackgroundContentsTask : public RendererTask {
- public:
-  BackgroundContentsTask(const base::string16& title,
-                         BackgroundContents* background_contents);
-  ~BackgroundContentsTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(BackgroundContentsTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_BACKGROUND_CONTENTS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/devtools_tag.cc b/chrome/browser/task_manager/providers/web_contents/devtools_tag.cc
deleted file mode 100644
index ad1f8f7..0000000
--- a/chrome/browser/task_manager/providers/web_contents/devtools_tag.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/devtools_tag.h"
-
-namespace task_manager {
-
-DevToolsTask* DevToolsTag::CreateTask() const {
-  return new DevToolsTask(web_contents());
-}
-
-DevToolsTag::DevToolsTag(content::WebContents* web_contents)
-    : WebContentsTag(web_contents) {
-}
-
-DevToolsTag::~DevToolsTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/devtools_tag.h b/chrome/browser/task_manager/providers/web_contents/devtools_tag.h
deleted file mode 100644
index 4f0dd11..0000000
--- a/chrome/browser/task_manager/providers/web_contents/devtools_tag.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/devtools_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by DevToolsWindow.
-class DevToolsTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  DevToolsTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  explicit DevToolsTag(content::WebContents* web_contents);
-  ~DevToolsTag() override;
-
-  DISALLOW_COPY_AND_ASSIGN(DevToolsTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/devtools_tag_browsertest.cc b/chrome/browser/task_manager/providers/web_contents/devtools_tag_browsertest.cc
deleted file mode 100644
index f4950b2..0000000
--- a/chrome/browser/task_manager/providers/web_contents/devtools_tag_browsertest.cc
+++ /dev/null
@@ -1,123 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/macros.h"
-#include "chrome/browser/devtools/devtools_window_testing.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "chrome/browser/ui/browser.h"
-#include "chrome/browser/ui/tabs/tab_strip_model.h"
-#include "chrome/test/base/in_process_browser_test.h"
-#include "chrome/test/base/ui_test_utils.h"
-#include "net/test/embedded_test_server/embedded_test_server.h"
-
-namespace task_manager {
-
-namespace {
-
-const char kTestPage1[] = "/devtools/debugger_test_page.html";
-const char kTestPage2[] = "/devtools/navigate_back.html";
-
-}  // namespace
-
-// Defines a browser test for testing that DevTools WebContents are being tagged
-// properly by a DevToolsTag and that the TagsManager records these tags. It
-// will also test that the WebContentsTaskProvider will be able to provide the
-// appropriate DevToolsTask.
-class DevToolsTagTest : public InProcessBrowserTest {
- public:
-  DevToolsTagTest()
-      : devtools_window_(nullptr) {
-    CHECK(embedded_test_server()->Start());
-  }
-
-  ~DevToolsTagTest() override {}
-
-  void LoadTestPage(const std::string& test_page) {
-    GURL url = embedded_test_server()->GetURL(test_page);
-    ui_test_utils::NavigateToURL(browser(), url);
-  }
-
-  void OpenDevToolsWindow(bool is_docked) {
-    devtools_window_ = DevToolsWindowTesting::OpenDevToolsWindowSync(
-        browser()->tab_strip_model()->GetWebContentsAt(0), is_docked);
-  }
-
-  void CloseDevToolsWindow() {
-    DevToolsWindowTesting::CloseDevToolsWindowSync(devtools_window_);
-  }
-
-  WebContentsTagsManager* tags_manager() const {
-    return WebContentsTagsManager::GetInstance();
-  }
-
- private:
-  DevToolsWindow* devtools_window_;
-
-  DISALLOW_COPY_AND_ASSIGN(DevToolsTagTest);
-};
-
-// Tests that opening a DevToolsWindow will result in tagging its main
-// WebContents and that tag will be recorded by the TagsManager.
-IN_PROC_BROWSER_TEST_F(DevToolsTagTest, TagsManagerRecordsATag) {
-  // Browser tests start with a single tab.
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-
-  // Navigating the same tab to the test page won't change the number of tracked
-  // tags. No devtools yet.
-  LoadTestPage(kTestPage1);
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-
-  // Test both docked and undocked devtools.
-  OpenDevToolsWindow(true);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-  CloseDevToolsWindow();
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-
-  // For the undocked devtools there will be two tags one for the main contents
-  // and one for the toolbox contents
-  OpenDevToolsWindow(false);
-  EXPECT_EQ(3U, tags_manager()->tracked_tags().size());
-  CloseDevToolsWindow();
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-}
-
-IN_PROC_BROWSER_TEST_F(DevToolsTagTest, DevToolsTaskIsProvided) {
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  // Browser tests start with a single tab.
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-
-  task_manager.StartObserving();
-
-  // The pre-existing tab is provided.
-  EXPECT_EQ(1U, task_manager.tasks().size());
-
-  LoadTestPage(kTestPage1);
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-  EXPECT_EQ(1U, task_manager.tasks().size());
-
-  OpenDevToolsWindow(true);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-  ASSERT_EQ(2U, task_manager.tasks().size());
-
-  const Task* task = task_manager.tasks().back();
-  EXPECT_EQ(Task::RENDERER, task->GetType());
-
-  // Navigating to a new page will not change the id of the devtools main
-  // WebContents (its js may update its title).
-  const int64_t task_id = task->task_id();
-  LoadTestPage(kTestPage2);
-  EXPECT_EQ(2U, tags_manager()->tracked_tags().size());
-  EXPECT_EQ(task_id, task_manager.tasks().back()->task_id());
-  EXPECT_EQ(task, task_manager.tasks().back());
-  EXPECT_NE(task_manager.tasks()[0]->title(),
-            task_manager.tasks()[1]->title());
-
-  CloseDevToolsWindow();
-  EXPECT_EQ(1U, tags_manager()->tracked_tags().size());
-  EXPECT_EQ(1U, task_manager.tasks().size());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/devtools_task.cc b/chrome/browser/task_manager/providers/web_contents/devtools_task.cc
deleted file mode 100644
index 963d8aa..0000000
--- a/chrome/browser/task_manager/providers/web_contents/devtools_task.cc
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/devtools_task.h"
-
-#include "content/public/browser/web_contents.h"
-
-namespace task_manager {
-
-DevToolsTask::DevToolsTask(content::WebContents* web_contents)
-    : TabContentsTask(web_contents) {
-}
-
-DevToolsTask::~DevToolsTask() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/devtools_task.h b/chrome/browser/task_manager/providers/web_contents/devtools_task.h
deleted file mode 100644
index 1b2bdd7..0000000
--- a/chrome/browser/task_manager/providers/web_contents/devtools_task.h
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/tab_contents_task.h"
-
-namespace task_manager {
-
-// Defines a task manager representation of the developer tools WebContents.
-class DevToolsTask : public TabContentsTask {
- public:
-  explicit DevToolsTask(content::WebContents* web_contents);
-  ~DevToolsTask() override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(DevToolsTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_DEVTOOLS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/extension_tag.cc b/chrome/browser/task_manager/providers/web_contents/extension_tag.cc
deleted file mode 100644
index 63577b9..0000000
--- a/chrome/browser/task_manager/providers/web_contents/extension_tag.cc
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/extension_tag.h"
-
-#include "content/public/browser/web_contents.h"
-
-#if defined(ENABLE_EXTENSIONS)
-#include "extensions/browser/process_manager.h"
-#endif
-
-namespace task_manager {
-
-ExtensionTask* ExtensionTag::CreateTask() const {
-  // Upon being asked to create a task, it means that the site instance is ready
-  // and connected, and the render frames have been initialized.
-  // It's OK if the following returns nullptr, ExtensionTask will then get the
-  // title from the WebContents.
-  const extensions::Extension* extension =
-      extensions::ProcessManager::Get(web_contents()->GetBrowserContext())->
-          GetExtensionForWebContents(web_contents());
-
-  return new ExtensionTask(web_contents(), extension, view_type_);
-}
-
-ExtensionTag::ExtensionTag(content::WebContents* web_contents,
-                           const extensions::ViewType view_type)
-    : WebContentsTag(web_contents),
-      view_type_(view_type) {
-}
-
-ExtensionTag::~ExtensionTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/extension_tag.h b/chrome/browser/task_manager/providers/web_contents/extension_tag.h
deleted file mode 100644
index a816f42..0000000
--- a/chrome/browser/task_manager/providers/web_contents/extension_tag.h
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/extension_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace extensions {
-class Extension;
-}  // namespace extensions
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by extensions.
-class ExtensionTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  ExtensionTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  ExtensionTag(content::WebContents* web_contents,
-               const extensions::ViewType view_type);
-  ~ExtensionTag() override;
-
-  // The ViewType of the extension WebContents this tag is attached to.
-  const extensions::ViewType view_type_;
-
-  DISALLOW_COPY_AND_ASSIGN(ExtensionTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/extension_tag_browsertest.cc b/chrome/browser/task_manager/providers/web_contents/extension_tag_browsertest.cc
deleted file mode 100644
index 0fcd21f..0000000
--- a/chrome/browser/task_manager/providers/web_contents/extension_tag_browsertest.cc
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/macros.h"
-#include "base/strings/utf_string_conversions.h"
-#include "build/build_config.h"
-#include "chrome/browser/extensions/extension_browsertest.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/common/chrome_switches.h"
-#include "extensions/browser/test_image_loader.h"
-#include "extensions/common/constants.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/skia_util.h"
-
-namespace task_manager {
-
-class ExtensionTagsTest : public ExtensionBrowserTest {
- public:
-  ExtensionTagsTest() {}
-  ~ExtensionTagsTest() override {}
-
- protected:
-  // ExtensionBrowserTest:
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    ExtensionBrowserTest::SetUpCommandLine(command_line);
-
-    // Do not launch device discovery process.
-    command_line->AppendSwitch(switches::kDisableDeviceDiscoveryNotifications);
-  }
-
-  const std::vector<WebContentsTag*>& tracked_tags() const {
-    return WebContentsTagsManager::GetInstance()->tracked_tags();
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(ExtensionTagsTest);
-};
-
-// Tests loading, disabling, enabling and unloading extensions and how that will
-// affect the recording of tags.
-IN_PROC_BROWSER_TEST_F(ExtensionTagsTest, Basic) {
-  // Browser tests start with a single tab.
-  EXPECT_EQ(1U, tracked_tags().size());
-
-  const extensions::Extension* extension = LoadExtension(
-      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
-          .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-          .AppendASCII("1.0.0.0"));
-  ASSERT_TRUE(extension);
-
-  EXPECT_EQ(2U, tracked_tags().size());
-
-  DisableExtension(extension->id());
-  EXPECT_EQ(1U, tracked_tags().size());
-
-  EnableExtension(extension->id());
-  EXPECT_EQ(2U, tracked_tags().size());
-
-  UnloadExtension(extension->id());
-  EXPECT_EQ(1U, tracked_tags().size());
-}
-
-// Test disabled due to flakiness. See bug: http://crbug.com/519333
-IN_PROC_BROWSER_TEST_F(ExtensionTagsTest,
-                       DISABLED_PreAndPostExistingTaskProviding) {
-  // Browser tests start with a single tab.
-  EXPECT_EQ(1U, tracked_tags().size());
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-
-  const extensions::Extension* extension = LoadExtension(
-      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
-          .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-          .AppendASCII("1.0.0.0"));
-  ASSERT_TRUE(extension);
-
-  EXPECT_EQ(2U, tracked_tags().size());
-  EXPECT_TRUE(task_manager.tasks().empty());
-
-  base::RunLoop run_loop;
-  run_loop.RunUntilIdle();
-
-  // Start observing, pre-existing tasks will be provided.
-  task_manager.StartObserving();
-  ASSERT_EQ(2U, task_manager.tasks().size());
-  const Task* extension_task = task_manager.tasks().back();
-  EXPECT_EQ(Task::EXTENSION, extension_task->GetType());
-
-  SkBitmap expected_bitmap =
-      extensions::TestImageLoader::LoadAndGetExtensionBitmap(
-          extension,
-          "icon_128.png",
-          extension_misc::EXTENSION_ICON_SMALL);
-  ASSERT_FALSE(expected_bitmap.empty());
-
-  EXPECT_TRUE(gfx::BitmapsAreEqual(*extension_task->icon().bitmap(),
-                                   expected_bitmap));
-
-  // Unload the extension and expect that the task manager now shows only the
-  // about:blank tab.
-  UnloadExtension(extension->id());
-  EXPECT_EQ(1U, tracked_tags().size());
-  ASSERT_EQ(1U, task_manager.tasks().size());
-  const Task* about_blank_task = task_manager.tasks().back();
-  EXPECT_EQ(Task::RENDERER, about_blank_task->GetType());
-  EXPECT_EQ(base::UTF8ToUTF16("Tab: about:blank"), about_blank_task->title());
-
-  // Reload the extension, the task manager should show it again.
-  ReloadExtension(extension->id());
-  EXPECT_EQ(2U, tracked_tags().size());
-  ASSERT_EQ(2U, task_manager.tasks().size());
-  EXPECT_EQ(Task::EXTENSION, task_manager.tasks().back()->GetType());
-}
-
-}  // namespace task_manager
-
diff --git a/chrome/browser/task_manager/providers/web_contents/extension_task.cc b/chrome/browser/task_manager/providers/web_contents/extension_task.cc
deleted file mode 100644
index 00d0437..0000000
--- a/chrome/browser/task_manager/providers/web_contents/extension_task.cc
+++ /dev/null
@@ -1,141 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/extension_task.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/ui/browser.h"
-#include "chrome/browser/ui/browser_finder.h"
-#include "chrome/browser/ui/chrome_pages.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/process_manager.h"
-#include "extensions/browser/view_type_utils.h"
-#include "extensions/common/constants.h"
-#include "extensions/common/extension.h"
-#include "extensions/common/manifest_handlers/icons_handler.h"
-#include "extensions/common/view_type.h"
-#include "grit/theme_resources.h"
-#include "ui/base/resource/resource_bundle.h"
-
-namespace task_manager {
-
-namespace {
-
-gfx::ImageSkia* g_default_icon = nullptr;
-
-gfx::ImageSkia* GetDefaultIcon() {
-  if (!ResourceBundle::HasSharedInstance())
-    return nullptr;
-
-  if (!g_default_icon) {
-    g_default_icon = ResourceBundle::GetSharedInstance().GetImageSkiaNamed(
-        IDR_EXTENSIONS_FAVICON);
-  }
-
-  return g_default_icon;
-}
-
-}  // namespace
-
-ExtensionTask::ExtensionTask(content::WebContents* web_contents,
-                             const extensions::Extension* extension,
-                             extensions::ViewType view_type)
-    : RendererTask(GetExtensionTitle(web_contents, extension, view_type),
-                   GetDefaultIcon(),
-                   web_contents,
-                   web_contents->GetRenderProcessHost()) {
-  LoadExtensionIcon(extension);
-}
-
-ExtensionTask::~ExtensionTask() {
-}
-
-void ExtensionTask::UpdateTitle() {
-  // The title of the extension should not change as a result of title change
-  // in its WebContents, so we ignore this.
-}
-
-void ExtensionTask::UpdateFavicon() {
-  // We don't care about the favicon of the WebContents but rather of the
-  // extension.
-}
-
-void ExtensionTask::Activate() {
-  // This task represents the extension view of (for example) a background page
-  // or browser action button, so there is no top-level window to bring to the
-  // front. Instead, when this task is double-clicked, we bring up the
-  // chrome://extensions page in a tab, and highlight the details for this
-  // extension.
-  //
-  // TODO(nick): For extensions::VIEW_TYPE_APP_WINDOW, and maybe others, there
-  // may actually be a window we could focus. Special case those here as needed.
-  const extensions::Extension* extension =
-      extensions::ProcessManager::Get(web_contents()->GetBrowserContext())
-          ->GetExtensionForWebContents(web_contents());
-
-  if (!extension)
-    return;
-
-  Browser* browser = chrome::FindTabbedBrowser(
-      Profile::FromBrowserContext(web_contents()->GetBrowserContext()), true);
-
-  // If an existing browser isn't found, don't create a new one.
-  if (!browser)
-    return;
-
-  chrome::ShowExtensions(browser, extension->id());
-}
-
-Task::Type ExtensionTask::GetType() const {
-  return Task::EXTENSION;
-}
-
-void ExtensionTask::OnExtensionIconImageChanged(extensions::IconImage* image) {
-  DCHECK_EQ(extension_icon_.get(), image);
-
-  if (!image->image_skia().isNull())
-    set_icon(image->image_skia());
-}
-
-base::string16 ExtensionTask::GetExtensionTitle(
-    content::WebContents* web_contents,
-    const extensions::Extension* extension,
-    extensions::ViewType view_type) const {
-  DCHECK(web_contents);
-
-  base::string16 title = extension ?
-      base::UTF8ToUTF16(extension->name()) :
-      RendererTask::GetTitleFromWebContents(web_contents);
-
-  bool is_background =
-      view_type == extensions::VIEW_TYPE_EXTENSION_BACKGROUND_PAGE;
-
-  return RendererTask::PrefixRendererTitle(
-      title,
-      extension && extension->is_app(),
-      true,  // is_extension
-      web_contents->GetBrowserContext()->IsOffTheRecord(),
-      is_background);
-}
-
-void ExtensionTask::LoadExtensionIcon(const extensions::Extension* extension) {
-  if (!extension)
-    return;
-
-  extension_icon_.reset(
-      new extensions::IconImage(web_contents()->GetBrowserContext(),
-                                extension,
-                                extensions::IconsInfo::GetIcons(extension),
-                                extension_misc::EXTENSION_ICON_SMALL,
-                                icon(),
-                                this));
-
-  // Triggers actual image loading with 1x resources.
-  extension_icon_->image_skia().GetRepresentation(1.0f);
-  set_icon(extension_icon_->image_skia());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/extension_task.h b/chrome/browser/task_manager/providers/web_contents/extension_task.h
deleted file mode 100644
index 27ad605..0000000
--- a/chrome/browser/task_manager/providers/web_contents/extension_task.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
-
-#include <memory>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-#include "extensions/browser/extension_icon_image.h"
-#include "extensions/common/view_type.h"
-
-namespace extensions {
-class Extension;
-}  // namespace extensions
-
-namespace task_manager {
-
-// Defines a task manager representation for extensions.
-class ExtensionTask
-    : public RendererTask,
-      public extensions::IconImage::Observer {
- public:
-  ExtensionTask(content::WebContents* web_contents,
-                const extensions::Extension* extension,
-                extensions::ViewType view_type);
-  ~ExtensionTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-  void Activate() override;
-  Type GetType() const override;
-
-  // extensions::IconImage::Observer
-  void OnExtensionIconImageChanged(extensions::IconImage* image) override;
-
- private:
-  // If |extension| is nullptr, this method will get the title from
-  // the |web_contents|.
-  base::string16 GetExtensionTitle(
-      content::WebContents* web_contents,
-      const extensions::Extension* extension,
-      extensions::ViewType view_type) const;
-
-  // This is called upon the creation of this task to load the extension icon
-  // for the first time if any.
-  void LoadExtensionIcon(const extensions::Extension* extension);
-
-  // The favicon of the extension represented by this task.
-  std::unique_ptr<extensions::IconImage> extension_icon_;
-
-  DISALLOW_COPY_AND_ASSIGN(ExtensionTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_EXTENSION_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/guest_tag.cc b/chrome/browser/task_manager/providers/web_contents/guest_tag.cc
deleted file mode 100644
index 78e0de6..0000000
--- a/chrome/browser/task_manager/providers/web_contents/guest_tag.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/guest_tag.h"
-
-namespace task_manager {
-
-GuestTask* GuestTag::CreateTask() const {
-  return new GuestTask(web_contents());
-}
-
-GuestTag::GuestTag(content::WebContents* web_contents)
-    : WebContentsTag(web_contents) {
-}
-
-GuestTag::~GuestTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/guest_tag.h b/chrome/browser/task_manager/providers/web_contents/guest_tag.h
deleted file mode 100644
index 725a327..0000000
--- a/chrome/browser/task_manager/providers/web_contents/guest_tag.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/guest_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by the GuestViewBase,
-// which represents browser <*view> tag plugin guests.
-class GuestTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  GuestTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  explicit GuestTag(content::WebContents* web_contents);
-  ~GuestTag() override;
-
-  DISALLOW_COPY_AND_ASSIGN(GuestTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/guest_task.cc b/chrome/browser/task_manager/providers/web_contents/guest_task.cc
deleted file mode 100644
index 88b4a6d..0000000
--- a/chrome/browser/task_manager/providers/web_contents/guest_task.cc
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/guest_task.h"
-
-#include "components/guest_view/browser/guest_view_base.h"
-#include "content/public/browser/web_contents.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-GuestTask::GuestTask(content::WebContents* web_contents)
-    : RendererTask(GetCurrentTitle(web_contents),
-                   GetFaviconFromWebContents(web_contents),
-                   web_contents,
-                   web_contents->GetRenderProcessHost()) {
-}
-
-GuestTask::~GuestTask() {
-}
-
-void GuestTask::UpdateTitle() {
-  set_title(GetCurrentTitle(web_contents()));
-}
-
-void GuestTask::UpdateFavicon() {
-  const gfx::ImageSkia* icon = GetFaviconFromWebContents(web_contents());
-  set_icon(icon ? *icon : gfx::ImageSkia());
-}
-
-Task::Type GuestTask::GetType() const {
-  return Task::GUEST;
-}
-
-base::string16 GuestTask::GetCurrentTitle(
-    content::WebContents* web_contents) const {
-  DCHECK(web_contents);
-
-  guest_view::GuestViewBase* guest =
-      guest_view::GuestViewBase::FromWebContents(web_contents);
-
-  if (!guest) {
-    // This can happen when an AppWindowContentsImpl is destroyed. It emits a
-    // DidFinishNavigation() events to the WebContentsObservers which triggers a
-    // title update in WebContentsTaskProvider. This happens before
-    // WebContentsDestroyed() is emitted.
-    return title();
-  }
-
-  base::string16 title =
-      l10n_util::GetStringFUTF16(guest->GetTaskPrefix(),
-                                 RendererTask::GetTitleFromWebContents(
-                                     web_contents));
-
-  return title;
-}
-
-}  // namespace task_manager
-
diff --git a/chrome/browser/task_manager/providers/web_contents/guest_task.h b/chrome/browser/task_manager/providers/web_contents/guest_task.h
deleted file mode 100644
index 5ba673b..0000000
--- a/chrome/browser/task_manager/providers/web_contents/guest_task.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace task_manager {
-
-// Defines a concrete RendererTask that represents WebContents owned by the
-// GuestViewBase which represents a <*view> tag that is a browser plugin guest.
-class GuestTask : public RendererTask {
- public:
-  explicit GuestTask(content::WebContents* web_contents);
-  ~GuestTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-  Type GetType() const override;
-
- private:
-  base::string16 GetCurrentTitle(content::WebContents* web_contents) const;
-
-  DISALLOW_COPY_AND_ASSIGN(GuestTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_GUEST_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/panel_tag.cc b/chrome/browser/task_manager/providers/web_contents/panel_tag.cc
deleted file mode 100644
index d65bec8..0000000
--- a/chrome/browser/task_manager/providers/web_contents/panel_tag.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/panel_tag.h"
-
-#include "chrome/browser/ui/panels/panel.h"
-
-namespace task_manager {
-
-PanelTask* PanelTag::CreateTask() const {
-  return new PanelTask(panel_, web_contents());
-}
-
-PanelTag::PanelTag(content::WebContents* web_contents, Panel* panel)
-    : WebContentsTag(web_contents),
-      panel_(panel) {
-}
-
-PanelTag::~PanelTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/panel_tag.h b/chrome/browser/task_manager/providers/web_contents/panel_tag.h
deleted file mode 100644
index 87820ff..0000000
--- a/chrome/browser/task_manager/providers/web_contents/panel_tag.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/panel_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by the PanelManager.
-class PanelTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  PanelTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  PanelTag(content::WebContents* web_contents, Panel* panel);
-  ~PanelTag() override;
-
-  Panel* panel_;
-
-  DISALLOW_COPY_AND_ASSIGN(PanelTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/panel_task.cc b/chrome/browser/task_manager/providers/web_contents/panel_task.cc
deleted file mode 100644
index 3e1a4af..0000000
--- a/chrome/browser/task_manager/providers/web_contents/panel_task.cc
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/panel_task.h"
-
-#include "base/i18n/rtl.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/ui/panels/panel.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/extension_registry.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace task_manager {
-
-namespace {
-
-const gfx::ImageSkia* GetPanelIcon(Panel* panel) {
-  const gfx::Image icon = panel->GetCurrentPageIcon();
-  return !icon.IsEmpty() ? icon.ToImageSkia() : nullptr;
-}
-
-}  // namespace
-
-PanelTask::PanelTask(Panel* panel, content::WebContents* web_contents)
-    : RendererTask(GetCurrentPanelTitle(panel),
-                   GetPanelIcon(panel),
-                   web_contents,
-                   web_contents->GetRenderProcessHost()),
-      panel_(panel) {
-}
-
-PanelTask::~PanelTask() {
-}
-
-void PanelTask::UpdateTitle() {
-  set_title(GetCurrentPanelTitle(panel_));
-}
-
-void PanelTask::UpdateFavicon() {
-  const gfx::ImageSkia* icon = GetPanelIcon(panel_);
-  set_icon(icon ? *icon : gfx::ImageSkia());
-}
-
-Task::Type PanelTask::GetType() const {
-  return Task::EXTENSION;
-}
-
-base::string16 PanelTask::GetCurrentPanelTitle(Panel* panel) const {
-  base::string16 title = panel->GetWindowTitle();
-  base::i18n::AdjustStringForLocaleDirection(&title);
-
-  extensions::ExtensionRegistry* registry =
-      extensions::ExtensionRegistry::Get(panel->profile());
-  const extensions::Extension* extension =
-      registry->enabled_extensions().GetByID(panel->extension_id());
-
-  const bool is_app = extension && extension->is_app();
-  const bool is_incognito = panel->profile()->IsOffTheRecord();
-
-  return PrefixRendererTitle(title,
-                             is_app,
-                             true,  // is_extension.
-                             is_incognito,
-                             false);  // is_background.
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/panel_task.h b/chrome/browser/task_manager/providers/web_contents/panel_task.h
deleted file mode 100644
index cc099ed..0000000
--- a/chrome/browser/task_manager/providers/web_contents/panel_task.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-class Panel;
-
-namespace task_manager {
-
-// Defines a task manager representation of WebContents owned by the
-// PanelManager.
-class PanelTask : public RendererTask {
- public:
-  PanelTask(Panel* panel, content::WebContents* web_contents);
-  ~PanelTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-  Task::Type GetType() const override;
-
- private:
-  base::string16 GetCurrentPanelTitle(Panel* panel) const;
-
-  Panel* panel_;
-
-  DISALLOW_COPY_AND_ASSIGN(PanelTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PANEL_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/prerender_tag.cc b/chrome/browser/task_manager/providers/web_contents/prerender_tag.cc
deleted file mode 100644
index 2c1d375..0000000
--- a/chrome/browser/task_manager/providers/web_contents/prerender_tag.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/prerender_tag.h"
-
-namespace task_manager {
-
-PrerenderTask* PrerenderTag::CreateTask() const {
-  return new PrerenderTask(web_contents());
-}
-
-PrerenderTag::PrerenderTag(content::WebContents* web_contents)
-    : WebContentsTag(web_contents) {
-}
-
-PrerenderTag::~PrerenderTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/prerender_tag.h b/chrome/browser/task_manager/providers/web_contents/prerender_tag.h
deleted file mode 100644
index d637eff..0000000
--- a/chrome/browser/task_manager/providers/web_contents/prerender_tag.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/prerender_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by the
-// PrerenderManager.
-class PrerenderTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  PrerenderTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  explicit PrerenderTag(content::WebContents* web_contents);
-  ~PrerenderTag() override;
-
-  DISALLOW_COPY_AND_ASSIGN(PrerenderTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/prerender_task.cc b/chrome/browser/task_manager/providers/web_contents/prerender_task.cc
deleted file mode 100644
index 66f826d..0000000
--- a/chrome/browser/task_manager/providers/web_contents/prerender_task.cc
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/prerender_task.h"
-
-#include "chrome/grit/generated_resources.h"
-#include "content/public/browser/web_contents.h"
-#include "grit/theme_resources.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace task_manager {
-
-namespace {
-
-gfx::ImageSkia* g_prerender_icon = nullptr;
-
-// Returns the prerender icon or |nullptr| if the |ResourceBundle| is not ready
-// yet.
-gfx::ImageSkia* GetPrerenderIcon() {
-  if (g_prerender_icon)
-    return g_prerender_icon;
-
-  if (!ResourceBundle::HasSharedInstance())
-    return nullptr;
-
-  g_prerender_icon =
-      ResourceBundle::GetSharedInstance().GetImageSkiaNamed(IDR_PRERENDER);
-  return g_prerender_icon;
-}
-
-base::string16 PrefixTitle(const base::string16& title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRERENDER_PREFIX, title);
-}
-
-}  // namespace
-
-PrerenderTask::PrerenderTask(content::WebContents* web_contents)
-    : RendererTask(
-          PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents)),
-          GetPrerenderIcon(),
-          web_contents,
-          web_contents->GetRenderProcessHost()) {
-}
-
-PrerenderTask::~PrerenderTask() {
-}
-
-void PrerenderTask::UpdateTitle() {
-  // As long as this task lives we keep prefixing its title with "Prerender:".
-  set_title(PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents())));
-}
-
-void PrerenderTask::UpdateFavicon() {
-  // As long as this task lives we keep using the prerender icon, so we ignore
-  // this event.
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/prerender_task.h b/chrome/browser/task_manager/providers/web_contents/prerender_task.h
deleted file mode 100644
index cbd41c2..0000000
--- a/chrome/browser/task_manager/providers/web_contents/prerender_task.h
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace task_manager {
-
-// Defines a task manager representation of WebContents owned by the
-// PrerenderManager.
-class PrerenderTask : public RendererTask {
- public:
-  explicit PrerenderTask(content::WebContents* web_contents);
-  ~PrerenderTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(PrerenderTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRERENDER_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/printing_tag.cc b/chrome/browser/task_manager/providers/web_contents/printing_tag.cc
deleted file mode 100644
index 7fb330b..0000000
--- a/chrome/browser/task_manager/providers/web_contents/printing_tag.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/printing_tag.h"
-
-namespace task_manager {
-
-PrintingTask* PrintingTag::CreateTask() const {
-  return new PrintingTask(web_contents());
-}
-
-PrintingTag::PrintingTag(content::WebContents* web_contents)
-    : WebContentsTag(web_contents) {
-}
-
-PrintingTag::~PrintingTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/printing_tag.h b/chrome/browser/task_manager/providers/web_contents/printing_tag.h
deleted file mode 100644
index dfcd671..0000000
--- a/chrome/browser/task_manager/providers/web_contents/printing_tag.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/printing_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents created for print previews
-// and background printing.
-class PrintingTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  PrintingTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  explicit PrintingTag(content::WebContents* web_contents);
-  ~PrintingTag() override;
-
-  DISALLOW_COPY_AND_ASSIGN(PrintingTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/printing_task.cc b/chrome/browser/task_manager/providers/web_contents/printing_task.cc
deleted file mode 100644
index 15bbf3f..0000000
--- a/chrome/browser/task_manager/providers/web_contents/printing_task.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/printing_task.h"
-
-#include "chrome/grit/generated_resources.h"
-#include "content/public/browser/web_contents.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-namespace {
-
-base::string16 PrefixTitle(const base::string16& title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRINT_PREFIX, title);
-}
-
-}  // namespace
-
-PrintingTask::PrintingTask(content::WebContents* web_contents)
-    : RendererTask(
-        PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents)),
-        RendererTask::GetFaviconFromWebContents(web_contents),
-        web_contents,
-        web_contents->GetRenderProcessHost()) {
-}
-
-PrintingTask::~PrintingTask() {
-}
-
-void PrintingTask::UpdateTitle() {
-  set_title(PrefixTitle(RendererTask::GetTitleFromWebContents(web_contents())));
-}
-
-void PrintingTask::UpdateFavicon() {
-  const gfx::ImageSkia* icon =
-      RendererTask::GetFaviconFromWebContents(web_contents());
-  set_icon(icon ? *icon : gfx::ImageSkia());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/printing_task.h b/chrome/browser/task_manager/providers/web_contents/printing_task.h
deleted file mode 100644
index 20b712c..0000000
--- a/chrome/browser/task_manager/providers/web_contents/printing_task.h
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace task_manager {
-
-// Defines a task manager representation for WebContents that are created for
-// print previews and background printing.
-class PrintingTask : public RendererTask {
- public:
-  explicit PrintingTask(content::WebContents* web_contents);
-  ~PrintingTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(PrintingTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_PRINTING_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/renderer_task.cc b/chrome/browser/task_manager/providers/web_contents/renderer_task.cc
deleted file mode 100644
index 25a68b0..0000000
--- a/chrome/browser/task_manager/providers/web_contents/renderer_task.cc
+++ /dev/null
@@ -1,244 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-#include <utility>
-
-#include "base/i18n/rtl.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/favicon/favicon_utils.h"
-#include "chrome/browser/process_resource_usage.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/grit/generated_resources.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/web_contents_delegate.h"
-#include "services/shell/public/cpp/interface_provider.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-namespace {
-
-// Creates the Mojo service wrapper that will be used to sample the V8 memory
-// usage and the the WebCache resource stats of the render process hosted by
-// |render_process_host|.
-ProcessResourceUsage* CreateRendererResourcesSampler(
-    content::RenderProcessHost* render_process_host) {
-  mojom::ResourceUsageReporterPtr service;
-  render_process_host->GetRemoteInterfaces()->GetInterface(&service);
-  return new ProcessResourceUsage(std::move(service));
-}
-
-// Gets the profile name associated with the browser context of the given
-// |render_process_host| from the profile info cache.
-base::string16 GetRendererProfileName(
-    const content::RenderProcessHost* render_process_host) {
-  Profile* profile =
-      Profile::FromBrowserContext(render_process_host->GetBrowserContext());
-  return Task::GetProfileNameFromProfile(profile);
-}
-
-bool IsRendererResourceSamplingDisabled(int64_t flags) {
-  return (flags & (REFRESH_TYPE_V8_MEMORY | REFRESH_TYPE_WEBCACHE_STATS)) == 0;
-}
-
-std::string GetRapporSampleName(content::WebContents* web_contents) {
-  return web_contents->GetVisibleURL().GetOrigin().spec();
-}
-
-}  // namespace
-
-RendererTask::RendererTask(const base::string16& title,
-                           const gfx::ImageSkia* icon,
-                           content::WebContents* web_contents,
-                           content::RenderProcessHost* render_process_host)
-    : Task(title,
-           GetRapporSampleName(web_contents),
-           icon,
-           render_process_host->GetHandle()),
-      web_contents_(web_contents),
-      render_process_host_(render_process_host),
-      renderer_resources_sampler_(
-          CreateRendererResourcesSampler(render_process_host_)),
-      render_process_id_(render_process_host_->GetID()),
-      v8_memory_allocated_(0),
-      v8_memory_used_(0),
-      webcache_stats_(blink::WebCache::ResourceTypeStats()),
-      profile_name_(GetRendererProfileName(render_process_host_)),
-      termination_status_(base::TERMINATION_STATUS_STILL_RUNNING),
-      termination_error_code_(0) {
-  // All renderer tasks are capable of reporting network usage, so the default
-  // invalid value of -1 doesn't apply here.
-  OnNetworkBytesRead(0);
-
-  // Tag the web_contents with a |ContentFaviconDriver| (if needed) so that
-  // we can use it to observe favicons changes.
-  favicon::CreateContentFaviconDriverForWebContents(web_contents);
-  favicon::ContentFaviconDriver::FromWebContents(web_contents)->AddObserver(
-      this);
-}
-
-RendererTask::~RendererTask() {
-  favicon::ContentFaviconDriver::FromWebContents(web_contents())->
-      RemoveObserver(this);
-}
-
-void RendererTask::UpdateRapporSampleName() {
-  set_rappor_sample_name(GetRapporSampleName(web_contents()));
-}
-
-void RendererTask::Activate() {
-  if (!web_contents_->GetDelegate())
-    return;
-
-  web_contents_->GetDelegate()->ActivateContents(web_contents_);
-}
-
-void RendererTask::Refresh(const base::TimeDelta& update_interval,
-                           int64_t refresh_flags) {
-  Task::Refresh(update_interval, refresh_flags);
-
-  if (IsRendererResourceSamplingDisabled(refresh_flags))
-    return;
-
-  // The renderer resources refresh is performed asynchronously, we will invoke
-  // it and record the current values (which might be invalid at the moment. We
-  // can safely ignore that and count on future refresh cycles potentially
-  // having valid values).
-  renderer_resources_sampler_->Refresh(base::Closure());
-
-  v8_memory_allocated_ = base::saturated_cast<int64_t>(
-      renderer_resources_sampler_->GetV8MemoryAllocated());
-  v8_memory_used_ = base::saturated_cast<int64_t>(
-      renderer_resources_sampler_->GetV8MemoryUsed());
-  webcache_stats_ = renderer_resources_sampler_->GetWebCoreCacheStats();
-}
-
-Task::Type RendererTask::GetType() const {
-  return Task::RENDERER;
-}
-
-int RendererTask::GetChildProcessUniqueID() const {
-  return render_process_id_;
-}
-
-void RendererTask::GetTerminationStatus(base::TerminationStatus* out_status,
-                                        int* out_error_code) const {
-  DCHECK(out_status);
-  DCHECK(out_error_code);
-
-  *out_status = termination_status_;
-  *out_error_code = termination_error_code_;
-}
-
-base::string16 RendererTask::GetProfileName() const {
-  return profile_name_;
-}
-
-int RendererTask::GetTabId() const {
-  return SessionTabHelper::IdForTab(web_contents_);
-}
-
-int64_t RendererTask::GetV8MemoryAllocated() const {
-  return v8_memory_allocated_;
-}
-
-int64_t RendererTask::GetV8MemoryUsed() const {
-  return v8_memory_used_;
-}
-
-bool RendererTask::ReportsWebCacheStats() const {
-  return true;
-}
-
-blink::WebCache::ResourceTypeStats RendererTask::GetWebCacheStats() const {
-  return webcache_stats_;
-}
-
-void RendererTask::OnFaviconUpdated(favicon::FaviconDriver* favicon_driver,
-                                    NotificationIconType notification_icon_type,
-                                    const GURL& icon_url,
-                                    bool icon_url_changed,
-                                    const gfx::Image& image) {
-  if (notification_icon_type == NON_TOUCH_16_DIP)
-    UpdateFavicon();
-}
-
-// static
-base::string16 RendererTask::GetTitleFromWebContents(
-    content::WebContents* web_contents) {
-  DCHECK(web_contents);
-  base::string16 title = web_contents->GetTitle();
-  if (title.empty()) {
-    GURL url = web_contents->GetURL();
-    title = base::UTF8ToUTF16(url.spec());
-    // Force URL to be LTR.
-    title = base::i18n::GetDisplayStringInLTRDirectionality(title);
-  } else {
-    // Since the title could later be concatenated with
-    // IDS_TASK_MANAGER_TAB_PREFIX (for example), we need to explicitly set the
-    // title to be LTR format if there is no strong RTL charater in it.
-    // Otherwise, if IDS_TASK_MANAGER_TAB_PREFIX is an RTL word, the
-    // concatenated result might be wrong. For example, http://mail.yahoo.com,
-    // whose title is "Yahoo! Mail: The best web-based Email!", without setting
-    // it explicitly as LTR format, the concatenated result will be "!Yahoo!
-    // Mail: The best web-based Email :BAT", in which the capital letters "BAT"
-    // stands for the Hebrew word for "tab".
-    base::i18n::AdjustStringForLocaleDirection(&title);
-  }
-  return title;
-}
-
-// static
-const gfx::ImageSkia* RendererTask::GetFaviconFromWebContents(
-    content::WebContents* web_contents) {
-  DCHECK(web_contents);
-
-  // Tag the web_contents with a |ContentFaviconDriver| (if needed) so that
-  // we can use it to retrieve the favicon if there is one.
-  favicon::CreateContentFaviconDriverForWebContents(web_contents);
-  gfx::Image image =
-      favicon::ContentFaviconDriver::FromWebContents(web_contents)->
-          GetFavicon();
-  if (image.IsEmpty())
-    return nullptr;
-
-  return image.ToImageSkia();
-}
-
-// static
-const base::string16 RendererTask::PrefixRendererTitle(
-    const base::string16& title,
-    bool is_app,
-    bool is_extension,
-    bool is_incognito,
-    bool is_background) {
-  int message_id = IDS_TASK_MANAGER_TAB_PREFIX;
-
-  if (is_incognito && !is_app && !is_extension) {
-    message_id = IDS_TASK_MANAGER_TAB_INCOGNITO_PREFIX;
-  } else if (is_app) {
-    if (is_background)
-      message_id = IDS_TASK_MANAGER_BACKGROUND_PREFIX;
-    else if (is_incognito)
-      message_id = IDS_TASK_MANAGER_APP_INCOGNITO_PREFIX;
-    else
-      message_id = IDS_TASK_MANAGER_APP_PREFIX;
-  } else if (is_extension) {
-    if (is_incognito)
-      message_id = IDS_TASK_MANAGER_EXTENSION_INCOGNITO_PREFIX;
-    else
-      message_id = IDS_TASK_MANAGER_EXTENSION_PREFIX;
-  }
-
-  return l10n_util::GetStringFUTF16(message_id, title);
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/renderer_task.h b/chrome/browser/task_manager/providers/web_contents/renderer_task.h
deleted file mode 100644
index 0609b3d..0000000
--- a/chrome/browser/task_manager/providers/web_contents/renderer_task.h
+++ /dev/null
@@ -1,138 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
-
-#include <stdint.h>
-
-#include <memory>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task.h"
-#include "components/favicon/core/favicon_driver_observer.h"
-#include "content/public/browser/navigation_entry.h"
-
-class ProcessResourceUsage;
-
-namespace content {
-class RenderProcessHost;
-class WebContents;
-}  // namespace content
-
-namespace task_manager {
-
-// Defines an abstract base class for various types of renderer process tasks
-// such as background contents, tab contents, ... etc.
-class RendererTask : public Task,
-                     public favicon::FaviconDriverObserver {
- public:
-  RendererTask(const base::string16& title,
-               const gfx::ImageSkia* icon,
-               content::WebContents* web_contents,
-               content::RenderProcessHost* render_process_host);
-  ~RendererTask() override;
-
-  // An abstract method that will be called when the event
-  // WebContentsObserver::DidNavigateMainFrame() occurs. This gives the
-  // freedom to concrete tasks to adjust the title however they need to before
-  // they set it.
-  virtual void UpdateTitle() = 0;
-
-  // An abstract method that will be called when the event
-  // FaviconDriverObserver::OnFaviconUpdated() occurs, so that concrete tasks
-  // can update their favicons.
-  virtual void UpdateFavicon() = 0;
-
-  // An overridable method that will be called when the event
-  // WebContentsObserver::DidNavigateMainFrame() occurs, so that we can update
-  // their Rappor sample name when a navigation takes place.
-  virtual void UpdateRapporSampleName();
-
-  // task_manager::Task:
-  void Activate() override;
-  void Refresh(const base::TimeDelta& update_interval,
-               int64_t refresh_flags) override;
-  Type GetType() const override;
-  int GetChildProcessUniqueID() const override;
-  void GetTerminationStatus(base::TerminationStatus* out_status,
-                            int* out_error_code) const override;
-  base::string16 GetProfileName() const override;
-  int GetTabId() const override;
-  int64_t GetV8MemoryAllocated() const override;
-  int64_t GetV8MemoryUsed() const override;
-  bool ReportsWebCacheStats() const override;
-  blink::WebCache::ResourceTypeStats GetWebCacheStats() const override;
-
-  // favicon::FaviconDriverObserver:
-  void OnFaviconUpdated(favicon::FaviconDriver* driver,
-                        NotificationIconType notification_icon_type,
-                        const GURL& icon_url,
-                        bool icon_url_changed,
-                        const gfx::Image& image) override;
-
-  void set_termination_status(base::TerminationStatus status) {
-    termination_status_ = status;
-  }
-
-  void set_termination_error_code(int error_code) {
-    termination_error_code_ = error_code;
-  }
-
- protected:
-  // Returns the title of the given |web_contents|.
-  static base::string16 GetTitleFromWebContents(
-      content::WebContents* web_contents);
-
-  // Returns the favicon of the given |web_contents| if any, and returns
-  // |nullptr| otherwise.
-  static const gfx::ImageSkia* GetFaviconFromWebContents(
-      content::WebContents* web_contents);
-
-  // Prefixes the given renderer |title| with the appropriate string based on
-  // whether it's an app, an extension, incognito or a background page or
-  // contents.
-  static const base::string16 PrefixRendererTitle(const base::string16& title,
-                                                  bool is_app,
-                                                  bool is_extension,
-                                                  bool is_incognito,
-                                                  bool is_background);
-
-  content::WebContents* web_contents() const { return web_contents_; }
-
- private:
-  // The WebContents of the task this object represents.
-  content::WebContents* web_contents_;
-
-  // The render process host of the task this object represents.
-  content::RenderProcessHost* render_process_host_;
-
-  // The Mojo service wrapper that will provide us with the V8 memory usage and
-  // the WebCache resource stats of the render process represented by this
-  // object.
-  std::unique_ptr<ProcessResourceUsage> renderer_resources_sampler_;
-
-  // The unique ID of the RenderProcessHost.
-  const int render_process_id_;
-
-  // The allocated and used V8 memory (in bytes).
-  int64_t v8_memory_allocated_;
-  int64_t v8_memory_used_;
-
-  // The WebKit resource cache statistics for this renderer.
-  blink::WebCache::ResourceTypeStats webcache_stats_;
-
-  // The profile name associated with the browser context of the render view
-  // host.
-  const base::string16 profile_name_;
-
-  base::TerminationStatus termination_status_;
-  int termination_error_code_;
-
-  DISALLOW_COPY_AND_ASSIGN(RendererTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_RENDERER_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/subframe_task.cc b/chrome/browser/task_manager/providers/web_contents/subframe_task.cc
deleted file mode 100644
index c43cc22..0000000
--- a/chrome/browser/task_manager/providers/web_contents/subframe_task.cc
+++ /dev/null
@@ -1,86 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/subframe_task.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/grit/generated_resources.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/site_instance.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/constants.h"
-#include "extensions/common/extension.h"
-#include "extensions/common/extension_set.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-namespace {
-
-base::string16 AdjustTitle(const content::SiteInstance* site_instance) {
-  DCHECK(site_instance);
-
-  // By default, subframe rows display the site, like this:
-  //     "Subframe: http://example.com/"
-  const GURL& site_url = site_instance->GetSiteURL();
-  std::string name = site_url.spec();
-
-  // If |site_url| wraps a chrome extension id, we can display the extension
-  // name instead, which is more human-readable.
-  if (site_url.SchemeIs(extensions::kExtensionScheme)) {
-    const extensions::Extension* extension =
-        extensions::ExtensionRegistry::Get(site_instance->GetBrowserContext())
-            ->enabled_extensions()
-            .GetExtensionOrAppByURL(site_url);
-    if (extension)
-      name = extension->name();
-  }
-
-  int message_id = site_instance->GetBrowserContext()->IsOffTheRecord() ?
-      IDS_TASK_MANAGER_SUBFRAME_INCOGNITO_PREFIX :
-      IDS_TASK_MANAGER_SUBFRAME_PREFIX;
-  return l10n_util::GetStringFUTF16(message_id, base::UTF8ToUTF16(name));
-}
-
-}  // namespace
-
-SubframeTask::SubframeTask(content::RenderFrameHost* render_frame_host,
-                           content::WebContents* web_contents,
-                           RendererTask* main_task)
-    : RendererTask(AdjustTitle(render_frame_host->GetSiteInstance()),
-                   nullptr,
-                   web_contents,
-                   render_frame_host->GetProcess()),
-      main_task_(main_task) {
-  // Note that we didn't get the RenderProcessHost from the WebContents, but
-  // rather from the RenderFrameHost. Out-of-process iframes reside on
-  // different processes than that of their main frame.
-}
-
-SubframeTask::~SubframeTask() {
-}
-
-void SubframeTask::UpdateTitle() {
-  // This will be called when the title changes on the WebContents's main frame,
-  // but this Task represents other frames, so we don't care.
-}
-
-void SubframeTask::UpdateFavicon() {
-  // This will be called when the favicon changes on the WebContents's main
-  // frame, but this Task represents other frames, so we don't care.
-}
-
-Task* SubframeTask::GetParentTask() const {
-  return main_task_;
-}
-
-void SubframeTask::Activate() {
-  // Activate the root task.
-  main_task_->Activate();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/subframe_task.h b/chrome/browser/task_manager/providers/web_contents/subframe_task.h
deleted file mode 100644
index 7cf05a0..0000000
--- a/chrome/browser/task_manager/providers/web_contents/subframe_task.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace content {
-class RenderFrameHost;
-class WebContents;
-}  // namespace content
-
-namespace task_manager {
-
-// Defines a concrete renderer task that can represent processes hosting
-// out-of-process iframes.
-class SubframeTask : public RendererTask {
- public:
-  SubframeTask(content::RenderFrameHost* render_frame_host,
-               content::WebContents* web_contents,
-               RendererTask* main_task);
-  ~SubframeTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-  void Activate() override;
-
-  // task_manager::Task:
-  Task* GetParentTask() const override;
-
- private:
-  // The task for the main frame of this WebContents.
-  RendererTask* main_task_;
-  DISALLOW_COPY_AND_ASSIGN(SubframeTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_SUBFRAME_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/subframe_task_browsertest.cc b/chrome/browser/task_manager/providers/web_contents/subframe_task_browsertest.cc
deleted file mode 100644
index 8608ae9..0000000
--- a/chrome/browser/task_manager/providers/web_contents/subframe_task_browsertest.cc
+++ /dev/null
@@ -1,129 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/macros.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/grit/generated_resources.h"
-#include "chrome/test/base/in_process_browser_test.h"
-#include "chrome/test/base/ui_test_utils.h"
-#include "content/public/test/browser_test_utils.h"
-#include "content/public/test/test_utils.h"
-#include "net/dns/mock_host_resolver.h"
-#include "net/test/embedded_test_server/embedded_test_server.h"
-#include "ui/base/l10n/l10n_util.h"
-
-namespace task_manager {
-
-namespace {
-
-// URL of a test page on a.com that has two cross-site iframes to b.com and
-// c.com.
-const char kCrossSitePageUrl[] = "/cross-site/a.com/iframe_cross_site.html";
-
-// URL of a test page on a.com that has no cross-site iframes.
-const char kSimplePageUrl[] = "/cross-site/a.com/title2.html";
-
-base::string16 GetExpectedSubframeTitlePrefix() {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_SUBFRAME_PREFIX,
-                                    base::string16());
-}
-
-base::string16 PrefixExpectedTabTitle(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
-                                    base::UTF8ToUTF16(title));
-}
-
-}  // namespace
-
-// A test for OOPIFs and how they show up in the task manager as
-// SubframeTasks.
-class SubframeTaskBrowserTest : public InProcessBrowserTest {
- public:
-  SubframeTaskBrowserTest() {}
-  ~SubframeTaskBrowserTest() override {}
-
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    InProcessBrowserTest::SetUpCommandLine(command_line);
-    content::IsolateAllSitesForTesting(command_line);
-  }
-
-  void SetUpOnMainThread() override {
-    host_resolver()->AddRule("*", "127.0.0.1");
-    ASSERT_TRUE(embedded_test_server()->Start());
-    content::SetupCrossSiteRedirector(embedded_test_server());
-  }
-
-  void NavigateTo(const char* page_url) const {
-    ui_test_utils::NavigateToURL(browser(),
-                                 embedded_test_server()->GetURL(page_url));
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(SubframeTaskBrowserTest);
-};
-
-// Makes sure that, if sites are isolated, the task manager will show the
-// expected SubframeTasks, and they will be shown as running on different
-// processes as expected.
-IN_PROC_BROWSER_TEST_F(SubframeTaskBrowserTest, TaskManagerShowsSubframeTasks) {
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  task_manager.StartObserving();
-
-  // Currently only the about:blank page.
-  ASSERT_EQ(1U, task_manager.tasks().size());
-  const Task* about_blank_task = task_manager.tasks().front();
-  EXPECT_EQ(Task::RENDERER, about_blank_task->GetType());
-  EXPECT_EQ(PrefixExpectedTabTitle("about:blank"), about_blank_task->title());
-
-  NavigateTo(kCrossSitePageUrl);
-
-  // Whether sites are isolated or not, we expect to have at least one tab
-  // contents task.
-  ASSERT_GE(task_manager.tasks().size(), 1U);
-  const Task* cross_site_task = task_manager.tasks().front();
-  EXPECT_EQ(Task::RENDERER, cross_site_task->GetType());
-  EXPECT_EQ(PrefixExpectedTabTitle("cross-site iframe test"),
-            cross_site_task->title());
-
-  if (!content::AreAllSitesIsolatedForTesting()) {
-    // Sites are not isolated. No SubframeTasks are expected, just the above
-    // task.
-    ASSERT_EQ(1U, task_manager.tasks().size());
-  } else {
-    // Sites are isolated. We expect, in addition to the above task, two more
-    // SubframeTasks, one for b.com and another for c.com.
-    ASSERT_EQ(3U, task_manager.tasks().size());
-    const Task* subframe_task_1 = task_manager.tasks()[1];
-    const Task* subframe_task_2 = task_manager.tasks()[2];
-
-    EXPECT_EQ(Task::RENDERER, subframe_task_1->GetType());
-    EXPECT_EQ(Task::RENDERER, subframe_task_2->GetType());
-
-    EXPECT_TRUE(base::StartsWith(subframe_task_1->title(),
-                                 GetExpectedSubframeTitlePrefix(),
-                                 base::CompareCase::INSENSITIVE_ASCII));
-    EXPECT_TRUE(base::StartsWith(subframe_task_2->title(),
-                                 GetExpectedSubframeTitlePrefix(),
-                                 base::CompareCase::INSENSITIVE_ASCII));
-
-    // All tasks must be running on different processes.
-    EXPECT_NE(subframe_task_1->process_id(), subframe_task_2->process_id());
-    EXPECT_NE(subframe_task_1->process_id(), cross_site_task->process_id());
-    EXPECT_NE(subframe_task_2->process_id(), cross_site_task->process_id());
-  }
-
-  // If we navigate to the simple page on a.com which doesn't have cross-site
-  // iframes, we expect not to have any SubframeTasks.
-  NavigateTo(kSimplePageUrl);
-
-  ASSERT_EQ(1U, task_manager.tasks().size());
-  const Task* simple_page_task = task_manager.tasks().front();
-  EXPECT_EQ(Task::RENDERER, simple_page_task->GetType());
-  EXPECT_EQ(PrefixExpectedTabTitle("Title Of Awesomeness"),
-            simple_page_task->title());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.cc b/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.cc
deleted file mode 100644
index c233395..0000000
--- a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.cc
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/tab_contents_tag.h"
-
-namespace task_manager {
-
-TabContentsTask* TabContentsTag::CreateTask() const {
-  return new TabContentsTask(web_contents());
-}
-
-TabContentsTag::TabContentsTag(content::WebContents* web_contents)
-    : WebContentsTag(web_contents) {
-}
-
-TabContentsTag::~TabContentsTag() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.h b/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.h
deleted file mode 100644
index 5b0fd89..0000000
--- a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/tab_contents_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace task_manager {
-
-// Defines a concrete UserData type for WebContents owned by the TabStripModel.
-class TabContentsTag : public WebContentsTag {
- public:
-  // task_manager::WebContentsTag:
-  TabContentsTask* CreateTask() const override;
-
- private:
-  friend class WebContentsTags;
-
-  explicit TabContentsTag(content::WebContents* web_contents);
-  ~TabContentsTag() override;
-
-  DISALLOW_COPY_AND_ASSIGN(TabContentsTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag_browsertest.cc b/chrome/browser/task_manager/providers/web_contents/tab_contents_tag_browsertest.cc
deleted file mode 100644
index 08e35d4..0000000
--- a/chrome/browser/task_manager/providers/web_contents/tab_contents_tag_browsertest.cc
+++ /dev/null
@@ -1,319 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <stddef.h>
-
-#include "base/macros.h"
-#include "base/path_service.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/task_manager/mock_web_contents_task_manager.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "chrome/browser/ui/browser.h"
-#include "chrome/browser/ui/tabs/tab_strip_model.h"
-#include "chrome/common/chrome_paths.h"
-#include "chrome/grit/generated_resources.h"
-#include "chrome/test/base/in_process_browser_test.h"
-#include "chrome/test/base/ui_test_utils.h"
-#include "components/favicon/content/content_favicon_driver.h"
-#include "components/favicon/core/favicon_driver.h"
-#include "components/favicon/core/favicon_driver_observer.h"
-#include "content/public/browser/favicon_status.h"
-#include "content/public/browser/navigation_entry.h"
-#include "net/test/embedded_test_server/embedded_test_server.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/page_transition_types.h"
-#include "ui/base/resource/resource_bundle.h"
-#include "ui/gfx/codec/png_codec.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/image/image_unittest_util.h"
-#include "ui/resources/grit/ui_resources.h"
-
-namespace task_manager {
-
-namespace {
-
-// Defines a test page file path along with its expected task manager reported
-// values.
-struct TestPageData {
-  const char* page_file;
-  const char* title;
-  Task::Type task_type;
-  int expected_prefix_message;
-};
-
-// The below test files are available in src/chrome/test/data/
-// TODO(afakhry): Add more test pages here as needed (e.g. pages that are hosted
-// in the tabs as apps or extensions).
-const TestPageData kTestPages[] = {
-    {
-        "/title1.html",
-        "",
-        Task::RENDERER,
-        IDS_TASK_MANAGER_TAB_PREFIX
-    },
-    {
-        "/title2.html",
-        "Title Of Awesomeness",
-        Task::RENDERER,
-        IDS_TASK_MANAGER_TAB_PREFIX
-    },
-    {
-        "/title3.html",
-        "Title Of More Awesomeness",
-        Task::RENDERER,
-        IDS_TASK_MANAGER_TAB_PREFIX
-    },
-};
-
-const size_t kTestPagesLength = arraysize(kTestPages);
-
-// Blocks till the current page uses a specific icon URL.
-class FaviconWaiter : public favicon::FaviconDriverObserver {
- public:
-  explicit FaviconWaiter(favicon::ContentFaviconDriver* driver)
-      : driver_(driver) {
-    driver_->AddObserver(this);
-  }
-
-  void WaitForFaviconWithURL(const GURL& url) {
-    if (GetCurrentFaviconURL() == url) {
-      driver_->RemoveObserver(this);
-      return;
-    }
-
-    target_favicon_url_ = url;
-    base::RunLoop run_loop;
-    quit_closure_ = run_loop.QuitClosure();
-    run_loop.Run();
-  }
-
- private:
-  GURL GetCurrentFaviconURL() {
-    const content::NavigationController& controller =
-        driver_->web_contents()->GetController();
-    content::NavigationEntry* entry = controller.GetLastCommittedEntry();
-    return entry ? entry->GetFavicon().url : GURL();
-  }
-
-  void OnFaviconUpdated(favicon::FaviconDriver* favicon_driver,
-                        NotificationIconType notification_icon_type,
-                        const GURL& icon_url,
-                        bool icon_url_changed,
-                        const gfx::Image& image) override {
-    if (notification_icon_type == NON_TOUCH_16_DIP &&
-        icon_url == target_favicon_url_) {
-      driver_->RemoveObserver(this);
-
-      if (!quit_closure_.is_null())
-        quit_closure_.Run();
-    }
-  }
-
-  favicon::ContentFaviconDriver* driver_;
-  GURL target_favicon_url_;
-  base::Closure quit_closure_;
-
-  DISALLOW_COPY_AND_ASSIGN(FaviconWaiter);
-};
-
-}  // namespace
-
-// Defines a browser test class for testing the task manager tracking of tab
-// contents.
-class TabContentsTagTest : public InProcessBrowserTest {
- public:
-  TabContentsTagTest() { EXPECT_TRUE(embedded_test_server()->Start()); }
-  ~TabContentsTagTest() override {}
-
-  void AddNewTestTabAt(int index, const char* test_page_file) {
-    int tabs_count_before = tabs_count();
-    GURL url = GetUrlOfFile(test_page_file);
-    AddTabAtIndex(index, url, ui::PAGE_TRANSITION_TYPED);
-    EXPECT_EQ(++tabs_count_before, tabs_count());
-  }
-
-  void NavigateToUrl(const char* test_page_file) {
-    ui_test_utils::NavigateToURL(browser(), GetUrlOfFile(test_page_file));
-  }
-
-  void CloseTabAt(int index) {
-    browser()->tab_strip_model()->CloseWebContentsAt(index,
-                                                     TabStripModel::CLOSE_NONE);
-  }
-
-  base::string16 GetTestPageExpectedTitle(const TestPageData& page_data) const {
-    // Pages with no title should fall back to their URL.
-    base::string16 title = base::UTF8ToUTF16(page_data.title);
-    if (title.empty()) {
-      GURL url = GetUrlOfFile(page_data.page_file);
-      return GetDefaultTitleForUrl(url);
-    }
-    return l10n_util::GetStringFUTF16(page_data.expected_prefix_message, title);
-  }
-
-  // Returns the expected title for |url| if |url| does not specify a custom
-  // title (e.g. via the <title> tag).
-  base::string16 GetDefaultTitleForUrl(const GURL& url) const {
-    base::string16 title =
-        base::UTF8ToUTF16(url.host() + ":" + url.port() + url.path());
-    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX, title);
-  }
-
-  base::string16 GetAboutBlankExpectedTitle() const {
-    return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
-                                      base::UTF8ToUTF16("about:blank"));
-  }
-
-  int tabs_count() const { return browser()->tab_strip_model()->count(); }
-
-  const std::vector<WebContentsTag*>& tracked_tags() const {
-    return WebContentsTagsManager::GetInstance()->tracked_tags();
-  }
-
-  GURL GetUrlOfFile(const char* test_page_file) const {
-    return embedded_test_server()->GetURL(test_page_file);
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TabContentsTagTest);
-};
-
-// Tests that TabContentsTags are being recorded correctly by the
-// WebContentsTagsManager.
-IN_PROC_BROWSER_TEST_F(TabContentsTagTest, BasicTagsTracking) {
-  // Browser tests start with a single tab.
-  EXPECT_EQ(1, tabs_count());
-  EXPECT_EQ(1U, tracked_tags().size());
-
-  // Add a bunch of tabs and make sure we're tracking them.
-  AddNewTestTabAt(0, kTestPages[0].page_file);
-  EXPECT_EQ(2, tabs_count());
-  EXPECT_EQ(2U, tracked_tags().size());
-
-  AddNewTestTabAt(1, kTestPages[1].page_file);
-  EXPECT_EQ(3, tabs_count());
-  EXPECT_EQ(3U, tracked_tags().size());
-
-  // Navigating the selected tab doesn't change the number of tabs nor the
-  // number of tags.
-  NavigateToUrl(kTestPages[2].page_file);
-  EXPECT_EQ(3, tabs_count());
-  EXPECT_EQ(3U, tracked_tags().size());
-
-  // Close a bunch of tabs and make sure we can notice that.
-  CloseTabAt(0);
-  CloseTabAt(0);
-  EXPECT_EQ(1, tabs_count());
-  EXPECT_EQ(1U, tracked_tags().size());
-}
-
-// Tests that the pre-task-manager-existing tabs are given to the task manager
-// once it starts observing.
-IN_PROC_BROWSER_TEST_F(TabContentsTagTest, PreExistingTaskProviding) {
-  // We start with the "about:blank" tab.
-  EXPECT_EQ(1, tabs_count());
-  EXPECT_EQ(1U, tracked_tags().size());
-
-  // Add a bunch of tabs and make sure when the task manager is created and
-  // starts observing sees those pre-existing tabs.
-  AddNewTestTabAt(0, kTestPages[0].page_file);
-  EXPECT_EQ(2, tabs_count());
-  EXPECT_EQ(2U, tracked_tags().size());
-  AddNewTestTabAt(1, kTestPages[1].page_file);
-  EXPECT_EQ(3, tabs_count());
-  EXPECT_EQ(3U, tracked_tags().size());
-
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  task_manager.StartObserving();
-  EXPECT_EQ(3U, task_manager.tasks().size());
-}
-
-// Tests that the task manager sees the correct tabs with their correct
-// corresponding tasks data.
-IN_PROC_BROWSER_TEST_F(TabContentsTagTest, PostExistingTaskProviding) {
-  // We start with the "about:blank" tab.
-  EXPECT_EQ(1, tabs_count());
-  EXPECT_EQ(1U, tracked_tags().size());
-
-  MockWebContentsTaskManager task_manager;
-  EXPECT_TRUE(task_manager.tasks().empty());
-  task_manager.StartObserving();
-  ASSERT_EQ(1U, task_manager.tasks().size());
-
-  const Task* first_tab_task = task_manager.tasks().front();
-  EXPECT_EQ(Task::RENDERER, first_tab_task->GetType());
-  EXPECT_EQ(GetAboutBlankExpectedTitle(), first_tab_task->title());
-
-  // Add the test pages in order and test the provided tasks.
-  for (const auto& test_page_data : kTestPages) {
-    AddNewTestTabAt(0, test_page_data.page_file);
-
-    const Task* task = task_manager.tasks().back();
-    EXPECT_EQ(test_page_data.task_type, task->GetType());
-    EXPECT_EQ(GetTestPageExpectedTitle(test_page_data), task->title());
-  }
-
-  EXPECT_EQ(1 + kTestPagesLength, task_manager.tasks().size());
-
-  // Close the last tab that was added. Make sure it doesn't show up in the
-  // task manager.
-  CloseTabAt(0);
-  EXPECT_EQ(kTestPagesLength, task_manager.tasks().size());
-  const base::string16 closed_tab_title =
-      GetTestPageExpectedTitle(kTestPages[kTestPagesLength - 1]);
-  for (const auto* task : task_manager.tasks())
-    EXPECT_NE(closed_tab_title, task->title());
-}
-
-// Test that the default favicon is shown in the task manager after navigating
-// from a page with a favicon to a page without a favicon. crbug.com/528924
-IN_PROC_BROWSER_TEST_F(TabContentsTagTest, NavigateToPageNoFavicon) {
-  // We start with the "about:blank" tab.
-  MockWebContentsTaskManager task_manager;
-  task_manager.StartObserving();
-  ASSERT_EQ(1, tabs_count());
-  ASSERT_EQ(1U, tracked_tags().size());
-
-  // Navigate to a page with a favicon.
-  GURL favicon_page_url = GetUrlOfFile("/favicon/page_with_favicon.html");
-  ui_test_utils::NavigateToURL(browser(), favicon_page_url);
-  ASSERT_GE(1U, task_manager.tasks().size());
-  Task* task = task_manager.tasks().back();
-  ASSERT_EQ(GetDefaultTitleForUrl(favicon_page_url), task->title());
-
-  // Wait for the browser to download the favicon.
-  favicon::ContentFaviconDriver* favicon_driver =
-      favicon::ContentFaviconDriver::FromWebContents(
-          browser()->tab_strip_model()->GetActiveWebContents());
-  FaviconWaiter waiter(favicon_driver);
-  waiter.WaitForFaviconWithURL(GetUrlOfFile("/favicon/icon.png"));
-
-  // Check that the task manager uses the specified favicon for the page.
-  base::FilePath test_dir;
-  PathService::Get(chrome::DIR_TEST_DATA, &test_dir);
-  std::string favicon_string;
-  base::ReadFileToString(
-      test_dir.AppendASCII("favicon").AppendASCII("icon.png"), &favicon_string);
-  SkBitmap favicon_bitmap;
-  gfx::PNGCodec::Decode(
-      reinterpret_cast<const unsigned char*>(favicon_string.data()),
-      favicon_string.length(), &favicon_bitmap);
-  ASSERT_TRUE(
-      gfx::test::AreBitmapsEqual(favicon_bitmap, *task->icon().bitmap()));
-
-  // Navigate to a page without a favicon.
-  GURL no_favicon_page_url = GetUrlOfFile("/title1.html");
-  ui_test_utils::NavigateToURL(browser(), no_favicon_page_url);
-  ASSERT_EQ(GetDefaultTitleForUrl(no_favicon_page_url), task->title());
-
-  // Check that the task manager uses the default favicon for the page.
-  gfx::Image default_favicon_image =
-      ResourceBundle::GetSharedInstance().GetNativeImageNamed(
-          IDR_DEFAULT_FAVICON);
-  EXPECT_TRUE(gfx::test::AreImagesEqual(default_favicon_image,
-                                        gfx::Image(task->icon())));
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/tab_contents_task.cc b/chrome/browser/task_manager/providers/web_contents/tab_contents_task.cc
deleted file mode 100644
index 098200d..0000000
--- a/chrome/browser/task_manager/providers/web_contents/tab_contents_task.cc
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/tab_contents_task.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/profiles/profile.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/browser/process_map.h"
-#include "extensions/common/constants.h"
-
-namespace task_manager {
-
-namespace {
-
-bool HostsExtension(content::WebContents* web_contents) {
-  DCHECK(web_contents);
-  return web_contents->GetURL().SchemeIs(extensions::kExtensionScheme);
-}
-
-}  // namespace
-
-
-TabContentsTask::TabContentsTask(content::WebContents* web_contents)
-    : RendererTask(base::string16(),
-                   RendererTask::GetFaviconFromWebContents(web_contents),
-                   web_contents,
-                   web_contents->GetRenderProcessHost()) {
-  set_title(GetCurrentTitle());
-}
-
-TabContentsTask::~TabContentsTask() {
-}
-
-void TabContentsTask::UpdateTitle() {
-  set_title(GetCurrentTitle());
-}
-
-void TabContentsTask::UpdateFavicon() {
-  const gfx::ImageSkia* icon =
-      RendererTask::GetFaviconFromWebContents(web_contents());
-  set_icon(icon ? *icon : gfx::ImageSkia());
-}
-
-Task::Type TabContentsTask::GetType() const {
-  // A tab that loads an extension URL is considered to be an extension even
-  // though it's tracked as a TabContentsTask.
-  return HostsExtension(web_contents()) ? Task::EXTENSION : Task::RENDERER;
-}
-
-base::string16 TabContentsTask::GetCurrentTitle() const {
-  // Check if the URL is an app and if the tab is hoisting an extension.
-  Profile* profile =
-      Profile::FromBrowserContext(web_contents()->GetBrowserContext());
-  extensions::ProcessMap* process_map = extensions::ProcessMap::Get(profile);
-  extensions::ExtensionRegistry* extension_registry =
-      extensions::ExtensionRegistry::Get(profile);
-  GURL url = web_contents()->GetURL();
-
-  bool is_app = process_map->Contains(GetChildProcessUniqueID()) &&
-      extension_registry->enabled_extensions().GetAppByURL(url) != nullptr;
-  bool is_extension = HostsExtension(web_contents());
-  bool is_incognito = profile->IsOffTheRecord();
-
-  base::string16 tab_title =
-      RendererTask::GetTitleFromWebContents(web_contents());
-
-  // Fall back to the URL if the title is empty.
-  return PrefixRendererTitle(tab_title,
-                             is_app,
-                             is_extension,
-                             is_incognito,
-                             false);  // is_background.
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/tab_contents_task.h b/chrome/browser/task_manager/providers/web_contents/tab_contents_task.h
deleted file mode 100644
index 753760e..0000000
--- a/chrome/browser/task_manager/providers/web_contents/tab_contents_task.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/renderer_task.h"
-
-namespace task_manager {
-
-// Defines a task manager representation of WebContents owned by the
-// TabStripModel.
-class TabContentsTask : public RendererTask {
- public:
-  explicit TabContentsTask(content::WebContents* web_contents);
-  ~TabContentsTask() override;
-
-  // task_manager::RendererTask:
-  void UpdateTitle() override;
-  void UpdateFavicon() override;
-  Type GetType() const override;
-
- private:
-  base::string16 GetCurrentTitle() const;
-
-  DISALLOW_COPY_AND_ASSIGN(TabContentsTask);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_TAB_CONTENTS_TASK_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_tag.cc b/chrome/browser/task_manager/providers/web_contents/web_contents_tag.cc
deleted file mode 100644
index 432ccc8..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_tag.cc
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "content/public/browser/web_contents.h"
-
-namespace task_manager {
-
-// static
-const WebContentsTag* WebContentsTag::FromWebContents(
-    const content::WebContents* contents) {
-  DCHECK(contents);
-  return static_cast<const WebContentsTag*>(contents->GetUserData(kTagKey));
-}
-
-WebContentsTag::WebContentsTag(content::WebContents* contents)
-    : web_contents_(contents) {
-  DCHECK(contents);
-  // You can't tag the |contents| here. The object creation is not complete yet.
-  // This will be done in the factory methods inside
-  // |task_manager::WebContentsTags|.
-}
-
-WebContentsTag::~WebContentsTag() {
-  WebContentsTagsManager::GetInstance()->RemoveTag(this);
-}
-
-// static
-void* WebContentsTag::kTagKey = &WebContentsTag::kTagKey;
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_tag.h b/chrome/browser/task_manager/providers/web_contents/web_contents_tag.h
deleted file mode 100644
index 713c201..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_tag.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
-
-#include "base/macros.h"
-#include "base/supports_user_data.h"
-
-namespace content {
-class WebContents;
-}  // namespace content
-
-namespace task_manager {
-
-class RendererTask;
-
-// Defines a TaskManager-specific UserData type for WebContents. This is an
-// abstract base class for all concrete UserData types. They all share the same
-// key. We have a concrete type for each WebContents owning service that the
-// task manager is interested in tracking.
-//
-// To instantiate a |WebContentsTag|, use the factory functions in
-// |task_manager::WebContentsTags|.
-class WebContentsTag : public base::SupportsUserData::Data {
- public:
-  // Retrieves the instance of the WebContentsTag that was attached to the
-  // specified WebContents and returns it. If no instance was attached, returns
-  // nullptr.
-  static const WebContentsTag* FromWebContents(
-      const content::WebContents* contents);
-
-  // The concrete Tags know how to instantiate a |RendererTask| that corresponds
-  // to the owning WebContents and Service. This will be used by the
-  // WebContentsTaskProvider to create the appropriate Tasks.
-  //
-  // The returned |RendererTask| is owned by the caller (in this case it will be
-  // the provider).
-  virtual RendererTask* CreateTask() const = 0;
-
-  content::WebContents* web_contents() const { return web_contents_; }
-
- protected:
-  friend class WebContentsTags;
-
-  explicit WebContentsTag(content::WebContents* contents);
-  ~WebContentsTag() override;
-
- private:
-  // The user data key.
-  static void* kTagKey;
-
-  // The owning WebContents.
-  content::WebContents* web_contents_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsTag);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAG_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.cc b/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.cc
deleted file mode 100644
index 80c1f4c..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.cc
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-
-#include <algorithm>
-
-#include "base/memory/singleton.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h"
-
-namespace task_manager {
-
-// static
-WebContentsTagsManager* WebContentsTagsManager::GetInstance() {
-  return base::Singleton<WebContentsTagsManager>::get();
-}
-
-void WebContentsTagsManager::AddTag(WebContentsTag* tag) {
-  DCHECK(tag);
-  tracked_tags_.push_back(tag);
-
-  if (provider_)
-    provider_->OnWebContentsTagCreated(tag);
-}
-
-void WebContentsTagsManager::RemoveTag(WebContentsTag* tag) {
-  DCHECK(tag);
-  tracked_tags_.erase(std::find(tracked_tags_.begin(),
-                                tracked_tags_.end(),
-                                tag));
-
-  // No need to inform the provider here. The provider will create an entry
-  // for each WebContents it's tracking which is a WebContentsObserver and
-  // can be used to track the lifetime of the WebContents.
-
-  // We must however make sure that the provider has already forgotten about the
-  // tag and its associated web_contents.
-  if (provider_)
-    CHECK(!provider_->HasWebContents(tag->web_contents()));
-}
-
-void WebContentsTagsManager::SetProvider(WebContentsTaskProvider* provider) {
-  DCHECK(provider);
-  DCHECK(!provider_);
-  provider_ = provider;
-}
-
-void WebContentsTagsManager::ClearProvider() {
-  DCHECK(provider_);
-  provider_ = nullptr;
-}
-
-void WebContentsTagsManager::ClearFromProvider(const WebContentsTag* tag) {
-  if (provider_)
-    provider_->OnWebContentsTagRemoved(tag);
-}
-
-WebContentsTagsManager::WebContentsTagsManager()
-    : provider_(nullptr) {
-}
-
-WebContentsTagsManager::~WebContentsTagsManager() {
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h b/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h
deleted file mode 100644
index 3300b3e..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
-
-#include <vector>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tag.h"
-
-namespace base {
-template<typename T>
-struct DefaultSingletonTraits;
-}  // namespace base
-
-namespace task_manager {
-
-class WebContentsTaskProvider;
-
-// Defines a manager to track the various TaskManager-specific WebContents
-// UserData (task_manager::WebContentsTags). This is used by the
-// WebContentsTaskProvider to get all the pre-existing WebContents once
-// WebContentsTaskProvider::StartUpdating() is called.
-class WebContentsTagsManager {
- public:
-  static WebContentsTagsManager* GetInstance();
-
-  void AddTag(WebContentsTag* tag);
-  void RemoveTag(WebContentsTag* tag);
-
-  // This is how the WebContentsTaskProvider starts and stops observing the
-  // creation of WebContents.
-  // There must be no or only one given provider at any given time.
-  void SetProvider(WebContentsTaskProvider* provider);
-  void ClearProvider();
-
-  // This is called by WebContentsTags::ClearTag(). This is needed for Tags
-  // whose destruction does not correspond to the destruction of their
-  // WebContents. In this case the provider (if any) must be manually cleared,
-  // or else the corresponding task for the |tag| will continue to exist.
-  void ClearFromProvider(const WebContentsTag* tag);
-
-  const std::vector<WebContentsTag*>& tracked_tags() const {
-    return tracked_tags_;
-  }
-
- private:
-  friend struct base::DefaultSingletonTraits<WebContentsTagsManager>;
-
-  WebContentsTagsManager();
-  ~WebContentsTagsManager();
-
-  // The provider that's currently observing the creation of WebContents.
-  WebContentsTaskProvider* provider_;
-
-  // A set of all the WebContentsTags seen so far.
-  std::vector<WebContentsTag*> tracked_tags_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsTagsManager);
-};
-
-}  // namespace task_manager
-
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TAGS_MANAGER_H_
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.cc b/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.cc
deleted file mode 100644
index e708be3..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.cc
+++ /dev/null
@@ -1,385 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h"
-
-#include "base/bind.h"
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/web_contents/subframe_task.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/web_contents_observer.h"
-
-using content::RenderFrameHost;
-using content::RenderWidgetHost;
-using content::SiteInstance;
-using content::WebContents;
-
-namespace task_manager {
-
-// Defines an entry for each WebContents that will be tracked by the provider.
-// The entry is used to observe certain events in its corresponding WebContents
-// and then it notifies the provider or the render task (representing the
-// WebContents) of these events.
-// The entry owns the created tasks representing the WebContents, and it is
-// itself owned by the provider.
-class WebContentsEntry : public content::WebContentsObserver {
- public:
-  WebContentsEntry(content::WebContents* web_contents,
-                   WebContentsTaskProvider* provider);
-  ~WebContentsEntry() override;
-
-  // Creates all the tasks associated with each |RenderFrameHost| in this
-  // entry's WebContents.
-  void CreateAllTasks();
-
-  // Clears all the tasks in this entry. The provider's observer will be
-  // notified if |notify_observer| is true.
-  void ClearAllTasks(bool notify_observer);
-
-  // Returns the |RendererTask| that corresponds to the given
-  // |render_frame_host| or |nullptr| if the given frame is not tracked by this
-  // entry.
-  RendererTask* GetTaskForFrame(RenderFrameHost* render_frame_host) const;
-
-  // content::WebContentsObserver:
-  void RenderFrameDeleted(RenderFrameHost* render_frame_host) override;
-  void RenderFrameHostChanged(RenderFrameHost* old_host,
-                              RenderFrameHost* new_host) override;
-  void RenderViewReady() override;
-  void WebContentsDestroyed() override;
-  void RenderProcessGone(base::TerminationStatus status) override;
-  void OnRendererUnresponsive(RenderWidgetHost* render_widget_host) override;
-  void DidFinishNavigation(
-      content::NavigationHandle* navigation_handle) override;
-  void TitleWasSet(content::NavigationEntry* entry, bool explicit_set) override;
-
- private:
-  // Defines a callback for WebContents::ForEachFrame() to create a
-  // corresponding task for the given |render_frame_host| and notifying the
-  // provider's observer of the new task.
-  void CreateTaskForFrame(RenderFrameHost* render_frame_host);
-
-  // Clears the task that corresponds to the given |render_frame_host| and
-  // notifies the provider's observer of the tasks removal.
-  void ClearTaskForFrame(RenderFrameHost* render_frame_host);
-
-  // The provider that owns this entry.
-  WebContentsTaskProvider* provider_;
-
-  // The RenderFrameHosts associated with this entry's WebContents that we're
-  // tracking mapped by their SiteInstances.
-  using FramesList = std::vector<RenderFrameHost*>;
-  using SiteInstanceToFramesMap = std::map<SiteInstance*, FramesList>;
-  SiteInstanceToFramesMap frames_by_site_instance_;
-
-  // The RendererTasks that we create for the task manager, mapped by their
-  // RenderFrameHosts.
-  using FramesToTasksMap = std::map<RenderFrameHost*, RendererTask*>;
-  FramesToTasksMap tasks_by_frames_;
-
-  // States whether we did record a main frame for this entry.
-  SiteInstance* main_frame_site_instance_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsEntry);
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-WebContentsEntry::WebContentsEntry(content::WebContents* web_contents,
-                                   WebContentsTaskProvider* provider)
-    : WebContentsObserver(web_contents),
-      provider_(provider),
-      main_frame_site_instance_(nullptr) {
-}
-
-WebContentsEntry::~WebContentsEntry() {
-  ClearAllTasks(false);
-}
-
-void WebContentsEntry::CreateAllTasks() {
-  DCHECK(web_contents()->GetMainFrame());
-  web_contents()->ForEachFrame(base::Bind(&WebContentsEntry::CreateTaskForFrame,
-                                          base::Unretained(this)));
-}
-
-void WebContentsEntry::ClearAllTasks(bool notify_observer) {
-  for (const auto& pair : frames_by_site_instance_) {
-    const FramesList& frames_list = pair.second;
-    DCHECK(!frames_list.empty());
-    RendererTask* task = tasks_by_frames_[frames_list[0]];
-
-    task->set_termination_status(web_contents()->GetCrashedStatus());
-    task->set_termination_error_code(web_contents()->GetCrashedErrorCode());
-
-    if (notify_observer)
-      provider_->NotifyObserverTaskRemoved(task);
-    delete task;
-  }
-
-  frames_by_site_instance_.clear();
-  tasks_by_frames_.clear();
-  main_frame_site_instance_ = nullptr;
-}
-
-RendererTask* WebContentsEntry::GetTaskForFrame(
-    RenderFrameHost* render_frame_host) const {
-  auto itr = tasks_by_frames_.find(render_frame_host);
-  if (itr == tasks_by_frames_.end())
-    return nullptr;
-
-  return itr->second;
-}
-
-void WebContentsEntry::RenderFrameDeleted(RenderFrameHost* render_frame_host) {
-  ClearTaskForFrame(render_frame_host);
-}
-
-void WebContentsEntry::RenderFrameHostChanged(RenderFrameHost* old_host,
-                                              RenderFrameHost* new_host) {
-  ClearTaskForFrame(old_host);
-  CreateTaskForFrame(new_host);
-}
-
-void WebContentsEntry::RenderViewReady() {
-  ClearAllTasks(true);
-  CreateAllTasks();
-}
-
-void WebContentsEntry::WebContentsDestroyed() {
-  ClearAllTasks(true);
-  provider_->DeleteEntry(web_contents());
-}
-
-void WebContentsEntry::RenderProcessGone(base::TerminationStatus status) {
-  ClearAllTasks(true);
-}
-
-void WebContentsEntry::OnRendererUnresponsive(
-    RenderWidgetHost* render_widget_host) {
-  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
-  if (!task)
-    return;
-
-  DCHECK_EQ(render_widget_host->GetProcess(),
-            web_contents()->GetMainFrame()->GetProcess());
-
-  provider_->NotifyObserverTaskUnresponsive(task);
-}
-
-void WebContentsEntry::DidFinishNavigation(
-    content::NavigationHandle* navigation_handle) {
-  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
-  if (!task)
-    return;
-
-  // Listening to WebContentsObserver::TitleWasSet() only is not enough in
-  // some cases when the the webpage doesn't have a title. That's why we update
-  // the title here as well.
-  task->UpdateTitle();
-
-  // Call RendererTask::UpdateFavicon() to set the current favicon to the
-  // default favicon. If the page has a non-default favicon,
-  // RendererTask::OnFaviconUpdated() will update the current favicon once
-  // FaviconDriver figures out the correct favicon for the page.
-  task->UpdateFavicon();
-  task->UpdateRapporSampleName();
-}
-
-void WebContentsEntry::TitleWasSet(content::NavigationEntry* entry,
-                                   bool explicit_set) {
-  RendererTask* task = GetTaskForFrame(web_contents()->GetMainFrame());
-  if (!task)
-    return;
-
-  task->UpdateTitle();
-  task->UpdateFavicon();
-}
-
-void WebContentsEntry::CreateTaskForFrame(RenderFrameHost* render_frame_host) {
-  DCHECK(!tasks_by_frames_.count(render_frame_host));
-
-  content::SiteInstance* site_instance = render_frame_host->GetSiteInstance();
-  if (!site_instance->GetProcess()->HasConnection())
-    return;
-
-  bool site_instance_exists =
-      frames_by_site_instance_.count(site_instance) != 0;
-  bool is_main_frame = (render_frame_host == web_contents()->GetMainFrame());
-  bool site_instance_is_main = (site_instance == main_frame_site_instance_);
-
-  RendererTask* new_task = nullptr;
-  // We don't create a task if there's one for this site_instance AND
-  // if this is not the main frame or we did record a main frame for the entry.
-  if (!site_instance_exists || (is_main_frame && !site_instance_is_main)) {
-    if (is_main_frame) {
-      const WebContentsTag* tag =
-          WebContentsTag::FromWebContents(web_contents());
-      new_task = tag->CreateTask();
-      main_frame_site_instance_ = site_instance;
-    } else {
-      new_task =
-          new SubframeTask(render_frame_host, web_contents(),
-                           GetTaskForFrame(web_contents()->GetMainFrame()));
-    }
-  }
-
-  if (site_instance_exists) {
-    // One of the existing frame hosts for this site instance.
-    FramesList& existing_frames_for_site_instance =
-        frames_by_site_instance_[site_instance];
-    RenderFrameHost* existing_rfh = existing_frames_for_site_instance[0];
-    RendererTask* old_task = tasks_by_frames_[existing_rfh];
-
-    if (!new_task) {
-      // We didn't create any new task, so we keep appending the old one.
-      tasks_by_frames_[render_frame_host] = old_task;
-    } else {
-      // Overwrite all the existing old tasks with the new one, and delete the
-      // old one.
-      for (RenderFrameHost* frame : existing_frames_for_site_instance)
-        tasks_by_frames_[frame] = new_task;
-
-      provider_->NotifyObserverTaskRemoved(old_task);
-      delete old_task;
-    }
-  }
-
-  frames_by_site_instance_[site_instance].push_back(render_frame_host);
-
-  if (new_task) {
-    tasks_by_frames_[render_frame_host] = new_task;
-    provider_->NotifyObserverTaskAdded(new_task);
-  }
-}
-
-void WebContentsEntry::ClearTaskForFrame(RenderFrameHost* render_frame_host) {
-  auto itr = tasks_by_frames_.find(render_frame_host);
-  if (itr == tasks_by_frames_.end())
-    return;
-
-  RendererTask* task = itr->second;
-  tasks_by_frames_.erase(itr);
-  content::SiteInstance* site_instance = render_frame_host->GetSiteInstance();
-  FramesList& frames = frames_by_site_instance_[site_instance];
-  frames.erase(std::find(frames.begin(), frames.end(), render_frame_host));
-
-  if (frames.empty()) {
-    frames_by_site_instance_.erase(site_instance);
-    provider_->NotifyObserverTaskRemoved(task);
-    delete task;
-
-    if (site_instance == main_frame_site_instance_)
-      main_frame_site_instance_ = nullptr;
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-WebContentsTaskProvider::WebContentsTaskProvider()
-    : is_updating_(false) {
-}
-
-WebContentsTaskProvider::~WebContentsTaskProvider() {
-  if (is_updating_) {
-    StopUpdating();
-  }
-}
-
-void WebContentsTaskProvider::OnWebContentsTagCreated(
-    const WebContentsTag* tag) {
-  DCHECK(tag);
-  content::WebContents* web_contents = tag->web_contents();
-  DCHECK(web_contents);
-
-  // TODO(afakhry): Check if we need this check. It seems that we no longer
-  // need it in the new implementation.
-  std::unique_ptr<WebContentsEntry>& entry = entries_map_[web_contents];
-  if (entry) {
-    // This case may happen if we added a WebContents while collecting all the
-    // pre-existing ones at the time |StartUpdating()| was called, but the
-    // notification of its connection hasn't been fired yet. In this case we
-    // ignore it since we're already tracking it.
-    return;
-  }
-
-  entry.reset(new WebContentsEntry(web_contents, this));
-  entry->CreateAllTasks();
-}
-
-void WebContentsTaskProvider::OnWebContentsTagRemoved(
-    const WebContentsTag* tag) {
-  DCHECK(tag);
-  content::WebContents* web_contents = tag->web_contents();
-  DCHECK(web_contents);
-
-  auto itr = entries_map_.find(web_contents);
-  DCHECK(itr != entries_map_.end());
-
-  // Must manually clear the tasks and notify the observer.
-  itr->second->ClearAllTasks(true);
-  entries_map_.erase(itr);  // Deletes the WebContentsEntry.
-}
-
-Task* WebContentsTaskProvider::GetTaskOfUrlRequest(int origin_pid,
-                                                   int child_id,
-                                                   int route_id) {
-  // If an origin PID was specified then the URL request originated in a plugin
-  // working on the WebContents' behalf, so ignore it.
-  if (origin_pid)
-    return nullptr;
-
-  content::RenderFrameHost* rfh =
-      content::RenderFrameHost::FromID(child_id, route_id);
-  content::WebContents* web_contents =
-      content::WebContents::FromRenderFrameHost(rfh);
-
-  auto itr = entries_map_.find(web_contents);
-  if (itr == entries_map_.end()) {
-    // Can happen if the tab was closed while a network request was being
-    // performed.
-    return nullptr;
-  }
-
-  return itr->second->GetTaskForFrame(rfh);
-}
-
-bool WebContentsTaskProvider::HasWebContents(
-    content::WebContents* web_contents) const {
-  return entries_map_.count(web_contents) != 0;
-}
-
-void WebContentsTaskProvider::StartUpdating() {
-  is_updating_ = true;
-
-  // 1- Collect all pre-existing WebContents from the WebContentsTagsManager.
-  WebContentsTagsManager* tags_manager = WebContentsTagsManager::GetInstance();
-  for (const auto* tag : tags_manager->tracked_tags())
-    OnWebContentsTagCreated(tag);
-
-  // 2- Start observing newly connected ones.
-  tags_manager->SetProvider(this);
-}
-
-void WebContentsTaskProvider::StopUpdating() {
-  is_updating_ = false;
-
-  // 1- Stop observing.
-  WebContentsTagsManager::GetInstance()->ClearProvider();
-
-  // 2- Clear storage.
-  entries_map_.clear();
-}
-
-void WebContentsTaskProvider::DeleteEntry(content::WebContents* web_contents) {
-  // This erase() will delete the WebContentsEntry, which is actually our
-  // caller, but it's expecting us to delete it.
-  bool success = entries_map_.erase(web_contents) != 0;
-  DCHECK(success);
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h b/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h
deleted file mode 100644
index de74d3a..0000000
--- a/chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
-#define CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
-
-#include <map>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/providers/task_provider.h"
-
-namespace content {
-class WebContents;
-}  // namespace content
-
-namespace task_manager {
-
-class WebContentsEntry;
-class WebContentsTag;
-
-// Defines a provider to provide the renderer tasks that are associated with
-// various |WebContents| from various services.
-// There should be no or only one instance of this class at any time.
-class WebContentsTaskProvider : public TaskProvider {
- public:
-  WebContentsTaskProvider();
-  ~WebContentsTaskProvider() override;
-
-  // This will be called every time we're notified that a new |WebContentsTag|
-  // has been created.
-  void OnWebContentsTagCreated(const WebContentsTag* tag);
-
-  // Manually remove |tag|'s corresponding Task.
-  void OnWebContentsTagRemoved(const WebContentsTag* tag);
-
-  // task_manager::TaskProvider:
-  Task* GetTaskOfUrlRequest(int origin_pid,
-                            int child_id,
-                            int route_id) override;
-
-  // Checks if the given |web_contents| is tracked by the provider.
-  bool HasWebContents(content::WebContents* web_contents) const;
-
- private:
-  friend class WebContentsEntry;
-
-  // task_manager::TaskProvider:
-  void StartUpdating() override;
-  void StopUpdating() override;
-
-  // Called when the given |web_contents| are destroyed so that we can delete
-  // its associated entry.
-  void DeleteEntry(content::WebContents* web_contents);
-
-  // A map to associate a |WebContents| with its corresponding entry that we
-  // create for it to be able to track it.
-  std::map<content::WebContents*, std::unique_ptr<WebContentsEntry>>
-      entries_map_;
-
-  // True if this provider is listening to WebContentsTags and updating its
-  // observers, false otherwise.
-  bool is_updating_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsTaskProvider);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_PROVIDERS_WEB_CONTENTS_WEB_CONTENTS_TASK_PROVIDER_H_
diff --git a/chrome/browser/task_manager/sampling/shared_sampler.h b/chrome/browser/task_manager/sampling/shared_sampler.h
deleted file mode 100644
index 004061a..0000000
--- a/chrome/browser/task_manager/sampling/shared_sampler.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_SAMPLING_SHARED_SAMPLER_H_
-#define CHROME_BROWSER_TASK_MANAGER_SAMPLING_SHARED_SAMPLER_H_
-
-#include <map>
-#include <memory>
-#include <utility>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/memory/ref_counted.h"
-#include "base/process/process_handle.h"
-#include "base/sequence_checker.h"
-#include "base/sequenced_task_runner.h"
-#include "build/build_config.h"
-
-namespace task_manager {
-
-struct ProcessDataSnapshot;
-
-// Defines sampler that will calculate resources for all processes all at once,
-// on the worker thread. Created by TaskManagerImpl on the UI thread, but used
-// mainly on a blocking pool thread.
-//
-// This exists because on Windows it is much faster to collect a group of
-// process metrics for all processes all at once using NtQuerySystemInformation
-// than to query the same data for for each process individually and because
-// some types like Idle Wakeups can only be collected this way.
-class SharedSampler : public base::RefCountedThreadSafe<SharedSampler> {
- public:
-  explicit SharedSampler(
-      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner);
-
-  // Below are the types of callbacks that are invoked on the UI thread
-  // when the refresh is done on the worker thread.
-  // These callbacks are passed via RegisterCallbacks.
-  using OnIdleWakeupsCallback = base::Callback<void(int)>;
-
-  // Returns a combination of refresh flags supported by the shared sampler.
-  int64_t GetSupportedFlags() const;
-
-  // Registers task group specific callbacks.
-  void RegisterCallbacks(base::ProcessId process_id,
-                         const OnIdleWakeupsCallback& on_idle_wakeups);
-
-  // Unregisters task group specific callbacks.
-  void UnregisterCallbacks(base::ProcessId process_id);
-
-  // Refreshes the expensive process' stats (for now only idle wakeups per
-  // second) on the worker thread.
-  void Refresh(base::ProcessId process_id, int64_t refresh_flags);
-
- private:
-  friend class base::RefCountedThreadSafe<SharedSampler>;
-  ~SharedSampler();
-
-#if defined(OS_WIN)
-  // The UI-thread callbacks in TaskGroup registered with RegisterCallbacks and
-  // to be called when refresh on the worker thread is done.
-  struct Callbacks {
-    Callbacks();
-    Callbacks(Callbacks&& other);
-    ~Callbacks();
-
-    OnIdleWakeupsCallback on_idle_wakeups;
-
-   private:
-    DISALLOW_COPY_AND_ASSIGN(Callbacks);
-  };
-
-  typedef std::map<base::ProcessId, Callbacks> CallbacksMap;
-
-  // Contains all results of refresh for a single process.
-  struct RefreshResult {
-    base::ProcessId process_id;
-    int idle_wakeups_per_second;
-  };
-
-  typedef std::vector<RefreshResult> RefreshResults;
-
-  // Posted on the worker thread to do the actual refresh.
-  std::unique_ptr<RefreshResults> RefreshOnWorkerThread();
-
-  // Called on UI thread when the refresh is done.
-  void OnRefreshDone(std::unique_ptr<RefreshResults> refresh_results);
-
-  // Clear cached data.
-  void ClearState();
-
-  // Used to filter process information.
-  static std::vector<base::FilePath> GetSupportedImageNames();
-  bool IsSupportedImageName(base::FilePath::StringPieceType image_name) const;
-
-  // Captures a snapshot of data for all chrome processes.
-  // Runs on the worker thread.
-  std::unique_ptr<ProcessDataSnapshot> CaptureSnapshot();
-
-  // Produce refresh results by diffing two snapshots.
-  static void MakeResultsFromTwoSnapshots(
-      const ProcessDataSnapshot& prev_snapshot,
-      const ProcessDataSnapshot& snapshot,
-      RefreshResults* results);
-
-  // Produce refresh results from one snapshot.
-  // This is used only the first time when only one snapshot is available.
-  static void MakeResultsFromSnapshot(
-      const ProcessDataSnapshot& snapshot,
-      RefreshResults* results);
-
-  // Accumulates callbacks passed from TaskGroup objects passed via
-  // RegisterCallbacks calls.
-  CallbacksMap callbacks_map_;
-
-  // Refresh flags passed via Refresh.
-  int64_t refresh_flags_;
-
-  // Snapshot of previously captured resources used to calculate the delta.
-  std::unique_ptr<ProcessDataSnapshot> previous_snapshot_;
-
-  // Size of the buffer previously used to query system information.
-  size_t previous_buffer_size_;
-
-  // Image names that CaptureSnapshot uses to filter processes.
-  const std::vector<base::FilePath> supported_image_names_;
-
-  // The specific blocking pool SequencedTaskRunner that will be used to post
-  // the refresh tasks onto serially.
-  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
-
-  // To assert we're running on the correct thread.
-  base::SequenceChecker worker_pool_sequenced_checker_;
-#endif  // defined(OS_WIN)
-
-  DISALLOW_COPY_AND_ASSIGN(SharedSampler);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_SAMPLING_SHARED_SAMPLER_H_
diff --git a/chrome/browser/task_manager/sampling/shared_sampler_posix.cc b/chrome/browser/task_manager/sampling/shared_sampler_posix.cc
deleted file mode 100644
index 57d8988..0000000
--- a/chrome/browser/task_manager/sampling/shared_sampler_posix.cc
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/shared_sampler.h"
-
-#include "content/public/browser/browser_thread.h"
-
-namespace task_manager {
-
-SharedSampler::SharedSampler(
-    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner) {}
-
-SharedSampler::~SharedSampler() {}
-
-int64_t SharedSampler::GetSupportedFlags() const { return 0; }
-
-void SharedSampler::RegisterCallbacks(
-    base::ProcessId process_id,
-    const OnIdleWakeupsCallback& on_idle_wakeups) {}
-
-void SharedSampler::UnregisterCallbacks(base::ProcessId process_id) {}
-
-void SharedSampler::Refresh(base::ProcessId process_id,
-                             int64_t refresh_flags) {}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/shared_sampler_win.cc b/chrome/browser/task_manager/sampling/shared_sampler_win.cc
deleted file mode 100644
index 8a3e01d..0000000
--- a/chrome/browser/task_manager/sampling/shared_sampler_win.cc
+++ /dev/null
@@ -1,618 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/shared_sampler.h"
-
-#include <windows.h>
-#include <winternl.h>
-
-#include <algorithm>
-
-#include "base/bind.h"
-#include "base/command_line.h"
-#include "base/path_service.h"
-#include "base/time/time.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "chrome/common/chrome_constants.h"
-#include "content/public/browser/browser_thread.h"
-
-namespace task_manager {
-
-namespace {
-
-// From <wdm.h>
-typedef LONG KPRIORITY;
-typedef LONG KWAIT_REASON;  // Full definition is in wdm.h
-
-// From ntddk.h
-typedef struct _VM_COUNTERS {
-  SIZE_T PeakVirtualSize;
-  SIZE_T VirtualSize;
-  ULONG PageFaultCount;
-  // Padding here in 64-bit
-  SIZE_T PeakWorkingSetSize;
-  SIZE_T WorkingSetSize;
-  SIZE_T QuotaPeakPagedPoolUsage;
-  SIZE_T QuotaPagedPoolUsage;
-  SIZE_T QuotaPeakNonPagedPoolUsage;
-  SIZE_T QuotaNonPagedPoolUsage;
-  SIZE_T PagefileUsage;
-  SIZE_T PeakPagefileUsage;
-} VM_COUNTERS;
-
-// Two possibilities available from here:
-// http://stackoverflow.com/questions/28858849/where-is-system-information-class-defined
-
-typedef enum _SYSTEM_INFORMATION_CLASS {
-  SystemProcessInformation = 5,  // This is the number that we need.
-} SYSTEM_INFORMATION_CLASS;
-
-// https://msdn.microsoft.com/en-us/library/gg750647.aspx?f=255&MSPPError=-2147217396
-typedef struct {
-  HANDLE UniqueProcess;  // Actually process ID
-  HANDLE UniqueThread;   // Actually thread ID
-} CLIENT_ID;
-
-// From http://alax.info/blog/1182, with corrections and modifications
-// Originally from
-// http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FStructures%2FSYSTEM_THREAD.html
-struct SYSTEM_THREAD_INFORMATION {
-  ULONGLONG KernelTime;
-  ULONGLONG UserTime;
-  ULONGLONG CreateTime;
-  ULONG WaitTime;
-  // Padding here in 64-bit
-  PVOID StartAddress;
-  CLIENT_ID ClientId;
-  KPRIORITY Priority;
-  LONG BasePriority;
-  ULONG ContextSwitchCount;
-  ULONG State;
-  KWAIT_REASON WaitReason;
-};
-#if _M_X64
-static_assert(sizeof(SYSTEM_THREAD_INFORMATION) == 80,
-              "Structure size mismatch");
-#else
-static_assert(sizeof(SYSTEM_THREAD_INFORMATION) == 64,
-              "Structure size mismatch");
-#endif
-
-// From http://alax.info/blog/1182, with corrections and modifications
-// Originally from
-// http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FSystem%20Information%2FStructures%2FSYSTEM_THREAD.html
-struct SYSTEM_PROCESS_INFORMATION {
-  ULONG NextEntryOffset;
-  ULONG NumberOfThreads;
-  // http://processhacker.sourceforge.net/doc/struct___s_y_s_t_e_m___p_r_o_c_e_s_s___i_n_f_o_r_m_a_t_i_o_n.html
-  ULONGLONG WorkingSetPrivateSize;
-  ULONG HardFaultCount;
-  ULONG Reserved1;
-  ULONGLONG CycleTime;
-  ULONGLONG CreateTime;
-  ULONGLONG UserTime;
-  ULONGLONG KernelTime;
-  UNICODE_STRING ImageName;
-  KPRIORITY BasePriority;
-  HANDLE ProcessId;
-  HANDLE ParentProcessId;
-  ULONG HandleCount;
-  ULONG Reserved2[2];
-  // Padding here in 64-bit
-  VM_COUNTERS VirtualMemoryCounters;
-  size_t Reserved3;
-  IO_COUNTERS IoCounters;
-  SYSTEM_THREAD_INFORMATION Threads[1];
-};
-#if _M_X64
-static_assert(sizeof(SYSTEM_PROCESS_INFORMATION) == 336,
-              "Structure size mismatch");
-#else
-static_assert(sizeof(SYSTEM_PROCESS_INFORMATION) == 248,
-              "Structure size mismatch");
-#endif
-
-// ntstatus.h conflicts with windows.h so define this locally.
-#define STATUS_SUCCESS              ((NTSTATUS)0x00000000L)
-#define STATUS_BUFFER_TOO_SMALL     ((NTSTATUS)0xC0000023L)
-#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
-
-// Simple memory buffer wrapper for passing the data out of
-// QuerySystemProcessInformation.
-class ByteBuffer {
- public:
-  explicit ByteBuffer(size_t capacity)
-      : size_(0), capacity_(0) {
-    if (capacity > 0)
-      grow(capacity);
-  }
-
-  ~ByteBuffer() {}
-
-  BYTE* data() { return data_.get(); }
-
-  size_t size() { return size_; }
-
-  void set_size(size_t new_size) {
-    DCHECK_LE(new_size, capacity_);
-    size_ = new_size;
-  }
-
-  size_t capacity() { return capacity_; }
-
-  void grow(size_t new_capacity) {
-    DCHECK_GT(new_capacity, capacity_);
-    capacity_ = new_capacity;
-    data_.reset(new BYTE[new_capacity]);
-  }
-
- private:
-  std::unique_ptr<BYTE[]> data_;
-  size_t size_;
-  size_t capacity_;
-
-  DISALLOW_COPY_AND_ASSIGN(ByteBuffer);
-};
-
-// Wrapper for NtQuerySystemProcessInformation with buffer reallocation logic.
-bool QuerySystemProcessInformation(ByteBuffer* buffer) {
-  typedef NTSTATUS(WINAPI * NTQUERYSYSTEMINFORMATION)(
-      SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation,
-      ULONG SystemInformationLength, PULONG ReturnLength);
-
-  HMODULE ntdll = ::GetModuleHandle(L"ntdll.dll");
-  if (!ntdll) {
-    NOTREACHED();
-    return false;
-  }
-
-  NTQUERYSYSTEMINFORMATION nt_query_system_information_ptr =
-      reinterpret_cast<NTQUERYSYSTEMINFORMATION>(
-          ::GetProcAddress(ntdll, "NtQuerySystemInformation"));
-  if (!nt_query_system_information_ptr) {
-    NOTREACHED();
-    return false;
-  }
-
-  NTSTATUS result;
-
-  // There is a potential race condition between growing the buffer and new
-  // processes being created. Try a few times before giving up.
-  for (int i = 0; i < 10; i++) {
-    ULONG data_size = 0;
-    ULONG buffer_size = static_cast<ULONG>(buffer->capacity());
-    result = nt_query_system_information_ptr(
-        SystemProcessInformation,
-        buffer->data(), buffer_size, &data_size);
-
-    if (result == STATUS_SUCCESS) {
-      buffer->set_size(data_size);
-      break;
-    }
-
-    if (result == STATUS_INFO_LENGTH_MISMATCH ||
-        result == STATUS_BUFFER_TOO_SMALL) {
-      // Insufficient buffer. Grow to the returned |data_size| plus 10% extra
-      // to avoid frequent reallocations and try again.
-      DCHECK_GT(data_size, buffer_size);
-      buffer->grow(static_cast<ULONG>(data_size * 1.1));
-    } else {
-      // An error other than the two above.
-      break;
-    }
-  }
-
-  return result == STATUS_SUCCESS;
-}
-
-// Per-thread data extracted from SYSTEM_THREAD_INFORMATION and stored in a
-// snapshot. This structure is accessed only on the worker thread.
-struct ThreadData {
-  base::PlatformThreadId thread_id;
-  ULONG context_switches;
-};
-
-// Per-process data extracted from SYSTEM_PROCESS_INFORMATION and stored in a
-// snapshot. This structure is accessed only on the worker thread.
-struct ProcessData {
-  ProcessData() = default;
-  ProcessData(ProcessData&&) = default;
-
-  std::vector<ThreadData> threads;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(ProcessData);
-};
-
-typedef std::map<base::ProcessId, ProcessData> ProcessDataMap;
-
-ULONG CountContextSwitchesDelta(const ProcessData& prev_process_data,
-  const ProcessData& new_process_data) {
-  // This one pass algorithm relies on the threads vectors to be
-  // ordered by thread_id.
-  ULONG delta = 0;
-  size_t prev_index = 0;
-
-  for (const auto& new_thread : new_process_data.threads) {
-    ULONG prev_thread_context_switches = 0;
-
-    // Iterate over the process threads from the previous snapshot skipping
-    // threads that don't exist anymore. Please note that this iteration starts
-    // from the last known prev_index and goes until a previous snapshot's
-    // thread ID >= the current snapshot's thread ID. So the overall algorithm
-    // is linear.
-    for (; prev_index < prev_process_data.threads.size(); ++prev_index) {
-      const auto& prev_thread = prev_process_data.threads[prev_index];
-      if (prev_thread.thread_id == new_thread.thread_id) {
-        // Threads match between two snapshots. Use the previous snapshot
-        // thread's context_switches to subtract from the delta.
-        prev_thread_context_switches = prev_thread.context_switches;
-        ++prev_index;
-        break;
-      }
-
-      if (prev_thread.thread_id > new_thread.thread_id) {
-        // This is due to a new thread that didn't exist in the previous
-        // snapshot. Keep the zero value of |prev_thread_context_switches| which
-        // essentially means the entire number of context switches of the new
-        // thread will be added to the delta.
-        break;
-      }
-    }
-
-    delta += new_thread.context_switches - prev_thread_context_switches;
-  }
-
-  return delta;
-}
-
-// Seeks a matching ProcessData by Process ID in a previous snapshot.
-// This uses the fact that ProcessDataMap entries are ordered by Process ID.
-const ProcessData* SeekInPreviousSnapshot(
-  base::ProcessId process_id, ProcessDataMap::const_iterator* iter_to_advance,
-  const ProcessDataMap::const_iterator& range_end) {
-  for (; *iter_to_advance != range_end; ++(*iter_to_advance)) {
-    if ((*iter_to_advance)->first == process_id) {
-      return &((*iter_to_advance)++)->second;
-    }
-    if ((*iter_to_advance)->first > process_id)
-      break;
-  }
-
-  return nullptr;
-}
-
-}  // namespace
-
-// ProcessDataSnapshot gets created and accessed only on the worker thread.
-// This is used to calculate metrics like Idle Wakeups / sec that require
-// a delta between two snapshots.
-// Please note that ProcessDataSnapshot has to be outside of anonymous namespace
-// in order to match the declaration in shared_sampler.h.
-struct ProcessDataSnapshot {
-  ProcessDataMap processes;
-  base::TimeTicks timestamp;
-};
-
-SharedSampler::SharedSampler(
-    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner)
-    : refresh_flags_(0), previous_buffer_size_(0),
-      supported_image_names_(GetSupportedImageNames()),
-      blocking_pool_runner_(blocking_pool_runner) {
-  DCHECK(blocking_pool_runner.get());
-
-  // This object will be created on the UI thread, however the sequenced checker
-  // will be used to assert we're running the expensive operations on one of the
-  // blocking pool threads.
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  worker_pool_sequenced_checker_.DetachFromSequence();
-}
-
-SharedSampler::~SharedSampler() {}
-
-int64_t SharedSampler::GetSupportedFlags() const {
-  return REFRESH_TYPE_IDLE_WAKEUPS;
-}
-
-SharedSampler::Callbacks::Callbacks() {}
-
-SharedSampler::Callbacks::~Callbacks() {}
-
-SharedSampler::Callbacks::Callbacks(Callbacks&& other) {
-  on_idle_wakeups = std::move(other.on_idle_wakeups);
-}
-
-void SharedSampler::RegisterCallbacks(
-    base::ProcessId process_id,
-    const OnIdleWakeupsCallback& on_idle_wakeups) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (process_id == 0)
-    return;
-
-  Callbacks callbacks;
-  callbacks.on_idle_wakeups = on_idle_wakeups;
-  bool result = callbacks_map_.insert(
-      std::make_pair(process_id, std::move(callbacks))).second;
-  DCHECK(result);
-}
-
-void SharedSampler::UnregisterCallbacks(base::ProcessId process_id) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (process_id == 0)
-    return;
-
-  callbacks_map_.erase(process_id);
-
-  if (callbacks_map_.empty())
-    ClearState();
-}
-
-void SharedSampler::Refresh(base::ProcessId process_id, int64_t refresh_flags) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK(callbacks_map_.find(process_id) != callbacks_map_.end());
-  DCHECK_NE(0, refresh_flags & GetSupportedFlags());
-
-  if (process_id == 0)
-    return;
-
-  if (refresh_flags_ == 0) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(), FROM_HERE,
-        base::Bind(&SharedSampler::RefreshOnWorkerThread, this),
-        base::Bind(&SharedSampler::OnRefreshDone, this));
-  } else {
-    // A group of consecutive Refresh calls should all specify the same refresh
-    // flags.
-    DCHECK_EQ(refresh_flags, refresh_flags_);
-  }
-
-  refresh_flags_ |= refresh_flags;
-}
-
-void SharedSampler::ClearState() {
-  previous_snapshot_.reset();
-}
-
-std::unique_ptr<SharedSampler::RefreshResults>
-SharedSampler::RefreshOnWorkerThread() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  std::unique_ptr<RefreshResults> results(new RefreshResults);
-
-  std::unique_ptr<ProcessDataSnapshot> snapshot = CaptureSnapshot();
-  if (snapshot) {
-    if (previous_snapshot_) {
-      MakeResultsFromTwoSnapshots(
-          *previous_snapshot_, *snapshot, results.get());
-    } else {
-      MakeResultsFromSnapshot(*snapshot, results.get());
-    }
-
-    previous_snapshot_ = std::move(snapshot);
-  } else {
-    // Failed to get snapshot. This is unlikely.
-    ClearState();
-  }
-
-  return results;
-}
-
-/* static */
-std::vector<base::FilePath> SharedSampler::GetSupportedImageNames() {
-  const wchar_t kNacl64Exe[] = L"nacl64.exe";
-
-  std::vector<base::FilePath> supported_names;
-
-  base::FilePath current_exe;
-  if (PathService::Get(base::FILE_EXE, &current_exe))
-    supported_names.push_back(current_exe.BaseName());
-
-  supported_names.push_back(
-      base::FilePath(chrome::kBrowserProcessExecutableName));
-  supported_names.push_back(base::FilePath(kNacl64Exe));
-
-  return supported_names;
-}
-
-bool SharedSampler::IsSupportedImageName(
-    base::FilePath::StringPieceType image_name) const {
-  for (const base::FilePath supported_name : supported_image_names_) {
-    if (base::FilePath::CompareEqualIgnoreCase(image_name,
-                                               supported_name.value()))
-      return true;
-  }
-
-  return false;
-}
-
-std::unique_ptr<ProcessDataSnapshot> SharedSampler::CaptureSnapshot() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  // Preallocate the buffer with the size determined on the previous call to
-  // QuerySystemProcessInformation. This should be sufficient most of the time.
-  // QuerySystemProcessInformation will grow the buffer if necessary.
-  ByteBuffer data_buffer(previous_buffer_size_);
-
-  if (!QuerySystemProcessInformation(&data_buffer))
-    return std::unique_ptr<ProcessDataSnapshot>();
-
-  previous_buffer_size_ = data_buffer.capacity();
-
-  std::unique_ptr<ProcessDataSnapshot> snapshot(new ProcessDataSnapshot);
-  snapshot->timestamp = base::TimeTicks::Now();
-
-  for (size_t offset = 0; offset < data_buffer.size(); ) {
-    auto pi = reinterpret_cast<const SYSTEM_PROCESS_INFORMATION*>(
-      data_buffer.data() + offset);
-
-    // Validate that the offset is valid and all needed data is within
-    // the buffer boundary.
-    if (offset + sizeof(SYSTEM_PROCESS_INFORMATION) > data_buffer.size())
-      break;
-    if (offset + sizeof(SYSTEM_PROCESS_INFORMATION) +
-            (pi->NumberOfThreads - 1) * sizeof(SYSTEM_THREAD_INFORMATION) >
-      data_buffer.size())
-      break;
-
-    if (pi->ImageName.Buffer) {
-      // Validate that the image name is within the buffer boundary.
-      // ImageName.Length seems to be in bytes rather than characters.
-      ULONG image_name_offset =
-          reinterpret_cast<BYTE*>(pi->ImageName.Buffer) - data_buffer.data();
-      if (image_name_offset + pi->ImageName.Length > data_buffer.size())
-        break;
-
-      // Check if this is a chrome process. Ignore all other processes.
-      if (IsSupportedImageName(pi->ImageName.Buffer)) {
-        // Collect enough data to be able to do a diff between two snapshots.
-        // Some threads might stop or new threads might be created between two
-        // snapshots. If a thread with a large number of context switches gets
-        // terminated the total number of context switches for the process might
-        // go down and the delta would be negative.
-        // To avoid that we need to compare thread IDs between two snapshots and
-        // not count context switches for threads that are missing in the most
-        // recent snapshot.
-        ProcessData process_data;
-
-        // Iterate over threads and store each thread's ID and number of context
-        // switches.
-        for (ULONG thread_index = 0; thread_index < pi->NumberOfThreads;
-             ++thread_index) {
-          const SYSTEM_THREAD_INFORMATION* ti = &pi->Threads[thread_index];
-          if (ti->ClientId.UniqueProcess != pi->ProcessId)
-            continue;
-
-          ThreadData thread_data;
-          thread_data.thread_id = static_cast<base::PlatformThreadId>(
-              reinterpret_cast<uintptr_t>(ti->ClientId.UniqueThread));
-          thread_data.context_switches = ti->ContextSwitchCount;
-          process_data.threads.push_back(thread_data);
-        }
-
-        // Order thread data by thread ID to help diff two snapshots.
-        std::sort(process_data.threads.begin(), process_data.threads.end(),
-            [](const ThreadData& l, const ThreadData r) {
-              return l.thread_id < r.thread_id;
-            });
-
-        base::ProcessId process_id = static_cast<base::ProcessId>(
-            reinterpret_cast<uintptr_t>(pi->ProcessId));
-        bool inserted = snapshot->processes.insert(
-            std::make_pair(process_id, std::move(process_data))).second;
-        DCHECK(inserted);
-      }
-    }
-
-    // Check for end of the list.
-    if (!pi->NextEntryOffset)
-      break;
-
-    // Jump to the next entry.
-    offset += pi->NextEntryOffset;
-  }
-
-  return snapshot;
-}
-
-void SharedSampler::MakeResultsFromTwoSnapshots(
-    const ProcessDataSnapshot& prev_snapshot,
-    const ProcessDataSnapshot& snapshot,
-    RefreshResults* results) {
-  // Time delta in seconds.
-  double time_delta = (snapshot.timestamp - prev_snapshot.timestamp)
-      .InSecondsF();
-
-  // Iterate over processes in both snapshots in parallel. This algorithm relies
-  // on map entries being ordered by Process ID.
-  ProcessDataMap::const_iterator prev_iter = prev_snapshot.processes.begin();
-
-  for (const auto& current_entry : snapshot.processes) {
-    base::ProcessId process_id = current_entry.first;
-    const ProcessData& process = current_entry.second;
-
-    const ProcessData* prev_snapshot_process = SeekInPreviousSnapshot(
-        process_id, &prev_iter, prev_snapshot.processes.end());
-
-    // Delta between the old snapshot and the new snapshot.
-    int idle_wakeups_delta;
-
-    if (prev_snapshot_process) {
-      // Processes match between two snapshots. Diff context switches.
-      idle_wakeups_delta =
-          CountContextSwitchesDelta(*prev_snapshot_process, process);
-    } else {
-      // Process is missing in the previous snapshot.
-      // Use entire number of context switches of the current process.
-      idle_wakeups_delta = CountContextSwitchesDelta(ProcessData(), process);
-    }
-
-    RefreshResult result;
-    result.process_id = process_id;
-    result.idle_wakeups_per_second =
-        static_cast<int>(round(idle_wakeups_delta / time_delta));
-    results->push_back(result);
-  }
-}
-
-void SharedSampler::MakeResultsFromSnapshot(const ProcessDataSnapshot& snapshot,
-                                            RefreshResults* results) {
-  for (const auto& pair : snapshot.processes) {
-    RefreshResult result;
-    result.process_id = pair.first;
-    // Use 0 for Idle Wakeups / sec in this case. This is consistent with
-    // ProcessMetrics::CalculateIdleWakeupsPerSecond implementation.
-    result.idle_wakeups_per_second = 0;
-    results->push_back(result);
-  }
-}
-
-void SharedSampler::OnRefreshDone(
-    std::unique_ptr<RefreshResults> refresh_results) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK_NE(0, refresh_flags_);
-
-  size_t result_index = 0;
-
-  for (const auto& callback_entry : callbacks_map_) {
-    base::ProcessId process_id = callback_entry.first;
-    // A sentinel value of -1 is used when the result isn't available.
-    // Task manager will use this to display 'N/A'.
-    int idle_wakeups_per_second = -1;
-
-    // Match refresh result by |process_id|.
-    // This relies on refresh results being ordered by Process ID.
-    // Please note that |refresh_results| might contain some extra entries that
-    // don't exist in |callbacks_map_| if there is more than one instance of
-    // Chrome. It might be missing some entries too if there is a race condition
-    // between getting process information on the worker thread and adding a
-    // corresponding TaskGroup to the task manager.
-    for (; result_index < refresh_results->size(); ++result_index) {
-      const auto& result = (*refresh_results)[result_index];
-      if (result.process_id == process_id) {
-        // Data matched in |refresh_results|.
-        idle_wakeups_per_second = result.idle_wakeups_per_second;
-        ++result_index;
-        break;
-      }
-
-      if (result.process_id > process_id) {
-        // An entry corresponding to |process_id| is missing. See above.
-        break;
-      }
-    }
-
-    if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_IDLE_WAKEUPS,
-                                                      refresh_flags_)) {
-      callback_entry.second.on_idle_wakeups.Run(idle_wakeups_per_second);
-    }
-  }
-
-  // Reset refresh_results_ to trigger RefreshOnWorkerThread next time Refresh
-  // is called.
-  refresh_flags_ = 0;
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_group.cc b/chrome/browser/task_manager/sampling/task_group.cc
deleted file mode 100644
index b5581d5..0000000
--- a/chrome/browser/task_manager/sampling/task_group.cc
+++ /dev/null
@@ -1,292 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/task_group.h"
-
-#include <algorithm>
-#include <limits>
-
-#include "base/bind.h"
-#include "base/callback.h"
-#include "build/build_config.h"
-#include "chrome/browser/task_manager/sampling/shared_sampler.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "components/nacl/browser/nacl_browser.h"
-#include "content/public/browser/browser_thread.h"
-#include "gpu/ipc/common/memory_stats.h"
-
-namespace task_manager {
-
-namespace {
-
-// A mask for the refresh types that are done in the background thread.
-const int kBackgroundRefreshTypesMask =
-    REFRESH_TYPE_CPU |
-    REFRESH_TYPE_MEMORY |
-    REFRESH_TYPE_IDLE_WAKEUPS |
-#if defined(OS_LINUX)
-    REFRESH_TYPE_FD_COUNT |
-#endif  // defined(OS_LINUX)
-    REFRESH_TYPE_PRIORITY;
-
-#if defined(OS_WIN)
-// Gets the GDI and USER Handles on Windows at one shot.
-void GetWindowsHandles(base::ProcessHandle handle,
-                       int64_t* out_gdi_current,
-                       int64_t* out_gdi_peak,
-                       int64_t* out_user_current,
-                       int64_t* out_user_peak) {
-  *out_gdi_current = 0;
-  *out_gdi_peak = 0;
-  *out_user_current = 0;
-  *out_user_peak = 0;
-  // Get a handle to |process| that has PROCESS_QUERY_INFORMATION rights.
-  HANDLE current_process = GetCurrentProcess();
-  HANDLE process_with_query_rights;
-  if (DuplicateHandle(current_process, handle, current_process,
-                      &process_with_query_rights, PROCESS_QUERY_INFORMATION,
-                      false, 0)) {
-    *out_gdi_current = static_cast<int64_t>(
-        GetGuiResources(process_with_query_rights, GR_GDIOBJECTS));
-    *out_gdi_peak = static_cast<int64_t>(
-        GetGuiResources(process_with_query_rights, GR_GDIOBJECTS_PEAK));
-    *out_user_current = static_cast<int64_t>(
-        GetGuiResources(process_with_query_rights, GR_USEROBJECTS));
-    *out_user_peak = static_cast<int64_t>(
-        GetGuiResources(process_with_query_rights, GR_USEROBJECTS_PEAK));
-    CloseHandle(process_with_query_rights);
-  }
-}
-#endif  // defined(OS_WIN)
-
-}  // namespace
-
-TaskGroup::TaskGroup(
-    base::ProcessHandle proc_handle,
-    base::ProcessId proc_id,
-    const base::Closure& on_background_calculations_done,
-    const scoped_refptr<SharedSampler>& shared_sampler,
-    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner)
-    : process_handle_(proc_handle),
-      process_id_(proc_id),
-      on_background_calculations_done_(on_background_calculations_done),
-      worker_thread_sampler_(nullptr),
-      shared_sampler_(shared_sampler),
-      expected_on_bg_done_flags_(kBackgroundRefreshTypesMask),
-      current_on_bg_done_flags_(0),
-      cpu_usage_(0.0),
-      gpu_memory_(-1),
-      per_process_network_usage_(-1),
-#if defined(OS_WIN)
-      gdi_current_handles_(-1),
-      gdi_peak_handles_(-1),
-      user_current_handles_(-1),
-      user_peak_handles_(-1),
-#endif  // defined(OS_WIN)
-#if !defined(DISABLE_NACL)
-      nacl_debug_stub_port_(-1),
-#endif  // !defined(DISABLE_NACL)
-      idle_wakeups_per_second_(-1),
-#if defined(OS_LINUX)
-      open_fd_count_(-1),
-#endif  // defined(OS_LINUX)
-      gpu_memory_has_duplicates_(false),
-      is_backgrounded_(false),
-      weak_ptr_factory_(this) {
-  scoped_refptr<TaskGroupSampler> sampler(
-      new TaskGroupSampler(base::Process::Open(proc_id),
-                           blocking_pool_runner,
-                           base::Bind(&TaskGroup::OnCpuRefreshDone,
-                                      weak_ptr_factory_.GetWeakPtr()),
-                           base::Bind(&TaskGroup::OnMemoryUsageRefreshDone,
-                                      weak_ptr_factory_.GetWeakPtr()),
-                           base::Bind(&TaskGroup::OnIdleWakeupsRefreshDone,
-                                      weak_ptr_factory_.GetWeakPtr()),
-#if defined(OS_LINUX)
-                           base::Bind(&TaskGroup::OnOpenFdCountRefreshDone,
-                                      weak_ptr_factory_.GetWeakPtr()),
-#endif  // defined(OS_LINUX)
-                           base::Bind(&TaskGroup::OnProcessPriorityDone,
-                                      weak_ptr_factory_.GetWeakPtr())));
-  worker_thread_sampler_.swap(sampler);
-
-  shared_sampler_->RegisterCallbacks(
-      process_id_, base::Bind(&TaskGroup::OnIdleWakeupsRefreshDone,
-                              weak_ptr_factory_.GetWeakPtr()));
-}
-
-TaskGroup::~TaskGroup() {
-  shared_sampler_->UnregisterCallbacks(process_id_);
-}
-
-void TaskGroup::AddTask(Task* task) {
-  DCHECK(task);
-  tasks_.push_back(task);
-}
-
-void TaskGroup::RemoveTask(Task* task) {
-  DCHECK(task);
-  tasks_.erase(std::remove(tasks_.begin(), tasks_.end(), task), tasks_.end());
-}
-
-void TaskGroup::Refresh(const gpu::VideoMemoryUsageStats& gpu_memory_stats,
-                        base::TimeDelta update_interval,
-                        int64_t refresh_flags) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  expected_on_bg_done_flags_ = refresh_flags & kBackgroundRefreshTypesMask;
-  // If a refresh type was recently disabled, we need to account for that too.
-  current_on_bg_done_flags_ &= expected_on_bg_done_flags_;
-
-  // First refresh the enabled non-expensive resources usages on the UI thread.
-  // 1- Refresh all the tasks as well as the total network usage (if enabled).
-  const bool network_usage_refresh_enabled =
-      TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_NETWORK_USAGE,
-                                                    refresh_flags);
-  per_process_network_usage_ = network_usage_refresh_enabled ? 0 : -1;
-  for (Task* task : tasks_) {
-    task->Refresh(update_interval, refresh_flags);
-
-    if (network_usage_refresh_enabled && task->ReportsNetworkUsage())
-      per_process_network_usage_ += task->network_usage();
-  }
-
-  // 2- Refresh GPU memory (if enabled).
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_GPU_MEMORY,
-                                                    refresh_flags)) {
-    RefreshGpuMemory(gpu_memory_stats);
-  }
-
-  // 3- Refresh Windows handles (if enabled).
-#if defined(OS_WIN)
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_HANDLES,
-                                                    refresh_flags)) {
-    RefreshWindowsHandles();
-  }
-#endif  // defined(OS_WIN)
-
-  // 4- Refresh the NACL debug stub port (if enabled).
-#if !defined(DISABLE_NACL)
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_NACL,
-                                                    refresh_flags) &&
-      !tasks_.empty()) {
-    RefreshNaClDebugStubPort(tasks_[0]->GetChildProcessUniqueID());
-  }
-#endif  // !defined(DISABLE_NACL)
-
-  int64_t shared_refresh_flags =
-      refresh_flags & shared_sampler_->GetSupportedFlags();
-
-  // 5- Refresh resources via SharedSampler if the current platform
-  // implementation supports that. The actual work is done on the worker thread.
-  // At the moment this is supported only on OS_WIN.
-  if (shared_refresh_flags != 0) {
-    shared_sampler_->Refresh(process_id_, shared_refresh_flags);
-    refresh_flags &= ~shared_refresh_flags;
-  }
-
-  // The remaining resource refreshes are time consuming and cannot be done on
-  // the UI thread. Do them all on the worker thread using the TaskGroupSampler.
-  // 6-  CPU usage.
-  // 7-  Memory usage.
-  // 8-  Idle Wakeups per second.
-  // 9-  (Linux and ChromeOS only) The number of file descriptors current open.
-  // 10- Process priority (foreground vs. background).
-  worker_thread_sampler_->Refresh(refresh_flags);
-}
-
-Task* TaskGroup::GetTaskById(TaskId task_id) const {
-  for (Task* task : tasks_) {
-    if (task->task_id() == task_id)
-      return task;
-  }
-  NOTREACHED();
-  return nullptr;
-}
-
-void TaskGroup::ClearCurrentBackgroundCalculationsFlags() {
-  current_on_bg_done_flags_ = 0;
-}
-
-bool TaskGroup::AreBackgroundCalculationsDone() const {
-  return expected_on_bg_done_flags_ == current_on_bg_done_flags_;
-}
-
-void TaskGroup::RefreshGpuMemory(
-    const gpu::VideoMemoryUsageStats& gpu_memory_stats) {
-  auto itr = gpu_memory_stats.process_map.find(process_id_);
-  if (itr == gpu_memory_stats.process_map.end()) {
-    gpu_memory_ = -1;
-    gpu_memory_has_duplicates_ = false;
-    return;
-  }
-
-  gpu_memory_ = itr->second.video_memory;
-  gpu_memory_has_duplicates_ = itr->second.has_duplicates;
-}
-
-void TaskGroup::RefreshWindowsHandles() {
-#if defined(OS_WIN)
-  GetWindowsHandles(process_handle_,
-                    &gdi_current_handles_,
-                    &gdi_peak_handles_,
-                    &user_current_handles_,
-                    &user_peak_handles_);
-#endif  // defined(OS_WIN)
-}
-
-void TaskGroup::RefreshNaClDebugStubPort(int child_process_unique_id) {
-#if !defined(DISABLE_NACL)
-  nacl::NaClBrowser* nacl_browser = nacl::NaClBrowser::GetInstance();
-  nacl_debug_stub_port_ =
-      nacl_browser->GetProcessGdbDebugStubPort(child_process_unique_id);
-#endif  // !defined(DISABLE_NACL)
-}
-
-void TaskGroup::OnCpuRefreshDone(double cpu_usage) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  cpu_usage_ = cpu_usage;
-  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_CPU);
-}
-
-void TaskGroup::OnMemoryUsageRefreshDone(MemoryUsageStats memory_usage) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  memory_usage_ = memory_usage;
-  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_MEMORY);
-}
-
-void TaskGroup::OnIdleWakeupsRefreshDone(int idle_wakeups_per_second) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  idle_wakeups_per_second_ = idle_wakeups_per_second;
-  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_IDLE_WAKEUPS);
-}
-
-#if defined(OS_LINUX)
-void TaskGroup::OnOpenFdCountRefreshDone(int open_fd_count) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  open_fd_count_ = open_fd_count;
-  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_FD_COUNT);
-}
-#endif  // defined(OS_LINUX)
-
-void TaskGroup::OnProcessPriorityDone(bool is_backgrounded) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  is_backgrounded_ = is_backgrounded;
-  OnBackgroundRefreshTypeFinished(REFRESH_TYPE_PRIORITY);
-}
-
-void TaskGroup::OnBackgroundRefreshTypeFinished(int64_t finished_refresh_type) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  current_on_bg_done_flags_ |= finished_refresh_type;
-  if (AreBackgroundCalculationsDone())
-    on_background_calculations_done_.Run();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_group.h b/chrome/browser/task_manager/sampling/task_group.h
deleted file mode 100644
index fb0ef97..0000000
--- a/chrome/browser/task_manager/sampling/task_group.h
+++ /dev/null
@@ -1,177 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_H_
-#define CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <map>
-#include <vector>
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/process/process_handle.h"
-#include "build/build_config.h"
-#include "chrome/browser/task_manager/providers/task.h"
-#include "chrome/browser/task_manager/sampling/task_group_sampler.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-
-namespace gpu {
-struct VideoMemoryUsageStats;
-}
-
-namespace task_manager {
-
-class SharedSampler;
-
-// Defines a group of tasks tracked by the task manager which belong to the same
-// process. This class lives on the UI thread.
-class TaskGroup {
- public:
-  TaskGroup(
-      base::ProcessHandle proc_handle,
-      base::ProcessId proc_id,
-      const base::Closure& on_background_calculations_done,
-      const scoped_refptr<SharedSampler>& shared_sampler,
-      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner);
-  ~TaskGroup();
-
-  // Adds and removes the given |task| to this group. |task| must be running on
-  // the same process represented by this group.
-  void AddTask(Task* task);
-  void RemoveTask(Task* task);
-
-  void Refresh(const gpu::VideoMemoryUsageStats& gpu_memory_stats,
-               base::TimeDelta update_interval,
-               int64_t refresh_flags);
-
-  Task* GetTaskById(TaskId task_id) const;
-
-  // This is to be called after the task manager had informed its observers with
-  // OnTasksRefreshedWithBackgroundCalculations() to begin another cycle for
-  // this notification type.
-  void ClearCurrentBackgroundCalculationsFlags();
-
-  // True if all enabled background operations calculating resource usage of the
-  // process represented by this TaskGroup have completed.
-  bool AreBackgroundCalculationsDone() const;
-
-  const base::ProcessHandle& process_handle() const { return process_handle_; }
-  const base::ProcessId& process_id() const { return process_id_; }
-
-  const std::vector<Task*>& tasks() const { return tasks_; }
-  size_t num_tasks() const { return tasks().size(); }
-  bool empty() const { return tasks().empty(); }
-
-  double cpu_usage() const { return cpu_usage_; }
-  int64_t private_bytes() const { return memory_usage_.private_bytes; }
-  int64_t shared_bytes() const { return memory_usage_.shared_bytes; }
-  int64_t physical_bytes() const { return memory_usage_.physical_bytes; }
-#if defined(OS_CHROMEOS)
-  int64_t swapped_bytes() const { return memory_usage_.swapped_bytes; }
-#endif
-  int64_t gpu_memory() const { return gpu_memory_; }
-  bool gpu_memory_has_duplicates() const { return gpu_memory_has_duplicates_; }
-  int64_t per_process_network_usage() const {
-    return per_process_network_usage_;
-  }
-  bool is_backgrounded() const { return is_backgrounded_; }
-
-#if defined(OS_WIN)
-  int64_t gdi_current_handles() const { return gdi_current_handles_; }
-  int64_t gdi_peak_handles() const { return gdi_peak_handles_; }
-  int64_t user_current_handles() const { return user_current_handles_; }
-  int64_t user_peak_handles() const { return user_peak_handles_; }
-#endif  // defined(OS_WIN)
-
-#if !defined(DISABLE_NACL)
-  int nacl_debug_stub_port() const { return nacl_debug_stub_port_; }
-#endif  // !defined(DISABLE_NACL)
-
-#if defined(OS_LINUX)
-  int open_fd_count() const { return open_fd_count_; }
-#endif  // defined(OS_LINUX)
-
-  int idle_wakeups_per_second() const { return idle_wakeups_per_second_; }
-
- private:
-  void RefreshGpuMemory(const gpu::VideoMemoryUsageStats& gpu_memory_stats);
-
-  void RefreshWindowsHandles();
-
-  // |child_process_unique_id| see Task::GetChildProcessUniqueID().
-  void RefreshNaClDebugStubPort(int child_process_unique_id);
-
-  void OnCpuRefreshDone(double cpu_usage);
-
-  void OnMemoryUsageRefreshDone(MemoryUsageStats memory_usage);
-
-  void OnIdleWakeupsRefreshDone(int idle_wakeups_per_second);
-
-#if defined(OS_LINUX)
-  void OnOpenFdCountRefreshDone(int open_fd_count);
-#endif  // defined(OS_LINUX)
-
-  void OnProcessPriorityDone(bool is_backgrounded);
-
-  void OnBackgroundRefreshTypeFinished(int64_t finished_refresh_type);
-
-  // The process' handle and ID.
-  base::ProcessHandle process_handle_;
-  base::ProcessId process_id_;
-
-  // This is a callback into the TaskManagerImpl to inform it that the
-  // background calculations for this TaskGroup has finished.
-  const base::Closure on_background_calculations_done_;
-
-  scoped_refptr<TaskGroupSampler> worker_thread_sampler_;
-
-  scoped_refptr<SharedSampler> shared_sampler_;
-
-  // Lists the Tasks in this TaskGroup.
-  // Tasks are not owned by the TaskGroup. They're owned by the TaskProviders.
-  std::vector<Task*> tasks_;
-
-  // Flags will be used to determine when the background calculations has
-  // completed for the enabled refresh types for this TaskGroup.
-  int64_t expected_on_bg_done_flags_;
-  int64_t current_on_bg_done_flags_;
-
-  // The per process resources usages.
-  double cpu_usage_;
-  MemoryUsageStats memory_usage_;
-  int64_t gpu_memory_;
-  // The network usage in bytes per second as the sum of all network usages of
-  // the individual tasks sharing the same process.
-  int64_t per_process_network_usage_;
-#if defined(OS_WIN)
-  // Windows GDI and USER Handles.
-  int64_t gdi_current_handles_;
-  int64_t gdi_peak_handles_;
-  int64_t user_current_handles_;
-  int64_t user_peak_handles_;
-#endif  // defined(OS_WIN)
-#if !defined(DISABLE_NACL)
-  int nacl_debug_stub_port_;
-#endif  // !defined(DISABLE_NACL)
-  int idle_wakeups_per_second_;
-#if defined(OS_LINUX)
-  // The number of file descriptors currently open by the process.
-  int open_fd_count_;
-#endif  // defined(OS_LINUX)
-  bool gpu_memory_has_duplicates_;
-  bool is_backgrounded_;
-
-  // Always keep this the last member of this class so that it's the first to be
-  // destroyed.
-  base::WeakPtrFactory<TaskGroup> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskGroup);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_H_
diff --git a/chrome/browser/task_manager/sampling/task_group_sampler.cc b/chrome/browser/task_manager/sampling/task_group_sampler.cc
deleted file mode 100644
index cb32eae..0000000
--- a/chrome/browser/task_manager/sampling/task_group_sampler.cc
+++ /dev/null
@@ -1,188 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/task_group_sampler.h"
-
-#include <utility>
-
-#include "base/bind.h"
-#include "base/callback.h"
-#include "base/process/process_metrics.h"
-#include "build/build_config.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "content/public/browser/browser_child_process_host.h"
-#include "content/public/browser/browser_thread.h"
-
-namespace task_manager {
-
-namespace {
-
-std::unique_ptr<base::ProcessMetrics> CreateProcessMetrics(
-    base::ProcessHandle handle) {
-#if !defined(OS_MACOSX)
-  return base::ProcessMetrics::CreateProcessMetrics(handle);
-#else
-  return base::ProcessMetrics::CreateProcessMetrics(
-      handle, content::BrowserChildProcessHost::GetPortProvider());
-#endif
-}
-
-}  // namespace
-
-TaskGroupSampler::TaskGroupSampler(
-    base::Process process,
-    const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner,
-    const OnCpuRefreshCallback& on_cpu_refresh,
-    const OnMemoryRefreshCallback& on_memory_refresh,
-    const OnIdleWakeupsCallback& on_idle_wakeups,
-#if defined(OS_LINUX)
-    const OnOpenFdCountCallback& on_open_fd_count,
-#endif  // defined(OS_LINUX)
-    const OnProcessPriorityCallback& on_process_priority)
-    : process_(std::move(process)),
-      process_metrics_(CreateProcessMetrics(process_.Handle())),
-      blocking_pool_runner_(blocking_pool_runner),
-      on_cpu_refresh_callback_(on_cpu_refresh),
-      on_memory_refresh_callback_(on_memory_refresh),
-      on_idle_wakeups_callback_(on_idle_wakeups),
-#if defined(OS_LINUX)
-      on_open_fd_count_callback_(on_open_fd_count),
-#endif  // defined(OS_LINUX)
-      on_process_priority_callback_(on_process_priority) {
-  DCHECK(blocking_pool_runner.get());
-
-  // This object will be created on the UI thread, however the sequenced checker
-  // will be used to assert we're running the expensive operations on one of the
-  // blocking pool threads.
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  worker_pool_sequenced_checker_.DetachFromSequence();
-}
-
-void TaskGroupSampler::Refresh(int64_t refresh_flags) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_CPU,
-                                                    refresh_flags)) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(),
-        FROM_HERE,
-        base::Bind(&TaskGroupSampler::RefreshCpuUsage, this),
-        on_cpu_refresh_callback_);
-  }
-
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_MEMORY,
-                                                    refresh_flags)) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(),
-        FROM_HERE,
-        base::Bind(&TaskGroupSampler::RefreshMemoryUsage, this),
-        on_memory_refresh_callback_);
-  }
-
-#if defined(OS_MACOSX) || defined(OS_LINUX)
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_IDLE_WAKEUPS,
-                                                    refresh_flags)) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(),
-        FROM_HERE,
-        base::Bind(&TaskGroupSampler::RefreshIdleWakeupsPerSecond, this),
-        on_idle_wakeups_callback_);
-  }
-#endif  // defined(OS_MACOSX) || defined(OS_LINUX)
-
-#if defined(OS_LINUX)
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_FD_COUNT,
-                                                    refresh_flags)) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(),
-        FROM_HERE,
-        base::Bind(&TaskGroupSampler::RefreshOpenFdCount, this),
-        on_open_fd_count_callback_);
-  }
-#endif  // defined(OS_LINUX)
-
-  if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_PRIORITY,
-                                                    refresh_flags)) {
-    base::PostTaskAndReplyWithResult(
-        blocking_pool_runner_.get(),
-        FROM_HERE,
-        base::Bind(&TaskGroupSampler::RefreshProcessPriority, this),
-        on_process_priority_callback_);
-  }
-}
-
-TaskGroupSampler::~TaskGroupSampler() {
-}
-
-double TaskGroupSampler::RefreshCpuUsage() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  return process_metrics_->GetCPUUsage();
-}
-
-MemoryUsageStats TaskGroupSampler::RefreshMemoryUsage() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  MemoryUsageStats memory_usage;
-#if defined(OS_MACOSX)
-  memory_usage.physical_bytes =
-      static_cast<int64_t>(process_metrics_->GetWorkingSetSize());
-
-  size_t private_bytes = 0;
-  size_t shared_bytes = 0;
-  if (process_metrics_->GetMemoryBytes(&private_bytes, &shared_bytes)) {
-    memory_usage.private_bytes = static_cast<int64_t>(private_bytes);
-    memory_usage.shared_bytes = static_cast<int64_t>(shared_bytes);
-  }
-#else
-  // Refreshing the physical/private/shared memory at one shot.
-  base::WorkingSetKBytes ws_usage;
-  if (process_metrics_->GetWorkingSetKBytes(&ws_usage)) {
-    memory_usage.private_bytes = static_cast<int64_t>(ws_usage.priv * 1024);
-    memory_usage.shared_bytes = static_cast<int64_t>(ws_usage.shared * 1024);
-#if defined(OS_LINUX)
-    // On Linux private memory is also resident. Just use it.
-    memory_usage.physical_bytes = memory_usage.private_bytes;
-#else
-    // Memory = working_set.private which is working set minus shareable. This
-    // avoids the unpredictable counting that occurs when calculating memory as
-    // working set minus shared (renderer code counted when one tab is open and
-    // not counted when two or more are open) and it is much more efficient to
-    // calculate on Windows.
-    memory_usage.physical_bytes =
-        static_cast<int64_t>(process_metrics_->GetWorkingSetSize());
-    memory_usage.physical_bytes -=
-        static_cast<int64_t>(ws_usage.shareable * 1024);
-#endif  // defined(OS_LINUX)
-
-#if defined(OS_CHROMEOS)
-    memory_usage.swapped_bytes = ws_usage.swapped * 1024;
-#endif  // defined(OS_CHROMEOS)
-  }
-#endif  // defined(OS_MACOSX)
-
-  return memory_usage;
-}
-
-int TaskGroupSampler::RefreshIdleWakeupsPerSecond() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  return process_metrics_->GetIdleWakeupsPerSecond();
-}
-
-#if defined(OS_LINUX)
-int TaskGroupSampler::RefreshOpenFdCount() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  return process_metrics_->GetOpenFdCount();
-}
-#endif  // defined(OS_LINUX)
-
-bool TaskGroupSampler::RefreshProcessPriority() {
-  DCHECK(worker_pool_sequenced_checker_.CalledOnValidSequence());
-
-  return process_.IsProcessBackgrounded();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_group_sampler.h b/chrome/browser/task_manager/sampling/task_group_sampler.h
deleted file mode 100644
index b8deb6f..0000000
--- a/chrome/browser/task_manager/sampling/task_group_sampler.h
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_SAMPLER_H_
-#define CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_SAMPLER_H_
-
-#include <stdint.h>
-
-#include <memory>
-
-#include "base/callback.h"
-#include "base/macros.h"
-#include "base/memory/ref_counted.h"
-#include "base/process/process.h"
-#include "base/process/process_handle.h"
-#include "base/process/process_metrics.h"
-#include "base/sequence_checker.h"
-#include "base/sequenced_task_runner.h"
-#include "build/build_config.h"
-
-namespace task_manager {
-
-// Wraps the memory usage stats values together so that it can be sent between
-// the UI and the worker threads.
-struct MemoryUsageStats {
-  int64_t private_bytes = -1;
-  int64_t shared_bytes = -1;
-  int64_t physical_bytes = -1;
-#if defined(OS_CHROMEOS)
-  int64_t swapped_bytes = -1;
-#endif
-
-  MemoryUsageStats() {}
-};
-
-// Defines the expensive process' stats sampler that will calculate these
-// resources on the worker thread. Objects of this class are created by the
-// TaskGroups on the UI thread, however it will be used mainly on a blocking
-// pool thread.
-class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
- public:
-  // Below are the types of callbacks that are invoked on the UI thread upon
-  // completion of corresponding refresh tasks on the worker thread.
-  using OnCpuRefreshCallback = base::Callback<void(double)>;
-  using OnMemoryRefreshCallback = base::Callback<void(MemoryUsageStats)>;
-  using OnIdleWakeupsCallback = base::Callback<void(int)>;
-#if defined(OS_LINUX)
-  using OnOpenFdCountCallback = base::Callback<void(int)>;
-#endif  // defined(OS_LINUX)
-  using OnProcessPriorityCallback = base::Callback<void(bool)>;
-
-  TaskGroupSampler(
-      base::Process process,
-      const scoped_refptr<base::SequencedTaskRunner>& blocking_pool_runner,
-      const OnCpuRefreshCallback& on_cpu_refresh,
-      const OnMemoryRefreshCallback& on_memory_refresh,
-      const OnIdleWakeupsCallback& on_idle_wakeups,
-#if defined(OS_LINUX)
-      const OnOpenFdCountCallback& on_open_fd_count,
-#endif  // defined(OS_LINUX)
-      const OnProcessPriorityCallback& on_process_priority);
-
-  // Refreshes the expensive process' stats (CPU usage, memory usage, and idle
-  // wakeups per second) on the worker thread.
-  void Refresh(int64_t refresh_flags);
-
- private:
-  friend class base::RefCountedThreadSafe<TaskGroupSampler>;
-  ~TaskGroupSampler();
-
-  // The refresh calls that will be done on the worker thread.
-  double RefreshCpuUsage();
-  MemoryUsageStats RefreshMemoryUsage();
-  int RefreshIdleWakeupsPerSecond();
-#if defined(OS_LINUX)
-  int RefreshOpenFdCount();
-#endif  // defined(OS_LINUX)
-  bool RefreshProcessPriority();
-
-  // The process that holds the handle that we own so that we can use it for
-  // creating the ProcessMetrics.
-  base::Process process_;
-
-  std::unique_ptr<base::ProcessMetrics> process_metrics_;
-
-  // The specific blocking pool SequencedTaskRunner that will be used to post
-  // the refresh tasks onto serially.
-  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
-
-  // The UI-thread callbacks in TaskGroup to be called when their corresponding
-  // refreshes on the worker thread are done.
-  const OnCpuRefreshCallback on_cpu_refresh_callback_;
-  const OnMemoryRefreshCallback on_memory_refresh_callback_;
-  const OnIdleWakeupsCallback on_idle_wakeups_callback_;
-#if defined(OS_LINUX)
-  const OnOpenFdCountCallback on_open_fd_count_callback_;
-#endif  // defined(OS_LINUX)
-  const OnProcessPriorityCallback on_process_priority_callback_;
-
-  // To assert we're running on the correct thread.
-  base::SequenceChecker worker_pool_sequenced_checker_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskGroupSampler);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_GROUP_SAMPLER_H_
diff --git a/chrome/browser/task_manager/sampling/task_manager_impl.cc b/chrome/browser/task_manager/sampling/task_manager_impl.cc
deleted file mode 100644
index 8d12ca5..0000000
--- a/chrome/browser/task_manager/sampling/task_manager_impl.cc
+++ /dev/null
@@ -1,549 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/task_manager_impl.h"
-
-#include <algorithm>
-#include <string>
-#include <unordered_map>
-#include <unordered_set>
-#include <vector>
-
-#include "base/command_line.h"
-#include "base/containers/adapters.h"
-#include "build/build_config.h"
-#include "chrome/browser/task_manager/providers/browser_process_task_provider.h"
-#include "chrome/browser/task_manager/providers/child_process_task_provider.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_task_provider.h"
-#include "chrome/browser/task_manager/sampling/shared_sampler.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/gpu_data_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/web_contents.h"
-
-#if defined(OS_CHROMEOS)
-#include "chrome/browser/task_manager/providers/arc/arc_process_task_provider.h"
-#include "components/arc/arc_bridge_service.h"
-#endif  // defined(OS_CHROMEOS)
-
-namespace task_manager {
-
-namespace {
-
-scoped_refptr<base::SequencedTaskRunner> GetBlockingPoolRunner() {
-  base::SequencedWorkerPool* blocking_pool =
-      content::BrowserThread::GetBlockingPool();
-  return blocking_pool->GetSequencedTaskRunner(
-      blocking_pool->GetSequenceToken());
-}
-
-base::LazyInstance<TaskManagerImpl> lazy_task_manager_instance =
-    LAZY_INSTANCE_INITIALIZER;
-
-}  // namespace
-
-TaskManagerImpl::TaskManagerImpl()
-    : on_background_data_ready_callback_(
-          base::Bind(&TaskManagerImpl::OnTaskGroupBackgroundCalculationsDone,
-                     base::Unretained(this))),
-      blocking_pool_runner_(GetBlockingPoolRunner()),
-      shared_sampler_(new SharedSampler(blocking_pool_runner_)),
-      is_running_(false) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  task_providers_.emplace_back(new BrowserProcessTaskProvider());
-  task_providers_.emplace_back(new ChildProcessTaskProvider());
-  task_providers_.emplace_back(new WebContentsTaskProvider());
-#if defined(OS_CHROMEOS)
-  if (arc::ArcBridgeService::GetEnabled(
-          base::CommandLine::ForCurrentProcess())) {
-    task_providers_.emplace_back(new ArcProcessTaskProvider());
-  }
-#endif  // defined(OS_CHROMEOS)
-
-  content::GpuDataManager::GetInstance()->AddObserver(this);
-}
-
-TaskManagerImpl::~TaskManagerImpl() {
-  content::GpuDataManager::GetInstance()->RemoveObserver(this);
-}
-
-// static
-TaskManagerImpl* TaskManagerImpl::GetInstance() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  return lazy_task_manager_instance.Pointer();
-}
-
-void TaskManagerImpl::ActivateTask(TaskId task_id) {
-  GetTaskByTaskId(task_id)->Activate();
-}
-
-bool TaskManagerImpl::IsTaskKillable(TaskId task_id) {
-  return GetTaskByTaskId(task_id)->IsKillable();
-}
-
-void TaskManagerImpl::KillTask(TaskId task_id) {
-  GetTaskByTaskId(task_id)->Kill();
-}
-
-double TaskManagerImpl::GetCpuUsage(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->cpu_usage();
-}
-
-int64_t TaskManagerImpl::GetPhysicalMemoryUsage(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->physical_bytes();
-}
-
-int64_t TaskManagerImpl::GetPrivateMemoryUsage(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->private_bytes();
-}
-
-int64_t TaskManagerImpl::GetSharedMemoryUsage(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->shared_bytes();
-}
-
-int64_t TaskManagerImpl::GetSwappedMemoryUsage(TaskId task_id) const {
-#if defined(OS_CHROMEOS)
-  return GetTaskGroupByTaskId(task_id)->swapped_bytes();
-#else
-  return -1;
-#endif
-}
-
-int64_t TaskManagerImpl::GetGpuMemoryUsage(TaskId task_id,
-                                           bool* has_duplicates) const {
-  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
-  if (has_duplicates)
-    *has_duplicates = task_group->gpu_memory_has_duplicates();
-  return task_group->gpu_memory();
-}
-
-int TaskManagerImpl::GetIdleWakeupsPerSecond(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->idle_wakeups_per_second();
-}
-
-int TaskManagerImpl::GetNaClDebugStubPort(TaskId task_id) const {
-#if !defined(DISABLE_NACL)
-  return GetTaskGroupByTaskId(task_id)->nacl_debug_stub_port();
-#else
-  return -2;
-#endif  // !defined(DISABLE_NACL)
-}
-
-void TaskManagerImpl::GetGDIHandles(TaskId task_id,
-                                    int64_t* current,
-                                    int64_t* peak) const {
-#if defined(OS_WIN)
-  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
-  *current = task_group->gdi_current_handles();
-  *peak = task_group->gdi_peak_handles();
-#else
-  *current = -1;
-  *peak = -1;
-#endif  // defined(OS_WIN)
-}
-
-void TaskManagerImpl::GetUSERHandles(TaskId task_id,
-                                     int64_t* current,
-                                     int64_t* peak) const {
-#if defined(OS_WIN)
-  const TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
-  *current = task_group->user_current_handles();
-  *peak = task_group->user_peak_handles();
-#else
-  *current = -1;
-  *peak = -1;
-#endif  // defined(OS_WIN)
-}
-
-int TaskManagerImpl::GetOpenFdCount(TaskId task_id) const {
-#if defined(OS_LINUX)
-  return GetTaskGroupByTaskId(task_id)->open_fd_count();
-#else
-  return -1;
-#endif  // defined(OS_LINUX)
-}
-
-bool TaskManagerImpl::IsTaskOnBackgroundedProcess(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->is_backgrounded();
-}
-
-const base::string16& TaskManagerImpl::GetTitle(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->title();
-}
-
-const std::string& TaskManagerImpl::GetTaskNameForRappor(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->rappor_sample_name();
-}
-
-base::string16 TaskManagerImpl::GetProfileName(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->GetProfileName();
-}
-
-const gfx::ImageSkia& TaskManagerImpl::GetIcon(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->icon();
-}
-
-const base::ProcessHandle& TaskManagerImpl::GetProcessHandle(
-    TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->process_handle();
-}
-
-const base::ProcessId& TaskManagerImpl::GetProcessId(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->process_id();
-}
-
-Task::Type TaskManagerImpl::GetType(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->GetType();
-}
-
-int TaskManagerImpl::GetTabId(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->GetTabId();
-}
-
-int TaskManagerImpl::GetChildProcessUniqueId(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->GetChildProcessUniqueID();
-}
-
-void TaskManagerImpl::GetTerminationStatus(TaskId task_id,
-                                           base::TerminationStatus* out_status,
-                                           int* out_error_code) const {
-  GetTaskByTaskId(task_id)->GetTerminationStatus(out_status, out_error_code);
-}
-
-int64_t TaskManagerImpl::GetNetworkUsage(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->network_usage();
-}
-
-int64_t TaskManagerImpl::GetProcessTotalNetworkUsage(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->per_process_network_usage();
-}
-
-int64_t TaskManagerImpl::GetSqliteMemoryUsed(TaskId task_id) const {
-  return GetTaskByTaskId(task_id)->GetSqliteMemoryUsed();
-}
-
-bool TaskManagerImpl::GetV8Memory(TaskId task_id,
-                                  int64_t* allocated,
-                                  int64_t* used) const {
-  const Task* task = GetTaskByTaskId(task_id);
-  if (!task->ReportsV8Memory())
-    return false;
-
-  *allocated = task->GetV8MemoryAllocated();
-  *used = task->GetV8MemoryUsed();
-
-  return true;
-}
-
-bool TaskManagerImpl::GetWebCacheStats(
-    TaskId task_id,
-    blink::WebCache::ResourceTypeStats* stats) const {
-  const Task* task = GetTaskByTaskId(task_id);
-  if (!task->ReportsWebCacheStats())
-    return false;
-
-  *stats = task->GetWebCacheStats();
-
-  return true;
-}
-
-const TaskIdList& TaskManagerImpl::GetTaskIdsList() const {
-  DCHECK(is_running_) << "Task manager is not running. You must observe the "
-      "task manager for it to start running";
-
-  if (sorted_task_ids_.empty()) {
-    // |comparator| groups and sorts by subtask-ness (to push all subtasks to be
-    // last), then by process type (e.g. the browser process should be first;
-    // renderer processes should be together), then tab id (processes used by
-    // the same tab should be kept together, and a tab should have a stable
-    // position in the list as it cycles through processes, and tab creation
-    // order is meaningful), and finally by task id (when all else is equal, put
-    // the oldest tasks first).
-    auto comparator = [](const Task* a, const Task* b) -> bool {
-      return std::make_tuple(a->HasParentTask(), a->GetType(), a->GetTabId(),
-                             a->task_id()) <
-             std::make_tuple(b->HasParentTask(), b->GetType(), b->GetTabId(),
-                             b->task_id());
-    };
-
-    const size_t num_groups = task_groups_by_proc_id_.size();
-    const size_t num_tasks = task_groups_by_task_id_.size();
-
-    // Populate |tasks_to_visit| with one task from each group.
-    std::vector<const Task*> tasks_to_visit;
-    tasks_to_visit.reserve(num_groups);
-    std::unordered_map<const Task*, std::vector<const Task*>> children;
-    for (const auto& groups_pair : task_groups_by_proc_id_) {
-      // The first task in the group (per |comparator|) is the one used for
-      // sorting the group relative to other groups.
-      const std::vector<Task*>& tasks = groups_pair.second->tasks();
-      Task* group_task =
-          *std::min_element(tasks.begin(), tasks.end(), comparator);
-      tasks_to_visit.push_back(group_task);
-
-      // Build the parent-to-child map, for use later.
-      for (const Task* task : tasks) {
-        if (task->HasParentTask())
-          children[task->GetParentTask()].push_back(task);
-        else
-          DCHECK(!group_task->HasParentTask());
-      }
-    }
-
-    // Now sort |tasks_to_visit| in reverse order (putting the browser process
-    // at back()). We will treat it as a stack from now on.
-    std::sort(tasks_to_visit.rbegin(), tasks_to_visit.rend(), comparator);
-    DCHECK_EQ(Task::BROWSER, tasks_to_visit.back()->GetType());
-
-    // Using |tasks_to_visit| as a stack, and |visited_groups| to track which
-    // groups we've already added, add groups to |sorted_task_ids_| until all
-    // groups have been added.
-    sorted_task_ids_.reserve(num_tasks);
-    std::unordered_set<TaskGroup*> visited_groups;
-    visited_groups.reserve(num_groups);
-    std::vector<Task*> current_group_tasks;  // Outside loop for fewer mallocs.
-    while (visited_groups.size() < num_groups) {
-      DCHECK(!tasks_to_visit.empty());
-      TaskGroup* current_group =
-          GetTaskGroupByTaskId(tasks_to_visit.back()->task_id());
-      tasks_to_visit.pop_back();
-
-      // Mark |current_group| as visited. If this fails, we've already added
-      // the group, and should skip over it.
-      if (!visited_groups.insert(current_group).second)
-        continue;
-
-      // Make a copy of |current_group->tasks()|, sort it, and append the ids.
-      current_group_tasks = current_group->tasks();
-      std::sort(current_group_tasks.begin(), current_group_tasks.end(),
-                comparator);
-      for (Task* task : current_group_tasks)
-        sorted_task_ids_.push_back(task->task_id());
-
-      // Find the children of the tasks we just added, and push them into
-      // |tasks_to_visit|, so that we visit them soon. Work in reverse order,
-      // so that we visit them in forward order.
-      for (Task* parent : base::Reversed(current_group_tasks)) {
-        auto children_of_parent = children.find(parent);
-        if (children_of_parent != children.end()) {
-          // Sort children[parent], and then append in reversed order.
-          std::sort(children_of_parent->second.begin(),
-                    children_of_parent->second.end(), comparator);
-          tasks_to_visit.insert(tasks_to_visit.end(),
-                                children_of_parent->second.rbegin(),
-                                children_of_parent->second.rend());
-        }
-      }
-    }
-    DCHECK_EQ(num_tasks, sorted_task_ids_.size());
-  }
-
-  return sorted_task_ids_;
-}
-
-TaskIdList TaskManagerImpl::GetIdsOfTasksSharingSameProcess(
-    TaskId task_id) const {
-  DCHECK(is_running_) << "Task manager is not running. You must observe the "
-      "task manager for it to start running";
-
-  TaskIdList result;
-  TaskGroup* group = GetTaskGroupByTaskId(task_id);
-  if (group) {
-    result.reserve(group->tasks().size());
-    for (Task* task : group->tasks())
-      result.push_back(task->task_id());
-  }
-  return result;
-}
-
-size_t TaskManagerImpl::GetNumberOfTasksOnSameProcess(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->num_tasks();
-}
-
-TaskId TaskManagerImpl::GetTaskIdForWebContents(
-    content::WebContents* web_contents) const {
-  if (!web_contents)
-    return -1;
-  content::RenderFrameHost* rfh = web_contents->GetMainFrame();
-  Task* task =
-      GetTaskByPidOrRoute(0, rfh->GetProcess()->GetID(), rfh->GetRoutingID());
-  if (!task)
-    return -1;
-  return task->task_id();
-}
-
-void TaskManagerImpl::TaskAdded(Task* task) {
-  DCHECK(task);
-
-  const base::ProcessId proc_id = task->process_id();
-  const TaskId task_id = task->task_id();
-
-  std::unique_ptr<TaskGroup>& task_group = task_groups_by_proc_id_[proc_id];
-  if (!task_group)
-    task_group.reset(new TaskGroup(task->process_handle(), proc_id,
-                                   on_background_data_ready_callback_,
-                                   shared_sampler_, blocking_pool_runner_));
-
-  task_group->AddTask(task);
-
-  task_groups_by_task_id_[task_id] = task_group.get();
-
-  // Invalidate the cached sorted IDs by clearing the list.
-  sorted_task_ids_.clear();
-
-  NotifyObserversOnTaskAdded(task_id);
-}
-
-void TaskManagerImpl::TaskRemoved(Task* task) {
-  DCHECK(task);
-
-  const base::ProcessId proc_id = task->process_id();
-  const TaskId task_id = task->task_id();
-
-  DCHECK(task_groups_by_proc_id_.count(proc_id));
-
-  NotifyObserversOnTaskToBeRemoved(task_id);
-
-  TaskGroup* task_group = GetTaskGroupByTaskId(task_id);
-  task_group->RemoveTask(task);
-  task_groups_by_task_id_.erase(task_id);
-
-  if (task_group->empty())
-    task_groups_by_proc_id_.erase(proc_id);  // Deletes |task_group|.
-
-  // Invalidate the cached sorted IDs by clearing the list.
-  sorted_task_ids_.clear();
-}
-
-void TaskManagerImpl::TaskUnresponsive(Task* task) {
-  DCHECK(task);
-  NotifyObserversOnTaskUnresponsive(task->task_id());
-}
-
-void TaskManagerImpl::OnVideoMemoryUsageStatsUpdate(
-    const gpu::VideoMemoryUsageStats& gpu_memory_stats) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  gpu_memory_stats_ = gpu_memory_stats;
-}
-
-// static
-void TaskManagerImpl::OnMultipleBytesReadUI(
-    std::vector<BytesReadParam>* params) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  DCHECK(params);
-
-  for (BytesReadParam& param : *params) {
-    if (!GetInstance()->UpdateTasksWithBytesRead(param)) {
-      // We can't match a task to the notification.  That might mean the
-      // tab that started a download was closed, or the request may have had
-      // no originating task associated with it in the first place.
-      // We attribute orphaned/unaccounted activity to the Browser process.
-      DCHECK(param.origin_pid || (param.child_id != -1));
-
-      param.origin_pid = 0;
-      param.child_id = param.route_id = -1;
-
-      GetInstance()->UpdateTasksWithBytesRead(param);
-    }
-  }
-}
-
-void TaskManagerImpl::Refresh() {
-  if (IsResourceRefreshEnabled(REFRESH_TYPE_GPU_MEMORY)) {
-    content::GpuDataManager::GetInstance()->
-        RequestVideoMemoryUsageStatsUpdate();
-  }
-
-  for (auto& groups_itr : task_groups_by_proc_id_) {
-    groups_itr.second->Refresh(gpu_memory_stats_,
-                               GetCurrentRefreshTime(),
-                               enabled_resources_flags());
-  }
-
-  NotifyObserversOnRefresh(GetTaskIdsList());
-}
-
-void TaskManagerImpl::StartUpdating() {
-  if (is_running_)
-    return;
-
-  is_running_ = true;
-
-  for (const auto& provider : task_providers_)
-    provider->SetObserver(this);
-
-  io_thread_helper_manager_.reset(new IoThreadHelperManager);
-}
-
-void TaskManagerImpl::StopUpdating() {
-  if (!is_running_)
-    return;
-
-  is_running_ = false;
-
-  io_thread_helper_manager_.reset();
-
-  for (const auto& provider : task_providers_)
-    provider->ClearObserver();
-
-  task_groups_by_proc_id_.clear();
-  task_groups_by_task_id_.clear();
-  sorted_task_ids_.clear();
-}
-
-Task* TaskManagerImpl::GetTaskByPidOrRoute(int origin_pid,
-                                           int child_id,
-                                           int route_id) const {
-  for (const auto& task_provider : task_providers_) {
-    Task* task =
-        task_provider->GetTaskOfUrlRequest(origin_pid, child_id, route_id);
-    if (task)
-      return task;
-  }
-  return nullptr;
-}
-
-bool TaskManagerImpl::UpdateTasksWithBytesRead(const BytesReadParam& param) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  Task* task =
-      GetTaskByPidOrRoute(param.origin_pid, param.child_id, param.route_id);
-  if (task) {
-    task->OnNetworkBytesRead(param.byte_count);
-    return true;
-  }
-
-  // Couldn't match the bytes to any existing task.
-  return false;
-}
-
-TaskGroup* TaskManagerImpl::GetTaskGroupByTaskId(TaskId task_id) const {
-  auto it = task_groups_by_task_id_.find(task_id);
-  DCHECK(it != task_groups_by_task_id_.end());
-  return it->second;
-}
-
-Task* TaskManagerImpl::GetTaskByTaskId(TaskId task_id) const {
-  return GetTaskGroupByTaskId(task_id)->GetTaskById(task_id);
-}
-
-void TaskManagerImpl::OnTaskGroupBackgroundCalculationsDone() {
-  // TODO(afakhry): There should be a better way for doing this!
-  bool are_all_processes_data_ready = true;
-  for (const auto& groups_itr : task_groups_by_proc_id_) {
-    are_all_processes_data_ready &=
-        groups_itr.second->AreBackgroundCalculationsDone();
-  }
-  if (are_all_processes_data_ready) {
-    NotifyObserversOnRefreshWithBackgroundCalculations(GetTaskIdsList());
-    for (const auto& groups_itr : task_groups_by_proc_id_)
-      groups_itr.second->ClearCurrentBackgroundCalculationsFlags();
-  }
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_manager_impl.h b/chrome/browser/task_manager/sampling/task_manager_impl.h
deleted file mode 100644
index eba0e8c..0000000
--- a/chrome/browser/task_manager/sampling/task_manager_impl.h
+++ /dev/null
@@ -1,173 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IMPL_H_
-#define CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IMPL_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "base/lazy_instance.h"
-#include "base/macros.h"
-#include "base/memory/scoped_vector.h"
-#include "base/sequenced_task_runner.h"
-#include "chrome/browser/task_manager/providers/task_provider.h"
-#include "chrome/browser/task_manager/providers/task_provider_observer.h"
-#include "chrome/browser/task_manager/sampling/task_group.h"
-#include "chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
-#include "content/public/browser/gpu_data_manager_observer.h"
-#include "gpu/ipc/common/memory_stats.h"
-
-namespace task_manager {
-
-class SharedSampler;
-
-// Defines a concrete implementation of the TaskManagerInterface.
-class TaskManagerImpl :
-    public TaskManagerInterface,
-    public TaskProviderObserver,
-    content::GpuDataManagerObserver {
- public:
-  ~TaskManagerImpl() override;
-
-  static TaskManagerImpl* GetInstance();
-
-  // task_manager::TaskManagerInterface:
-  void ActivateTask(TaskId task_id) override;
-  bool IsTaskKillable(TaskId task_id) override;
-  void KillTask(TaskId task_id) override;
-  double GetCpuUsage(TaskId task_id) const override;
-  int64_t GetPhysicalMemoryUsage(TaskId task_id) const override;
-  int64_t GetPrivateMemoryUsage(TaskId task_id) const override;
-  int64_t GetSharedMemoryUsage(TaskId task_id) const override;
-  int64_t GetSwappedMemoryUsage(TaskId task_id) const override;
-  int64_t GetGpuMemoryUsage(TaskId task_id,
-                            bool* has_duplicates) const override;
-  int GetIdleWakeupsPerSecond(TaskId task_id) const override;
-  int GetNaClDebugStubPort(TaskId task_id) const override;
-  void GetGDIHandles(TaskId task_id,
-                     int64_t* current,
-                     int64_t* peak) const override;
-  void GetUSERHandles(TaskId task_id,
-                      int64_t* current,
-                      int64_t* peak) const override;
-  int GetOpenFdCount(TaskId task_id) const override;
-  bool IsTaskOnBackgroundedProcess(TaskId task_id) const override;
-  const base::string16& GetTitle(TaskId task_id) const override;
-  const std::string& GetTaskNameForRappor(TaskId task_id) const override;
-  base::string16 GetProfileName(TaskId task_id) const override;
-  const gfx::ImageSkia& GetIcon(TaskId task_id) const override;
-  const base::ProcessHandle& GetProcessHandle(TaskId task_id) const override;
-  const base::ProcessId& GetProcessId(TaskId task_id) const override;
-  Task::Type GetType(TaskId task_id) const override;
-  int GetTabId(TaskId task_id) const override;
-  int GetChildProcessUniqueId(TaskId task_id) const override;
-  void GetTerminationStatus(TaskId task_id,
-                            base::TerminationStatus* out_status,
-                            int* out_error_code) const override;
-  int64_t GetNetworkUsage(TaskId task_id) const override;
-  int64_t GetProcessTotalNetworkUsage(TaskId task_id) const override;
-  int64_t GetSqliteMemoryUsed(TaskId task_id) const override;
-  bool GetV8Memory(TaskId task_id,
-                   int64_t* allocated,
-                   int64_t* used) const override;
-  bool GetWebCacheStats(
-      TaskId task_id,
-      blink::WebCache::ResourceTypeStats* stats) const override;
-  const TaskIdList& GetTaskIdsList() const override;
-  TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const override;
-  size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const override;
-  TaskId GetTaskIdForWebContents(
-      content::WebContents* web_contents) const override;
-
-  // task_manager::TaskProviderObserver:
-  void TaskAdded(Task* task) override;
-  void TaskRemoved(Task* task) override;
-  void TaskUnresponsive(Task* task) override;
-
-  // content::GpuDataManagerObserver:
-  void OnVideoMemoryUsageStatsUpdate(
-      const gpu::VideoMemoryUsageStats& gpu_memory_stats) override;
-
-  // The notification method on the UI thread when multiple bytes are read
-  // from URLRequests. This will be called by the |io_thread_helper_|
-  static void OnMultipleBytesReadUI(std::vector<BytesReadParam>* params);
-
- private:
-  friend struct base::DefaultLazyInstanceTraits<TaskManagerImpl>;
-
-  TaskManagerImpl();
-
-  // task_manager::TaskManagerInterface:
-  void Refresh() override;
-  void StartUpdating() override;
-  void StopUpdating() override;
-
-  // Lookup a task by its pid, child_id and possibly route_id.
-  Task* GetTaskByPidOrRoute(int pid, int child_id, int route_id) const;
-
-  // Based on |param| the appropriate task will be updated by its network usage.
-  // Returns true if it was able to match |param| to an existing task, returns
-  // false otherwise, at which point the caller must explicitly match these
-  // bytes to the browser process by calling this method again with
-  // |param.origin_pid = 0| and |param.child_id = param.route_id = -1|.
-  bool UpdateTasksWithBytesRead(const BytesReadParam& param);
-
-  TaskGroup* GetTaskGroupByTaskId(TaskId task_id) const;
-  Task* GetTaskByTaskId(TaskId task_id) const;
-
-  // Called back by a TaskGroup when the resource calculations done on the
-  // background thread has completed.
-  void OnTaskGroupBackgroundCalculationsDone();
-
-  const base::Closure on_background_data_ready_callback_;
-
-  // Map TaskGroups by the IDs of the processes they represent.
-  std::map<base::ProcessId, std::unique_ptr<TaskGroup>> task_groups_by_proc_id_;
-
-  // Map each task by its ID to the TaskGroup on which it resides.
-  // Keys are unique but values will have duplicates (i.e. multiple tasks
-  // running on the same process represented by a single TaskGroup).
-  std::map<TaskId, TaskGroup*> task_groups_by_task_id_;
-
-  // A cached sorted list of the task IDs.
-  mutable std::vector<TaskId> sorted_task_ids_;
-
-  // The manager of the IO thread helper used to handle network bytes
-  // notifications on IO thread. The manager itself lives on the UI thread, but
-  // the IO thread helper lives entirely on the IO thread.
-  std::unique_ptr<IoThreadHelperManager> io_thread_helper_manager_;
-
-  // The list of the task providers that are owned and observed by this task
-  // manager implementation.
-  std::vector<std::unique_ptr<TaskProvider>> task_providers_;
-
-  // The current GPU memory usage stats that was last received from the
-  // GpuDataManager.
-  gpu::VideoMemoryUsageStats gpu_memory_stats_;
-
-  // The specific blocking pool SequencedTaskRunner that will be used to make
-  // sure TaskGroupSampler posts their refreshes serially.
-  scoped_refptr<base::SequencedTaskRunner> blocking_pool_runner_;
-
-  // A special sampler shared with all instances of TaskGroup that calculates a
-  // subset of resources for all processes at once.
-  scoped_refptr<SharedSampler> shared_sampler_;
-
-  // This will be set to true while there are observers and the task manager is
-  // running.
-  bool is_running_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerImpl);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IMPL_H_
diff --git a/chrome/browser/task_manager/sampling/task_manager_impl_unittest.cc b/chrome/browser/task_manager/sampling/task_manager_impl_unittest.cc
deleted file mode 100644
index 52a2dee..0000000
--- a/chrome/browser/task_manager/sampling/task_manager_impl_unittest.cc
+++ /dev/null
@@ -1,214 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/macros.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/task_manager/providers/task.h"
-#include "chrome/browser/task_manager/sampling/task_manager_impl.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "content/public/test/test_browser_thread_bundle.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace task_manager {
-
-namespace {
-
-// A Task for unittests, not backed by a real process, that can report any given
-// value.
-class FakeTask : public Task {
- public:
-  FakeTask(base::ProcessId process_id,
-           Type type,
-           const std::string& title,
-           int tab_id)
-      : Task(base::ASCIIToUTF16(title),
-             "FakeTask",
-             nullptr,
-             base::kNullProcessHandle,
-             process_id),
-        type_(type),
-        parent_(nullptr),
-        tab_id_(tab_id) {
-    TaskManagerImpl::GetInstance()->TaskAdded(this);
-  }
-
-  ~FakeTask() override { TaskManagerImpl::GetInstance()->TaskRemoved(this); }
-
-  Type GetType() const override { return type_; }
-
-  int GetChildProcessUniqueID() const override { return 0; }
-
-  const Task* GetParentTask() const override { return parent_; }
-
-  int GetTabId() const override { return tab_id_; }
-
-  void SetParent(Task* parent) { parent_ = parent; }
-
- private:
-  Type type_;
-  Task* parent_;
-  int tab_id_;
-
-  DISALLOW_COPY_AND_ASSIGN(FakeTask);
-};
-
-}  // namespace
-
-class TaskManagerImplTest : public testing::Test, public TaskManagerObserver {
- public:
-  TaskManagerImplTest()
-      : TaskManagerObserver(base::TimeDelta::FromSeconds(1),
-                            REFRESH_TYPE_NONE) {
-    TaskManagerImpl::GetInstance()->AddObserver(this);
-  }
-  ~TaskManagerImplTest() override {
-    tasks_.clear();
-    observed_task_manager()->RemoveObserver(this);
-  }
-
-  FakeTask* AddTask(int pid_offset,
-                    Task::Type type,
-                    const std::string& title,
-                    int tab_id) {
-    // Offset based on the current process id, to avoid collisions with the
-    // browser process task.
-    base::ProcessId process_id = base::GetCurrentProcId() + pid_offset;
-    tasks_.emplace_back(new FakeTask(process_id, type, title, tab_id));
-    return tasks_.back().get();
-  }
-
-  std::string DumpSortedTasks() {
-    std::string result;
-    for (TaskId task_id : observed_task_manager()->GetTaskIdsList()) {
-      result += base::UTF16ToUTF8(observed_task_manager()->GetTitle(task_id));
-      result += "\n";
-    }
-    return result;
-  }
-
- private:
-  content::TestBrowserThreadBundle thread_bundle_;
-  std::vector<std::unique_ptr<FakeTask>> tasks_;
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerImplTest);
-};
-
-TEST_F(TaskManagerImplTest, SortingTypes) {
-  AddTask(100, Task::GPU, "Gpu Process", -1);
-
-  Task* tab1 = AddTask(200, Task::RENDERER, "Tab One", 10);
-  AddTask(400, Task::EXTENSION, "Extension Subframe: Tab One", 10)
-      ->SetParent(tab1);
-  AddTask(300, Task::RENDERER, "Subframe: Tab One", 10)->SetParent(tab1);
-
-  Task* tab2 =
-      AddTask(200, Task::RENDERER, "Tab Two: sharing process with Tab One", 20);
-
-  AddTask(301, Task::RENDERER, "Subframe: Tab Two", 20)->SetParent(tab2);
-  AddTask(400, Task::EXTENSION, "Extension Subframe: Tab Two", 20)
-      ->SetParent(tab2);
-
-  AddTask(600, Task::ARC, "ARC", -1);
-  AddTask(800, Task::UTILITY, "Utility One", -1);
-  AddTask(700, Task::UTILITY, "Utility Two", -1);
-  AddTask(1000, Task::GUEST, "Guest", 20);
-  AddTask(900, Task::WORKER, "Worker", -1);
-  AddTask(500, Task::ZYGOTE, "Zygote", -1);
-
-  AddTask(300, Task::RENDERER, "Subframe: Tab One (2)", 10)->SetParent(tab1);
-  AddTask(300, Task::RENDERER, "Subframe: Tab One (third)", 10)
-      ->SetParent(tab1);
-  AddTask(300, Task::RENDERER, "Subframe: Tab One (4)", 10)->SetParent(tab1);
-
-  EXPECT_EQ(
-      "Browser\n"
-      "Gpu Process\n"
-      "ARC\n"
-      "Zygote\n"
-      "Utility One\n"
-      "Utility Two\n"
-      "Tab One\n"
-      "Tab Two: sharing process with Tab One\n"
-      "Subframe: Tab One\n"
-      "Subframe: Tab One (2)\n"
-      "Subframe: Tab One (third)\n"
-      "Subframe: Tab One (4)\n"
-      "Extension Subframe: Tab One\n"
-      "Extension Subframe: Tab Two\n"
-      "Subframe: Tab Two\n"
-      "Guest\n"
-      "Worker\n",
-      DumpSortedTasks());
-}
-
-TEST_F(TaskManagerImplTest, SortingCycles) {
-  // Two tabs, with subframes in the other's process. This induces a cycle in
-  // the TaskGroup dependencies, without being a cycle in the Tasks. This can
-  // happen in practice.
-  Task* tab1 = AddTask(200, Task::RENDERER, "Tab 1: Process 200", 10);
-  AddTask(300, Task::RENDERER, "Subframe in Tab 1: Process 300", 10)
-      ->SetParent(tab1);
-  Task* tab2 = AddTask(300, Task::RENDERER, "Tab 2: Process 300", 20);
-  AddTask(200, Task::RENDERER, "Subframe in Tab 2: Process 200", 20)
-      ->SetParent(tab2);
-
-  // Simulated GPU process.
-  AddTask(100, Task::GPU, "Gpu Process", -1);
-
-  // Two subframes that list each other as a parent (a true cycle). This
-  // shouldn't happen in practice, but we want the sorting code to handle it
-  // gracefully.
-  FakeTask* cycle1 = AddTask(501, Task::SANDBOX_HELPER, "Cycle 1", -1);
-  FakeTask* cycle2 = AddTask(500, Task::ARC, "Cycle 2", -1);
-  cycle1->SetParent(cycle2);
-  cycle2->SetParent(cycle1);
-
-  // A cycle where both elements are in the same group.
-  FakeTask* cycle3 = AddTask(600, Task::SANDBOX_HELPER, "Cycle 3", -1);
-  FakeTask* cycle4 = AddTask(600, Task::ARC, "Cycle 4", -1);
-  cycle3->SetParent(cycle4);
-  cycle4->SetParent(cycle3);
-
-  // Tasks listing a cycle as their parent.
-  FakeTask* lollipop5 = AddTask(701, Task::EXTENSION, "Child of Cycle 3", -1);
-  lollipop5->SetParent(cycle3);
-  FakeTask* lollipop6 = AddTask(700, Task::PLUGIN, "Child of Cycle 4", -1);
-  lollipop6->SetParent(cycle4);
-
-  // A task listing itself as parent.
-  FakeTask* self_cycle = AddTask(800, Task::RENDERER, "Self Cycle", 5);
-  self_cycle->SetParent(self_cycle);
-
-  // Add a plugin child to tab1 and tab2.
-  AddTask(900, Task::PLUGIN, "Plugin: Tab 2", 20)->SetParent(tab1);
-  AddTask(901, Task::PLUGIN, "Plugin: Tab 1", 10)->SetParent(tab1);
-
-  // Finish with a normal renderer task.
-  AddTask(903, Task::RENDERER, "Tab: Normal Renderer", 30);
-
-  // Cycles should wind up on the bottom of the list.
-  EXPECT_EQ(
-      "Browser\n"
-      "Gpu Process\n"
-      "Tab 1: Process 200\n"
-      "Subframe in Tab 2: Process 200\n"
-      "Tab 2: Process 300\n"
-      "Subframe in Tab 1: Process 300\n"
-      "Plugin: Tab 1\n"
-      "Plugin: Tab 2\n"
-      "Tab: Normal Renderer\n"
-      "Cycle 2\n"           // ARC
-      "Cycle 1\n"           // Child of 2
-      "Cycle 4\n"           // ARC; task_id > Cycle 2's
-      "Cycle 3\n"           // Same-process child of 4 (SANDBOX_HELPER > ARC)
-      "Child of Cycle 4\n"  // Child of 4
-      "Child of Cycle 3\n"  // Child of 3
-      "Self Cycle\n",       // RENDERER (> ARC)
-      DumpSortedTasks());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.cc b/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.cc
deleted file mode 100644
index ae01667..0000000
--- a/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.cc
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h"
-
-#include "chrome/browser/task_manager/sampling/task_manager_impl.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-
-namespace task_manager {
-
-namespace {
-
-TaskManagerIoThreadHelper* g_io_thread_helper = nullptr;
-
-}  // namespace
-
-IoThreadHelperManager::IoThreadHelperManager() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO,
-      FROM_HERE,
-      base::Bind(&TaskManagerIoThreadHelper::CreateInstance));
-}
-
-IoThreadHelperManager::~IoThreadHelperManager() {
-  // This may be called at exit time when the main thread is no longer
-  // registered as the UI thread.
-  DCHECK(
-      content::BrowserThread::CurrentlyOn(content::BrowserThread::UI) ||
-      !content::BrowserThread::IsMessageLoopValid(content::BrowserThread::UI));
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO,
-      FROM_HERE,
-      base::Bind(&TaskManagerIoThreadHelper::DeleteInstance));
-}
-
-// static
-void TaskManagerIoThreadHelper::CreateInstance() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-  DCHECK(!g_io_thread_helper);
-
-  g_io_thread_helper = new TaskManagerIoThreadHelper;
-}
-
-// static
-void TaskManagerIoThreadHelper::DeleteInstance() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  delete g_io_thread_helper;
-  g_io_thread_helper = nullptr;
-}
-
-// static
-void TaskManagerIoThreadHelper::OnRawBytesRead(const net::URLRequest& request,
-                                               int64_t bytes_read) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  if (g_io_thread_helper)
-    g_io_thread_helper->OnNetworkBytesRead(request, bytes_read);
-}
-
-TaskManagerIoThreadHelper::TaskManagerIoThreadHelper() : weak_factory_(this) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-}
-
-TaskManagerIoThreadHelper::~TaskManagerIoThreadHelper() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-}
-
-void TaskManagerIoThreadHelper::OnMultipleBytesReadIO() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  DCHECK(!bytes_read_buffer_.empty());
-
-  std::vector<BytesReadParam>* bytes_read_buffer =
-      new std::vector<BytesReadParam>();
-  bytes_read_buffer_.swap(*bytes_read_buffer);
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI,
-      FROM_HERE,
-      base::Bind(&TaskManagerImpl::OnMultipleBytesReadUI,
-                 base::Owned(bytes_read_buffer)));
-}
-
-void TaskManagerIoThreadHelper::OnNetworkBytesRead(
-    const net::URLRequest& request, int64_t bytes_read) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  // Only net::URLRequestJob instances created by the ResourceDispatcherHost
-  // have an associated ResourceRequestInfo and a render frame associated.
-  // All other jobs will have -1 returned for the render process child and
-  // routing ids - the jobs may still match a resource based on their origin id,
-  // otherwise BytesRead() will attribute the activity to the Browser resource.
-  const content::ResourceRequestInfo* info =
-      content::ResourceRequestInfo::ForRequest(&request);
-  int child_id = -1;
-  int route_id = -1;
-  if (info)
-    info->GetAssociatedRenderFrame(&child_id, &route_id);
-
-  // Get the origin PID of the request's originator.  This will only be set for
-  // plugins - for renderer or browser initiated requests it will be zero.
-  int origin_pid = info ? info->GetOriginPID() : 0;
-
-  if (bytes_read_buffer_.empty()) {
-    // Schedule a task to process the received bytes requests a second from now.
-    // We're trying to calculate the tasks' network usage speed as bytes per
-    // second so we collect as many requests during one seconds before the below
-    // delayed TaskManagerIoThreadHelper::OnMultipleBytesReadIO() process them
-    // after one second from now.
-    content::BrowserThread::PostDelayedTask(
-        content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&TaskManagerIoThreadHelper::OnMultipleBytesReadIO,
-                   weak_factory_.GetWeakPtr()),
-        base::TimeDelta::FromSeconds(1));
-  }
-
-  bytes_read_buffer_.push_back(
-      BytesReadParam(origin_pid, child_id, route_id, bytes_read));
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h b/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h
deleted file mode 100644
index ff5315b..0000000
--- a/chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h
+++ /dev/null
@@ -1,98 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
-#define CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
-
-#include <stdint.h>
-
-#include <vector>
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-
-namespace net {
-class URLRequest;
-}  // namespace net
-
-namespace task_manager {
-
-// Defines a wrapper of values that will be sent from IO to UI thread upon
-// reception of bytes read notifications.
-struct BytesReadParam {
-  // The PID of the originating process of the URLRequest, if the request is
-  // sent on behalf of another process. Otherwise it's 0.
-  int origin_pid;
-
-  // The unique ID of the host of the child process requestor.
-  int child_id;
-
-  // The ID of the IPC route for the URLRequest (this identifies the
-  // RenderView or like-thing in the renderer that the request gets routed
-  // to).
-  int route_id;
-
-  // The number of bytes read.
-  int64_t byte_count;
-
-  BytesReadParam(int origin_pid,
-                 int child_id,
-                 int route_id,
-                 int64_t byte_count)
-      : origin_pid(origin_pid),
-        child_id(child_id),
-        route_id(route_id),
-        byte_count(byte_count) {
-  }
-};
-
-// Defines a utility class used to schedule the creation and removal of the
-// TaskManagerIoThreadHelper on the IO thread.
-class IoThreadHelperManager {
- public:
-  IoThreadHelperManager();
-  ~IoThreadHelperManager();
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(IoThreadHelperManager);
-};
-
-// Defines a class used by the task manager to receive notifications of the
-// network bytes read by the various tasks.
-// This object lives entirely only on the IO thread.
-class TaskManagerIoThreadHelper {
- public:
-  // Create and delete the instance of this class. They must be called on the IO
-  // thread.
-  static void CreateInstance();
-  static void DeleteInstance();
-
-  // This is used to forward the call to update the network bytes from the
-  // TaskManagerInterface if the new task manager is enabled.
-  static void OnRawBytesRead(const net::URLRequest& request,
-                             int64_t bytes_read);
-
- private:
-  TaskManagerIoThreadHelper();
-  ~TaskManagerIoThreadHelper();
-
-  // We gather multiple notifications on the IO thread in one second before a
-  // call is made to the following function to start the processing.
-  void OnMultipleBytesReadIO();
-
-  // This will update the task manager with the network bytes read.
-  void OnNetworkBytesRead(const net::URLRequest& request, int64_t bytes_read);
-
-  // This buffer will be filled on IO thread with information about the number
-  // of bytes read from URLRequests.
-  std::vector<BytesReadParam> bytes_read_buffer_;
-
-  base::WeakPtrFactory<TaskManagerIoThreadHelper> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerIoThreadHelper);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_SAMPLING_TASK_MANAGER_IO_THREAD_HELPER_H_
diff --git a/chrome/browser/task_manager/task_manager_browsertest.cc b/chrome/browser/task_manager/task_manager_browsertest.cc
deleted file mode 100644
index b6ce188..0000000
--- a/chrome/browser/task_manager/task_manager_browsertest.cc
+++ /dev/null
@@ -1,1295 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <stddef.h>
-#include <vector>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/path_service.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "build/build_config.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/chrome_notification_types.h"
-#include "chrome/browser/devtools/devtools_window_testing.h"
-#include "chrome/browser/extensions/extension_browsertest.h"
-#include "chrome/browser/extensions/extension_service.h"
-#include "chrome/browser/infobars/infobar_service.h"
-#include "chrome/browser/notifications/notification.h"
-#include "chrome/browser/notifications/notification_test_util.h"
-#include "chrome/browser/notifications/notification_ui_manager.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
-#include "chrome/browser/task_manager/task_manager_tester.h"
-#include "chrome/browser/ui/browser.h"
-#include "chrome/browser/ui/browser_commands.h"
-#include "chrome/browser/ui/browser_dialogs.h"
-#include "chrome/browser/ui/browser_window.h"
-#include "chrome/browser/ui/panels/panel.h"
-#include "chrome/browser/ui/panels/panel_manager.h"
-#include "chrome/browser/ui/tabs/tab_strip_model.h"
-#include "chrome/browser/web_applications/web_app.h"
-#include "chrome/common/chrome_switches.h"
-#include "chrome/grit/generated_resources.h"
-#include "chrome/test/base/in_process_browser_test.h"
-#include "chrome/test/base/ui_test_utils.h"
-#include "components/infobars/core/confirm_infobar_delegate.h"
-#include "components/infobars/core/infobar.h"
-#include "content/public/browser/notification_service.h"
-#include "content/public/browser/page_navigator.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/test/browser_test_utils.h"
-#include "content/public/test/content_browser_test_utils.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/common/extension.h"
-#include "net/dns/mock_host_resolver.h"
-#include "net/test/embedded_test_server/embedded_test_server.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/page_transition_types.h"
-
-using content::WebContents;
-using task_manager::browsertest_util::ColumnSpecifier;
-using task_manager::browsertest_util::MatchAboutBlankTab;
-using task_manager::browsertest_util::MatchAnyApp;
-using task_manager::browsertest_util::MatchAnyExtension;
-using task_manager::browsertest_util::MatchAnySubframe;
-using task_manager::browsertest_util::MatchAnyTab;
-using task_manager::browsertest_util::MatchAnyUtility;
-using task_manager::browsertest_util::MatchApp;
-using task_manager::browsertest_util::MatchExtension;
-using task_manager::browsertest_util::MatchSubframe;
-using task_manager::browsertest_util::MatchTab;
-using task_manager::browsertest_util::MatchUtility;
-using task_manager::browsertest_util::WaitForTaskManagerRows;
-using task_manager::browsertest_util::WaitForTaskManagerStatToExceed;
-
-namespace {
-
-const base::FilePath::CharType* kTitle1File = FILE_PATH_LITERAL("title1.html");
-
-}  // namespace
-
-class TaskManagerBrowserTest : public ExtensionBrowserTest {
- public:
-  TaskManagerBrowserTest() {}
-  ~TaskManagerBrowserTest() override {}
-
-  task_manager::TaskManagerTester* model() { return model_.get(); }
-
-  void ShowTaskManager() {
-    // Show the task manager. This populates the model, and helps with debugging
-    // (you see the task manager).
-    chrome::ShowTaskManager(browser());
-    model_ = task_manager::TaskManagerTester::Create(
-        base::Bind(&TaskManagerBrowserTest::TaskManagerTableModelSanityCheck,
-                   base::Unretained(this)));
-  }
-
-  void HideTaskManager() {
-    model_.reset();
-
-    // Hide the task manager, and wait for it to go.
-    chrome::HideTaskManager();
-    base::RunLoop().RunUntilIdle();  // OnWindowClosed happens asynchronously.
-  }
-
-  GURL GetTestURL() {
-    return ui_test_utils::GetTestUrl(
-        base::FilePath(base::FilePath::kCurrentDirectory),
-        base::FilePath(kTitle1File));
-  }
-
-  int FindResourceIndex(const base::string16& title) {
-    for (int i = 0; i < model_->GetRowCount(); ++i) {
-      if (title == model_->GetRowTitle(i))
-        return i;
-    }
-    return -1;
-  }
-
- protected:
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    ExtensionBrowserTest::SetUpCommandLine(command_line);
-
-    // Do not launch device discovery process.
-    command_line->AppendSwitch(switches::kDisableDeviceDiscoveryNotifications);
-  }
-
-  void TearDownOnMainThread() override { model_.reset(); }
-
-  void SetUpOnMainThread() override {
-    host_resolver()->AddRule("*", "127.0.0.1");
-
-    // Add content/test/data so we can use cross_site_iframe_factory.html
-    base::FilePath test_data_dir;
-    ASSERT_TRUE(base::PathService::Get(base::DIR_SOURCE_ROOT, &test_data_dir));
-    embedded_test_server()->ServeFilesFromDirectory(
-        test_data_dir.AppendASCII("content/test/data/"));
-    ASSERT_TRUE(embedded_test_server()->Start());
-    content::SetupCrossSiteRedirector(embedded_test_server());
-  }
-
- private:
-  void TaskManagerTableModelSanityCheck() {
-    // Ensure the groups are self-consistent.
-    for (int i = 0; i < model()->GetRowCount(); ++i) {
-      int start, length;
-      model()->GetRowsGroupRange(i, &start, &length);
-      for (int j = 0; j < length; ++j) {
-        int start2, length2;
-        model()->GetRowsGroupRange(start + j, &start2, &length2);
-        EXPECT_EQ(start, start2);
-        EXPECT_EQ(length, length2);
-      }
-    }
-  }
-
-  std::unique_ptr<task_manager::TaskManagerTester> model_;
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerBrowserTest);
-};
-
-class TaskManagerUtilityProcessBrowserTest : public TaskManagerBrowserTest {
- public:
-  TaskManagerUtilityProcessBrowserTest() {}
-
- protected:
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    TaskManagerBrowserTest::SetUpCommandLine(command_line);
-
-    // Enable out-of-process proxy resolver. Use a trivial PAC script to ensure
-    // that some javascript is being executed.
-    command_line->AppendSwitch(switches::kV8PacMojoOutOfProcess);
-    command_line->AppendSwitchASCII(
-        switches::kProxyPacUrl,
-        "data:,function FindProxyForURL(url, host){return \"DIRECT;\";}");
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerUtilityProcessBrowserTest);
-};
-
-// Parameterized variant of TaskManagerBrowserTest which runs with/without
-// --site-per-process, which enables out of process iframes (OOPIFs).
-class TaskManagerOOPIFBrowserTest : public TaskManagerBrowserTest,
-                                    public testing::WithParamInterface<bool> {
- public:
-  TaskManagerOOPIFBrowserTest() {}
-
- protected:
-  void SetUpCommandLine(base::CommandLine* command_line) override {
-    TaskManagerBrowserTest::SetUpCommandLine(command_line);
-    if (GetParam())
-      content::IsolateAllSitesForTesting(command_line);
-  }
-
-  bool ShouldExpectSubframes() {
-    return content::AreAllSitesIsolatedForTesting();
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerOOPIFBrowserTest);
-};
-
-INSTANTIATE_TEST_CASE_P(, TaskManagerOOPIFBrowserTest, ::testing::Bool());
-
-#if defined(OS_MACOSX) || defined(OS_LINUX)
-#define MAYBE_ShutdownWhileOpen DISABLED_ShutdownWhileOpen
-#else
-#define MAYBE_ShutdownWhileOpen ShutdownWhileOpen
-#endif
-
-// Regression test for http://crbug.com/13361
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, MAYBE_ShutdownWhileOpen) {
-  ShowTaskManager();
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeTabContentsChanges) {
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
-
-  // Open a new tab and make sure the task manager notices it.
-  AddTabAtIndex(0, GetTestURL(), ui::PAGE_TRANSITION_TYPED);
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-
-  // Close the tab and verify that we notice.
-  browser()->tab_strip_model()->CloseWebContentsAt(0,
-                                                   TabStripModel::CLOSE_NONE);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillTab) {
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
-
-  // Open a new tab and make sure the task manager notices it.
-  AddTabAtIndex(0, GetTestURL(), ui::PAGE_TRANSITION_TYPED);
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-
-  // Killing the tab via task manager should remove the row.
-  int tab = FindResourceIndex(MatchTab("title1.html"));
-  ASSERT_NE(-1, tab);
-  ASSERT_NE(-1, model()->GetTabId(tab));
-  model()->Kill(tab);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchTab("title1.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Tab should reappear in task manager upon reload.
-  chrome::Reload(browser(), CURRENT_TAB);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-}
-
-// Regression test for http://crbug.com/444945.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NavigateAwayFromHungRenderer) {
-  ShowTaskManager();
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  GURL url1(embedded_test_server()->GetURL("/title2.html"));
-  GURL url3(embedded_test_server()->GetURL("a.com", "/iframe.html"));
-
-  // Open a new tab and make sure the task manager notices it.
-  AddTabAtIndex(0, url1, ui::PAGE_TRANSITION_TYPED);
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  WebContents* tab1 = browser()->tab_strip_model()->GetActiveWebContents();
-
-  // Initiate a navigation that will create a new WebContents in the same
-  // SiteInstance. Then immediately hang the renderer so that title3.html can't
-  // load in this process.
-  content::WebContentsAddedObserver web_contents_added_observer;
-  int dummy_value = 0;
-  ASSERT_TRUE(content::ExecuteScriptAndExtractInt(
-      tab1->GetMainFrame(),
-      "window.open('title3.html', '_blank');\n"
-      "window.domAutomationController.send(55);\n"
-      "while(1);",
-      &dummy_value));
-
-  // Blocks until a new WebContents appears as a result of window.open().
-  WebContents* tab2 = web_contents_added_observer.GetWebContents();
-
-  // Make sure the new WebContents is in tab1's hung renderer process.
-  ASSERT_NE(nullptr, tab2);
-  ASSERT_NE(tab1, tab2);
-  ASSERT_EQ(tab1->GetMainFrame()->GetProcess(),
-            tab2->GetMainFrame()->GetProcess())
-      << "New WebContents must be in the same process as the old WebContents, "
-      << "so that the new tab doesn't finish loading (what this test is all "
-      << "about)";
-  ASSERT_EQ(tab1->GetSiteInstance(), tab2->GetSiteInstance())
-      << "New WebContents must initially be in the same site instance as the "
-      << "old WebContents";
-
-  // Now navigate this tab to a different site. This should wind up in a
-  // different renderer process, so it should complete and show up in the task
-  // manager.
-  tab2->OpenURL(content::OpenURLParams(url3, content::Referrer(), CURRENT_TAB,
-                                       ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticePanel) {
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
-                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                    .AppendASCII("1.0.0.0")));
-
-  // Open a new panel to an extension url.
-  GURL url(
-    "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/french_sentence.html");
-  Panel* docked_panel = PanelManager::GetInstance()->CreatePanel(
-      web_app::GenerateApplicationNameFromExtensionId(
-          last_loaded_extension_id()),
-      browser()->profile(), url, nullptr, gfx::Rect(300, 400),
-      PanelManager::CREATE_AS_DOCKED);
-  docked_panel->Show();
-
-  // Make sure that a task manager model created after the panel shows the
-  // existence of the panel and the extension.
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      1,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Create a second, detached panel.
-  Panel* detached_panel = PanelManager::GetInstance()->CreatePanel(
-      web_app::GenerateApplicationNameFromExtensionId(
-          last_loaded_extension_id()),
-      browser()->profile(), url, nullptr, gfx::Rect(150, 150),
-      PanelManager::CREATE_AS_DETACHED);
-  detached_panel->ShowInactive();
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      2, MatchExtension("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-                        "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyExtension()));
-
-  // Close the panels and verify that we notice.
-  docked_panel->Close();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      1, MatchExtension("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-                        "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-
-  detached_panel->Close();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      0,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticePanelChanges) {
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
-                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                    .AppendASCII("1.0.0.0")));
-
-  // Browser, the New Tab Page and Extension background page.
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Open a new panel to an extension url and make sure we notice that.
-  GURL url(
-    "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/french_sentence.html");
-  Panel* panel = PanelManager::GetInstance()->CreatePanel(
-      web_app::GenerateApplicationNameFromExtensionId(
-          last_loaded_extension_id()),
-      browser()->profile(),
-      url,
-      nullptr,
-      gfx::Rect(300, 400),
-      PanelManager::CREATE_AS_DOCKED);
-  panel->ShowInactive();
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      1,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Close the panel and verify that we notice.
-  panel->Close();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      0,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-
-  // Unload extension.
-  UnloadExtension(last_loaded_extension_id());
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-}
-
-// Kills a process that has more than one task manager entry.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillPanelViaExtensionResource) {
-  ShowTaskManager();
-  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
-                                .AppendASCII("Extensions")
-                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                                .AppendASCII("1.0.0.0")));
-
-  // Open a new panel to an extension url.
-  GURL url(
-      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-      "french_sentence.html");
-  Panel* panel = PanelManager::GetInstance()->CreatePanel(
-      web_app::GenerateApplicationNameFromExtensionId(
-          last_loaded_extension_id()),
-      browser()->profile(),
-      url,
-      nullptr,
-      gfx::Rect(300, 400),
-      PanelManager::CREATE_AS_DETACHED);
-  panel->Show();
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      1,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Kill the process via the BACKGROUND PAGE (not the panel). Verify that both
-  // the background page and the panel go away from the task manager.
-  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
-  ASSERT_NE(-1, background_page);
-  ASSERT_EQ(-1, model()->GetTabId(background_page));
-  model()->Kill(background_page);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-}
-
-// Kills a process that has more than one task manager entry. This test is the
-// same as KillPanelViaExtensionResource except it does the kill via the other
-// entry.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, KillPanelViaPanelResource) {
-  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
-                                .AppendASCII("Extensions")
-                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                                .AppendASCII("1.0.0.0")));
-
-  // Open a new panel to an extension url.
-  GURL url(
-      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-      "french_sentence.html");
-  Panel* panel = PanelManager::GetInstance()->CreatePanel(
-      web_app::GenerateApplicationNameFromExtensionId(
-          last_loaded_extension_id()),
-      browser()->profile(),
-      url,
-      nullptr,
-      gfx::Rect(300, 400),
-      PanelManager::CREATE_AS_DETACHED);
-  panel->ShowInactive();
-
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(
-      1,
-      MatchExtension(
-          "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-          "french_sentence.html")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
-  ASSERT_NE(-1, background_page);
-  ASSERT_EQ(-1, model()->GetTabId(background_page));
-
-  // Kill the process via the PANEL RESOURCE (not the background page). Verify
-  // that both the background page and the panel go away from the task manager.
-  int panel_index = FindResourceIndex(MatchExtension(
-      "chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/"
-      "french_sentence.html"));
-  ASSERT_NE(-1, panel_index);
-  ASSERT_NE(-1, model()->GetTabId(panel_index));
-  model()->Kill(panel_index);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeExtensionTabChanges) {
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("good").AppendASCII("Extensions")
-                    .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                    .AppendASCII("1.0.0.0")));
-
-  // Browser, Extension background page, and the New Tab Page.
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  // Open a new tab to an extension URL. Afterwards, the third entry (background
-  // page) should be an extension resource whose title starts with "Extension:".
-  // The fourth entry (page.html) is also of type extension and has both a
-  // WebContents and an extension. The title should start with "Extension:".
-  GURL url("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/page.html");
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchExtension("Foobar")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  int extension_tab = FindResourceIndex(MatchExtension("Foobar"));
-  ASSERT_NE(-1, extension_tab);
-  ASSERT_NE(-1, model()->GetTabId(extension_tab));
-
-  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
-  ASSERT_NE(-1, background_page);
-  ASSERT_EQ(-1, model()->GetTabId(background_page));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeExtensionTab) {
-  // With the task manager closed, open a new tab to an extension URL.
-  // Afterwards, when we open the task manager, the third entry (background
-  // page) should be an extension resource whose title starts with "Extension:".
-  // The fourth entry (page.html) is also of type extension and has both a
-  // WebContents and an extension. The title should start with "Extension:".
-  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("good")
-                                .AppendASCII("Extensions")
-                                .AppendASCII("behllobkkfkfnphdnhnkndlbkcpglgmj")
-                                .AppendASCII("1.0.0.0")));
-  GURL url("chrome-extension://behllobkkfkfnphdnhnkndlbkcpglgmj/page.html");
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchExtension("Foobar")));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("My extension 1")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  int extension_tab = FindResourceIndex(MatchExtension("Foobar"));
-  ASSERT_NE(-1, extension_tab);
-  ASSERT_NE(-1, model()->GetTabId(extension_tab));
-
-  int background_page = FindResourceIndex(MatchExtension("My extension 1"));
-  ASSERT_NE(-1, background_page);
-  ASSERT_EQ(-1, model()->GetTabId(background_page));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeAppTabChanges) {
-  ShowTaskManager();
-
-  ASSERT_TRUE(LoadExtension(test_data_dir_.AppendASCII("packaged_app")));
-  ExtensionService* service = extensions::ExtensionSystem::Get(
-                                  browser()->profile())->extension_service();
-  const extensions::Extension* extension =
-      service->GetExtensionById(last_loaded_extension_id(), false);
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
-
-  // Open a new tab to the app's launch URL and make sure we notice that.
-  GURL url(extension->GetResourceURL("main.html"));
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-
-  // There should be 1 "App: " tab and the original new tab page.
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchApp("Packaged App Test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-
-  // Check that the third entry (main.html) is of type extension and has both
-  // a tab contents and an extension.
-  int app_tab = FindResourceIndex(MatchApp("Packaged App Test"));
-  ASSERT_NE(-1, app_tab);
-  ASSERT_NE(-1, model()->GetTabId(app_tab));
-  ASSERT_EQ(2, browser()->tab_strip_model()->count());
-
-  // Unload extension to make sure the tab goes away.
-  UnloadExtension(last_loaded_extension_id());
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_EQ(1, browser()->tab_strip_model()->count());
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeAppTab) {
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("packaged_app")));
-  ExtensionService* service = extensions::ExtensionSystem::Get(
-      browser()->profile())->extension_service();
-  const extensions::Extension* extension =
-      service->GetExtensionById(last_loaded_extension_id(), false);
-
-  // Open a new tab to the app's launch URL and make sure we notice that.
-  GURL url(extension->GetResourceURL("main.html"));
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-
-  ShowTaskManager();
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchApp("Packaged App Test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
-
-  // Check that the third entry (main.html) is of type extension and has both
-  // a tab contents and an extension.
-  int app_tab = FindResourceIndex(MatchApp("Packaged App Test"));
-  ASSERT_NE(-1, app_tab);
-  ASSERT_NE(-1, model()->GetTabId(app_tab));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabChanges) {
-  ShowTaskManager();
-
-  // The app under test acts on URLs whose host is "localhost",
-  // so the URLs we navigate to must have host "localhost".
-  GURL::Replacements replace_host;
-  replace_host.SetHostStr("localhost");
-  GURL base_url = embedded_test_server()->GetURL(
-      "/extensions/api_test/app_process/");
-  base_url = base_url.ReplaceComponents(replace_host);
-
-  // Open a new tab to an app URL before the app is loaded.
-  GURL url(base_url.Resolve("path1/empty.html"));
-  content::WindowedNotificationObserver observer(
-      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
-      content::NotificationService::AllSources());
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-  observer.Wait();
-
-  // Check that the new entry's title starts with "Tab:".
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-
-  // Load the hosted app and make sure it still starts with "Tab:",
-  // since it hasn't changed to an app process yet.
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
-  // Force the TaskManager to query the title.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("Unmodified")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-
-  // Now reload and check that the last entry's title now starts with "App:".
-  ui_test_utils::NavigateToURL(browser(), url);
-
-  // Force the TaskManager to query the title.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchApp("Unmodified")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-
-  // Disable extension and reload.
-  DisableExtension(last_loaded_extension_id());
-  ui_test_utils::NavigateToURL(browser(), url);
-
-  // The hosted app should now show up as a normal "Tab: ".
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAboutBlankTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("Unmodified")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabAfterReload) {
-  // The app under test acts on URLs whose host is "localhost",
-  // so the URLs we navigate to must have host "localhost".
-  GURL base_url = embedded_test_server()->GetURL(
-      "localhost", "/extensions/api_test/app_process/");
-
-  // Open a new tab to an app URL before the app is loaded.
-  GURL url(base_url.Resolve("path1/empty.html"));
-  content::WindowedNotificationObserver observer(
-      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
-      content::NotificationService::AllSources());
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-  observer.Wait();
-
-  // Load the hosted app and make sure it still starts with "Tab:",
-  // since it hasn't changed to an app process yet.
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
-
-  // Now reload, which should transition this tab to being an App.
-  ui_test_utils::NavigateToURL(browser(), url);
-
-  ShowTaskManager();
-
-  // The TaskManager should show this as an "App: "
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyApp()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, NoticeHostedAppTabBeforeReload) {
-  // The app under test acts on URLs whose host is "localhost",
-  // so the URLs we navigate to must have host "localhost".
-  GURL base_url = embedded_test_server()->GetURL(
-      "localhost", "/extensions/api_test/app_process/");
-
-  // Open a new tab to an app URL before the app is loaded.
-  GURL url(base_url.Resolve("path1/empty.html"));
-  content::WindowedNotificationObserver observer(
-      content::NOTIFICATION_NAV_ENTRY_COMMITTED,
-      content::NotificationService::AllSources());
-  AddTabAtIndex(0, url, ui::PAGE_TRANSITION_TYPED);
-  observer.Wait();
-
-  // Load the hosted app and make sure it still starts with "Tab:",
-  // since it hasn't changed to an app process yet.
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("api_test").AppendASCII("app_process")));
-
-  ShowTaskManager();
-
-  // The TaskManager should show this as a "Tab: " because the page hasn't been
-  // reloaded since the hosted app was installed.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyApp()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnyExtension()));
-}
-
-// Regression test for http://crbug.com/18693.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, ReloadExtension) {
-  ShowTaskManager();
-  ASSERT_TRUE(LoadExtension(
-      test_data_dir_.AppendASCII("common").AppendASCII("background_page")));
-
-  // Wait until we see the loaded extension in the task manager (the three
-  // resources are: the browser process, New Tab Page, and the extension).
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchExtension("background_page")));
-
-  // Reload the extension a few times and make sure our resource count doesn't
-  // increase.
-  std::string extension_id = last_loaded_extension_id();
-  for (int i = 1; i <= 5; i++) {
-    SCOPED_TRACE(testing::Message() << "Reloading extension for the " << i
-                                    << "th time.");
-    ReloadExtension(extension_id);
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchExtension("background_page")));
-  }
-}
-
-// Checks that task manager counts a worker thread JS heap size.
-// http://crbug.com/241066
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, WebWorkerJSHeapMemory) {
-  ShowTaskManager();
-  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
-  ui_test_utils::NavigateToURL(browser(), GetTestURL());
-  size_t minimal_heap_size = 4 * 1024 * 1024 * sizeof(void*);
-  std::string test_js = base::StringPrintf(
-      "var blob = new Blob([\n"
-      "    'mem = new Array(%lu);',\n"
-      "    'for (var i = 0; i < mem.length; i += 16)',"
-      "    '  mem[i] = i;',\n"
-      "    'postMessage(\"okay\");']);\n"
-      "blobURL = window.URL.createObjectURL(blob);\n"
-      "var worker = new Worker(blobURL);\n"
-      "worker.addEventListener('message', function(e) {\n"
-      "  window.domAutomationController.send(e.data);\n"  // e.data == "okay"
-      "});\n"
-      "worker.postMessage('go');\n",
-      static_cast<unsigned long>(minimal_heap_size));
-  std::string ok;
-  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
-      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
-  ASSERT_EQ("okay", ok);
-
-  // The worker has allocated objects of at least |minimal_heap_size| bytes.
-  // Wait for the heap stats to reflect this.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY, minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY_USED,
-      minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-}
-
-// Checks that task manager counts renderer JS heap size.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, JSHeapMemory) {
-  ShowTaskManager();
-  ui_test_utils::NavigateToURL(browser(), GetTestURL());
-  size_t minimal_heap_size = 4 * 1024 * 1024 * sizeof(void*);
-  std::string test_js = base::StringPrintf(
-      "mem = new Array(%lu);\n"
-      "for (var i = 0; i < mem.length; i += 16)\n"
-      "  mem[i] = i;\n"
-      "window.domAutomationController.send(\"okay\");\n",
-      static_cast<unsigned long>(minimal_heap_size));
-  std::string ok;
-  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
-      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
-  ASSERT_EQ("okay", ok);
-
-  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
-
-  // The page's js has allocated objects of at least |minimal_heap_size| bytes.
-  // Wait for the heap stats to reflect this.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY, minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchTab("title1.html"), ColumnSpecifier::V8_MEMORY_USED,
-      minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-}
-
-// Checks that task manager counts idle wakeups.
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest,
-                       IdleWakeups) {
-  ShowTaskManager();
-  model()->ToggleColumnVisibility(ColumnSpecifier::IDLE_WAKEUPS);
-
-  ui_test_utils::NavigateToURL(browser(), GetTestURL());
-
-  std::string test_js =
-    "function myWait() {\n"
-    "  setTimeout(function() { myWait(); }, 1)\n"
-    "}\n"
-    "myWait();\n"
-    "window.domAutomationController.send(\"okay\");\n";
-
-  std::string ok;
-  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
-      browser()->tab_strip_model()->GetActiveWebContents(), test_js, &ok));
-  ASSERT_EQ("okay", ok);
-
-  // The script above should trigger a lot of idle wakeups - up to 1000 per
-  // second. Let's make sure we get at least 100 (in case the test runs slow).
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchTab("title1.html"), ColumnSpecifier::IDLE_WAKEUPS, 100));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("title1.html")));
-}
-
-// Checks that task manager counts utility process JS heap size.
-IN_PROC_BROWSER_TEST_F(TaskManagerUtilityProcessBrowserTest,
-                       UtilityJSHeapMemory) {
-  ShowTaskManager();
-  model()->ToggleColumnVisibility(ColumnSpecifier::V8_MEMORY);
-
-  auto proxy_resolver_name =
-      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PROXY_RESOLVER_NAME);
-  ui_test_utils::NavigateToURL(browser(), GetTestURL());
-  // The PAC script is trivial, so don't expect a large heap.
-  size_t minimal_heap_size = 1024;
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchUtility(proxy_resolver_name), ColumnSpecifier::V8_MEMORY,
-      minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerStatToExceed(
-      MatchUtility(proxy_resolver_name), ColumnSpecifier::V8_MEMORY_USED,
-      minimal_heap_size));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyUtility()));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchUtility(proxy_resolver_name)));
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsNewDockedWindow) {
-  ShowTaskManager();  // Task manager shown BEFORE dev tools window.
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  DevToolsWindow* devtools =
-      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), true);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsNewUndockedWindow) {
-  ShowTaskManager();  // Task manager shown BEFORE dev tools window.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  DevToolsWindow* devtools =
-      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), false);
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
-  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsOldDockedWindow) {
-  DevToolsWindow* devtools =
-      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), true);
-  ShowTaskManager();  // Task manager shown AFTER dev tools window.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnyTab()));
-  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
-}
-
-IN_PROC_BROWSER_TEST_F(TaskManagerBrowserTest, DevToolsOldUndockedWindow) {
-  DevToolsWindow* devtools =
-      DevToolsWindowTesting::OpenDevToolsWindowSync(browser(), false);
-  ShowTaskManager();  // Task manager shown AFTER dev tools window.
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnyTab()));
-  DevToolsWindowTesting::CloseDevToolsWindowSync(devtools);
-}
-
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, KillSubframe) {
-  ShowTaskManager();
-
-  GURL main_url(embedded_test_server()->GetURL(
-      "/cross-site/a.com/iframe_cross_site.html"));
-  browser()->OpenURL(content::OpenURLParams(main_url, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-    int subframe_b = FindResourceIndex(MatchSubframe("http://b.com/"));
-    ASSERT_NE(-1, subframe_b);
-    ASSERT_NE(-1, model()->GetTabId(subframe_b));
-
-    model()->Kill(subframe_b);
-
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  }
-
-  HideTaskManager();
-  ShowTaskManager();
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  }
-}
-
-// Tests what happens when a tab navigates to a site (a.com) that it previously
-// has a cross-process subframe into (b.com).
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, NavigateToSubframeProcess) {
-  ShowTaskManager();
-
-  // Navigate the tab to a page on a.com with cross-process subframes to
-  // b.com and c.com.
-  GURL a_dotcom(embedded_test_server()->GetURL(
-      "/cross-site/a.com/iframe_cross_site.html"));
-  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-  }
-
-  // Now navigate to a page on b.com with a simple (same-site) iframe.
-  // This should not show any subframe resources in the task manager.
-  GURL b_dotcom(
-      embedded_test_server()->GetURL("/cross-site/b.com/iframe.html"));
-
-  browser()->OpenURL(content::OpenURLParams(b_dotcom, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  HideTaskManager();
-  ShowTaskManager();
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-}
-
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
-                       NavigateToSiteWithSubframeToOriginalSite) {
-  ShowTaskManager();
-
-  // Navigate to a page on b.com with a simple (same-site) iframe.
-  // This should not show any subframe resources in the task manager.
-  GURL b_dotcom(
-      embedded_test_server()->GetURL("/cross-site/b.com/iframe.html"));
-
-  browser()->OpenURL(content::OpenURLParams(b_dotcom, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-
-  // Now navigate the tab to a page on a.com with cross-process subframes to
-  // b.com and c.com.
-  GURL a_dotcom(embedded_test_server()->GetURL(
-      "/cross-site/a.com/iframe_cross_site.html"));
-  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-  }
-
-  HideTaskManager();
-  ShowTaskManager();
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-  }
-}
-
-// Tests what happens when a tab navigates a cross-frame iframe (to b.com)
-// back to the site of the parent document (a.com).
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
-                       CrossSiteIframeBecomesSameSite) {
-  ShowTaskManager();
-
-  // Navigate the tab to a page on a.com with cross-process subframes to
-  // b.com and c.com.
-  GURL a_dotcom(embedded_test_server()->GetURL(
-      "/cross-site/a.com/iframe_cross_site.html"));
-  browser()->OpenURL(content::OpenURLParams(a_dotcom, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-  }
-
-  // Navigate the b.com frame back to a.com. It is no longer a cross-site iframe
-  ASSERT_TRUE(content::ExecuteScript(
-      browser()->tab_strip_model()->GetActiveWebContents()->GetMainFrame(),
-      "document.getElementById('frame1').src='/title1.html';"
-      "document.title='aac';"));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
-  }
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  HideTaskManager();
-  ShowTaskManager();
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(0, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnySubframe()));
-  }
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchTab("aac")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-}
-
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest,
-                       LeavePageWithCrossSiteIframes) {
-  ShowTaskManager();
-
-  // Navigate the tab to a page on a.com with cross-process subframes.
-  GURL a_dotcom_with_iframes(embedded_test_server()->GetURL(
-      "/cross-site/a.com/iframe_cross_site.html"));
-  browser()->OpenURL(content::OpenURLParams(a_dotcom_with_iframes,
-                                            content::Referrer(), CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("cross-site iframe test")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(1, MatchAnyTab()));
-
-  if (!ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(2, MatchAnySubframe()));
-  }
-
-  // Navigate the tab to a page on a.com without cross-process subframes, and
-  // the subframe processes should disappear.
-  GURL a_dotcom_simple(
-      embedded_test_server()->GetURL("/cross-site/a.com/title2.html"));
-  browser()->OpenURL(content::OpenURLParams(a_dotcom_simple,
-                                            content::Referrer(), CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-
-  HideTaskManager();
-  ShowTaskManager();
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("Title Of Awesomeness")));
-  ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-}
-
-IN_PROC_BROWSER_TEST_P(TaskManagerOOPIFBrowserTest, OrderingOfDependentRows) {
-  ShowTaskManager();
-
-  GURL a_with_frames(embedded_test_server()->GetURL(
-      "a.com", "/cross_site_iframe_factory.html?a(b,b,c(d,a,b,c))"));
-  browser()->OpenURL(content::OpenURLParams(a_with_frames, content::Referrer(),
-                                            CURRENT_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  if (ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://d.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(3, MatchAnySubframe()));
-  }
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(1, MatchTab("Cross-site iframe factory")));
-
-  int index = FindResourceIndex(MatchTab("Cross-site iframe factory"));
-  std::vector<int> subframe_offsets;
-  if (ShouldExpectSubframes()) {
-    subframe_offsets = {
-        FindResourceIndex(MatchSubframe("http://b.com/")) - index,
-        FindResourceIndex(MatchSubframe("http://c.com/")) - index,
-        FindResourceIndex(MatchSubframe("http://d.com/")) - index};
-    EXPECT_THAT(subframe_offsets, testing::UnorderedElementsAre(1, 2, 3));
-  }
-
-  // Opening a new tab should appear below the existing tab.
-  GURL other_tab_url(embedded_test_server()->GetURL(
-      "d.com", "/cross_site_iframe_factory.html?d(a(c(b)))"));
-  browser()->OpenURL(content::OpenURLParams(other_tab_url, content::Referrer(),
-                                            NEW_FOREGROUND_TAB,
-                                            ui::PAGE_TRANSITION_TYPED, false));
-
-  ASSERT_NO_FATAL_FAILURE(
-      WaitForTaskManagerRows(2, MatchTab("Cross-site iframe factory")));
-  if (ShouldExpectSubframes()) {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(6, MatchAnySubframe()));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(2, MatchSubframe("http://b.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(2, MatchSubframe("http://c.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://d.com/")));
-    ASSERT_NO_FATAL_FAILURE(
-        WaitForTaskManagerRows(1, MatchSubframe("http://a.com/")));
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(6, MatchAnySubframe()));
-  } else {
-    ASSERT_NO_FATAL_FAILURE(WaitForTaskManagerRows(0, MatchAnySubframe()));
-  }
-
-  // The first tab may have moved in absolute position in the list (due to
-  // random e.g. zygote or gpu activity).
-  index = FindResourceIndex(MatchTab("Cross-site iframe factory"));
-
-  // Tab 2's rows should immediately follow tab 1.
-  int tab2_start = index + static_cast<int>(subframe_offsets.size()) + 1;
-  int tab2_count = ShouldExpectSubframes() ? 4 : 1;
-  ASSERT_LE(tab2_start + tab2_count, model()->GetRowCount());
-
-  EXPECT_EQ("Tab: Cross-site iframe factory",
-            base::UTF16ToUTF8(model()->GetRowTitle(tab2_start)));
-  if (ShouldExpectSubframes()) {
-    // The relative ordering of tab1's subframe rows shall be the same as what
-    // was observed previously.
-    ASSERT_EQ(subframe_offsets[0],
-              FindResourceIndex(MatchSubframe("http://b.com/")) - index);
-    ASSERT_EQ(subframe_offsets[1],
-              FindResourceIndex(MatchSubframe("http://c.com/")) - index);
-    ASSERT_EQ(subframe_offsets[2],
-              FindResourceIndex(MatchSubframe("http://d.com/")) - index);
-
-    // Because the subframes for tab 2 are nested, their order is deterministic.
-    EXPECT_EQ("Subframe: http://a.com/",
-              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 1)));
-    EXPECT_EQ("Subframe: http://c.com/",
-              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 2)));
-    EXPECT_EQ("Subframe: http://b.com/",
-              base::UTF16ToUTF8(model()->GetRowTitle(tab2_start + 3)));
-  }
-}
diff --git a/chrome/browser/task_manager/task_manager_browsertest_util.cc b/chrome/browser/task_manager/task_manager_browsertest_util.cc
deleted file mode 100644
index 925704a..0000000
--- a/chrome/browser/task_manager/task_manager_browsertest_util.cc
+++ /dev/null
@@ -1,256 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
-
-#include "base/bind_helpers.h"
-#include "base/command_line.h"
-#include "base/location.h"
-#include "base/run_loop.h"
-#include "base/single_thread_task_runner.h"
-#include "base/strings/pattern.h"
-#include "base/strings/string16.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/test/test_timeouts.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/timer/timer.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/task_manager/task_manager_tester.h"
-#include "chrome/grit/generated_resources.h"
-#include "extensions/strings/grit/extensions_strings.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/models/table_model_observer.h"
-
-namespace task_manager {
-namespace browsertest_util {
-
-namespace {
-
-// Helper class to run a message loop until a TaskManagerTester is in an
-// expected state. If timeout occurs, an ASCII version of the task manager's
-// contents, along with a summary of the expected state, are dumped to test
-// output, to assist debugging.
-class ResourceChangeObserver {
- public:
-  ResourceChangeObserver(int required_count,
-                         const base::string16& title_pattern,
-                         ColumnSpecifier column_specifier,
-                         size_t min_column_value)
-      : required_count_(required_count),
-        title_pattern_(title_pattern),
-        column_specifier_(column_specifier),
-        min_column_value_(min_column_value) {
-    task_manager_tester_ = TaskManagerTester::Create(base::Bind(
-        &ResourceChangeObserver::OnResourceChange, base::Unretained(this)));
-  }
-
-  void RunUntilSatisfied() {
-    // See if the condition is satisfied without having to run the loop. This
-    // check has to be placed after the installation of the
-    // TaskManagerModelObserver, because resources may change before that.
-    if (IsSatisfied())
-      return;
-
-    timer_.Start(FROM_HERE, TestTimeouts::action_timeout(), this,
-                 &ResourceChangeObserver::OnTimeout);
-
-    run_loop_.Run();
-
-    // If we succeeded normally (no timeout), check our post condition again
-    // before returning control to the test. If it is no longer satisfied, the
-    // test is likely flaky: we were waiting for a state that was only achieved
-    // emphemerally), so treat this as a failure.
-    if (!IsSatisfied() && timer_.IsRunning()) {
-      FAIL() << "Wait condition satisfied only emphemerally. Likely test "
-             << "problem. Maybe wait instead for the state below?\n"
-             << DumpTaskManagerModel();
-    }
-
-    timer_.Stop();
-  }
-
- private:
-  void OnResourceChange() {
-    if (!IsSatisfied())
-      return;
-
-    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
-                                                  run_loop_.QuitClosure());
-  }
-
-  bool IsSatisfied() { return CountMatches() == required_count_; }
-
-  int CountMatches() {
-    int match_count = 0;
-    for (int i = 0; i < task_manager_tester_->GetRowCount(); i++) {
-      if (!base::MatchPattern(task_manager_tester_->GetRowTitle(i),
-                              title_pattern_))
-        continue;
-
-      if (GetColumnValue(i) < min_column_value_)
-        continue;
-
-      match_count++;
-    }
-    return match_count;
-  }
-
-  int64_t GetColumnValue(int index) {
-    return task_manager_tester_->GetColumnValue(column_specifier_, index);
-  }
-
-  const char* GetColumnName() {
-    switch (column_specifier_) {
-      case ColumnSpecifier::COLUMN_NONE:
-        return "N/A";
-      case ColumnSpecifier::V8_MEMORY:
-        return "V8 Memory";
-      case ColumnSpecifier::V8_MEMORY_USED:
-        return "V8 Memory Used";
-      case ColumnSpecifier::SQLITE_MEMORY_USED:
-        return "SQLite Memory Used";
-      case ColumnSpecifier::IDLE_WAKEUPS:
-        return "Idle wake ups";
-    }
-    return "N/A";
-  }
-
-  void OnTimeout() {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
-                                                  run_loop_.QuitClosure());
-    FAIL() << "Timed out.\n" << DumpTaskManagerModel();
-  }
-
-  testing::Message DumpTaskManagerModel() {
-    testing::Message task_manager_state_dump;
-    task_manager_state_dump << "Waiting for exactly " << required_count_
-                            << " matches of wildcard pattern \""
-                            << base::UTF16ToASCII(title_pattern_) << "\"";
-    if (min_column_value_ > 0) {
-      task_manager_state_dump << " && [" << GetColumnName()
-                              << " >= " << min_column_value_ << "]";
-    }
-    task_manager_state_dump << "\nCurrently there are " << CountMatches()
-                            << " matches.";
-    task_manager_state_dump << "\nCurrent Task Manager Model is:";
-    for (int i = 0; i < task_manager_tester_->GetRowCount(); i++) {
-      task_manager_state_dump
-          << "\n  > " << std::setw(40) << std::left
-          << base::UTF16ToASCII(task_manager_tester_->GetRowTitle(i));
-      if (min_column_value_ > 0) {
-        task_manager_state_dump << " [" << GetColumnName()
-                                << " == " << GetColumnValue(i) << "]";
-      }
-    }
-    return task_manager_state_dump;
-  }
-
-  std::unique_ptr<TaskManagerTester> task_manager_tester_;
-  const int required_count_;
-  const base::string16 title_pattern_;
-  const ColumnSpecifier column_specifier_;
-  const int64_t min_column_value_;
-  base::RunLoop run_loop_;
-  base::OneShotTimer timer_;
-};
-
-}  // namespace
-
-void WaitForTaskManagerRows(int required_count,
-                            const base::string16& title_pattern) {
-  const int column_value_dont_care = 0;
-  ResourceChangeObserver observer(required_count, title_pattern,
-                                  ColumnSpecifier::COLUMN_NONE,
-                                  column_value_dont_care);
-  observer.RunUntilSatisfied();
-}
-
-void WaitForTaskManagerStatToExceed(const base::string16& title_pattern,
-                                    ColumnSpecifier column_getter,
-                                    size_t min_column_value) {
-  const int wait_for_one_match = 1;
-  ResourceChangeObserver observer(wait_for_one_match, title_pattern,
-                                  column_getter, min_column_value);
-  observer.RunUntilSatisfied();
-}
-
-base::string16 MatchTab(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_TAB_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyTab() {
-  return MatchTab("*");
-}
-
-base::string16 MatchAboutBlankTab() {
-  return MatchTab("about:blank");
-}
-
-base::string16 MatchExtension(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_EXTENSION_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyExtension() {
-  return MatchExtension("*");
-}
-
-base::string16 MatchApp(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_APP_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyApp() {
-  return MatchApp("*");
-}
-
-base::string16 MatchWebView(const char* title) {
-  return l10n_util::GetStringFUTF16(
-      IDS_EXTENSION_TASK_MANAGER_WEBVIEW_TAG_PREFIX, base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyWebView() {
-  return MatchWebView("*");
-}
-
-base::string16 MatchBackground(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_BACKGROUND_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyBackground() {
-  return MatchBackground("*");
-}
-
-base::string16 MatchPrint(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_PRINT_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnyPrint() {
-  return MatchPrint("*");
-}
-
-base::string16 MatchSubframe(const char* title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_SUBFRAME_PREFIX,
-                                    base::ASCIIToUTF16(title));
-}
-
-base::string16 MatchAnySubframe() {
-  return MatchSubframe("*");
-}
-
-base::string16 MatchUtility(const base::string16& title) {
-  return l10n_util::GetStringFUTF16(IDS_TASK_MANAGER_UTILITY_PREFIX, title);
-}
-
-base::string16 MatchAnyUtility() {
-  return MatchUtility(base::ASCIIToUTF16("*"));
-}
-
-}  // namespace browsertest_util
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/task_manager_browsertest_util.h b/chrome/browser/task_manager/task_manager_browsertest_util.h
deleted file mode 100644
index 8e2860e..0000000
--- a/chrome/browser/task_manager/task_manager_browsertest_util.h
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-// These "task_manager::browsertest_util" functions allow you to wait for a
-// task manager to show a particular state, enabling tests of the form "do
-// something that ought to create a process, then wait for that process to show
-// up in the Task Manager." They are intended to abstract away the details of
-// the platform's TaskManager UI.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_BROWSERTEST_UTIL_H_
-#define CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_BROWSERTEST_UTIL_H_
-
-#include <stddef.h>
-
-#include "base/strings/string16.h"
-
-namespace task_manager {
-namespace browsertest_util {
-
-// Specifies some integer-valued column of numeric data reported by the task
-// manager model. Please add more here as needed by tests.
-enum class ColumnSpecifier {
-  V8_MEMORY,
-  V8_MEMORY_USED,
-  SQLITE_MEMORY_USED,
-  IDLE_WAKEUPS,
-
-  COLUMN_NONE,  // Default value.
-};
-
-// Runs the message loop, observing the task manager, until there are exactly
-// |resource_count| many resources whose titles match the pattern
-// |title_pattern|. The match is done via string_util's base::MatchPattern, so
-// |title_pattern| may contain wildcards like "*".
-//
-// If the wait times out, this test will trigger a gtest failure. To get
-// meaningful errors, tests should wrap invocations of this function with
-// ASSERT_NO_FATAL_FAILURE().
-void WaitForTaskManagerRows(int resource_count,
-                            const base::string16& title_pattern);
-
-// Make the indicated TaskManager column be visible.
-void ShowColumn(ColumnSpecifier column_specifier);
-
-// Waits for the row identified by |title_pattern| to be showing a numeric data
-// value of at least |min_column_value| in the task manager column identified by
-// |column_specifier|. As with WaitForTaskManagerRows(), |title_pattern| is
-// meant to be a string returned by MatchTab() or similar.
-//
-// To get meaningful errors, tests should wrap invocations of this function with
-// ASSERT_NO_FATAL_FAILURE().
-void WaitForTaskManagerStatToExceed(const base::string16& title_pattern,
-                                    ColumnSpecifier column_specifier,
-                                    size_t min_column_value);
-
-// ASCII matcher convenience functions for use with WaitForTaskManagerRows()
-base::string16 MatchTab(const char* title);         // "Tab: " + title
-base::string16 MatchAnyTab();                       // "Tab: *"
-base::string16 MatchAboutBlankTab();                // "Tab: about:blank"
-base::string16 MatchExtension(const char* title);   // "Extension: " + title
-base::string16 MatchAnyExtension();                 // "Extension: *"
-base::string16 MatchApp(const char* title);         // "App: " + title
-base::string16 MatchAnyApp();                       // "App: *"
-base::string16 MatchWebView(const char* title);     // "WebView: " + title
-base::string16 MatchAnyWebView();                   // "WebView: *"
-base::string16 MatchBackground(const char* title);  // "Background: " + title
-base::string16 MatchAnyBackground();                // "Background: *"
-base::string16 MatchPrint(const char* title);       // "Print: " + title
-base::string16 MatchAnyPrint();                     // "Print: *"
-base::string16 MatchSubframe(const char* title);    // "Subframe: " + title
-base::string16 MatchAnySubframe();                  // "Subframe: *"
-// "Utility: " + title
-base::string16 MatchUtility(const base::string16& title);
-base::string16 MatchAnyUtility();                   // "Utility: *"
-
-}  // namespace browsertest_util
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_BROWSERTEST_UTIL_H_
diff --git a/chrome/browser/task_manager/task_manager_interface.cc b/chrome/browser/task_manager/task_manager_interface.cc
deleted file mode 100644
index 624f241..0000000
--- a/chrome/browser/task_manager/task_manager_interface.cc
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/task_manager_interface.h"
-
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/task_manager/sampling/task_manager_impl.h"
-#include "chrome/browser/task_manager/sampling/task_manager_io_thread_helper.h"
-#include "chrome/common/chrome_switches.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/browser_thread.h"
-
-#if defined(OS_MACOSX)
-#include "chrome/browser/ui/browser_dialogs.h"
-#endif  // defined(OS_MACOSX)
-
-namespace task_manager {
-
-// static
-void TaskManagerInterface::RegisterPrefs(PrefRegistrySimple* registry) {
-  registry->RegisterDictionaryPref(prefs::kTaskManagerWindowPlacement);
-  registry->RegisterDictionaryPref(prefs::kTaskManagerColumnVisibility);
-  registry->RegisterBooleanPref(prefs::kTaskManagerEndProcessEnabled, true);
-}
-
-// static
-bool TaskManagerInterface::IsEndProcessEnabled() {
-  PrefService* state = g_browser_process->local_state();
-  return !state || state->GetBoolean(prefs::kTaskManagerEndProcessEnabled);
-}
-
-// static
-TaskManagerInterface* TaskManagerInterface::GetTaskManager() {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  return TaskManagerImpl::GetInstance();
-}
-
-// static
-void TaskManagerInterface::OnRawBytesRead(const net::URLRequest& request,
-                                          int64_t bytes_read) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-  TaskManagerIoThreadHelper::OnRawBytesRead(request, bytes_read);
-}
-
-void TaskManagerInterface::AddObserver(TaskManagerObserver* observer) {
-  observers_.AddObserver(observer);
-  observer->observed_task_manager_ = this;
-
-  ResourceFlagsAdded(observer->desired_resources_flags());
-
-  base::TimeDelta current_refresh_time = GetCurrentRefreshTime();
-  if (current_refresh_time == base::TimeDelta::Max()) {
-    // This is the first observer to be added. Start updating.
-    StartUpdating();
-  }
-
-  if (observer->desired_refresh_time() > current_refresh_time)
-    return;
-
-  // Reached here, then this is EITHER (not the first observer to be added AND
-  // it requires a more frequent refresh rate) OR (it's the very first observer
-  // to be added).
-  // Reset the refresh timer.
-  ScheduleRefresh(observer->desired_refresh_time());
-}
-
-void TaskManagerInterface::RemoveObserver(TaskManagerObserver* observer) {
-  observers_.RemoveObserver(observer);
-  observer->observed_task_manager_ = nullptr;
-
-  // Recalculate the minimum refresh rate and the enabled resource flags.
-  int64_t flags = 0;
-  base::TimeDelta min_time = base::TimeDelta::Max();
-  base::ObserverList<TaskManagerObserver>::Iterator itr(&observers_);
-  while (TaskManagerObserver* obs = itr.GetNext()) {
-    if (obs->desired_refresh_time() < min_time)
-      min_time = obs->desired_refresh_time();
-
-    flags |= obs->desired_resources_flags();
-  }
-
-  if (min_time == base::TimeDelta::Max()) {
-    // This is the last observer to be removed. Stop updating.
-    SetEnabledResourceFlags(0);
-    refresh_timer_->Stop();
-    StopUpdating();
-  } else {
-    SetEnabledResourceFlags(flags);
-    ScheduleRefresh(min_time);
-  }
-}
-
-void TaskManagerInterface::RecalculateRefreshFlags() {
-  int64_t flags = 0;
-  base::ObserverList<TaskManagerObserver>::Iterator itr(&observers_);
-  while (TaskManagerObserver* obs = itr.GetNext())
-    flags |= obs->desired_resources_flags();
-
-  SetEnabledResourceFlags(flags);
-}
-
-bool TaskManagerInterface::IsResourceRefreshEnabled(RefreshType type) const {
-  return (enabled_resources_flags_ & type) != 0;
-}
-
-TaskManagerInterface::TaskManagerInterface()
-    : refresh_timer_(new base::Timer(true, true)),
-      enabled_resources_flags_(0) {
-}
-
-TaskManagerInterface::~TaskManagerInterface() {
-}
-
-void TaskManagerInterface::NotifyObserversOnTaskAdded(TaskId id) {
-  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskAdded(id));
-}
-
-void TaskManagerInterface::NotifyObserversOnTaskToBeRemoved(TaskId id) {
-  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskToBeRemoved(id));
-}
-
-void TaskManagerInterface::NotifyObserversOnRefresh(
-    const TaskIdList& task_ids) {
-  FOR_EACH_OBSERVER(TaskManagerObserver,
-                    observers_,
-                    OnTasksRefreshed(task_ids));
-}
-
-void TaskManagerInterface::NotifyObserversOnRefreshWithBackgroundCalculations(
-      const TaskIdList& task_ids) {
-  FOR_EACH_OBSERVER(TaskManagerObserver,
-                    observers_,
-                    OnTasksRefreshedWithBackgroundCalculations(task_ids));
-}
-
-void TaskManagerInterface::NotifyObserversOnTaskUnresponsive(TaskId id) {
-  FOR_EACH_OBSERVER(TaskManagerObserver, observers_, OnTaskUnresponsive(id));
-}
-
-base::TimeDelta TaskManagerInterface::GetCurrentRefreshTime() const {
-  return refresh_timer_->IsRunning() ? refresh_timer_->GetCurrentDelay()
-                                     : base::TimeDelta::Max();
-}
-
-void TaskManagerInterface::ResourceFlagsAdded(int64_t flags) {
-  enabled_resources_flags_ |= flags;
-}
-
-void TaskManagerInterface::SetEnabledResourceFlags(int64_t flags) {
-  enabled_resources_flags_ = flags;
-}
-
-void TaskManagerInterface::ScheduleRefresh(base::TimeDelta refresh_time) {
-  refresh_timer_->Start(FROM_HERE,
-                        refresh_time,
-                        base::Bind(&TaskManagerInterface::Refresh,
-                                   base::Unretained(this)));
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/task_manager_interface.h b/chrome/browser/task_manager/task_manager_interface.h
deleted file mode 100644
index 70c5956..0000000
--- a/chrome/browser/task_manager/task_manager_interface.h
+++ /dev/null
@@ -1,279 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_INTERFACE_H_
-#define CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_INTERFACE_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <memory>
-#include <utility>
-
-#include "base/macros.h"
-#include "base/observer_list.h"
-#include "base/process/kill.h"
-#include "base/process/process_handle.h"
-#include "base/time/time.h"
-#include "base/timer/timer.h"
-#include "chrome/browser/task_manager/providers/task.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
-#include "third_party/WebKit/public/web/WebCache.h"
-#include "ui/gfx/image/image_skia.h"
-
-class PrefRegistrySimple;
-
-namespace content {
-class WebContents;
-}  // namespace content
-
-namespace net {
-class URLRequest;
-}  // namespace net
-
-namespace task_manager {
-
-// Defines the interface for any implementation of the task manager.
-// Concrete implementations have no control over the refresh rate nor the
-// enabled calculations of the usage of the various resources.
-class TaskManagerInterface {
- public:
-  // Registers the task manager related prefs.
-  static void RegisterPrefs(PrefRegistrySimple* registry);
-
-  // Returns true if the user is allowed to end processes.
-  static bool IsEndProcessEnabled();
-
-  // Gets the existing instance of the task manager if any, otherwise it will
-  // create it first. Must be called on the UI thread.
-  static TaskManagerInterface* GetTaskManager();
-
-  // This notification will be received on the IO thread from
-  // ChromeNetworkDelegate to update the task manager with network usage.
-  static void OnRawBytesRead(const net::URLRequest& request,
-                             int64_t bytes_read);
-
-  void AddObserver(TaskManagerObserver* observer);
-  void RemoveObserver(TaskManagerObserver* observer);
-
-  // Activates the task with |task_id| by bringing its container to the front if
-  // possible.
-  virtual void ActivateTask(TaskId task_id) = 0;
-
-  // Returns if the task is killable.
-  virtual bool IsTaskKillable(TaskId task_id) = 0;
-
-  // Kills the task with |task_id|.
-  virtual void KillTask(TaskId task_id) = 0;
-
-  // returns the CPU usage in percent for the process on which the task with
-  // |task_id| is running during the current refresh cycle.
-  virtual double GetCpuUsage(TaskId task_id) const = 0;
-
-  // Returns the current physical/private/shared memory usage of the task with
-  // |task_id| in bytes. A value of -1 means no valid value is currently
-  // available.
-  virtual int64_t GetPhysicalMemoryUsage(TaskId task_id) const = 0;
-  virtual int64_t GetPrivateMemoryUsage(TaskId task_id) const = 0;
-  virtual int64_t GetSharedMemoryUsage(TaskId task_id) const = 0;
-  virtual int64_t GetSwappedMemoryUsage(TaskId task_id) const = 0;
-
-  // Returns the GPU memory usage of the task with |task_id| in bytes. A value
-  // of -1 means no valid value is currently available.
-  // |has_duplicates| will be set to true if this process' GPU resource count is
-  // inflated because it is counting other processes' resources.
-  virtual int64_t GetGpuMemoryUsage(TaskId task_id,
-                                    bool* has_duplicates) const = 0;
-
-  // Returns the number of average idle CPU wakeups per second since the last
-  // refresh cycle. A value of -1 means no valid value is currently available.
-  virtual int GetIdleWakeupsPerSecond(TaskId task_id) const = 0;
-
-  // Returns the NaCl GDB debug stub port. A value of
-  // |nacl::kGdbDebugStubPortUnknown| means no valid value is currently
-  // available. A value of -2 means NaCl is not enabled for this build.
-  virtual int GetNaClDebugStubPort(TaskId task_id) const = 0;
-
-  // On Windows, gets the current and peak number of GDI and USER handles in
-  // use. A value of -1 means no valid value is currently available.
-  virtual void GetGDIHandles(TaskId task_id,
-                             int64_t* current,
-                             int64_t* peak) const = 0;
-  virtual void GetUSERHandles(TaskId task_id,
-                              int64_t* current,
-                              int64_t* peak) const = 0;
-
-  // On Linux and ChromeOS, gets the number of file descriptors currently open
-  // by the process on which the task with |task_id| is running, or -1 if no
-  // valid value is currently available.
-  virtual int GetOpenFdCount(TaskId task_id) const = 0;
-
-  // Returns whether the task with |task_id| is running on a backgrounded
-  // process.
-  virtual bool IsTaskOnBackgroundedProcess(TaskId task_id) const = 0;
-
-  // Returns the title of the task with |task_id|.
-  virtual const base::string16& GetTitle(TaskId task_id) const = 0;
-
-  // Returns the canonicalized name of the task with |task_id| that can be used
-  // to represent this task in a Rappor sample via RapporService.
-  virtual const std::string& GetTaskNameForRappor(TaskId task_id) const = 0;
-
-  // Returns the name of the profile associated with the browser context of the
-  // render view host that the task with |task_id| represents (if that task
-  // represents a renderer).
-  virtual base::string16 GetProfileName(TaskId task_id) const = 0;
-
-  // Returns the favicon of the task with |task_id|.
-  virtual const gfx::ImageSkia& GetIcon(TaskId task_id) const = 0;
-
-  // Returns the ID and handle of the process on which the task with |task_id|
-  // is running.
-  virtual const base::ProcessHandle& GetProcessHandle(TaskId task_id) const = 0;
-  virtual const base::ProcessId& GetProcessId(TaskId task_id) const = 0;
-
-  // Returns the type of the task with |task_id|.
-  virtual Task::Type GetType(TaskId task_id) const = 0;
-
-  // Gets the unique ID of the tab if the task with |task_id| represents a
-  // WebContents of a tab. Returns -1 otherwise.
-  virtual int GetTabId(TaskId task_id) const = 0;
-
-  // Returns the unique ID of the BrowserChildProcessHost/RenderProcessHost on
-  // which the task with |task_id| is running. It is not the PID nor the handle
-  // of the process.
-  // For a task that represents the browser process, the return value is 0.
-  // For a task that doesn't have a host on the browser process, the return
-  // value is also 0. For other tasks that represent renderers and other child
-  // processes, the return value is whatever unique IDs of their hosts in the
-  // browser process.
-  virtual int GetChildProcessUniqueId(TaskId task_id) const = 0;
-
-  // If the process, in which the task with |task_id| is running, is terminated
-  // this gets the termination status. Currently implemented only for Renderer
-  // processes. The values will only be valid if the process has actually
-  // terminated.
-  virtual void GetTerminationStatus(TaskId task_id,
-                                    base::TerminationStatus* out_status,
-                                    int* out_error_code) const = 0;
-
-  // Returns the network usage (in bytes per second) during the current refresh
-  // cycle for the task with |task_id|. A value of -1 means no valid value is
-  // currently available or that task has never been notified of any network
-  // usage.
-  virtual int64_t GetNetworkUsage(TaskId task_id) const = 0;
-
-  // Returns the total network usage (in bytes per second) during the current
-  // refresh cycle for the process on which the task with |task_id| is running.
-  // This is the sum of all the network usage of the individual tasks (that
-  // can be gotten by the above GetNetworkUsage()). A value of -1 means network
-  // usage calculation refresh is currently not available.
-  virtual int64_t GetProcessTotalNetworkUsage(TaskId task_id) const = 0;
-
-  // Returns the Sqlite used memory (in bytes) for the task with |task_id|.
-  // A value of -1 means no valid value is currently available.
-  virtual int64_t GetSqliteMemoryUsed(TaskId task_id) const = 0;
-
-  // Returns the allocated and used V8 memory (in bytes) for the task with
-  // |task_id|. A return value of false means no valid value is currently
-  // available.
-  virtual bool GetV8Memory(TaskId task_id,
-                           int64_t* allocated,
-                           int64_t* used) const = 0;
-
-  // Gets the Webkit resource cache stats for the task with |task_id|.
-  // A return value of false means that task does NOT report WebCache stats.
-  virtual bool GetWebCacheStats(
-      TaskId task_id,
-      blink::WebCache::ResourceTypeStats* stats) const = 0;
-
-  // Gets the list of task IDs currently tracked by the task manager. Tasks that
-  // share the same process id will always be consecutive. The list will be
-  // sorted in a way that reflects the process tree: the browser process will be
-  // first, followed by the gpu process if it exists. Related processes (e.g., a
-  // subframe process and its parent) will be kept together if possible. Callers
-  // can expect this ordering to be stable when a process is added or removed.
-  virtual const TaskIdList& GetTaskIdsList() const = 0;
-
-  // Gets the list of task IDs of the tasks that run on the same process as the
-  // task with |task_id|. The returned list will at least include |task_id|.
-  virtual TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const = 0;
-
-  // Gets the number of task-manager tasks running on the same process on which
-  // the Task with |task_id| is running.
-  virtual size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const = 0;
-
-  // Returns the TaskId associated with the main task for |web_contents|.
-  // Returns -1 if |web_contents| is nullptr or does not currently have an
-  // associated Task.
-  virtual TaskId GetTaskIdForWebContents(
-      content::WebContents* web_contents) const = 0;
-
-  // Returns true if the resource |type| usage calculation is enabled and
-  // the implementation should refresh its value (this means that at least one
-  // of the observers require this value). False otherwise.
-  bool IsResourceRefreshEnabled(RefreshType type) const;
-
- protected:
-  TaskManagerInterface();
-  virtual ~TaskManagerInterface();
-
-  // Notifying observers of various events.
-  void NotifyObserversOnTaskAdded(TaskId id);
-  void NotifyObserversOnTaskToBeRemoved(TaskId id);
-  void NotifyObserversOnRefresh(const TaskIdList& task_ids);
-  void NotifyObserversOnRefreshWithBackgroundCalculations(
-      const TaskIdList& task_ids);
-  void NotifyObserversOnTaskUnresponsive(TaskId id);
-
-  // Refresh all the enabled resources usage of all the available tasks.
-  virtual void Refresh() = 0;
-
-  // StartUpdating will be called once an observer is added, and StopUpdating
-  // will be called when the last observer is removed.
-  virtual void StartUpdating() = 0;
-  virtual void StopUpdating() = 0;
-
-  // Returns the current refresh time that this task manager is running at. It
-  // will return base::TimeDelta::Max() if the task manager is not running.
-  base::TimeDelta GetCurrentRefreshTime() const;
-
-  int64_t enabled_resources_flags() const { return enabled_resources_flags_; }
-
-  void set_timer_for_testing(std::unique_ptr<base::Timer> timer) {
-    refresh_timer_ = std::move(timer);
-  }
-
- private:
-  friend class TaskManagerObserver;
-
-  // This should be called after each time an observer changes its own desired
-  // resources refresh flags.
-  void RecalculateRefreshFlags();
-
-  // Appends |flags| to the |enabled_resources_flags_|.
-  void ResourceFlagsAdded(int64_t flags);
-
-  // Sets |enabled_resources_flags_| to |flags|.
-  void SetEnabledResourceFlags(int64_t flags);
-
-  // Schedules the task manager refresh cycles using the given |refresh_time|.
-  // It stops any existing refresh schedule.
-  void ScheduleRefresh(base::TimeDelta refresh_time);
-
-  // The list of observers.
-  base::ObserverList<TaskManagerObserver> observers_;
-
-  // The timer that will be used to schedule the successive refreshes.
-  std::unique_ptr<base::Timer> refresh_timer_;
-
-  // The flags containing the enabled resources types calculations.
-  int64_t enabled_resources_flags_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerInterface);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_INTERFACE_H_
diff --git a/chrome/browser/task_manager/task_manager_observer.cc b/chrome/browser/task_manager/task_manager_observer.cc
deleted file mode 100644
index 4a3900f..0000000
--- a/chrome/browser/task_manager/task_manager_observer.cc
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/task_manager_observer.h"
-
-#include "chrome/browser/task_manager/task_manager_interface.h"
-
-namespace task_manager {
-
-// static
-bool TaskManagerObserver::IsResourceRefreshEnabled(RefreshType refresh_type,
-                                                   int refresh_flags) {
-  return (refresh_flags & refresh_type) != 0;
-}
-
-TaskManagerObserver::TaskManagerObserver(base::TimeDelta refresh_time,
-                                         int64_t resources_flags)
-    : observed_task_manager_(nullptr),
-      desired_refresh_time_(refresh_time < base::TimeDelta::FromSeconds(1)
-                                ? base::TimeDelta::FromSeconds(1)
-                                : refresh_time),
-      desired_resources_flags_(resources_flags) {}
-
-TaskManagerObserver::~TaskManagerObserver() {
-  if (observed_task_manager())
-    observed_task_manager()->RemoveObserver(this);
-}
-
-void TaskManagerObserver::AddRefreshType(RefreshType type) {
-  desired_resources_flags_ |= type;
-
-  if (observed_task_manager_)
-    observed_task_manager_->RecalculateRefreshFlags();
-}
-
-void TaskManagerObserver::RemoveRefreshType(RefreshType type) {
-  desired_resources_flags_ &= ~type;
-
-  if (observed_task_manager_)
-    observed_task_manager_->RecalculateRefreshFlags();
-}
-
-void TaskManagerObserver::SetRefreshTypesFlags(int64_t flags) {
-  desired_resources_flags_ = flags;
-
-  if (observed_task_manager_)
-    observed_task_manager_->RecalculateRefreshFlags();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/task_manager_observer.h b/chrome/browser/task_manager/task_manager_observer.h
deleted file mode 100644
index c7c4f9c..0000000
--- a/chrome/browser/task_manager/task_manager_observer.h
+++ /dev/null
@@ -1,144 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_OBSERVER_H_
-#define CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_OBSERVER_H_
-
-#include <stdint.h>
-
-#include <vector>
-
-#include "base/macros.h"
-#include "base/time/time.h"
-#include "build/build_config.h"
-
-namespace task_manager {
-
-class TaskManagerInterface;
-
-using TaskId = int64_t;
-using TaskIdList = std::vector<TaskId>;
-
-// Defines a list of types of resources that an observer needs to be refreshed
-// on every task manager refresh cycle.
-enum RefreshType {
-  REFRESH_TYPE_NONE              = 0,
-  REFRESH_TYPE_CPU               = 1,
-  REFRESH_TYPE_MEMORY            = 1 << 1,
-  REFRESH_TYPE_GPU_MEMORY        = 1 << 2,
-  REFRESH_TYPE_V8_MEMORY         = 1 << 3,
-  REFRESH_TYPE_SQLITE_MEMORY     = 1 << 4,
-  REFRESH_TYPE_WEBCACHE_STATS    = 1 << 5,
-  REFRESH_TYPE_NETWORK_USAGE     = 1 << 6,
-  REFRESH_TYPE_NACL              = 1 << 7,
-  REFRESH_TYPE_IDLE_WAKEUPS      = 1 << 8,
-  REFRESH_TYPE_HANDLES           = 1 << 9,
-
-  // Whether an observer is interested in knowing if a process is foregrounded
-  // or backgrounded.
-  REFRESH_TYPE_PRIORITY          = 1 << 10,
-
-#if defined(OS_LINUX)
-  // For observers interested in getting the number of open file descriptors of
-  // processes.
-  REFRESH_TYPE_FD_COUNT          = 1 << 11,
-#endif  // defined(OS_LINUX)
-};
-
-// Defines the interface for observers of the task manager.
-class TaskManagerObserver {
- public:
-  static bool IsResourceRefreshEnabled(RefreshType refresh_type,
-                                       int refresh_flags);
-
-  // Constructs a TaskManagerObserver given the minimum |refresh_time| that it
-  // it requires the task manager to be refreshing the values at, along with the
-  // |resources_flags| that it needs to be calculated on each refresh cycle of
-  // the task manager (use the above flags in |ResourceType|).
-  //
-  // Notes:
-  // 1- The task manager will refresh at least once every |refresh_time| as
-  // long as this observer is added to it. There might be other observers that
-  // require more frequent refreshes.
-  // 2- Refresh time values less than 1 second will be considered as 1 second.
-  // 3- Depending on the other observers, the task manager may refresh more
-  // resources than those defined in |resources_flags|.
-  // 4- Upon the removal of the observer from the task manager, the task manager
-  // will update its refresh time and the calculated resources to be the minimum
-  // required value of all the remaining observers.
-  TaskManagerObserver(base::TimeDelta refresh_time, int64_t resources_flags);
-  virtual ~TaskManagerObserver();
-
-  // Notifies the observer that a chrome task with |id| has started and the task
-  // manager is now monitoring it. The resource usage of this newly-added task
-  // will remain invalid until the next refresh cycle of the task manager.
-  virtual void OnTaskAdded(TaskId id) {}
-
-  // Notifies the observer that a chrome task with |id| is about to be destroyed
-  // and removed from the task manager right after this call. Observers which
-  // are interested in doing some calculations related to the resource usage of
-  // this task upon its removal may do so inside this call.
-  virtual void OnTaskToBeRemoved(TaskId id) {}
-
-  // Notifies the observer that the task manager has just finished a refresh
-  // cycle to calculate the resources usage of all tasks whose IDs are given in
-  // |task_ids|. |task_ids| will be sorted such that the task representing the
-  // browser process is at the top of the list and the rest of the IDs will be
-  // sorted by the process IDs on which the tasks are running, then by the task
-  // IDs themselves.
-  virtual void OnTasksRefreshed(const TaskIdList& task_ids) {}
-
-  // Notifies the observer that the task manager has just finished a refresh
-  // cycle that calculated all the resource usage of all tasks whose IDs are in
-  // |task_ids| including the resource usages that are calculated in the
-  // background such CPU and memory (If those refresh types are enabled).
-  // This event can take longer to be fired, and can miss some changes that may
-  // happen to non-background calculations in-between two successive
-  // invocations. Listen to this ONLY if you must know when all the background
-  // resource calculations to be valid for all the available processes.
-  // |task_ids| will be sorted as specified in OnTasksRefreshed() above.
-  virtual void OnTasksRefreshedWithBackgroundCalculations(
-      const TaskIdList& task_ids) {}
-
-  // Notifies the observer that the task with |id| is running on a renderer that
-  // has become unresponsive.
-  virtual void OnTaskUnresponsive(TaskId id) {}
-
-  const base::TimeDelta& desired_refresh_time() const {
-    return desired_refresh_time_;
-  }
-
-  int64_t desired_resources_flags() const { return desired_resources_flags_; }
-
- protected:
-  TaskManagerInterface* observed_task_manager() const {
-    return observed_task_manager_;
-  }
-
-  // Add or Remove a refresh |type|.
-  void AddRefreshType(RefreshType type);
-  void RemoveRefreshType(RefreshType type);
-  void SetRefreshTypesFlags(int64_t flags);
-
- private:
-  friend class TaskManagerInterface;
-
-  // The currently observed task Manager.
-  TaskManagerInterface* observed_task_manager_;
-
-  // The minimum update time of the task manager that this observer needs to
-  // do its job.
-  base::TimeDelta desired_refresh_time_;
-
-  // The flags that contain the resources that this observer needs to be
-  // calculated on each refresh.
-  int64_t desired_resources_flags_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerObserver);
-};
-
-}  // namespace task_manager
-
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_OBSERVER_H_
diff --git a/chrome/browser/task_manager/task_manager_observer_unittest.cc b/chrome/browser/task_manager/task_manager_observer_unittest.cc
deleted file mode 100644
index fdd46d4..0000000
--- a/chrome/browser/task_manager/task_manager_observer_unittest.cc
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <stdint.h>
-
-#include "base/macros.h"
-#include "chrome/browser/task_manager/test_task_manager.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace task_manager {
-
-namespace {
-
-// Defines a concrete observer that will be used for testing.
-class TestObserver : public TaskManagerObserver {
- public:
-  TestObserver(base::TimeDelta refresh_time, int64_t resources_flags)
-      : TaskManagerObserver(refresh_time, resources_flags) {}
-
-  ~TestObserver() override {}
-
-  // task_manager::TaskManagerObserver:
-  void OnTaskAdded(TaskId id) override {}
-  void OnTaskToBeRemoved(TaskId id) override {}
-  void OnTasksRefreshed(const TaskIdList& task_ids) override {}
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TestObserver);
-};
-
-// Defines a test to validate the behavior of the task manager in response to
-// adding and removing different kind of observers.
-class TaskManagerObserverTest : public testing::Test {
- public:
-  TaskManagerObserverTest() {}
-  ~TaskManagerObserverTest() override {}
-
-  TestTaskManager& task_manager() { return task_manager_; }
-
- private:
-  TestTaskManager task_manager_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskManagerObserverTest);
-};
-
-}  // namespace
-
-// Validates that the minimum refresh time to be requested is one second. Also
-// validates the desired resource flags.
-TEST_F(TaskManagerObserverTest, Basic) {
-  base::TimeDelta refresh_time1 = base::TimeDelta::FromSeconds(2);
-  base::TimeDelta refresh_time2 = base::TimeDelta::FromMilliseconds(999);
-  int64_t flags1 = RefreshType::REFRESH_TYPE_CPU |
-                   RefreshType::REFRESH_TYPE_WEBCACHE_STATS |
-                   RefreshType::REFRESH_TYPE_HANDLES;
-  int64_t flags2 =
-      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_NACL;
-
-  TestObserver observer1(refresh_time1, flags1);
-  TestObserver observer2(refresh_time2, flags2);
-
-  EXPECT_EQ(refresh_time1, observer1.desired_refresh_time());
-  EXPECT_EQ(base::TimeDelta::FromSeconds(1), observer2.desired_refresh_time());
-  EXPECT_EQ(flags1, observer1.desired_resources_flags());
-  EXPECT_EQ(flags2, observer2.desired_resources_flags());
-}
-
-// Validates the behavior of the task manager in response to adding and
-// removing observers.
-TEST_F(TaskManagerObserverTest, TaskManagerResponseToObservers) {
-  EXPECT_EQ(base::TimeDelta::Max(), task_manager().GetRefreshTime());
-  EXPECT_EQ(0, task_manager().GetEnabledFlags());
-
-  // Add a bunch of observers and make sure the task manager responds correctly.
-  base::TimeDelta refresh_time1 = base::TimeDelta::FromSeconds(3);
-  base::TimeDelta refresh_time2 = base::TimeDelta::FromSeconds(10);
-  base::TimeDelta refresh_time3 = base::TimeDelta::FromSeconds(3);
-  base::TimeDelta refresh_time4 = base::TimeDelta::FromSeconds(2);
-  int64_t flags1 = RefreshType::REFRESH_TYPE_CPU |
-                   RefreshType::REFRESH_TYPE_WEBCACHE_STATS |
-                   RefreshType::REFRESH_TYPE_HANDLES;
-  int64_t flags2 =
-      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_NACL;
-  int64_t flags3 =
-      RefreshType::REFRESH_TYPE_MEMORY | RefreshType::REFRESH_TYPE_CPU;
-  int64_t flags4 = RefreshType::REFRESH_TYPE_GPU_MEMORY;
-
-  TestObserver observer1(refresh_time1, flags1);
-  TestObserver observer2(refresh_time2, flags2);
-  TestObserver observer3(refresh_time3, flags3);
-  TestObserver observer4(refresh_time4, flags4);
-
-  task_manager().AddObserver(&observer1);
-  task_manager().AddObserver(&observer2);
-  task_manager().AddObserver(&observer3);
-  task_manager().AddObserver(&observer4);
-
-  EXPECT_EQ(refresh_time4, task_manager().GetRefreshTime());
-  EXPECT_EQ(flags1 | flags2 | flags3 | flags4,
-            task_manager().GetEnabledFlags());
-
-  // Removing observers should also reflect on the refresh time and resource
-  // flags.
-  task_manager().RemoveObserver(&observer4);
-  EXPECT_EQ(refresh_time3, task_manager().GetRefreshTime());
-  EXPECT_EQ(flags1 | flags2 | flags3, task_manager().GetEnabledFlags());
-  task_manager().RemoveObserver(&observer3);
-  EXPECT_EQ(refresh_time1, task_manager().GetRefreshTime());
-  EXPECT_EQ(flags1 | flags2, task_manager().GetEnabledFlags());
-  task_manager().RemoveObserver(&observer2);
-  EXPECT_EQ(refresh_time1, task_manager().GetRefreshTime());
-  EXPECT_EQ(flags1, task_manager().GetEnabledFlags());
-  task_manager().RemoveObserver(&observer1);
-  EXPECT_EQ(base::TimeDelta::Max(), task_manager().GetRefreshTime());
-  EXPECT_EQ(0, task_manager().GetEnabledFlags());
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/task_manager_tester.cc b/chrome/browser/task_manager/task_manager_tester.cc
deleted file mode 100644
index 5d6bd43..0000000
--- a/chrome/browser/task_manager/task_manager_tester.cc
+++ /dev/null
@@ -1,170 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/task_manager_tester.h"
-
-#include "base/memory/ptr_util.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
-#include "chrome/browser/ui/browser_dialogs.h"
-#include "chrome/browser/ui/task_manager/task_manager_table_model.h"
-#include "chrome/common/chrome_switches.h"
-#include "chrome/grit/generated_resources.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "ui/base/models/table_model_observer.h"
-
-namespace task_manager {
-
-// Temporarily intercepts the calls between a TableModel and its Observer,
-// running |callback| whenever anything happens.
-class ScopedInterceptTableModelObserver : public ui::TableModelObserver {
- public:
-  ScopedInterceptTableModelObserver(
-      ui::TableModel* model_to_intercept,
-      ui::TableModelObserver* real_table_model_observer,
-      const base::Closure& callback)
-      : model_to_intercept_(model_to_intercept),
-        real_table_model_observer_(real_table_model_observer),
-        callback_(callback) {
-    model_to_intercept_->SetObserver(this);
-  }
-
-  ~ScopedInterceptTableModelObserver() override {
-    model_to_intercept_->SetObserver(real_table_model_observer_);
-  }
-
-  // ui::TableModelObserver:
-  void OnModelChanged() override {
-    real_table_model_observer_->OnModelChanged();
-    callback_.Run();
-  }
-  void OnItemsChanged(int start, int length) override {
-    real_table_model_observer_->OnItemsChanged(start, length);
-    callback_.Run();
-  }
-  void OnItemsAdded(int start, int length) override {
-    real_table_model_observer_->OnItemsAdded(start, length);
-    callback_.Run();
-  }
-  void OnItemsRemoved(int start, int length) override {
-    real_table_model_observer_->OnItemsRemoved(start, length);
-    callback_.Run();
-  }
-
- private:
-  ui::TableModel* model_to_intercept_;
-  ui::TableModelObserver* real_table_model_observer_;
-  base::Closure callback_;
-};
-
-namespace {
-
-// Returns the TaskManagerTableModel for the the visible NewTaskManagerView.
-TaskManagerTableModel* GetRealModel() {
-  return chrome::ShowTaskManager(nullptr);
-}
-
-}  // namespace
-
-TaskManagerTester::TaskManagerTester(const base::Closure& on_resource_change)
-    : model_(GetRealModel()) {
-  // Eavesdrop the model->view conversation, since the model only supports
-  // single observation.
-  if (!on_resource_change.is_null()) {
-    interceptor_.reset(new ScopedInterceptTableModelObserver(
-        model_, model_->table_model_observer_, on_resource_change));
-  }
-}
-
-TaskManagerTester::~TaskManagerTester() {
-  CHECK_EQ(GetRealModel(), model_) << "Task Manager should not be hidden "
-                                      "while TaskManagerTester is alive. "
-                                      "This indicates a test bug.";
-}
-
-// TaskManagerTester:
-int TaskManagerTester::GetRowCount() {
-  return model_->RowCount();
-}
-
-base::string16 TaskManagerTester::GetRowTitle(int row) {
-  return model_->GetText(row, IDS_TASK_MANAGER_TASK_COLUMN);
-}
-
-void TaskManagerTester::ToggleColumnVisibility(ColumnSpecifier column) {
-  int column_id = 0;
-  switch (column) {
-    case ColumnSpecifier::COLUMN_NONE:
-      return;
-    case ColumnSpecifier::SQLITE_MEMORY_USED:
-      column_id = IDS_TASK_MANAGER_SQLITE_MEMORY_USED_COLUMN;
-      break;
-    case ColumnSpecifier::V8_MEMORY_USED:
-    case ColumnSpecifier::V8_MEMORY:
-      column_id = IDS_TASK_MANAGER_JAVASCRIPT_MEMORY_ALLOCATED_COLUMN;
-      break;
-    case ColumnSpecifier::IDLE_WAKEUPS:
-      column_id = IDS_TASK_MANAGER_IDLE_WAKEUPS_COLUMN;
-      break;
-  }
-  model_->ToggleColumnVisibility(column_id);
-}
-
-int64_t TaskManagerTester::GetColumnValue(ColumnSpecifier column, int row) {
-  TaskId task_id = model_->tasks_[row];
-  int64_t value = 0;
-  int64_t ignored = 0;
-  bool success = false;
-
-  switch (column) {
-    case ColumnSpecifier::COLUMN_NONE:
-      break;
-    case ColumnSpecifier::V8_MEMORY:
-      success = task_manager()->GetV8Memory(task_id, &value, &ignored);
-      break;
-    case ColumnSpecifier::V8_MEMORY_USED:
-      success = task_manager()->GetV8Memory(task_id, &ignored, &value);
-      break;
-    case ColumnSpecifier::SQLITE_MEMORY_USED:
-      value = task_manager()->GetSqliteMemoryUsed(task_id);
-      success = true;
-      break;
-    case ColumnSpecifier::IDLE_WAKEUPS:
-      value = task_manager()->GetIdleWakeupsPerSecond(task_id);
-      success = true;
-      break;
-  }
-  if (!success)
-    return 0;
-  return value;
-}
-
-int32_t TaskManagerTester::GetTabId(int row) {
-  TaskId task_id = model_->tasks_[row];
-  return task_manager()->GetTabId(task_id);
-}
-
-void TaskManagerTester::Kill(int row) {
-  model_->KillTask(row);
-}
-
-void TaskManagerTester::GetRowsGroupRange(int row,
-                                          int* out_start,
-                                          int* out_length) {
-  return model_->GetRowsGroupRange(row, out_start, out_length);
-}
-
-TaskManagerInterface* TaskManagerTester::task_manager() {
-  return model_->observed_task_manager();
-}
-
-// static
-std::unique_ptr<TaskManagerTester> TaskManagerTester::Create(
-    const base::Closure& callback) {
-  return base::WrapUnique(new TaskManagerTester(callback));
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/task_manager_tester.h b/chrome/browser/task_manager/task_manager_tester.h
deleted file mode 100644
index 94d075f..0000000
--- a/chrome/browser/task_manager/task_manager_tester.h
+++ /dev/null
@@ -1,71 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_TESTER_H_
-#define CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_TESTER_H_
-
-#include <stdint.h>
-
-#include <memory>
-
-#include "base/callback_forward.h"
-#include "base/strings/string16.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
-
-namespace task_manager {
-
-class ScopedInterceptTableModelObserver;
-class TaskManagerInterface;
-class TaskManagerTableModel;
-
-// An adapter to simplify testing the task manager.
-class TaskManagerTester {
- public:
-  using ColumnSpecifier = browsertest_util::ColumnSpecifier;
-
-  ~TaskManagerTester();
-
-  // Creates a TaskManagerTester backed by the current task manager. The task
-  // manager should already be visible when you call this function.
-  // |on_resource_change|, if not a null callback, will be invoked when the
-  // underlying model changes.
-  static std::unique_ptr<TaskManagerTester> Create(
-      const base::Closure& on_resource_change);
-
-  // Get the number of rows currently in the task manager.
-  int GetRowCount();
-
-  // Get the title text of a particular |row|.
-  base::string16 GetRowTitle(int row);
-
-  // Hide or show a column. If a column is not visible its stats are not
-  // necessarily gathered.
-  void ToggleColumnVisibility(ColumnSpecifier column);
-
-  // Get the value of a column as an int64. Memory values are in bytes.
-  int64_t GetColumnValue(ColumnSpecifier column, int row);
-
-  // If |row| is associated with a WebContents, return its SessionID. Otherwise,
-  // return -1.
-  int32_t GetTabId(int row);
-
-  // Kill the process of |row|.
-  void Kill(int row);
-
-  // Gets the start index and length of the group to which the task at
-  // |row_index| belongs.
-  void GetRowsGroupRange(int row, int* out_start, int* out_length);
-
- private:
-  explicit TaskManagerTester(const base::Closure& on_resource_change);
-
-  TaskManagerInterface* task_manager();
-
-  TaskManagerTableModel* model_;
-  std::unique_ptr<ScopedInterceptTableModelObserver> interceptor_;
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_TASK_MANAGER_TESTER_H_
diff --git a/chrome/browser/task_manager/test_task_manager.cc b/chrome/browser/task_manager/test_task_manager.cc
deleted file mode 100644
index c0fab6d..0000000
--- a/chrome/browser/task_manager/test_task_manager.cc
+++ /dev/null
@@ -1,177 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/test_task_manager.h"
-
-namespace task_manager {
-
-TestTaskManager::TestTaskManager()
-    : handle_(base::kNullProcessHandle),
-      pid_(base::kNullProcessId) {
-  set_timer_for_testing(
-      std::unique_ptr<base::Timer>(new base::MockTimer(true, true)));
-}
-
-TestTaskManager::~TestTaskManager() {
-}
-
-void TestTaskManager::ActivateTask(TaskId task_id) {
-}
-
-bool TestTaskManager::IsTaskKillable(TaskId task_id) {
-  return true;
-}
-
-void TestTaskManager::KillTask(TaskId task_id) {
-}
-
-double TestTaskManager::GetCpuUsage(TaskId task_id) const {
-  return 0.0;
-}
-
-int64_t TestTaskManager::GetPhysicalMemoryUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetPrivateMemoryUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetSharedMemoryUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetSwappedMemoryUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetGpuMemoryUsage(TaskId task_id,
-                                           bool* has_duplicates) const {
-  return -1;
-}
-
-int TestTaskManager::GetIdleWakeupsPerSecond(TaskId task_id) const {
-  return -1;
-}
-
-int TestTaskManager::GetNaClDebugStubPort(TaskId task_id) const {
-  return -1;
-}
-
-void TestTaskManager::GetGDIHandles(TaskId task_id,
-                                    int64_t* current,
-                                    int64_t* peak) const {}
-
-void TestTaskManager::GetUSERHandles(TaskId task_id,
-                                     int64_t* current,
-                                     int64_t* peak) const {}
-
-int TestTaskManager::GetOpenFdCount(TaskId task_id) const {
-  return -1;
-}
-
-bool TestTaskManager::IsTaskOnBackgroundedProcess(TaskId task_id) const {
-  return false;
-}
-
-const base::string16& TestTaskManager::GetTitle(TaskId task_id) const {
-  return title_;
-}
-
-const std::string& TestTaskManager::GetTaskNameForRappor(TaskId task_id) const {
-  return rappor_sample_;
-}
-
-base::string16 TestTaskManager::GetProfileName(TaskId task_id) const {
-  return base::string16();
-}
-
-const gfx::ImageSkia& TestTaskManager::GetIcon(TaskId task_id) const {
-  return icon_;
-}
-
-const base::ProcessHandle& TestTaskManager::GetProcessHandle(
-    TaskId task_id) const {
-  return handle_;
-}
-
-const base::ProcessId& TestTaskManager::GetProcessId(TaskId task_id) const {
-  return pid_;
-}
-
-Task::Type TestTaskManager::GetType(TaskId task_id) const {
-  return Task::UNKNOWN;
-}
-
-int TestTaskManager::GetTabId(TaskId task_id) const {
-  return -1;
-}
-
-int TestTaskManager::GetChildProcessUniqueId(TaskId task_id) const {
-  return 0;
-}
-
-void TestTaskManager::GetTerminationStatus(TaskId task_id,
-                                           base::TerminationStatus* out_status,
-                                           int* out_error_code) const {
-  DCHECK(out_status);
-  DCHECK(out_error_code);
-
-  *out_status = base::TERMINATION_STATUS_STILL_RUNNING;
-  *out_error_code = 0;
-}
-
-int64_t TestTaskManager::GetNetworkUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetProcessTotalNetworkUsage(TaskId task_id) const {
-  return -1;
-}
-
-int64_t TestTaskManager::GetSqliteMemoryUsed(TaskId task_id) const {
-  return -1;
-}
-
-bool TestTaskManager::GetV8Memory(TaskId task_id,
-                                  int64_t* allocated,
-                                  int64_t* used) const {
-  return false;
-}
-
-bool TestTaskManager::GetWebCacheStats(
-    TaskId task_id,
-    blink::WebCache::ResourceTypeStats* stats) const {
-  return false;
-}
-
-const TaskIdList& TestTaskManager::GetTaskIdsList() const {
-  return ids_;
-}
-
-TaskIdList TestTaskManager::GetIdsOfTasksSharingSameProcess(
-    TaskId task_id) const {
-  TaskIdList result;
-  result.push_back(task_id);
-  return result;
-}
-
-size_t TestTaskManager::GetNumberOfTasksOnSameProcess(TaskId task_id) const {
-  return 1;
-}
-
-TaskId TestTaskManager::GetTaskIdForWebContents(
-    content::WebContents* web_contents) const {
-  return -1;
-}
-
-base::TimeDelta TestTaskManager::GetRefreshTime() {
-  return GetCurrentRefreshTime();
-}
-
-int64_t TestTaskManager::GetEnabledFlags() {
-  return enabled_resources_flags();
-}
-
-}  // namespace task_manager
diff --git a/chrome/browser/task_manager/test_task_manager.h b/chrome/browser/task_manager/test_task_manager.h
deleted file mode 100644
index a023fb0..0000000
--- a/chrome/browser/task_manager/test_task_manager.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_TEST_TASK_MANAGER_H_
-#define CHROME_BROWSER_TASK_MANAGER_TEST_TASK_MANAGER_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include "base/macros.h"
-#include "base/timer/mock_timer.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
-
-namespace task_manager {
-
-// This is a partial stub implementation that can be used as a base class for
-// implementations of the task manager used in unit tests.
-class TestTaskManager : public TaskManagerInterface {
- public:
-  TestTaskManager();
-  ~TestTaskManager() override;
-
-  // task_manager::TaskManagerInterface:
-  void ActivateTask(TaskId task_id) override;
-  bool IsTaskKillable(TaskId task_id) override;
-  void KillTask(TaskId task_id) override;
-  double GetCpuUsage(TaskId task_id) const override;
-  int64_t GetPhysicalMemoryUsage(TaskId task_id) const override;
-  int64_t GetPrivateMemoryUsage(TaskId task_id) const override;
-  int64_t GetSharedMemoryUsage(TaskId task_id) const override;
-  int64_t GetSwappedMemoryUsage(TaskId task_id) const override;
-  int64_t GetGpuMemoryUsage(TaskId task_id,
-                            bool* has_duplicates) const override;
-  int GetIdleWakeupsPerSecond(TaskId task_id) const override;
-  int GetNaClDebugStubPort(TaskId task_id) const override;
-  void GetGDIHandles(TaskId task_id,
-                     int64_t* current,
-                     int64_t* peak) const override;
-  void GetUSERHandles(TaskId task_id,
-                      int64_t* current,
-                      int64_t* peak) const override;
-  int GetOpenFdCount(TaskId task_id) const override;
-  bool IsTaskOnBackgroundedProcess(TaskId task_id) const override;
-  const base::string16& GetTitle(TaskId task_id) const override;
-  const std::string& GetTaskNameForRappor(TaskId task_id) const override;
-  base::string16 GetProfileName(TaskId task_id) const override;
-  const gfx::ImageSkia& GetIcon(TaskId task_id) const override;
-  const base::ProcessHandle& GetProcessHandle(TaskId task_id) const override;
-  const base::ProcessId& GetProcessId(TaskId task_id) const override;
-  Task::Type GetType(TaskId task_id) const override;
-  int GetTabId(TaskId task_id) const override;
-  int GetChildProcessUniqueId(TaskId task_id) const override;
-  void GetTerminationStatus(TaskId task_id,
-                            base::TerminationStatus* out_status,
-                            int* out_error_code) const override;
-  int64_t GetNetworkUsage(TaskId task_id) const override;
-  int64_t GetProcessTotalNetworkUsage(TaskId task_id) const override;
-  int64_t GetSqliteMemoryUsed(TaskId task_id) const override;
-  bool GetV8Memory(TaskId task_id,
-                   int64_t* allocated,
-                   int64_t* used) const override;
-  bool GetWebCacheStats(
-      TaskId task_id,
-      blink::WebCache::ResourceTypeStats* stats) const override;
-  const TaskIdList& GetTaskIdsList() const override;
-  TaskIdList GetIdsOfTasksSharingSameProcess(TaskId task_id) const override;
-  size_t GetNumberOfTasksOnSameProcess(TaskId task_id) const override;
-  TaskId GetTaskIdForWebContents(
-      content::WebContents* web_contents) const override;
-
-  base::TimeDelta GetRefreshTime();
-  int64_t GetEnabledFlags();
-
- protected:
-  // task_manager::TaskManager:
-  void Refresh() override {}
-  void StartUpdating() override {}
-  void StopUpdating() override {}
-
-  base::ProcessHandle handle_;
-  base::ProcessId pid_;
-  base::string16 title_;
-  std::string rappor_sample_;
-  gfx::ImageSkia icon_;
-  TaskIdList ids_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TestTaskManager);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_TEST_TASK_MANAGER_H_
diff --git a/chrome/browser/task_manager/web_contents_tags.cc b/chrome/browser/task_manager/web_contents_tags.cc
deleted file mode 100644
index adb6eb4..0000000
--- a/chrome/browser/task_manager/web_contents_tags.cc
+++ /dev/null
@@ -1,176 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/task_manager/web_contents_tags.h"
-
-#include "chrome/browser/task_manager/providers/web_contents/background_contents_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/devtools_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/extension_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/guest_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/panel_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/prerender_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/printing_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/tab_contents_tag.h"
-#include "chrome/browser/task_manager/providers/web_contents/web_contents_tags_manager.h"
-#include "components/guest_view/browser/guest_view_base.h"
-#include "content/public/browser/web_contents.h"
-#include "extensions/browser/view_type_utils.h"
-
-#if defined(ENABLE_EXTENSIONS)
-#include "chrome/browser/ui/panels/panel.h"
-#include "extensions/browser/process_manager.h"
-#endif
-
-namespace task_manager {
-
-#if defined(ENABLE_TASK_MANAGER)
-namespace {
-
-// Adds the |tag| to |contents|. It also adds the |tag| to the
-// |WebContentsTagsManager|.
-// Note: This will fail if |contents| is already tagged by |tag|.
-void TagWebContents(content::WebContents* contents,
-                    WebContentsTag* tag,
-                    void* tag_key) {
-  DCHECK(contents);
-  DCHECK(tag);
-  DCHECK(WebContentsTag::FromWebContents(contents) == nullptr);
-  contents->SetUserData(tag_key, tag);
-  WebContentsTagsManager::GetInstance()->AddTag(tag);
-}
-
-#if defined(ENABLE_EXTENSIONS)
-
-bool IsExtensionWebContents(content::WebContents* contents) {
-  DCHECK(contents);
-
-  if (guest_view::GuestViewBase::IsGuest(contents))
-    return false;
-
-  extensions::ViewType view_type = extensions::GetViewType(contents);
-  return (view_type != extensions::VIEW_TYPE_INVALID &&
-          view_type != extensions::VIEW_TYPE_TAB_CONTENTS &&
-          view_type != extensions::VIEW_TYPE_BACKGROUND_CONTENTS &&
-          view_type != extensions::VIEW_TYPE_PANEL);
-}
-
-#endif  // defined(ENABLE_EXTENSIONS)
-
-}  // namespace
-#endif  // defined(ENABLE_TASK_MANAGER)
-
-// static
-void WebContentsTags::CreateForBackgroundContents(
-    content::WebContents* web_contents,
-    BackgroundContents* background_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(
-        web_contents,
-        new BackgroundContentsTag(web_contents, background_contents),
-        WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-// static
-void WebContentsTags::CreateForDevToolsContents(
-    content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new DevToolsTag(web_contents),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-// static
-void WebContentsTags::CreateForPrerenderContents(
-    content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new PrerenderTag(web_contents),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-// static
-void WebContentsTags::CreateForTabContents(content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new TabContentsTag(web_contents),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-// static
-void WebContentsTags::CreateForPanel(content::WebContents* web_contents,
-                                     Panel* panel) {
-#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
-  DCHECK(panel);
-  DCHECK_EQ(web_contents, panel->GetWebContents());
-
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new PanelTag(web_contents, panel),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
-}
-
-// static
-void WebContentsTags::CreateForPrintingContents(
-    content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_PRINT_PREVIEW)
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new PrintingTag(web_contents),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_PRINT_PREVIEW)
-}
-
-// static
-void WebContentsTags::CreateForGuestContents(
-    content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  DCHECK(guest_view::GuestViewBase::IsGuest(web_contents));
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new GuestTag(web_contents),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-// static
-void WebContentsTags::CreateForExtension(content::WebContents* web_contents,
-                                         extensions::ViewType view_type) {
-#if defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
-  DCHECK(IsExtensionWebContents(web_contents));
-
-  if (!WebContentsTag::FromWebContents(web_contents)) {
-    TagWebContents(web_contents,
-                   new ExtensionTag(web_contents, view_type),
-                   WebContentsTag::kTagKey);
-  }
-#endif  // defined(ENABLE_TASK_MANAGER) && defined(ENABLE_EXTENSIONS)
-}
-
-// static
-void WebContentsTags::ClearTag(content::WebContents* web_contents) {
-#if defined(ENABLE_TASK_MANAGER)
-  const WebContentsTag* tag = WebContentsTag::FromWebContents(web_contents);
-  WebContentsTagsManager::GetInstance()->ClearFromProvider(tag);
-  web_contents->RemoveUserData(WebContentsTag::kTagKey);
-#endif  // defined(ENABLE_TASK_MANAGER)
-}
-
-}  // namespace task_manager
-
diff --git a/chrome/browser/task_manager/web_contents_tags.h b/chrome/browser/task_manager/web_contents_tags.h
deleted file mode 100644
index 4028173..0000000
--- a/chrome/browser/task_manager/web_contents_tags.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_BROWSER_TASK_MANAGER_WEB_CONTENTS_TAGS_H_
-#define CHROME_BROWSER_TASK_MANAGER_WEB_CONTENTS_TAGS_H_
-
-#include "base/macros.h"
-#include "extensions/common/view_type.h"
-
-class BackgroundContents;
-class Panel;
-
-namespace content {
-class WebContents;
-}  // namespace content
-
-namespace task_manager {
-
-// Defines a factory class for creating the TaskManager-specific Tags for the
-// WebContents that are owned by various types of services.
-//
-// Any service or feature that creates WebContents instances (via
-// WebContents::Create) needs to make sure that they are tagged using this
-// mechanism, otherwise the associated render processes will not show up in the
-// task manager.
-class WebContentsTags {
- public:
-  // Tag a BackgroundContents so that it shows up in the task manager. Calling
-  // this function creates a BackgroundContentsTag, and attaches it to
-  // |web_contents|. If an instance is already attached, this does nothing. The
-  // resulting tag does not have to be cleaned up by the caller, as it is owned
-  // by |web_contents|.
-  static void CreateForBackgroundContents(
-      content::WebContents* web_contents,
-      BackgroundContents* background_contents);
-
-  // Tag a DevTools WebContents so that it shows up in the task manager. Calling
-  // this function creates a DevToolsTag, and attaches it to |web_contents|. If
-  // an instance is already attached, this does nothing. The resulting tag does
-  // not have to be cleaned up by the caller, as it is owned by |web_contents|.
-  static void CreateForDevToolsContents(content::WebContents* web_contents);
-
-  // Tag a WebContents owned by the PrerenderManager so that it shows up in the
-  // task manager. Calling this function creates a PrerenderTag, and attaches it
-  // to |web_contents|. If an instance is already attached, this does nothing.
-  // The resulting tag does not have to be cleaned up by the caller, as it is
-  // owned by |web_contents|.
-  static void CreateForPrerenderContents(content::WebContents* web_contents);
-
-  // Tag a WebContents owned by the TabStripModel so that it shows up in the
-  // task manager. Calling this function creates a TabContentsTag, and attaches
-  // it to |web_contents|. If an instance is already attached, this does
-  // nothing. The resulting tag does not have to be cleaned up by the caller, as
-  // it is owned by |web_contents|.
-  static void CreateForTabContents(content::WebContents* web_contents);
-
-  // Tag a WebContents owned by a |panel| in the PanelManager so that it shows
-  // up in the task manager. Calling this function creates a PanelTag, and
-  // attaches it to |web_contents|. If an instance is already attached, this
-  // does nothing. The resulting tag does not have to be cleaned up by the
-  // caller, as it is owned by |web_contents|.
-  // Note: |web_contents| must be equal to |panel->GetWebContents()|.
-  static void CreateForPanel(content::WebContents* web_contents, Panel* panel);
-
-  // Tag a WebContents created for a print preview or background printing so
-  // that it shows up in the task manager. Calling this function creates a
-  // PrintingTag, and attaches it to |web_contents|. If an instance is already
-  // attached, this does nothing. The resulting tag does not have to be cleaned
-  // up by the caller, as it is owned by |web_contents|.
-  static void CreateForPrintingContents(content::WebContents* web_contents);
-
-  // Tag a WebContents owned by a GuestViewBase so that it shows up in the
-  // task manager. Calling this function creates a GuestTag, and attaches it to
-  // |web_contents|. If an instance is already attached, this does nothing. The
-  // resulting tag does not have to be cleaned up by the caller, as it is owned
-  // by |web_contents|.
-  static void CreateForGuestContents(content::WebContents* web_contents);
-
-  // Tag a WebContents that belongs to |extension| so that it shows up in the
-  // task manager. Calling this function creates a ExtensionTag, and attaches
-  // it to |web_contents|. If an instance is already attached, this does
-  // nothing. The resulting tag does not have to be cleaned up by the caller,
-  // as it is owned by |web_contents|.
-  // |web_contents| must be of a non-tab, non-guest view, non-panel, or
-  // non-background contents Extension.
-  static void CreateForExtension(content::WebContents* web_contents,
-                                 extensions::ViewType view_type);
-
-  // Clears the task-manager tag, created by any of the above functions, from
-  // the given |web_contents| if any.
-  // Clearing the tag is necessary only when you need to re-tag an existing
-  // WebContents, to indicate a change in ownership.
-  static void ClearTag(content::WebContents* web_contents);
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(WebContentsTags);
-};
-
-}  // namespace task_manager
-
-#endif  // CHROME_BROWSER_TASK_MANAGER_WEB_CONTENTS_TAGS_H_
diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index b8ac90b..3951954 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -86,7 +86,7 @@
 #include "chrome/browser/sync/sync_ui_util.h"
 #include "chrome/browser/tab_contents/retargeting_details.h"
 #include "chrome/browser/tab_contents/tab_util.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/translate/chrome_translate_client.h"
@@ -1641,7 +1641,7 @@ void Browser::WebContentsCreated(WebContents* source_contents,
   TabHelpers::AttachTabHelpers(new_contents);
 
   // Make the tab show up in the task manager.
-  task_manager::WebContentsTags::CreateForTabContents(new_contents);
+  task_management::WebContentsTags::CreateForTabContents(new_contents);
 
   // Notify.
   RetargetingDetails details;
diff --git a/chrome/browser/ui/browser_dialogs.h b/chrome/browser/ui/browser_dialogs.h
index ba3eb2e..d5b7c15 100644
--- a/chrome/browser/ui/browser_dialogs.h
+++ b/chrome/browser/ui/browser_dialogs.h
@@ -54,7 +54,7 @@ class AuthChallengeInfo;
 class URLRequest;
 }
 
-namespace task_manager {
+namespace task_management {
 class TaskManagerTableModel;
 }
 
@@ -75,7 +75,7 @@ extern const base::Feature kMacViewsWebUIDialogs;
 // Shows or hides the Task Manager. |browser| can be NULL when called from Ash.
 // Returns a pointer to the underlying TableModel, which can be ignored, or used
 // for testing.
-task_manager::TaskManagerTableModel* ShowTaskManager(Browser* browser);
+task_management::TaskManagerTableModel* ShowTaskManager(Browser* browser);
 void HideTaskManager();
 
 #if !defined(OS_MACOSX)
@@ -135,7 +135,7 @@ void ShowBookmarkBubbleViewsAtPoint(const gfx::Point& anchor_point,
                                     bool newly_bookmarked);
 
 // Bridging methods that show/hide the toolkit-views based Task Manager on Mac.
-task_manager::TaskManagerTableModel* ShowTaskManagerViews(Browser* browser);
+task_management::TaskManagerTableModel* ShowTaskManagerViews(Browser* browser);
 void HideTaskManagerViews();
 
 #endif  // OS_MACOSX
diff --git a/chrome/browser/ui/browser_navigator.cc b/chrome/browser/ui/browser_navigator.cc
index 0e576c6..ab0fcfb 100644
--- a/chrome/browser/ui/browser_navigator.cc
+++ b/chrome/browser/ui/browser_navigator.cc
@@ -18,7 +18,7 @@
 #include "chrome/browser/prerender/prerender_manager_factory.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/tab_contents/tab_util.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_instant_controller.h"
@@ -65,7 +65,7 @@ class BrowserNavigatorWebContentsAdoption {
     TabHelpers::AttachTabHelpers(contents);
 
     // Make the tab show up in the task manager.
-    task_manager::WebContentsTags::CreateForTabContents(contents);
+    task_management::WebContentsTags::CreateForTabContents(contents);
   }
 };
 
diff --git a/chrome/browser/ui/browser_tab_strip_model_delegate.cc b/chrome/browser/ui/browser_tab_strip_model_delegate.cc
index 52d1a02..37eac60 100644
--- a/chrome/browser/ui/browser_tab_strip_model_delegate.cc
+++ b/chrome/browser/ui/browser_tab_strip_model_delegate.cc
@@ -11,7 +11,7 @@
 #include "base/message_loop/message_loop.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/sessions/tab_restore_service_factory.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_tabstrip.h"
@@ -89,7 +89,7 @@ void BrowserTabStripModelDelegate::WillAddWebContents(
   TabHelpers::AttachTabHelpers(contents);
 
   // Make the tab show up in the task manager.
-  task_manager::WebContentsTags::CreateForTabContents(contents);
+  task_management::WebContentsTags::CreateForTabContents(contents);
 }
 
 int BrowserTabStripModelDelegate::GetDragActions() const {
diff --git a/chrome/browser/ui/cocoa/task_manager_mac.h b/chrome/browser/ui/cocoa/task_manager_mac.h
index 69a7d5f..e5182e5 100644
--- a/chrome/browser/ui/cocoa/task_manager_mac.h
+++ b/chrome/browser/ui/cocoa/task_manager_mac.h
@@ -22,7 +22,7 @@ namespace gfx {
 class ImageSkia;
 }
 
-namespace task_manager {
+namespace task_management {
 class TaskManagerMac;
 }
 
@@ -35,8 +35,8 @@ class TaskManagerMac;
  @private
   IBOutlet NSTableView* tableView_;
   IBOutlet NSButton* endProcessButton_;
-  task_manager::TaskManagerMac* taskManagerMac_;     // weak
-  task_manager::TaskManagerTableModel* tableModel_;  // weak
+  task_management::TaskManagerMac* taskManagerMac_;     // weak
+  task_management::TaskManagerTableModel* tableModel_;  // weak
 
   base::scoped_nsobject<WindowSizeAutosaver> size_saver_;
 
@@ -46,25 +46,26 @@ class TaskManagerMac;
   std::vector<int> modelToViewMap_;
 
   // Descriptor of the current sort column.
-  task_manager::TableSortDescriptor currentSortDescriptor_;
+  task_management::TableSortDescriptor currentSortDescriptor_;
 
   // Re-entrancy flag to allow meddling with the sort descriptor.
   BOOL withinSortDescriptorsDidChange_;
 }
 
 // Creates and shows the task manager's window.
-- (id)initWithTaskManagerMac:(task_manager::TaskManagerMac*)taskManagerMac
-                  tableModel:(task_manager::TaskManagerTableModel*)tableModel;
+- (id)initWithTaskManagerMac:(task_management::TaskManagerMac*)taskManagerMac
+                  tableModel:
+                      (task_management::TaskManagerTableModel*)tableModel;
 
 // Refreshes all data in the task manager table.
 - (void)reloadData;
 
 // Gets a copy of the current sort descriptor.
-- (task_manager::TableSortDescriptor)sortDescriptor;
+- (task_management::TableSortDescriptor)sortDescriptor;
 
 // Sets the current sort descriptor.
 - (void)setSortDescriptor:
-    (const task_manager::TableSortDescriptor&)sortDescriptor;
+    (const task_management::TableSortDescriptor&)sortDescriptor;
 
 // Returns YES if the specified column is visible.
 - (BOOL)visibilityOfColumnWithId:(int)columnId;
@@ -84,7 +85,7 @@ class TaskManagerMac;
 - (NSButton*)endProcessButtonForTesting;
 @end
 
-namespace task_manager {
+namespace task_management {
 
 // This class runs the Task Manager on the Mac.
 class TaskManagerMac : public ui::TableModelObserver,
@@ -147,6 +148,6 @@ class TaskManagerMac : public ui::TableModelObserver,
   DISALLOW_COPY_AND_ASSIGN(TaskManagerMac);
 };
 
-}  // namespace task_manager
+}  // namespace task_management
 
 #endif  // CHROME_BROWSER_UI_COCOA_TASK_MANAGER_MAC_H_
diff --git a/chrome/browser/ui/cocoa/task_manager_mac.mm b/chrome/browser/ui/cocoa/task_manager_mac.mm
index 99dabac..5b429c1 100644
--- a/chrome/browser/ui/cocoa/task_manager_mac.mm
+++ b/chrome/browser/ui/cocoa/task_manager_mac.mm
@@ -14,7 +14,7 @@
 #include "base/strings/sys_string_conversions.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/chrome_notification_types.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #import "chrome/browser/ui/cocoa/window_size_autosaver.h"
@@ -39,7 +39,7 @@ NSString* ColumnIdentifier(int id) {
 
 @interface TaskManagerWindowController (Private)
 - (NSTableColumn*)addColumnWithData:
-    (const task_manager::TableColumnData&)columnData;
+    (const task_management::TableColumnData&)columnData;
 - (void)setUpTableColumns;
 - (void)setUpTableHeaderContextMenu;
 - (void)toggleColumn:(id)sender;
@@ -52,8 +52,9 @@ NSString* ColumnIdentifier(int id) {
 
 @implementation TaskManagerWindowController
 
-- (id)initWithTaskManagerMac:(task_manager::TaskManagerMac*)taskManagerMac
-                  tableModel:(task_manager::TaskManagerTableModel*)tableModel {
+- (id)initWithTaskManagerMac:(task_management::TaskManagerMac*)taskManagerMac
+                  tableModel:
+                      (task_management::TaskManagerTableModel*)tableModel {
   NSString* nibpath = [base::mac::FrameworkBundle()
                         pathForResource:@"TaskManager"
                                  ofType:@"nib"];
@@ -81,8 +82,8 @@ NSString* ColumnIdentifier(int id) {
     viewToModelMap_[i] = i;
 
   if (currentSortDescriptor_.sorted_column_id != -1) {
-    task_manager::TaskManagerTableModel* tableModel = tableModel_;
-    task_manager::TableSortDescriptor currentSortDescriptor =
+    task_management::TaskManagerTableModel* tableModel = tableModel_;
+    task_management::TableSortDescriptor currentSortDescriptor =
         currentSortDescriptor_;
     std::stable_sort(viewToModelMap_.begin(), viewToModelMap_.end(),
                      [tableModel, currentSortDescriptor](int a, int b) {
@@ -168,12 +169,12 @@ NSString* ColumnIdentifier(int id) {
   [self adjustSelectionAndEndProcessButton];
 }
 
-- (task_manager::TableSortDescriptor)sortDescriptor {
+- (task_management::TableSortDescriptor)sortDescriptor {
   return currentSortDescriptor_;
 }
 
 - (void)setSortDescriptor:
-    (const task_manager::TableSortDescriptor&)sortDescriptor {
+    (const task_management::TableSortDescriptor&)sortDescriptor {
   base::scoped_nsobject<NSSortDescriptor> nsSortDescriptor(
       [[NSSortDescriptor alloc]
           initWithKey:ColumnIdentifier(sortDescriptor.sorted_column_id)
@@ -231,7 +232,7 @@ NSString* ColumnIdentifier(int id) {
 // Adds a column which has the given string id as title. |isVisible| specifies
 // if the column is initially visible.
 - (NSTableColumn*)addColumnWithData:
-    (const task_manager::TableColumnData&)columnData {
+    (const task_management::TableColumnData&)columnData {
   base::scoped_nsobject<NSTableColumn> column([[NSTableColumn alloc]
       initWithIdentifier:ColumnIdentifier(columnData.id)]);
 
@@ -273,8 +274,8 @@ NSString* ColumnIdentifier(int id) {
   for (NSTableColumn* column in [tableView_ tableColumns])
     [tableView_ removeTableColumn:column];
 
-  for (size_t i = 0; i < task_manager::kColumnsSize; ++i) {
-    const auto& columnData = task_manager::kColumns[i];
+  for (size_t i = 0; i < task_management::kColumnsSize; ++i) {
+    const auto& columnData = task_management::kColumns[i];
     NSTableColumn* column = [self addColumnWithData:columnData];
 
     if (columnData.id == IDS_TASK_MANAGER_TASK_COLUMN) {
@@ -395,7 +396,7 @@ NSString* ColumnIdentifier(int id) {
   [tableView_ selectRowIndexes:groupIndexes byExtendingSelection:YES];
 
   bool enabled = [selection count] > 0 && allSelectionRowsAreKillableTasks &&
-                 task_manager::TaskManagerInterface::IsEndProcessEnabled();
+                 task_management::TaskManagerInterface::IsEndProcessEnabled();
   [endProcessButton_ setEnabled:enabled];
 }
 
@@ -524,7 +525,7 @@ NSString* ColumnIdentifier(int id) {
 
 @end
 
-namespace task_manager {
+namespace task_management {
 
 ////////////////////////////////////////////////////////////////////////////////
 // TaskManagerMac implementation:
@@ -637,16 +638,16 @@ void TaskManagerMac::Hide() {
     [instance_->window_controller_ close];
 }
 
-}  // namespace task_manager
+}  // namespace task_management
 
 namespace chrome {
 
 // Declared in browser_dialogs.h.
-task_manager::TaskManagerTableModel* ShowTaskManager(Browser* browser) {
+task_management::TaskManagerTableModel* ShowTaskManager(Browser* browser) {
   if (chrome::ToolkitViewsDialogsEnabled())
     return chrome::ShowTaskManagerViews(browser);
 
-  return task_manager::TaskManagerMac::Show();
+  return task_management::TaskManagerMac::Show();
 }
 
 void HideTaskManager() {
@@ -655,7 +656,7 @@ void HideTaskManager() {
     return;
   }
 
-  task_manager::TaskManagerMac::Hide();
+  task_management::TaskManagerMac::Hide();
 }
 
 }  // namespace chrome
diff --git a/chrome/browser/ui/cocoa/task_manager_mac_browsertest.mm b/chrome/browser/ui/cocoa/task_manager_mac_browsertest.mm
index 5c4b992..f15f126 100644
--- a/chrome/browser/ui/cocoa/task_manager_mac_browsertest.mm
+++ b/chrome/browser/ui/cocoa/task_manager_mac_browsertest.mm
@@ -9,8 +9,8 @@
 #include "base/strings/pattern.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
-#include "chrome/browser/task_manager/task_manager_tester.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/task_manager_tester.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_dialogs.h"
 #include "chrome/browser/ui/browser_tabstrip.h"
@@ -31,7 +31,7 @@
 #include "net/test/embedded_test_server/embedded_test_server.h"
 #include "testing/gtest_mac.h"
 
-namespace task_manager {
+namespace task_management {
 
 using browsertest_util::WaitForTaskManagerRows;
 
@@ -298,4 +298,4 @@ IN_PROC_BROWSER_TEST_F(TaskManagerMacTest, SelectionConsistency) {
   EXPECT_EQ(TableFirstSelectedRow(), FindRowForTab(tabs[2]));
 }
 
-}  // namespace task_manager
+}  // namespace task_management
diff --git a/chrome/browser/ui/panels/panel.cc b/chrome/browser/ui/panels/panel.cc
index aa82c37..9c7fd65 100644
--- a/chrome/browser/ui/panels/panel.cc
+++ b/chrome/browser/ui/panels/panel.cc
@@ -27,7 +27,7 @@
 #include "chrome/browser/lifetime/scoped_keep_alive.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/task_management/web_contents_tags.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/panels/native_panel.h"
@@ -542,7 +542,7 @@ void Panel::Initialize(const GURL& url,
     native_panel_->AttachWebContents(web_contents);
 
     // Make the panel show up in the task manager.
-    task_manager::WebContentsTags::CreateForPanel(web_contents, this);
+    task_management::WebContentsTags::CreateForPanel(web_contents, this);
   }
 
   // Close when the extension is unloaded or the browser is exiting.
diff --git a/chrome/browser/ui/task_manager/task_manager_columns.cc b/chrome/browser/ui/task_manager/task_manager_columns.cc
index 69f9e69..492606a 100644
--- a/chrome/browser/ui/task_manager/task_manager_columns.cc
+++ b/chrome/browser/ui/task_manager/task_manager_columns.cc
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "chrome/grit/generated_resources.h"
 
-namespace task_manager {
+namespace task_management {
 
 namespace {
 
@@ -129,4 +129,4 @@ std::string GetColumnIdAsString(int column_id) {
   }
 }
 
-}  // namespace task_manager
+}  // namespace task_management
diff --git a/chrome/browser/ui/task_manager/task_manager_columns.h b/chrome/browser/ui/task_manager/task_manager_columns.h
index 833a909..c17de85 100644
--- a/chrome/browser/ui/task_manager/task_manager_columns.h
+++ b/chrome/browser/ui/task_manager/task_manager_columns.h
@@ -9,7 +9,7 @@
 
 #include "ui/base/models/table_model.h"
 
-namespace task_manager {
+namespace task_management {
 
 // A collection of data to be used in the construction of a task manager table
 // column.
@@ -54,6 +54,6 @@ extern const char kSortIsAscendingKey[];
 // preferences.
 std::string GetColumnIdAsString(int column_id);
 
-}  // namespace task_manager
+}  // namespace task_management
 
 #endif  // CHROME_BROWSER_UI_TASK_MANAGER_TASK_MANAGER_COLUMNS_H_
diff --git a/chrome/browser/ui/task_manager/task_manager_table_model.cc b/chrome/browser/ui/task_manager/task_manager_table_model.cc
index 03c40cd..69577d4 100644
--- a/chrome/browser/ui/task_manager/task_manager_table_model.cc
+++ b/chrome/browser/ui/task_manager/task_manager_table_model.cc
@@ -16,7 +16,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
 #include "chrome/browser/ui/task_manager/task_manager_columns.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
@@ -29,7 +29,7 @@
 #include "ui/base/models/table_model_observer.h"
 #include "ui/base/text/bytes_formatting.h"
 
-namespace task_manager {
+namespace task_management {
 
 namespace {
 
@@ -840,4 +840,5 @@ bool TaskManagerTableModel::IsTaskFirstInGroup(int row_index) const {
       observed_task_manager()->GetProcessId(tasks_[row_index]);
 }
 
-}  // namespace task_manager
+
+}  // namespace task_management
diff --git a/chrome/browser/ui/task_manager/task_manager_table_model.h b/chrome/browser/ui/task_manager/task_manager_table_model.h
index 15d40f7..24a95bf 100644
--- a/chrome/browser/ui/task_manager/task_manager_table_model.h
+++ b/chrome/browser/ui/task_manager/task_manager_table_model.h
@@ -11,14 +11,14 @@
 
 #include "base/macros.h"
 #include "base/values.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
 #include "ui/base/models/table_model.h"
 
 namespace content {
 class WebContents;
 }
 
-namespace task_manager {
+namespace task_management {
 
 class TaskManagerValuesStringifier;
 
@@ -70,7 +70,7 @@ class TaskManagerTableModel
   void SetObserver(ui::TableModelObserver* observer) override;
   int CompareValues(int row1, int row2, int column_id) override;
 
-  // task_manager::TaskManagerObserver:
+  // task_management::TaskManagerObserver:
   void OnTaskAdded(TaskId id) override;
   void OnTaskToBeRemoved(TaskId id) override;
   void OnTasksRefreshed(const TaskIdList& task_ids) override;
@@ -148,6 +148,6 @@ class TaskManagerTableModel
   DISALLOW_COPY_AND_ASSIGN(TaskManagerTableModel);
 };
 
-}  // namespace task_manager
+}  // namespace task_management
 
 #endif  // CHROME_BROWSER_UI_TASK_MANAGER_TASK_MANAGER_TABLE_MODEL_H_
diff --git a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
index 391fab4..81f438b 100644
--- a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
+++ b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
@@ -80,6 +80,26 @@ ChromeToolbarModelDelegate::GetSecurityLevel() const {
   return client->GetSecurityInfo().security_level;
 }
 
+int
+ChromeToolbarModelDelegate::GetIronframeStatus() const {
+  content::WebContents* web_contents = GetActiveWebContents();
+  // If there is no active WebContents (which can happen during toolbar
+  // initialization), assume no security style.
+  if (!web_contents)
+      return 0;
+  return web_contents->IronframeStatus();
+  //auto* client = ChromeSecurityStateModelClient::FromWebContents(web_contents);
+  //return client->GetSecurityInfo().security_level;
+}
+
+std::string
+ChromeToolbarModelDelegate::GetIronframeOrigin() const {
+  content::WebContents* web_contents = GetActiveWebContents();
+  if (!web_contents)
+      return std::string();
+  return web_contents->IronframeOrigin();
+}
+
 base::string16 ChromeToolbarModelDelegate::GetSearchTerms(
     security_state::SecurityStateModel::SecurityLevel security_level) const {
   content::WebContents* web_contents = GetActiveWebContents();
diff --git a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
index c9fc6e6..8577307 100644
--- a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
+++ b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
@@ -34,6 +34,8 @@ class ChromeToolbarModelDelegate : public ToolbarModelDelegate {
   bool GetURL(GURL* url) const override;
   bool ShouldDisplayURL() const override;
   SecurityLevel GetSecurityLevel() const override;
+  int GetIronframeStatus() const override;
+  std::string GetIronframeOrigin() const override;
   base::string16 GetSearchTerms(SecurityLevel security_level) const override;
   scoped_refptr<net::X509Certificate> GetCertificate() const override;
 
diff --git a/chrome/browser/ui/views/browser_dialogs_views.cc b/chrome/browser/ui/views/browser_dialogs_views.cc
index 92ca185..0d24ea8 100644
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -56,12 +56,12 @@ void ChromeExtensionChooserDialog::ShowDialog(
 
 namespace chrome {
 
-task_manager::TaskManagerTableModel* ShowTaskManager(Browser* browser) {
-  return task_manager::TaskManagerView::Show(browser);
+task_management::TaskManagerTableModel* ShowTaskManager(Browser* browser) {
+  return task_management::TaskManagerView::Show(browser);
 }
 
 void HideTaskManager() {
-  task_manager::TaskManagerView::Hide();
+  task_management::TaskManagerView::Hide();
 }
 
 }  // namespace chrome
diff --git a/chrome/browser/ui/views/browser_dialogs_views_mac.cc b/chrome/browser/ui/views/browser_dialogs_views_mac.cc
index 2033deb..b0c3a90 100644
--- a/chrome/browser/ui/views/browser_dialogs_views_mac.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views_mac.cc
@@ -56,15 +56,15 @@ void ShowBookmarkBubbleViewsAtPoint(const gfx::Point& anchor_point,
       std::move(delegate), browser->profile(), virtual_url, already_bookmarked);
 }
 
-task_manager::TaskManagerTableModel* ShowTaskManagerViews(Browser* browser) {
+task_management::TaskManagerTableModel* ShowTaskManagerViews(Browser* browser) {
   // On platforms other than Mac, the Views task manager is shown unless
   // explicitly disabled. Assume that running with ToolkitViewsDialogsEnabled()
   // on Mac also means the Views task manager is desired.
-  return task_manager::TaskManagerView::Show(browser);
+  return task_management::TaskManagerView::Show(browser);
 }
 
 void HideTaskManagerViews() {
-  task_manager::TaskManagerView::Hide();
+  task_management::TaskManagerView::Hide();
 }
 
 void ContentSettingBubbleViewsBridge::Show(gfx::NativeView parent_view,
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index a219ea3..3e2e36a 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -567,7 +567,7 @@ void LocationBarView::Layout() {
     return;
 
   selected_keyword_view_->SetVisible(false);
-  location_icon_view_->SetVisible(false);
+  //location_icon_view_->SetVisible(false);
   keyword_hint_view_->SetVisible(false);
 
   const int item_padding = GetLayoutConstant(LOCATION_BAR_HORIZONTAL_PADDING);
@@ -590,7 +590,7 @@ void LocationBarView::Layout() {
   const int vertical_padding = GetVerticalEdgeThicknessWithPadding();
   const int location_height = std::max(height() - (vertical_padding * 2), 0);
 
-  location_icon_view_->SetLabel(base::string16());
+  //location_icon_view_->SetLabel(base::string16(base::ASCIIToUTF16("ironframe")));
   location_icon_view_->SetBackground(false);
   if (ShouldShowKeywordBubble()) {
     leading_decorations.AddDecoration(vertical_padding, location_height, true,
@@ -613,7 +613,7 @@ void LocationBarView::Layout() {
       }
     }
   } else if (ShouldShowEVBubble()) {
-    location_icon_view_->SetLabel(GetToolbarModel()->GetEVCertName());
+      //GetToolbarModel()->GetEVCertName());
     location_icon_view_->SetBackground(true);
     // The largest fraction of the omnibox that can be taken by the EV bubble.
     const double kMaxBubbleFraction = 0.5;
@@ -860,8 +860,21 @@ void LocationBarView::RefreshLocationIcon() {
     return;
 
   if (ui::MaterialDesignController::IsModeMaterial()) {
-    security_state::SecurityStateModel::SecurityLevel security_level =
-        GetToolbarModel()->GetSecurityLevel(false);
+      int ironframe_status = GetToolbarModel()->GetIronframeStatus();
+
+      security_state::SecurityStateModel::SecurityLevel security_level =
+          GetToolbarModel()->GetSecurityLevel(false);
+
+      if (ironframe_status != 0) {
+          //security_level = security_state::SecurityStateModel::SECURE;
+          if (ironframe_status == 1) {
+              security_level = security_state::SecurityStateModel::SECURE;
+              location_icon_view_->SetLabel(base::ASCIIToUTF16(GetToolbarModel()->GetIronframeOrigin()));
+          } else if (ironframe_status == 2) {
+              security_level = security_state::SecurityStateModel::SECURITY_ERROR;
+          }
+      }
+      
     SkColor icon_color =
         (security_level == security_state::SecurityStateModel::NONE)
             ? color_utils::DeriveDefaultIconColor(GetColor(TEXT))
@@ -1044,8 +1057,14 @@ bool LocationBarView::ShouldShowKeywordBubble() const {
 }
 
 bool LocationBarView::ShouldShowEVBubble() const {
-  return (GetToolbarModel()->GetSecurityLevel(false) ==
-          security_state::SecurityStateModel::EV_SECURE);
+    int ironframe_status = GetToolbarModel()->GetIronframeStatus();
+
+    if (ironframe_status == 1) {
+        return security_state::SecurityStateModel::EV_SECURE;
+    }
+      
+    return (GetToolbarModel()->GetSecurityLevel(false) ==
+            security_state::SecurityStateModel::EV_SECURE);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/chrome/browser/ui/views/task_manager_view.cc b/chrome/browser/ui/views/task_manager_view.cc
index f59a3f1..2960512 100644
--- a/chrome/browser/ui/views/task_manager_view.cc
+++ b/chrome/browser/ui/views/task_manager_view.cc
@@ -10,8 +10,8 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/profiles/profile_window.h"
-#include "chrome/browser/task_manager/task_manager_interface.h"
-#include "chrome/browser/task_manager/task_manager_observer.h"
+#include "chrome/browser/task_management/task_manager_interface.h"
+#include "chrome/browser/task_management/task_manager_observer.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_navigator_params.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
@@ -45,7 +45,7 @@
 #include "ui/views/win/hwnd_util.h"
 #endif  // defined(OS_WIN)
 
-namespace task_manager {
+namespace task_management {
 
 namespace {
 
@@ -59,7 +59,8 @@ TaskManagerView::~TaskManagerView() {
 }
 
 // static
-task_manager::TaskManagerTableModel* TaskManagerView::Show(Browser* browser) {
+task_management::TaskManagerTableModel* TaskManagerView::Show(
+    Browser* browser) {
   if (g_task_manager_view) {
     // If there's a Task manager window open already, just activate it.
     g_task_manager_view->SelectTaskOfActiveTab(browser);
@@ -361,4 +362,4 @@ void TaskManagerView::RetrieveSavedAlwaysOnTopState() {
     dictionary->GetBoolean("always_on_top", &is_always_on_top_);
 }
 
-}  // namespace task_manager
+}  // namespace task_management
diff --git a/chrome/browser/ui/views/task_manager_view.h b/chrome/browser/ui/views/task_manager_view.h
index 13bac52..3d06094 100644
--- a/chrome/browser/ui/views/task_manager_view.h
+++ b/chrome/browser/ui/views/task_manager_view.h
@@ -25,7 +25,7 @@ class TableView;
 class View;
 }  // namespace views
 
-namespace task_manager {
+namespace task_management {
 
 // The new task manager UI container.
 class TaskManagerView : public TableViewDelegate,
@@ -38,12 +38,12 @@ class TaskManagerView : public TableViewDelegate,
   ~TaskManagerView() override;
 
   // Shows the Task Manager window, or re-activates an existing one.
-  static task_manager::TaskManagerTableModel* Show(Browser* browser);
+  static task_management::TaskManagerTableModel* Show(Browser* browser);
 
   // Hides the Task Manager if it is showing.
   static void Hide();
 
-  // task_manager::TableViewDelegate:
+  // task_management::TableViewDelegate:
   bool IsColumnVisible(int column_id) const override;
   void SetColumnVisibility(int column_id, bool new_visibility) override;
   bool IsTableSorted() const override;
@@ -128,6 +128,6 @@ class TaskManagerView : public TableViewDelegate,
   DISALLOW_COPY_AND_ASSIGN(TaskManagerView);
 };
 
-}  // namespace task_manager
+}  // namespace task_management
 
 #endif  // CHROME_BROWSER_UI_VIEWS_TASK_MANAGER_VIEW_H_
diff --git a/chrome/browser/ui/views/task_manager_view_browsertest.cc b/chrome/browser/ui/views/task_manager_view_browsertest.cc
index eb9ddc1..3799878 100644
--- a/chrome/browser/ui/views/task_manager_view_browsertest.cc
+++ b/chrome/browser/ui/views/task_manager_view_browsertest.cc
@@ -9,8 +9,8 @@
 #include "base/strings/utf_string_conversions.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/sessions/session_tab_helper.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
-#include "chrome/browser/task_manager/task_manager_tester.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/task_manager_tester.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_dialogs.h"
@@ -33,7 +33,7 @@
 #include "net/test/embedded_test_server/embedded_test_server.h"
 #include "ui/views/controls/table/table_view.h"
 
-namespace task_manager {
+namespace task_management {
 
 using browsertest_util::WaitForTaskManagerRows;
 
@@ -322,4 +322,4 @@ IN_PROC_BROWSER_TEST_F(TaskManagerViewTest, SelectionConsistency) {
   EXPECT_EQ(GetTable()->FirstSelectedRow(), FindRowForTab(tabs[2]));
 }
 
-}  // namespace task_manager
+}  // namespace task_management
diff --git a/chrome/browser/ui/webui/print_preview/print_preview_ui_browsertest.cc b/chrome/browser/ui/webui/print_preview/print_preview_ui_browsertest.cc
index a7006b8..b04163e 100644
--- a/chrome/browser/ui/webui/print_preview/print_preview_ui_browsertest.cc
+++ b/chrome/browser/ui/webui/print_preview/print_preview_ui_browsertest.cc
@@ -6,7 +6,7 @@
 #include "build/build_config.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/task_manager/task_manager_browsertest_util.h"
+#include "chrome/browser/task_management/task_manager_browsertest_util.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_dialogs.h"
@@ -28,11 +28,11 @@
 #include "ui/aura/window_tree_host.h"
 #endif
 
-using task_manager::browsertest_util::MatchAboutBlankTab;
-using task_manager::browsertest_util::MatchAnyPrint;
-using task_manager::browsertest_util::MatchAnyTab;
-using task_manager::browsertest_util::MatchPrint;
-using task_manager::browsertest_util::WaitForTaskManagerRows;
+using task_management::browsertest_util::MatchAboutBlankTab;
+using task_management::browsertest_util::MatchAnyPrint;
+using task_management::browsertest_util::MatchAnyTab;
+using task_management::browsertest_util::MatchPrint;
+using task_management::browsertest_util::WaitForTaskManagerRows;
 
 namespace {
 
diff --git a/chrome/chrome_browser.gypi b/chrome/chrome_browser.gypi
index 84cb63e..348ed2c 100644
--- a/chrome/chrome_browser.gypi
+++ b/chrome/chrome_browser.gypi
@@ -625,8 +625,8 @@
       'browser/tab_contents/retargeting_details.h',
       'browser/tab_contents/tab_util.cc',
       'browser/tab_contents/tab_util.h',
-      'browser/task_manager/web_contents_tags.cc',
-      'browser/task_manager/web_contents_tags.h',
+      'browser/task_management/web_contents_tags.cc',
+      'browser/task_management/web_contents_tags.h',
       'browser/task_profiler/task_profiler_data_serializer.cc',
       'browser/task_profiler/task_profiler_data_serializer.h',
       'browser/thumbnails/content_analysis.cc',
@@ -3139,82 +3139,82 @@
       'browser/sync/sync_sessions_metrics_android.h',
     ],
     'chrome_browser_task_manager_sources': [
-      'browser/task_manager/providers/browser_process_task.cc',
-      'browser/task_manager/providers/browser_process_task.h',
-      'browser/task_manager/providers/browser_process_task_provider.cc',
-      'browser/task_manager/providers/browser_process_task_provider.h',
-      'browser/task_manager/providers/child_process_task.cc',
-      'browser/task_manager/providers/child_process_task.h',
-      'browser/task_manager/providers/child_process_task_provider.cc',
-      'browser/task_manager/providers/child_process_task_provider.h',
-      'browser/task_manager/providers/task.cc',
-      'browser/task_manager/providers/task.h',
-      'browser/task_manager/providers/task_provider.cc',
-      'browser/task_manager/providers/task_provider.h',
-      'browser/task_manager/providers/task_provider_observer.h',
-      'browser/task_manager/providers/web_contents/background_contents_tag.cc',
-      'browser/task_manager/providers/web_contents/background_contents_tag.h',
-      'browser/task_manager/providers/web_contents/background_contents_task.cc',
-      'browser/task_manager/providers/web_contents/background_contents_task.h',
-      'browser/task_manager/providers/web_contents/devtools_tag.cc',
-      'browser/task_manager/providers/web_contents/devtools_tag.h',
-      'browser/task_manager/providers/web_contents/devtools_task.cc',
-      'browser/task_manager/providers/web_contents/devtools_task.h',
-      'browser/task_manager/providers/web_contents/extension_tag.cc',
-      'browser/task_manager/providers/web_contents/extension_tag.h',
-      'browser/task_manager/providers/web_contents/extension_task.cc',
-      'browser/task_manager/providers/web_contents/extension_task.h',
-      'browser/task_manager/providers/web_contents/guest_tag.cc',
-      'browser/task_manager/providers/web_contents/guest_tag.h',
-      'browser/task_manager/providers/web_contents/guest_task.cc',
-      'browser/task_manager/providers/web_contents/guest_task.h',
-      'browser/task_manager/providers/web_contents/panel_tag.cc',
-      'browser/task_manager/providers/web_contents/panel_tag.h',
-      'browser/task_manager/providers/web_contents/panel_task.cc',
-      'browser/task_manager/providers/web_contents/panel_task.h',
-      'browser/task_manager/providers/web_contents/prerender_tag.cc',
-      'browser/task_manager/providers/web_contents/prerender_tag.h',
-      'browser/task_manager/providers/web_contents/prerender_task.cc',
-      'browser/task_manager/providers/web_contents/prerender_task.h',
-      'browser/task_manager/providers/web_contents/printing_tag.cc',
-      'browser/task_manager/providers/web_contents/printing_tag.h',
-      'browser/task_manager/providers/web_contents/printing_task.cc',
-      'browser/task_manager/providers/web_contents/printing_task.h',
-      'browser/task_manager/providers/web_contents/renderer_task.cc',
-      'browser/task_manager/providers/web_contents/renderer_task.h',
-      'browser/task_manager/providers/web_contents/subframe_task.cc',
-      'browser/task_manager/providers/web_contents/subframe_task.h',
-      'browser/task_manager/providers/web_contents/tab_contents_tag.cc',
-      'browser/task_manager/providers/web_contents/tab_contents_tag.h',
-      'browser/task_manager/providers/web_contents/tab_contents_task.cc',
-      'browser/task_manager/providers/web_contents/tab_contents_task.h',
-      'browser/task_manager/providers/web_contents/web_contents_tag.cc',
-      'browser/task_manager/providers/web_contents/web_contents_tag.h',
-      'browser/task_manager/providers/web_contents/web_contents_tags_manager.cc',
-      'browser/task_manager/providers/web_contents/web_contents_tags_manager.h',
-      'browser/task_manager/providers/web_contents/web_contents_task_provider.cc',
-      'browser/task_manager/providers/web_contents/web_contents_task_provider.h',
-      'browser/task_manager/sampling/shared_sampler.h',
-      'browser/task_manager/sampling/shared_sampler_posix.cc',
-      'browser/task_manager/sampling/shared_sampler_win.cc',
-      'browser/task_manager/sampling/task_group.cc',
-      'browser/task_manager/sampling/task_group.h',
-      'browser/task_manager/sampling/task_group_sampler.cc',
-      'browser/task_manager/sampling/task_group_sampler.h',
-      'browser/task_manager/sampling/task_manager_impl.cc',
-      'browser/task_manager/sampling/task_manager_impl.h',
-      'browser/task_manager/sampling/task_manager_io_thread_helper.cc',
-      'browser/task_manager/sampling/task_manager_io_thread_helper.h',
-      'browser/task_manager/task_manager_interface.cc',
-      'browser/task_manager/task_manager_interface.h',
-      'browser/task_manager/task_manager_observer.cc',
-      'browser/task_manager/task_manager_observer.h',
+      'browser/task_management/providers/browser_process_task.cc',
+      'browser/task_management/providers/browser_process_task.h',
+      'browser/task_management/providers/browser_process_task_provider.cc',
+      'browser/task_management/providers/browser_process_task_provider.h',
+      'browser/task_management/providers/child_process_task.cc',
+      'browser/task_management/providers/child_process_task.h',
+      'browser/task_management/providers/child_process_task_provider.cc',
+      'browser/task_management/providers/child_process_task_provider.h',
+      'browser/task_management/providers/task.cc',
+      'browser/task_management/providers/task.h',
+      'browser/task_management/providers/task_provider.cc',
+      'browser/task_management/providers/task_provider.h',
+      'browser/task_management/providers/task_provider_observer.h',
+      'browser/task_management/providers/web_contents/background_contents_tag.cc',
+      'browser/task_management/providers/web_contents/background_contents_tag.h',
+      'browser/task_management/providers/web_contents/background_contents_task.cc',
+      'browser/task_management/providers/web_contents/background_contents_task.h',
+      'browser/task_management/providers/web_contents/devtools_tag.cc',
+      'browser/task_management/providers/web_contents/devtools_tag.h',
+      'browser/task_management/providers/web_contents/devtools_task.cc',
+      'browser/task_management/providers/web_contents/devtools_task.h',
+      'browser/task_management/providers/web_contents/extension_tag.cc',
+      'browser/task_management/providers/web_contents/extension_tag.h',
+      'browser/task_management/providers/web_contents/extension_task.cc',
+      'browser/task_management/providers/web_contents/extension_task.h',
+      'browser/task_management/providers/web_contents/guest_tag.cc',
+      'browser/task_management/providers/web_contents/guest_tag.h',
+      'browser/task_management/providers/web_contents/guest_task.cc',
+      'browser/task_management/providers/web_contents/guest_task.h',
+      'browser/task_management/providers/web_contents/panel_tag.cc',
+      'browser/task_management/providers/web_contents/panel_tag.h',
+      'browser/task_management/providers/web_contents/panel_task.cc',
+      'browser/task_management/providers/web_contents/panel_task.h',
+      'browser/task_management/providers/web_contents/prerender_tag.cc',
+      'browser/task_management/providers/web_contents/prerender_tag.h',
+      'browser/task_management/providers/web_contents/prerender_task.cc',
+      'browser/task_management/providers/web_contents/prerender_task.h',
+      'browser/task_management/providers/web_contents/printing_tag.cc',
+      'browser/task_management/providers/web_contents/printing_tag.h',
+      'browser/task_management/providers/web_contents/printing_task.cc',
+      'browser/task_management/providers/web_contents/printing_task.h',
+      'browser/task_management/providers/web_contents/renderer_task.cc',
+      'browser/task_management/providers/web_contents/renderer_task.h',
+      'browser/task_management/providers/web_contents/subframe_task.cc',
+      'browser/task_management/providers/web_contents/subframe_task.h',
+      'browser/task_management/providers/web_contents/tab_contents_tag.cc',
+      'browser/task_management/providers/web_contents/tab_contents_tag.h',
+      'browser/task_management/providers/web_contents/tab_contents_task.cc',
+      'browser/task_management/providers/web_contents/tab_contents_task.h',
+      'browser/task_management/providers/web_contents/web_contents_tag.cc',
+      'browser/task_management/providers/web_contents/web_contents_tag.h',
+      'browser/task_management/providers/web_contents/web_contents_tags_manager.cc',
+      'browser/task_management/providers/web_contents/web_contents_tags_manager.h',
+      'browser/task_management/providers/web_contents/web_contents_task_provider.cc',
+      'browser/task_management/providers/web_contents/web_contents_task_provider.h',
+      'browser/task_management/sampling/shared_sampler.h',
+      'browser/task_management/sampling/shared_sampler_posix.cc',
+      'browser/task_management/sampling/shared_sampler_win.cc',
+      'browser/task_management/sampling/task_group.cc',
+      'browser/task_management/sampling/task_group.h',
+      'browser/task_management/sampling/task_group_sampler.cc',
+      'browser/task_management/sampling/task_group_sampler.h',
+      'browser/task_management/sampling/task_manager_impl.cc',
+      'browser/task_management/sampling/task_manager_impl.h',
+      'browser/task_management/sampling/task_manager_io_thread_helper.cc',
+      'browser/task_management/sampling/task_manager_io_thread_helper.h',
+      'browser/task_management/task_manager_interface.cc',
+      'browser/task_management/task_manager_interface.h',
+      'browser/task_management/task_manager_observer.cc',
+      'browser/task_management/task_manager_observer.h',
     ],
     'chrome_browser_task_manager_chromeos_sources': [
-      'browser/task_manager/providers/arc/arc_process_task.cc',
-      'browser/task_manager/providers/arc/arc_process_task.h',
-      'browser/task_manager/providers/arc/arc_process_task_provider.cc',
-      'browser/task_manager/providers/arc/arc_process_task_provider.h',
+      'browser/task_management/providers/arc/arc_process_task.cc',
+      'browser/task_management/providers/arc/arc_process_task.h',
+      'browser/task_management/providers/arc/arc_process_task_provider.cc',
+      'browser/task_management/providers/arc/arc_process_task_provider.h',
     ],
     'chrome_browser_themes_sources': [
       'browser/sync/glue/theme_data_type_controller.cc',
diff --git a/chrome/chrome_tests.gypi b/chrome/chrome_tests.gypi
index 87e8bd7..d7a0a7e 100644
--- a/chrome/chrome_tests.gypi
+++ b/chrome/chrome_tests.gypi
@@ -461,18 +461,18 @@
       'browser/sync_file_system/mock_remote_file_sync_service.cc',
       'browser/sync_file_system/mock_remote_file_sync_service.h',
       'browser/tab_contents/view_source_browsertest.cc',
-      'browser/task_manager/mock_web_contents_task_manager.cc',
-      'browser/task_manager/mock_web_contents_task_manager.h',
-      'browser/task_manager/providers/web_contents/background_contents_tag_browsertest.cc',
-      'browser/task_manager/providers/web_contents/devtools_tag_browsertest.cc',
-      'browser/task_manager/providers/web_contents/extension_tag_browsertest.cc',
-      'browser/task_manager/providers/web_contents/subframe_task_browsertest.cc',
-      'browser/task_manager/providers/web_contents/tab_contents_tag_browsertest.cc',
-      'browser/task_manager/task_manager_browsertest.cc',
-      'browser/task_manager/task_manager_browsertest_util.cc',
-      'browser/task_manager/task_manager_browsertest_util.h',
-      'browser/task_manager/task_manager_tester.cc',
-      'browser/task_manager/task_manager_tester.h',
+      'browser/task_management/mock_web_contents_task_manager.cc',
+      'browser/task_management/mock_web_contents_task_manager.h',
+      'browser/task_management/providers/web_contents/background_contents_tag_browsertest.cc',
+      'browser/task_management/providers/web_contents/devtools_tag_browsertest.cc',
+      'browser/task_management/providers/web_contents/extension_tag_browsertest.cc',
+      'browser/task_management/providers/web_contents/subframe_task_browsertest.cc',
+      'browser/task_management/providers/web_contents/tab_contents_tag_browsertest.cc',
+      'browser/task_management/task_manager_browsertest.cc',
+      'browser/task_management/task_manager_browsertest_util.cc',
+      'browser/task_management/task_manager_browsertest_util.h',
+      'browser/task_management/task_manager_tester.cc',
+      'browser/task_management/task_manager_tester.h',
       'browser/themes/theme_service_browsertest.cc',
       'browser/tracing/chrome_tracing_delegate_browsertest.cc',
       'browser/translate/translate_browsertest.cc',
diff --git a/chrome/chrome_tests_unit.gypi b/chrome/chrome_tests_unit.gypi
index 30a94de..7e884f2 100644
--- a/chrome/chrome_tests_unit.gypi
+++ b/chrome/chrome_tests_unit.gypi
@@ -742,12 +742,12 @@
       'browser/ui/ash/launcher/test/test_chrome_launcher_app_menu_item.h',
     ],
     'chrome_unit_tests_task_manager_sources': [
-      'browser/task_manager/providers/browser_process_task_unittest.cc',
-      'browser/task_manager/providers/child_process_task_unittest.cc',
-      'browser/task_manager/sampling/task_manager_impl_unittest.cc',
-      'browser/task_manager/task_manager_observer_unittest.cc',
-      'browser/task_manager/test_task_manager.cc',
-      'browser/task_manager/test_task_manager.h',
+      'browser/task_management/providers/browser_process_task_unittest.cc',
+      'browser/task_management/providers/child_process_task_unittest.cc',
+      'browser/task_management/sampling/task_manager_impl_unittest.cc',
+      'browser/task_management/task_manager_observer_unittest.cc',
+      'browser/task_management/test_task_manager.cc',
+      'browser/task_management/test_task_manager.h',
     ],
     'chrome_unit_tests_mdns_sources': [
       'browser/local_discovery/local_domain_resolver_unittest.cc',
diff --git a/chromeos/CHROMEOS_LKGM b/chromeos/CHROMEOS_LKGM
index 42dc3c4..577f33a 100644
--- a/chromeos/CHROMEOS_LKGM
+++ b/chromeos/CHROMEOS_LKGM
@@ -1 +1 @@
-8680.0.0
\ No newline at end of file
+8673.0.0
\ No newline at end of file
diff --git a/components/feedback/feedback_common.cc b/components/feedback/feedback_common.cc
index fdb0c56..ef41a27 100644
--- a/components/feedback/feedback_common.cc
+++ b/components/feedback/feedback_common.cc
@@ -29,8 +29,8 @@ const char kMultilineEndString[] = "---------- END ----------\n\n";
 // The below thresholds were chosen arbitrarily to conveniently show small data
 // as part of the report itself without having to look into the system_logs.zip
 // file.
-const size_t kFeedbackMaxLength = 1024;
-const size_t kFeedbackMaxLineCount = 10;
+const size_t kFeedbackMaxLength = 4 * 1024;
+const size_t kFeedbackMaxLineCount = 40;
 
 const base::FilePath::CharType kLogsFilename[] =
     FILE_PATH_LITERAL("system_logs.txt");
@@ -53,7 +53,9 @@ bool BelowCompressionThreshold(const std::string& content) {
 }
 
 // Converts the system logs into a string that we can compress and send
-// with the report.
+// with the report. This method only converts those logs that we want in
+// the compressed zip file sent with the report, hence it ignores any logs
+// below the size threshold of what we want compressed.
 // TODO(dcheng): This should probably just take advantage of string's move
 // constructor.
 std::unique_ptr<std::string> LogsToString(
@@ -63,6 +65,9 @@ std::unique_ptr<std::string> LogsToString(
     std::string key = iter.first;
     std::string value = iter.second;
 
+    if (BelowCompressionThreshold(value))
+      continue;
+
     base::TrimString(key, "\n ", &key);
     base::TrimString(value, "\n ", &value);
 
diff --git a/components/toolbar/toolbar_model.h b/components/toolbar/toolbar_model.h
index afc86a9..9b2858f 100644
--- a/components/toolbar/toolbar_model.h
+++ b/components/toolbar/toolbar_model.h
@@ -61,6 +61,10 @@ class ToolbarModel {
   virtual security_state::SecurityStateModel::SecurityLevel GetSecurityLevel(
       bool ignore_editing) const = 0;
 
+
+  virtual int GetIronframeStatus() const = 0;
+  virtual std::string GetIronframeOrigin() const = 0;
+
   // Returns true if a call to GetText() would return something other than the
   // URL because of search term replacement.
   bool WouldReplaceURL() const;
diff --git a/components/toolbar/toolbar_model_delegate.h b/components/toolbar/toolbar_model_delegate.h
index 33f95c8..5fcac02 100644
--- a/components/toolbar/toolbar_model_delegate.h
+++ b/components/toolbar/toolbar_model_delegate.h
@@ -40,6 +40,10 @@ class ToolbarModelDelegate {
   // user edits that may be in progress.
   virtual SecurityLevel GetSecurityLevel() const = 0;
 
+  virtual int GetIronframeStatus() const = 0;
+
+  virtual std::string GetIronframeOrigin() const = 0;
+
   // Returns search terms as in search::GetSearchTerms() if such terms should
   // appear in the omnibox (i.e. the page is sufficiently secure, search term
   // replacement is enabled, editing is not in progress, etc.) given that the
diff --git a/components/toolbar/toolbar_model_impl.cc b/components/toolbar/toolbar_model_impl.cc
index f6c7410..d86c7c3 100644
--- a/components/toolbar/toolbar_model_impl.cc
+++ b/components/toolbar/toolbar_model_impl.cc
@@ -83,6 +83,21 @@ SecurityStateModel::SecurityLevel ToolbarModelImpl::GetSecurityLevel(
              : delegate_->GetSecurityLevel();
 }
 
+int ToolbarModelImpl::GetIronframeStatus() const {
+  // When editing or empty, assume no ironframe
+  return ((input_in_progress()) || !ShouldDisplayURL())
+             ? 0
+             : delegate_->GetIronframeStatus();
+}
+
+std::string ToolbarModelImpl::GetIronframeOrigin() const {
+  // When editing or empty, assume no ironframe
+    base::string16 empty;
+  return ((input_in_progress()) || !ShouldDisplayURL())
+      ? std::string()
+             : delegate_->GetIronframeOrigin();
+}
+
 int ToolbarModelImpl::GetIcon() const {
   switch (GetSecurityLevel(false)) {
     case SecurityStateModel::NONE:
diff --git a/components/toolbar/toolbar_model_impl.h b/components/toolbar/toolbar_model_impl.h
index 4b823f6..5ba4e10 100644
--- a/components/toolbar/toolbar_model_impl.h
+++ b/components/toolbar/toolbar_model_impl.h
@@ -38,6 +38,10 @@ class ToolbarModelImpl : public ToolbarModel {
   bool WouldPerformSearchTermReplacement(bool ignore_editing) const override;
   security_state::SecurityStateModel::SecurityLevel GetSecurityLevel(
       bool ignore_editing) const override;
+
+  int GetIronframeStatus() const override;
+  std::string GetIronframeOrigin() const override;
+
   int GetIcon() const override;
   gfx::VectorIconId GetVectorIcon() const override;
   base::string16 GetEVCertName() const override;
diff --git a/content/browser/ssl/ssl_policy.cc b/content/browser/ssl/ssl_policy.cc
index a45e135..e84b99e 100644
--- a/content/browser/ssl/ssl_policy.cc
+++ b/content/browser/ssl/ssl_policy.cc
@@ -147,6 +147,17 @@ void SSLPolicy::UpdateEntry(NavigationEntryImpl* entry,
 
   InitializeEntryIfNeeded(entry);
 
+  // if (web_contents->IronframeStatus() != 0)
+  // {
+  //     if (web_contents->IronframeStatus() == 1) {
+  //         entry->GetSSL().security_style = SECURITY_STYLE_AUTHENTICATED;
+  //     } else if (web_contents->IronframeStatus() == 2) {
+  //         entry->GetSSL().security_style = SECURITY_STYLE_AUTHENTICATION_BROKEN;
+  //     }
+  // }
+
+
+  
   if (entry->GetSSL().security_style == SECURITY_STYLE_UNAUTHENTICATED)
     return;
 
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 26e6d0a..a99271c 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -697,6 +697,12 @@ bool WebContentsImpl::OnMessageReceived(RenderViewHost* render_view_host,
                         OnFirstVisuallyNonEmptyPaint)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidLoadResourceFromMemoryCache,
                         OnDidLoadResourceFromMemoryCache)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_IronframeOrigin,
+                        OnIronframeOrigin)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_ValidIronframe,
+                        OnValidIronframe)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_InvalidIronframe,
+                        OnInvalidIronframe)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidDisplayInsecureContent,
                         OnDidDisplayInsecureContent)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidRunInsecureContent,
@@ -1181,6 +1187,10 @@ const std::string& WebContentsImpl::GetEncoding() const {
   return canonical_encoding_;
 }
 
+int WebContentsImpl::IronframeStatus() const {
+  return ironframe_status_;
+}
+
 bool WebContentsImpl::DisplayedInsecureContent() const {
   return displayed_insecure_content_;
 }
@@ -3480,6 +3490,35 @@ void WebContentsImpl::OnDidLoadResourceFromMemoryCache(
   }
 }
 
+
+std::string WebContentsImpl::IronframeOrigin() const {
+      RecordAction(base::UserMetricsAction("Ironframe.Origin"));
+      return ironframe_origin_;
+}
+
+
+void WebContentsImpl::OnIronframeOrigin(const std::string& origin) {
+    ironframe_origin_ = origin;
+}
+
+void WebContentsImpl::OnValidIronframe() {
+  RecordAction(base::UserMetricsAction("Ironframe.Valid"));
+  ironframe_status_ = 1;
+  this->DidChangeVisibleSSLState();
+// displayed_insecure_content_ = false;
+  //SSLManager::NotifySSLInternalStateChanged(
+  //GetController().GetBrowserContext());
+}
+void WebContentsImpl::OnInvalidIronframe() {
+  RecordAction(base::UserMetricsAction("Ironframe.Invalid"));
+  ironframe_status_ = 2;
+  this->DidChangeVisibleSSLState();
+// displayed_insecure_content_ = true;
+  //SSLManager::NotifySSLInternalStateChanged(
+  //  GetController().GetBrowserContext());
+}
+
+
 void WebContentsImpl::OnDidDisplayInsecureContent() {
   RecordAction(base::UserMetricsAction("SSL.DisplayedInsecureContent"));
   displayed_insecure_content_ = true;
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index 91226f8..a962147 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -291,6 +291,8 @@ class CONTENT_EXPORT WebContentsImpl
   uint64_t GetUploadSize() const override;
   uint64_t GetUploadPosition() const override;
   const std::string& GetEncoding() const override;
+  int IronframeStatus() const override;
+  std::string IronframeOrigin() const override;
   bool DisplayedInsecureContent() const override;
   void IncrementCapturerCount(const gfx::Size& capture_size) override;
   void DecrementCapturerCount() override;
@@ -909,6 +911,9 @@ class CONTENT_EXPORT WebContentsImpl
                                         const std::string& http_request,
                                         const std::string& mime_type,
                                         ResourceType resource_type);
+  void OnIronframeOrigin(const std::string& origin);
+  void OnValidIronframe();
+  void OnInvalidIronframe();
   void OnDidDisplayInsecureContent();
   void OnDidRunInsecureContent(const GURL& security_origin,
                                const GURL& target_url);
@@ -1199,6 +1204,11 @@ class CONTENT_EXPORT WebContentsImpl
   // The canonicalized character encoding.
   std::string canonical_encoding_;
 
+  //   0 - no ironframe, 1 - valid ironframe, 2 - invalid ironframe
+  int  ironframe_status_;
+
+  std::string ironframe_origin_;
+  
   // True if this is a secure page which displayed insecure content.
   bool displayed_insecure_content_;
 
diff --git a/content/common/frame_messages.h b/content/common/frame_messages.h
index 5a649f3..e2ec270 100644
--- a/content/common/frame_messages.h
+++ b/content/common/frame_messages.h
@@ -1461,6 +1461,10 @@ IPC_MESSAGE_ROUTED0(FrameHostMsg_DispatchLoad)
 IPC_MESSAGE_ROUTED1(FrameHostMsg_RouteMessageEvent,
                     FrameMsg_PostMessage_Params)
 
+IPC_MESSAGE_ROUTED1(FrameHostMsg_IronframeOrigin, std::string)
+IPC_MESSAGE_ROUTED0(FrameHostMsg_ValidIronframe)
+IPC_MESSAGE_ROUTED0(FrameHostMsg_InvalidIronframe)
+
 // Sent when the renderer displays insecure content in a secure origin.
 IPC_MESSAGE_ROUTED0(FrameHostMsg_DidDisplayInsecureContent)
 
diff --git a/content/public/browser/web_contents.h b/content/public/browser/web_contents.h
index c34b118..1cbb335 100644
--- a/content/public/browser/web_contents.h
+++ b/content/public/browser/web_contents.h
@@ -364,6 +364,13 @@ class WebContents : public PageNavigator,
   // Returns the character encoding of the page.
   virtual const std::string& GetEncoding() const = 0;
 
+
+  // True if this is a secure page which displayed insecure content.
+  virtual int IronframeStatus() const = 0;
+
+  // True if this is a secure page which displayed insecure content.
+  virtual std::string IronframeOrigin() const = 0;
+
   // True if this is a secure page which displayed insecure content.
   virtual bool DisplayedInsecureContent() const = 0;
 
diff --git a/content/renderer/media/aec_dump_message_filter.cc b/content/renderer/media/aec_dump_message_filter.cc
index 76f104c..1d6ac4b 100644
--- a/content/renderer/media/aec_dump_message_filter.cc
+++ b/content/renderer/media/aec_dump_message_filter.cc
@@ -9,7 +9,7 @@
 #include "content/renderer/media/webrtc_logging.h"
 #include "ipc/ipc_logging.h"
 #include "ipc/ipc_sender.h"
-
+#
 namespace {
 const int kInvalidDelegateId = -1;
 }
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 9fb4467..bd657d6 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -4198,6 +4198,17 @@ void RenderFrameImpl::didLoadResourceFromMemoryCache(
       response.mimeType().utf8(), WebURLRequestToResourceType(request)));
 }
 
+void RenderFrameImpl::ironframeOrigin(const blink::WebCString& origin) {
+    Send(new FrameHostMsg_IronframeOrigin(routing_id_, origin));
+}
+
+void RenderFrameImpl::validIronframe() {
+  Send(new FrameHostMsg_ValidIronframe(routing_id_));
+}
+void RenderFrameImpl::invalidIronframe() {
+  Send(new FrameHostMsg_InvalidIronframe(routing_id_));
+}
+
 void RenderFrameImpl::didDisplayInsecureContent() {
   Send(new FrameHostMsg_DidDisplayInsecureContent(routing_id_));
 }
diff --git a/content/renderer/render_frame_impl.h b/content/renderer/render_frame_impl.h
index b670441..eac67d3 100644
--- a/content/renderer/render_frame_impl.h
+++ b/content/renderer/render_frame_impl.h
@@ -567,6 +567,9 @@ class CONTENT_EXPORT RenderFrameImpl
   void didLoadResourceFromMemoryCache(
       const blink::WebURLRequest& request,
       const blink::WebURLResponse& response) override;
+  void validIronframe() override;
+  void invalidIronframe() override;
+  void ironframeOrigin(const blink::WebCString& origin) override;
   void didDisplayInsecureContent() override;
   void didRunInsecureContent(const blink::WebSecurityOrigin& origin,
                              const blink::WebURL& target) override;
diff --git a/content/renderer/render_view_impl.cc b/content/renderer/render_view_impl.cc
index 5766f5e..d7b1590 100644
--- a/content/renderer/render_view_impl.cc
+++ b/content/renderer/render_view_impl.cc
@@ -221,7 +221,6 @@ using blink::WebFrameContentDumper;
 using blink::WebGestureEvent;
 using blink::WebHistoryItem;
 using blink::WebHTTPBody;
-using blink::WebHitTestResult;
 using blink::WebIconURL;
 using blink::WebImage;
 using blink::WebInputElement;
@@ -267,6 +266,10 @@ using blink::WebRuntimeFeatures;
 using base::Time;
 using base::TimeDelta;
 
+#if defined(OS_ANDROID)
+using blink::WebContentDetectionResult;
+using blink::WebHitTestResult;
+#endif
 
 namespace content {
 
@@ -2802,11 +2805,8 @@ void RenderViewImpl::pageImportanceSignalsChanged() {
       main_render_frame_->GetRoutingID(), signals));
 }
 
-// TODO(dglazkov): Remove this ifdef. The content detection code
-// should not be platform-specific.
-// See http://crbug.com/635214 for details.
 #if defined(OS_ANDROID)
-WebURL RenderViewImpl::detectContentIntentAt(
+WebContentDetectionResult RenderViewImpl::detectContentAround(
     const WebHitTestResult& touch_hit) {
   DCHECK(touch_hit.node().isTextNode());
 
@@ -2815,10 +2815,11 @@ WebURL RenderViewImpl::detectContentIntentAt(
   for (const auto& detector : content_detectors_) {
     ContentDetector::Result content = detector->FindTappedContent(touch_hit);
     if (content.valid) {
-      return content.intent_url;
+      return WebContentDetectionResult(content.content_boundaries,
+          base::UTF8ToUTF16(content.text), content.intent_url);
     }
   }
-  return WebURL();
+  return WebContentDetectionResult();
 }
 
 void RenderViewImpl::scheduleContentIntent(const WebURL& intent,
diff --git a/content/renderer/render_view_impl.h b/content/renderer/render_view_impl.h
index 67d9a5c..b99b942 100644
--- a/content/renderer/render_view_impl.h
+++ b/content/renderer/render_view_impl.h
@@ -65,6 +65,7 @@
 #if defined(OS_ANDROID)
 #include "content/renderer/android/content_detector.h"
 #include "content/renderer/android/renderer_date_time_picker.h"
+#include "third_party/WebKit/public/web/WebContentDetectionResult.h"
 #endif
 
 #if defined(COMPILER_MSVC)
@@ -389,7 +390,7 @@ class CONTENT_EXPORT RenderViewImpl
   void scheduleContentIntent(const blink::WebURL& intent,
                              bool is_main_frame) override;
   void cancelScheduledContentIntents() override;
-  blink::WebURL detectContentIntentAt(
+  blink::WebContentDetectionResult detectContentAround(
       const blink::WebHitTestResult& touch_hit) override;
 
   // Only used on Android since all other platforms implement
diff --git a/mash/example/window_type_launcher/BUILD.gn b/mash/example/window_type_launcher/BUILD.gn
index 7c5c49a..b9a39ff 100644
--- a/mash/example/window_type_launcher/BUILD.gn
+++ b/mash/example/window_type_launcher/BUILD.gn
@@ -8,22 +8,32 @@ import("//services/shell/public/service_manifest.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//tools/grit/repack.gni")
 
-service("window_type_launcher") {
+executable("window_type_launcher") {
+  output_name = "window_type_launcher_exe"
   testonly = true
 
   sources = [
+    "main.cc",
     "window_type_launcher.cc",
     "window_type_launcher.h",
   ]
 
   deps = [
+    ":window_type_launcher_resources",
     "//base",
+    "//base:base_static",
+    "//base:i18n",
+    "//build/config/sanitizers:deps",
+    "//build/win:default_exe_manifest",
     "//mash/public/interfaces",
     "//mash/session/public/interfaces",
+    "//mojo/common:common_base",
+    "//mojo/edk/system",
     "//mojo/public/cpp/bindings",
     "//services/shell/public/cpp",
     "//services/shell/public/interfaces",
-    "//services/tracing/public/cpp",
+    "//services/shell/runner:init",
+    "//services/shell/runner/common",
     "//services/ui/public/cpp",
     "//services/ui/public/interfaces",
     "//skia",
@@ -32,18 +42,29 @@ service("window_type_launcher") {
     "//ui/gfx/geometry",
     "//ui/gfx/geometry/mojo",
     "//ui/views",
-    "//ui/views/mus:for_mojo_application",
+    "//ui/views/mus",
   ]
 
-  resources = [ "$root_out_dir/views_mus_resources.pak" ]
-
   data_deps = [
     ":manifest",
     "//services/ui",
   ]
 }
 
+copy("window_type_launcher_resources") {
+  sources = [
+    "$root_out_dir/views_mus_resources.pak",
+  ]
+  outputs = [
+    "$root_out_dir/Packages/window_type_launcher_exe/resources/views_mus_resources.pak",
+  ]
+  deps = [
+    "//ui/views/mus:resources",
+  ]
+}
+
 service_manifest("manifest") {
-  name = "window_type_launcher"
+  type = "exe"
+  name = "window_type_launcher_exe"
   source = "manifest.json"
 }
diff --git a/mash/example/window_type_launcher/main.cc b/mash/example/window_type_launcher/main.cc
new file mode 100644
index 0000000..f243228
--- /dev/null
+++ b/mash/example/window_type_launcher/main.cc
@@ -0,0 +1,76 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <utility>
+
+#include "base/at_exit.h"
+#include "base/command_line.h"
+#include "base/debug/stack_trace.h"
+#include "base/i18n/icu_util.h"
+#include "base/macros.h"
+#include "base/message_loop/message_loop.h"
+#include "base/process/launch.h"
+#include "base/threading/thread.h"
+#include "build/build_config.h"
+#include "mash/example/window_type_launcher/window_type_launcher.h"
+#include "mojo/edk/embedder/embedder.h"
+#include "mojo/edk/embedder/process_delegate.h"
+#include "services/shell/public/cpp/service_context.h"
+#include "services/shell/public/interfaces/service.mojom.h"
+#include "services/shell/runner/common/client_util.h"
+#include "services/shell/runner/init.h"
+
+namespace {
+
+class ProcessDelegate : public mojo::edk::ProcessDelegate {
+ public:
+  ProcessDelegate() {}
+  ~ProcessDelegate() override {}
+
+ private:
+  void OnShutdownComplete() override {}
+
+  DISALLOW_COPY_AND_ASSIGN(ProcessDelegate);
+};
+
+}
+
+int main(int argc, char** argv) {
+  base::AtExitManager at_exit;
+  base::CommandLine::Init(argc, argv);
+
+  shell::InitializeLogging();
+  shell::WaitForDebuggerIfNecessary();
+
+#if !defined(OFFICIAL_BUILD)
+  base::debug::EnableInProcessStackDumping();
+#if defined(OS_WIN)
+  base::RouteStdioToConsole(false);
+#endif
+#endif
+
+  {
+    mojo::edk::Init();
+
+    ProcessDelegate process_delegate;
+    base::Thread io_thread("io_thread");
+    base::Thread::Options io_thread_options(base::MessageLoop::TYPE_IO, 0);
+    CHECK(io_thread.StartWithOptions(io_thread_options));
+
+    mojo::edk::InitIPCSupport(&process_delegate, io_thread.task_runner().get());
+    mojo::edk::SetParentPipeHandleFromCommandLine();
+
+    base::i18n::InitializeICU();
+
+    base::MessageLoop loop;
+    WindowTypeLauncher delegate;
+    shell::ServiceContext impl(&delegate,
+                               shell::GetServiceRequestFromCommandLine());
+    loop.Run();
+
+    mojo::edk::ShutdownIPCSupport();
+  }
+
+  return 0;
+}
diff --git a/mash/example/window_type_launcher/manifest.json b/mash/example/window_type_launcher/manifest.json
index dfbe5ae..a5aea1d 100644
--- a/mash/example/window_type_launcher/manifest.json
+++ b/mash/example/window_type_launcher/manifest.json
@@ -1,6 +1,6 @@
 {
   "manifest_version":  1,
-  "name": "mojo:window_type_launcher",
+  "name": "exe:window_type_launcher_exe",
   "display_name": "Window Type Launcher",
   "capabilities": {
     "provided": { "mash:launchable": [ "mash::mojom::Launchable" ] },
diff --git a/mash/example/window_type_launcher/window_type_launcher.cc b/mash/example/window_type_launcher/window_type_launcher.cc
index c428456..57995ff 100644
--- a/mash/example/window_type_launcher/window_type_launcher.cc
+++ b/mash/example/window_type_launcher/window_type_launcher.cc
@@ -12,11 +12,8 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/platform_thread.h"
 #include "mash/session/public/interfaces/session.mojom.h"
-#include "services/shell/public/c/main.h"
 #include "services/shell/public/cpp/connection.h"
 #include "services/shell/public/cpp/connector.h"
-#include "services/shell/public/cpp/service.h"
-#include "services/shell/public/cpp/service_runner.h"
 #include "services/ui/public/cpp/property_type_converters.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_event_dispatcher.h"
@@ -520,8 +517,3 @@ void WindowTypeLauncher::Create(const shell::Identity& remote_identity,
                                 mash::mojom::LaunchableRequest request) {
   bindings_.AddBinding(this, std::move(request));
 }
-
-MojoResult ServiceMain(MojoHandle service_request_handle) {
-  return shell::ServiceRunner(new WindowTypeLauncher)
-      .Run(service_request_handle);
-}
diff --git a/media/gpu/vaapi_tfp_picture.cc b/media/gpu/vaapi_tfp_picture.cc
index b099c5e..ea48421 100644
--- a/media/gpu/vaapi_tfp_picture.cc
+++ b/media/gpu/vaapi_tfp_picture.cc
@@ -1,7 +1,7 @@
 // Copyright 2014 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#
 #include "media/gpu/vaapi_tfp_picture.h"
 
 #include <X11/Xlib.h>
diff --git a/third_party/WebKit/LayoutTests/LeakExpectations b/third_party/WebKit/LayoutTests/LeakExpectations
index 7649d98..0cca4cf 100644
--- a/third_party/WebKit/LayoutTests/LeakExpectations
+++ b/third_party/WebKit/LayoutTests/LeakExpectations
@@ -106,13 +106,3 @@ crbug.com/594309 [ Linux ] imported/csswg-test/vendor-imports/mozilla/mozilla-ce
 crbug.com/594309 [ Linux ] imported/csswg-test/vendor-imports/mozilla/mozilla-central-reftests/variables/variable-external-font-face-01.html [ Pass Leak ]
 crbug.com/594309 [ Linux ] imported/csswg-test/vendor-imports/mozilla/mozilla-central-reftests/variables/variable-font-face-02.html [ Pass Leak ]
 crbug.com/594309 [ Linux ] imported/csswg-test/vendor-imports/mozilla/mozilla-central-reftests/writing-modes-3/text-combine-upright-compression-007.html [ Leak ]
-
-# These fail in the leak detector: http://crbug.com/612924#c4
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual.html [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_pointerout_after_pointercancel_touch-manual.html [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_touch-action-auto-css_touch-manual.html  [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_releasepointercapture_onpointercancel_touch-manual.html [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual.html  [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_highest-parent-none_touch-manual.html  [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_pointercancel_touch-manual.html  [ Leak ]
-crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_pointerleave_after_pointercancel_touch-manual.html  [ Leak ]
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/TestExpectations b/third_party/WebKit/LayoutTests/TestExpectations
index fb4f390..2075a5e 100644
--- a/third_party/WebKit/LayoutTests/TestExpectations
+++ b/third_party/WebKit/LayoutTests/TestExpectations
@@ -887,47 +887,59 @@ crbug.com/630671 imported/wpt/pointerevents/pointerevent_capture_suppressing_mou
 crbug.com/630671 imported/wpt/pointerevents/pointerevent_releasepointercapture_events_to_original_target-manual.html [ Skip ]
 crbug.com/630671 imported/wpt/pointerevents/pointerevent_setpointercapture_relatedtarget-manual.html [ Skip ]
 
+# These fail in the leak detector: http://crbug.com/612924#c4
+crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual.html [ Skip ]
+crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_pointerout_after_pointercancel_touch-manual.html [ Skip ]
+crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_touch-action-auto-css_touch-manual.html  [ Skip ]
+crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_releasepointercapture_onpointercancel_touch-manual.html [ Skip ]
+crbug.com/619060 [ Linux ] imported/wpt/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual.html  [ Skip ]
+
 # The commented lines here for Mac is due to the fact that there is a more
 # generic skip rule in the next block of rules. However, when they get fixed
 # these should be uncommented as there is no touch support on Mac.
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual.html [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerenter_nohover-manual.html [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_after_pointerup_nohover-manual.html [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_after_pointercancel_touch-manual.html [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointercancel_touch-manual.html [ Skip ]
+# crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerenter_nohover-manual.html [ Skip ]
+# crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_after_pointerup_nohover-manual.html [ Skip ]
+# crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_after_pointercancel_touch-manual.html [ Skip ]
+# crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointercancel_touch-manual.html [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerout_after_pointerup_nohover-manual.html [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointertype_touch-manual.html [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_releasepointercapture_onpointercancel_touch-manual.html [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerout_after_pointercancel_touch-manual.html [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_touch-manual.html [ Skip ]
+# crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_pointerleave_touch-manual.html [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-auto-css_touch-manual.html  [ Skip ]
 crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-pan-x-css_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-button-test_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-table-test_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_highest-parent-none_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-span-test_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-svg-test_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-none-css_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_parent-none_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-y_touch-manual.html  [ Skip ]
-crbug.com/613672 [ Mac ] imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual.html  [ Skip ]
-
-# These are errors even when running the tests manually.
-crbug.com/629722 imported/wpt/pointerevents/pointerevent_lostpointercapture_is_first-manual.html  [ Skip ]
-crbug.com/629722 imported/wpt/pointerevents/pointerevent_lostpointercapture_for_disconnected_node-manual.html  [ Skip ]
-
-# There is no assoicated JS file to support automated user inputs.
-crbug.com/629724 imported/wpt/pointerevents/pointerevent_suppress_compat_events_on_click.html [ Skip ]
-crbug.com/629724 imported/wpt/pointerevents/pointerevent_suppress_compat_events_on_drag_mouse.html [ Skip ]
-
-# We should send PointerLeave events for stylus devices.
+
+# These are crashing on Linux debug builds and timing out on Mac as it doesn't support touch
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_lostpointercapture_for_disconnected_node-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_lostpointercapture_is_first-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_pointercancel_touch-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_pointerenter_nohover-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_pointerleave_after_pointercancel_touch-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_pointerleave_after_pointerup_nohover-manual.html  [ Skip ]
+crbug.com/619060 imported/wpt/pointerevents/pointerevent_pointerleave_touch-manual.html  [ Skip ]
+
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_suppress_compat_events_on_click.html [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_suppress_compat_events_on_drag_mouse.html [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-y_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_highest-parent-none_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-inherit_parent-none_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-keyboard-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-none-css_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-pan-x-css_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-span-test_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-svg-test_touch-manual.html  [ Skip ]
+crbug.com/627341 imported/wpt/pointerevents/pointerevent_touch-action-table-test_touch-manual.html  [ Skip ]
+
 crbug.com/583413 imported/wpt/pointerevents/pointerevent_pointerleave_pen-manual.html  [ Failure ]
 
+crbug.com/627716 imported/wpt/pointerevents/pointerevent_touch-action-button-test_touch-manual.html [ Skip ]
+
 # These testcases are incorrect, mark them as failing until they're fixed in the testsuite.
 # https://lists.w3.org/Archives/Public/www-style/2016Jan/0275.html
 # https://lists.w3.org/Archives/Public/www-style/2016Jan/0276.html
diff --git a/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash-expected.txt b/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash-expected.txt
deleted file mode 100644
index 358595c..0000000
--- a/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash-expected.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-crbug.com/634155: Don't crash when section has no header.
-
-
diff --git a/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash.html b/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash.html
deleted file mode 100644
index 88ddf50..0000000
--- a/third_party/WebKit/LayoutTests/fragmentation/no-repeating-thead-no-crash.html
+++ /dev/null
@@ -1,13 +0,0 @@
-<!DOCTYPE html>
-<style>
-    body { -webkit-column-width: 50px; }
-    tr { break-inside:avoid; }
-</style>
-crbug.com/634155: Don't crash when section has no header.
-<table>
-   <td><br></td>
-</table>
-<script>
-    if (window.testRunner)
-        testRunner.dumpAsText();
-</script>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
new file mode 100644
index 0000000..1bc6cdc
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
@@ -0,0 +1,66 @@
+<!DOCTYPE html>
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<meta name="timeout" content="long"></meta>
+<head>
+</head>
+<body>
+    <pre id="result">UNSET</pre>
+    <div id=prot style="height:480;width:700;background-image:url('tile.gif');">
+        <iframe id=protfr border=0 frameBorder=0 scrolling="no" src="resources/openskies3.html" style="height:270;width:333"></iframe>
+    </div>
+    <script>
+     var t = async_test('IronFrame scroll test');
+     setTimeout(function(){
+         t.step(function () {
+             assert_equals(document.getElementById("result").innerHTML, "PASS", "Scroll incorrect");
+         });
+         t.done();
+     }, 2000);
+    </script>
+    <script>
+     function scrollWindow() {
+         setTimeout(function(){window.scrollTo(0, 100);}, 1000);
+     }
+     window.addEventListener("load", scrollWindow, false);
+    </script>
+    DUMMY CONTENT
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    DUMMY CONTENT
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg b/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg
new file mode 100644
index 0000000..caea5cc
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/ishi.jpg differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html
new file mode 100644
index 0000000..cd9e029
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/closedskies3.html
@@ -0,0 +1,2 @@
+<body>
+    <iframe id="bigframe" style="position:absolute;top:0;left:0" border=0 frameBorder=0 scrolling="no" height=3000 width=3000 src="unprotected3.html"></iframe>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html
new file mode 100644
index 0000000..51656e4
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/eviliron.html
@@ -0,0 +1,4 @@
+<html>
+    <script>
+    </script>
+    <img src="ishi.jpg">
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
new file mode 100644
index 0000000..1a1dceb
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
@@ -0,0 +1,15 @@
+// httpserver.go
+package main
+
+import (
+	"flag"
+	"net/http"
+)
+
+var port = flag.String("port", "8080", "Define what TCP port to bind to")
+var root = flag.String("root", ".", "Define the root filesystem path")
+
+func main() {
+	flag.Parse()
+	panic(http.ListenAndServe(":"+*port, http.FileServer(http.Dir(*root))))
+}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg
new file mode 100644
index 0000000..caea5cc
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/ishi.jpg differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
new file mode 100644
index 0000000..edecfff
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+<body>
+  <pre id="result1"></pre>
+  <iframe id="bigframe" style="position:absolute;top:0;left:0" border=0 frameBorder=0 scrolling="no" height=3000 width=3000 src="protected3.html">
+  </iframe>
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png
new file mode 100644
index 0000000..9feafc5
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png
new file mode 100644
index 0000000..7d864c6
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/price.png differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
new file mode 100644
index 0000000..9824401
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
@@ -0,0 +1,61 @@
+<html requestVisibility=1>
+    <body>
+        <script>
+         var enabled=true;
+         var numAlerts = 0;
+         var width0 = -1;
+         var height0 = -1;
+         var width1 = -1;
+         var height1 = -1;
+        </script>
+        <img src="paypal.png" style="position:absolute;top:0;left:0">
+        <script>
+         var prev;
+         var prevMsg="";
+         var v={};
+         var visible=false;
+
+         var update = function(){
+             if(v.visible.width < 333 || v.visible.height< 270 ) {
+                 visible=false;
+             } else {
+                 visible=true;
+             }
+             if (width0 == - 1) {
+                 if (v.visible.width != 300 || v.visible.height != 150) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PARTIAL PASS";
+                 }
+                 width0 = v.visible.width;
+                 height0 = v.visible.height;
+             } else if (width0 != v.visible.width || height0 != v.visible.height) {
+                 if (v.visible.width != 300 || v.visible.height != 92) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PASS";
+                 }
+
+                 if (width1 == -1) {
+                     width1 = v.visible.width;
+                     height1 = v.visible.height;
+                 }
+             }
+         }
+         function go() {
+             document.documentElement.addEventListener('requestedvisibility', function(e) {
+                 if(e.message!=prevMsg){
+                     prev=e.timeStamp;
+                     prevMsg=e.message;
+                 }
+                 v = JSON.parse(e.message);
+                 v.innerHeight = innerHeight;
+                 v.innerWidth  = innerWidth;
+                 v.ancestorOrigins = document.location.ancestorOrigins;
+                 update();
+             });
+         }
+         if(enabled) { window.onload=go; }
+        </script>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif
new file mode 100644
index 0000000..6c950c8
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/tile.gif differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html
new file mode 100644
index 0000000..a53192d
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/unprotected3.html
@@ -0,0 +1,61 @@
+<html>
+    <!-- could also be
+         <html requestVisibility=1>
+         !-->
+    <body>
+        <script>
+         var enabled=false;
+         if(parent.frameElement.id!="unprotfr"){
+             document.requestVisibility();
+             enabled=true;
+         }
+
+        </script>
+
+        <img src="paypal.png" style="position:absolute;top:0;left:0">
+        <script>
+         var prev;
+         var prevMsg="";
+         var v={};
+         var visible=false;
+         var viz = top.document.getElementById("viz").contentWindow.document.getElementById("render");
+
+         var update = function(){
+             if(v.visible.width < 333 ||
+                v.visible.height< 270 ) {
+                    visible=false;
+             } else {
+                 visible=true;
+             }
+             if(!visible) {
+                 viz.style.backgroundColor="red";
+             } else {
+                 if(visible && Date.now()-prev < 2000) {
+                     viz.style.backgroundColor="yellow";
+                     setTimeout(update, 2250);
+                 } else {
+                     viz.style.backgroundColor="white";
+                 }
+             }
+         }
+
+         function go() { document.documentElement.onerror = function(e) {
+             if(e.message!=prevMsg){
+                 prev=e.timeStamp;
+                 prevMsg=e.message;
+             }
+             v = JSON.parse(e.message);
+             v.innerHeight = innerHeight;
+             v.innerWidth  = innerWidth;
+             v.timestamp   = e.timeStamp;
+             v.ancestorOrigins = document.location.ancestorOrigins;
+             viz.innerText = JSON.stringify(v);
+             var x = viz.innerText;
+             update();
+             //console.log(viz.innerText);
+         }
+         }
+         if(enabled) { window.onload=go; }
+        </script>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html
new file mode 100644
index 0000000..5d2f5b0
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/viz.html
@@ -0,0 +1,13 @@
+<head>
+    <style>
+     body{
+
+         font-family: 'Open Sans', sans-serif !important;
+         font-size: 14px;
+     }
+    </style>
+
+</head>
+<body>
+    <div style="word-wrap:break-word;font-size:24px" id="render">   </div>
+</body>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif
new file mode 100644
index 0000000..6c950c8
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif differ
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual-automation.js
index 904f62b..c703dda 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_change-touch-action-onpointerdown_touch-manual-automation.js
@@ -1,2 +1,2 @@
 if (window.chrome && chrome.gpuBenchmarking)
-  chrome.gpuBenchmarking.smoothScrollBy(50, function() {}, 250, 250, 1, "down");
\ No newline at end of file
+  chrome.gpuBenchmarking.smoothDrag(250, 250, 200, 200, function() {}, 1);
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_common_input.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_common_input.js
index f5282e1..9c23f18 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_common_input.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_common_input.js
@@ -55,71 +55,33 @@ function mouseScrollLeft() {
 }
 
 // Touch actions
-const scrollOffset = 30;
-const boundaryOffset = 5;
-const touchSourceType = 1;
 function touchTapInTarget(targetId) {
   if (window.chrome && chrome.gpuBenchmarking) {
     var target = document.getElementById(targetId);
-    target.scrollIntoViewIfNeeded();
     var targetRect = target.getBoundingClientRect();
-    chrome.gpuBenchmarking.tap(targetRect.left+boundaryOffset, targetRect.top+boundaryOffset);
-  }
-}
-
-function scrollPageIfNeeded(targetRect, startX, startY) {
-  if (startY > window.innerHeight) {
-    window.scrollTo(0, targetRect.top);
-  }
-  if (startX > window.innerWidth) {
-    window.scrollTo(targetRect.left, 0);
-  }
-}
-
-// TODO(nzolghadr): these two functions can be removed if we know the ID of the elements where we want to touch, see https://crbug.com/633672.
-function touchSmoothScrollUp(target) {
-  if (window.chrome && chrome.gpuBenchmarking) {
-    var targetRect = target.getBoundingClientRect();
-    var startX = targetRect.left+targetRect.width/2;
-    var startY = targetRect.top+targetRect.height/2;
-    scrollPageIfNeeded(targetRect, startX, startY);
+    window.scrollTo(targetRect.left, targetRect.top);
     targetRect = target.getBoundingClientRect();
-    startX = targetRect.left+targetRect.width/2;
-    startY = targetRect.top+targetRect.height/2;
-    chrome.gpuBenchmarking.smoothScrollBy(scrollOffset, function() {}, startX, startY, touchSourceType, "down");
-  }
-}
-
-function touchSmoothScrollLeft(target, callback_func) {
-  if (window.chrome && chrome.gpuBenchmarking) {
-    var targetRect = target.getBoundingClientRect();
-    var startX = targetRect.left+targetRect.width/2;
-    var startY = targetRect.top+targetRect.height/2;
-    scrollPageIfNeeded(targetRect, startX, startY);
-    targetRect = target.getBoundingClientRect();
-    startX = targetRect.left+targetRect.width/2;
-    startY = targetRect.top+targetRect.height/2;
-    chrome.gpuBenchmarking.smoothScrollBy(scrollOffset, callback_func, startX, startY, touchSourceType, "right");
+    chrome.gpuBenchmarking.tap(targetRect.left+5, targetRect.top+5);
   }
 }
 
 function touchScrollUpInTarget(targetId) {
   if (window.chrome && chrome.gpuBenchmarking) {
     var target = document.getElementById(targetId);
-    touchSmoothScrollUp(target);
+    var targetRect = target.getBoundingClientRect();
+    window.scrollTo(targetRect.left, targetRect.top);
+    targetRect = target.getBoundingClientRect();
+    chrome.gpuBenchmarking.smoothDrag(targetRect.left, targetRect.bottom-5, targetRect.left, targetRect.top+5);
   }
 }
 
-function touchScrollLeftInTarget(targetId, callback_func) {
+function touchScrollLeftInTarget(targetId) {
   if (window.chrome && chrome.gpuBenchmarking) {
     var target = document.getElementById(targetId);
-    touchSmoothScrollLeft(target, callback_func);
-  }
-}
-
-function touchScrollByPosition(x, y, offset, direction, callback_func) {
-  if (window.chrome && chrome.gpuBenchmarking) {
-    chrome.gpuBenchmarking.smoothScrollBy(offset, callback_func, x, y, 1, direction);
+    var targetRect = target.getBoundingClientRect();
+    window.scrollTo(targetRect.left, targetRect.top);
+    targetRect = target.getBoundingClientRect();
+    chrome.gpuBenchmarking.smoothDrag(targetRect.right-5, targetRect.top+5, targetRect.left+5, targetRect.top+5);
   }
 }
 
@@ -138,12 +100,12 @@ function penClickIntoTarget(target) {
 // Keyboard actions
 function keyboardScrollUp() {
   if (window.eventSender)
-    eventSender.keyDown('ArrowDown');
+    eventSender.keyDown('downArrow');
 }
 
 function keyboardScrollLeft() {
   if (window.eventSender)
-    eventSender.keyDown('ArrowRight');
+    eventSender.keyDown('rightArrow');
 }
 
 // Defined in every test
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-button-test_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-button-test_touch-manual-automation.js
index 8e6a5db..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-button-test_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-button-test_touch-manual-automation.js
@@ -1,24 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
-  window.setTimeout(function() {
-    touchTapInTarget('btnComplete');}
-    , scrollReturnInterval);
-}
-
 function inject_input() {
-   var target = document.getElementById("target0");
-   var targetRect = target.getBoundingClientRect();
-
-   var button = document.getElementsByTagName("button")[0];
-   var buttonRect = button.getBoundingClientRect();
-
-   var x = (buttonRect.left - targetRect.left)/2;
-   touchScrollByPosition(x, targetRect.top + 100, 30, "down");
-   touchScrollByPosition(x, targetRect.top + 100, 30, "right", callback_function);
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
+  touchTapInTarget('btnComplete');
+}
 
-   window.setTimeout(function() {
-    touchSmoothScrollUp(button);
-    touchSmoothScrollLeft(button, callback_function);
-    } , 4*scrollReturnInterval);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual-automation.js
index d672827..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-auto-child-none_touch-manual-automation.js
@@ -4,4 +4,5 @@ function inject_input() {
   touchScrollUpInTarget('target0');
   touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
-}
\ No newline at end of file
+}
+
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual-automation.js
index d672827..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-none_touch-manual-automation.js
@@ -4,4 +4,5 @@ function inject_input() {
   touchScrollUpInTarget('target0');
   touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
-}
\ No newline at end of file
+}
+
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual-automation.js
index a2db692..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-inherit_child-pan-x-child-pan-x_touch-manual-automation.js
@@ -1,10 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
+function inject_input() {
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
 }
 
-function inject_input() {
-  touchScrollUpInTarget('target0');
-  touchScrollLeftInTarget('target0', callback_function);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual-automation.js
index a2db692..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y-pan-y_touch-manual-automation.js
@@ -1,10 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
+function inject_input() {
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
 }
 
-function inject_input() {
-  touchScrollUpInTarget('target0');
-  touchScrollLeftInTarget('target0', callback_function);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual-automation.js
index f1f1dfa..4fffdcf 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-x-pan-y_touch-manual-automation.js
@@ -3,4 +3,5 @@ importAutomationScript('/pointerevents/pointerevent_common_input.js');
 function inject_input() {
   touchScrollUpInTarget('target0');
   touchScrollLeftInTarget('target0');
-}
\ No newline at end of file
+}
+
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual-automation.js
index d672827..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-pan-y-css_touch-manual-automation.js
@@ -4,4 +4,5 @@ function inject_input() {
   touchScrollUpInTarget('target0');
   touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
-}
\ No newline at end of file
+}
+
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-span-test_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-span-test_touch-manual-automation.js
index 149a1d5..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-span-test_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-span-test_touch-manual-automation.js
@@ -1,22 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
+function inject_input() {
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
 }
 
-function inject_input() {
-   var target = document.getElementById("target0");
-   var targetRect = target.getBoundingClientRect();
-
-   var span = document.getElementsByTagName("span")[0];
-   var spanRect = span.getBoundingClientRect();
-
-   var x = (spanRect.left - targetRect.left)/2;
-   touchScrollByPosition(x, targetRect.top + 100, 30, "down");
-   touchScrollByPosition(x, targetRect.top + 100, 30, "right");
-
-   window.setTimeout(function() {
-    touchSmoothScrollUp(span);
-    touchSmoothScrollLeft(span, callback_function);
-    } , 6*scrollReturnInterval);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-svg-test_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-svg-test_touch-manual-automation.js
index 752573d..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-svg-test_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-svg-test_touch-manual-automation.js
@@ -1,22 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
+function inject_input() {
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
   touchTapInTarget('btnComplete');
 }
 
-function inject_input() {
-   var target = document.getElementById("target0");
-   var targetRect = target.getBoundingClientRect();
-
-   var svg = document.getElementsByTagName("svg")[0];
-   var svgRect = svg.getBoundingClientRect();
-
-   var x = (svgRect.left - targetRect.left)/2;
-   touchScrollByPosition(x, targetRect.top + 100, 30, "down");
-   touchScrollByPosition(x, targetRect.top + 100, 30, "right");
-
-   window.setTimeout(function() {
-     touchSmoothScrollUp(svg);
-     touchSmoothScrollLeft(svg, callback_function);
-     } , 4*scrollReturnInterval);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-table-test_touch-manual-automation.js b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-table-test_touch-manual-automation.js
index b1d4bb6..d972b5a 100644
--- a/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-table-test_touch-manual-automation.js
+++ b/third_party/WebKit/LayoutTests/imported/wpt_automation/pointerevents/pointerevent_touch-action-table-test_touch-manual-automation.js
@@ -1,22 +1,8 @@
 importAutomationScript('/pointerevents/pointerevent_common_input.js');
 
-function callback_function() {
-  window.setTimeout(function() {
-    touchTapInTarget('btnComplete');}
-    , 2 * scrollReturnInterval);
-}
-
 function inject_input() {
-  touchScrollUpInTarget('row1');
-  window.setTimeout(function() {
-    touchScrollLeftInTarget('row1');
-    } , 2*scrollReturnInterval);
-
-  window.setTimeout(function() {
-    touchScrollUpInTarget('cell3');
-    } , 2*scrollReturnInterval);
+  touchScrollUpInTarget('target0');
+  touchScrollLeftInTarget('target0');
+  touchTapInTarget('btnComplete');
+}
 
-  window.setTimeout(function() {
-    touchScrollLeftInTarget('cell3', callback_function);
-    } , 2*scrollReturnInterval);
-}
\ No newline at end of file
diff --git a/third_party/WebKit/Source/core/core.gypi b/third_party/WebKit/Source/core/core.gypi
index 96062ce..7b927f2 100644
--- a/third_party/WebKit/Source/core/core.gypi
+++ b/third_party/WebKit/Source/core/core.gypi
@@ -131,6 +131,7 @@
             'events/CustomEvent.idl',
             'events/DragEvent.idl',
             'events/ErrorEvent.idl',
+            'events/RequestedVisibilityEvent.idl',
             'events/Event.idl',
             'events/EventTarget.idl',
             'events/FocusEvent.idl',
@@ -475,6 +476,7 @@
             'events/CustomEvent.idl',
             'events/DragEvent.idl',
             'events/ErrorEvent.idl',
+            'events/RequestedVisibilityEvent.idl',
             'events/Event.idl',
             'events/FocusEvent.idl',
             'events/HashChangeEvent.idl',
@@ -2769,6 +2771,8 @@
             'events/DragEvent.h',
             'events/ErrorEvent.cpp',
             'events/ErrorEvent.h',
+            'events/RequestedVisibilityEvent.cpp',
+            'events/RequestedVisibilityEvent.h',
             'events/Event.cpp',
             'events/EventDispatchMediator.cpp',
             'events/EventDispatchMediator.h',
@@ -3759,6 +3763,7 @@
             'events/CustomEventInit.idl',
             'events/DragEventInit.idl',
             'events/ErrorEventInit.idl',
+            'events/RequestedVisibilityEventInit.idl',
             'events/EventInit.idl',
             'events/EventListenerOptions.idl',
             'events/EventModifierInit.idl',
@@ -3839,6 +3844,8 @@
             '<(blink_core_output_dir)/events/DragEventInit.h',
             '<(blink_core_output_dir)/events/ErrorEventInit.cpp',
             '<(blink_core_output_dir)/events/ErrorEventInit.h',
+            '<(blink_core_output_dir)/events/RequestedVisibilityEventInit.cpp',
+            '<(blink_core_output_dir)/events/RequestedVisibilityEventInit.h',
             '<(blink_core_output_dir)/events/EventInit.cpp',
             '<(blink_core_output_dir)/events/EventInit.h',
             '<(blink_core_output_dir)/events/EventListenerOptions.cpp',
diff --git a/third_party/WebKit/Source/core/dom/Document.cpp b/third_party/WebKit/Source/core/dom/Document.cpp
index 8c1c043..e386f4a 100644
--- a/third_party/WebKit/Source/core/dom/Document.cpp
+++ b/third_party/WebKit/Source/core/dom/Document.cpp
@@ -26,6 +26,7 @@
  */
 
 #include "core/dom/Document.h"
+#include "core/events/ErrorEvent.h"
 
 #include "bindings/core/v8/DOMDataStore.h"
 #include "bindings/core/v8/ExceptionMessages.h"
@@ -121,11 +122,13 @@
 #include "core/editing/serializers/Serialization.h"
 #include "core/editing/spellcheck/SpellChecker.h"
 #include "core/events/BeforeUnloadEvent.h"
+#include "core/events/ErrorEvent.h"
 #include "core/events/Event.h"
 #include "core/events/EventFactory.h"
 #include "core/events/EventListener.h"
 #include "core/events/HashChangeEvent.h"
 #include "core/events/PageTransitionEvent.h"
+#include "core/events/RequestedVisibilityEvent.h"
 #include "core/events/ScopedEventQueue.h"
 #include "core/events/VisualViewportResizeEvent.h"
 #include "core/events/VisualViewportScrollEvent.h"
@@ -185,6 +188,7 @@
 #include "core/layout/LayoutView.h"
 #include "core/layout/TextAutosizer.h"
 #include "core/layout/api/LayoutViewItem.h"
+#include "core/layout/compositing/CompositedLayerMapping.h"
 #include "core/layout/compositing/PaintLayerCompositor.h"
 #include "core/loader/CookieJar.h"
 #include "core/loader/DocumentLoader.h"
@@ -211,6 +215,9 @@
 #include "core/svg/SVGScriptElement.h"
 #include "core/svg/SVGTitleElement.h"
 #include "core/svg/SVGUseElement.h"
+#include "core/testing/Internals.h"
+#include "core/testing/InternalRuntimeFlags.h"
+#include "core/testing/InternalSettings.h"
 #include "core/timing/DOMWindowPerformance.h"
 #include "core/timing/Performance.h"
 #include "core/workers/SharedWorkerRepositoryClient.h"
@@ -393,6 +400,8 @@ Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC
     , m_domWindow(m_frame ? m_frame->localDOMWindow() : 0)
     , m_importsController(initializer.importsController())
     , m_contextFeatures(ContextFeatures::defaultSwitch())
+    , m_requestedVisibility(new VisibilityDocumentSet())
+    , m_requestVisibilityRect(nullptr)
     , m_wellFormed(false)
     , m_printing(false)
     , m_wasPrinting(false)
@@ -3902,6 +3911,13 @@ void Document::enqueueAnimationFrameEvent(Event* event)
     ensureScriptedAnimationController().enqueueEvent(event);
 }
 
+void Document::enqueueRequestedVisibilityEvent(const String& msg)
+{
+    RequestedVisibilityEvent* event = RequestedVisibilityEvent::create(msg);
+    event->setTarget(documentElement());
+    ensureScriptedAnimationController().enqueueEvent(event);
+}
+
 void Document::enqueueUniqueAnimationFrameEvent(Event* event)
 {
     ensureScriptedAnimationController().enqueuePerFrameEvent(event);
@@ -5794,6 +5810,145 @@ bool Document::hasFocus() const
     return page() && page()->focusController().isDocumentFocused(*this);
 }
 
+
+void Document::validIronframe(){
+    m_frame->loader().client()->ironframeOrigin(this->origin().ascii());
+    m_frame->loader().client()->validIronframe();
+    
+    // Set attribute.
+    //this->documentElement()->setAttribute("requestVisibility", "1", ASSERT_NO_EXCEPTION);
+}
+
+void Document::invalidIronframe(){
+    m_frame->loader().client()->invalidIronframe();
+    // Set attribute.
+    //this->documentElement()->setAttribute("requestVisibility", "1", ASSERT_NO_EXCEPTION);
+}
+
+
+VisibilityDocumentSet *Document::requestedVisibility() {
+    return m_requestedVisibility;
+}
+
+void Document::requestVisibility(){
+    // Set attribute.
+    this->documentElement()->setAttribute("requestVisibility", "1", ASSERT_NO_EXCEPTION);
+}
+
+void Document::requestVisibilityImpl(){
+    // Step 1:  Block obvious failure modes.  Probably insert SVG test here?
+    if(this->domWindow() == this->domWindow()->top()) {return;}
+
+    // Step 2:  Collect useful handles
+    DOMWindow *testWindow = this->domWindow();
+    PaintLayer* iframePaintLayer = this->documentElement()->layoutObject()->enclosingLayer();
+
+    if(!iframePaintLayer) { return; }
+    GraphicsLayer* iframeGraphicsLayer = iframePaintLayer->graphicsLayerBacking();
+    const PaintLayer* rootPaintLayer = this->domWindow()->top()->document()->body()->layoutObject()->enclosingLayer()->root(); // XXX DMK top scrolling layer
+    GraphicsLayer* rootGraphicsLayer = rootPaintLayer->graphicsLayerBacking();
+    if(!iframeGraphicsLayer || !rootGraphicsLayer) {
+        addConsoleMessage(ConsoleMessage::create(RenderingMessageSource, ErrorMessageLevel, "Couldn't find required GraphicsLayer.  One may not have been created for this document."));
+        return;
+    }
+    // Step 3:  Discover our effective Bounds.  We are effectively trying to compute the "keyhole" that reaches us,
+    //          through multiple iframes and scroll/translateX values.  The "sacred" transform is position and size.
+    //          This is presently being done via boundsInViewportSpace, which works through almost everything.
+    //          Almost.  (Scale3d needs to be corrected for, or rejected.)
+
+    IntRect bounds = this->documentElement()->boundsInViewport();
+    IntRect origBounds = bounds;
+
+    testWindow = this->domWindow();
+    float sx, sy;
+    sx=sy=0;
+    bool moreElements=true;
+    Element *testElement = this->documentElement();
+    Document *testDocument = this;
+
+    bool do_move = true;
+    bool hostile=false;
+    while(moreElements){
+        if(testDocument->documentElement()==testElement){
+            testElement=testDocument->domWindow()->frameElement();
+            testDocument=&testElement->document();
+            sx+=testWindow->scrollX();
+            sy+=testWindow->scrollY();
+            testWindow=testWindow->parent();
+        } else {
+            testElement=testElement->parentElement();
+        }
+        // HACK!! Remove use of childrenClipRect
+        IntRect child = IntRect(testElement->layoutObject()->enclosingLayer()->clipper().childrenClipRect());
+        if(testElement->tagName()=="foreignObject"){
+            hostile=true;
+        }
+        if(testElement->tagName()=="IFRAME") {
+            IntRect ifrBounds = testElement->boundsInViewport();
+            child.setWidth(fmin(ifrBounds.size().width(), child.size().width()));
+            child.setHeight(fmin(ifrBounds.size().height(), child.size().height()));
+        }
+        bounds.intersect(child);
+        if(testElement == this->domWindow()->top()->document()->documentElement()) {
+            moreElements=false;
+        }
+    }
+    // intersect with visible viewport.  XXX stop using IntRect, start using FloatRect
+    FrameView *mainFrameView = this->page()->deprecatedLocalMainFrame()->view();
+    LayoutRect mainViewRect = mainFrameView->layoutView()->viewRect();
+    IntRect mainViewIntRect = IntRect(mainViewRect);
+    bounds.intersect(mainViewIntRect);
+
+    FloatRect mainViewFloatRect = FloatRect(mainViewRect);
+    if(!bounds.size().width() || !bounds.size().height()) do_move=false;
+    // XXX for each registered visibility req, look for collisions with us, if so block the raise
+    VisibilityDocumentSet *ds = this->domWindow()->top()->document()->requestedVisibility();
+
+    for(Document *reqdoc : *ds){
+        if(reqdoc == this) break; // maybe this is right?
+        if(reqdoc->m_requestVisibilityRect && reqdoc->m_requestVisibilityRect->intersects(bounds)) {
+            // XXX DMK better would be to run bounds.subtract but then there'd have to *be* a bounds.subtract method.
+            //         Also, subtraction is a not quite so defined as intersection.  Largest contiguous from 0,0?
+            //         Largest contiguous from any corner?  God forbid, pile-o-rects?  Let's just run for the hills for now
+            hostile=true;
+            //return;  // there is a rather fun attack if you try this
+        }
+    }
+
+    if(hostile){
+        do_move=false;
+        bounds.setWidth(0);
+        bounds.setHeight(0);
+    }
+    if(this->documentElement()->hasAttribute("visibilityOnly")) { do_move=false; } // XXX DMK expand on this, there are uses
+    if (do_move) {
+        FloatRect fbounds = bounds;
+        this->set_requestVisibilityRect(&fbounds);
+        rootGraphicsLayer->addChild(iframeGraphicsLayer);
+        iframeGraphicsLayer->setPosition(FloatPoint(bounds.x(), bounds.y()));
+        iframeGraphicsLayer->setSize(FloatSize(bounds.size().width(), bounds.size().height()));
+        iframeGraphicsLayer->setBackgroundColor(Color::black);
+        iframeGraphicsLayer->setMasksToBounds(true);
+        iframeGraphicsLayer->setOpacity(1.0);
+        IntSize offset = IntSize(bounds.x()-origBounds.x()-topDocument().domWindow()->scrollX(), bounds.y()-origBounds.y()-topDocument().domWindow()->scrollY());
+        iframeGraphicsLayer->setOffsetFromLayoutObject(offset, GraphicsLayer::ShouldSetNeedsDisplay::SetNeedsDisplay);// const IntSize & offset,ShouldSetNeedsDisplay shouldSetNeedsDisplay)
+    }
+    // report.  sx and sy are
+    bounds.setWidth(fmax(bounds.size().width() - sx, 0));
+    bounds.setHeight(fmax(bounds.size().height()- sy, 0));
+    //XXX DMK correctly integrate ancestorOrigins and return a clientRect for the visible region of the frame
+    String s = String("{\"viewport\": {\"x\": " + String::number((int)mainViewFloatRect.x()) + ", \"y\": " + String::number((int)mainViewFloatRect.y()) + ", \"width\": " + String::number((int)mainViewFloatRect.size().width()) + ", \"height\": " + String::number((int)mainViewFloatRect.size().height()) + "},  \"visible\": {\"x\": " + String::number((int)bounds.x()) + ",  \"y\": " + String::number((int)bounds.y()) + ", \"width\": " + String::number((int)bounds.size().width()) + ", \"height\": " + String::number((int)bounds.size().height()) + "}}");
+    DEFINE_STATIC_LOCAL(String, prev_event, ());
+    bool duplicate = false;
+    if (s == prev_event) {
+        duplicate = true;
+    }
+    prev_event = s;
+    if (!duplicate) {
+        this->enqueueRequestedVisibilityEvent(s);
+    }
+};
+
 template<unsigned type>
 bool shouldInvalidateNodeListCachesForAttr(const HeapHashSet<WeakMember<const LiveNodeListBase>> nodeLists[], const QualifiedName& attrName)
 {
@@ -5994,6 +6149,7 @@ DEFINE_TRACE(Document)
     visitor->trace(m_intersectionObserverData);
     visitor->trace(m_snapCoordinator);
     visitor->trace(m_resizeObserverController);
+    visitor->trace(m_requestedVisibility);
     Supplementable<Document>::trace(visitor);
     TreeScope::trace(visitor);
     ContainerNode::trace(visitor);
diff --git a/third_party/WebKit/Source/core/dom/Document.h b/third_party/WebKit/Source/core/dom/Document.h
index 2d874b3..cbf3003 100644
--- a/third_party/WebKit/Source/core/dom/Document.h
+++ b/third_party/WebKit/Source/core/dom/Document.h
@@ -177,6 +177,7 @@ struct AnnotatedRegionValue;
 struct FocusParams;
 struct IconURL;
 
+using VisibilityDocumentSet = HeapHashSet<WeakMember<Document>>;
 using MouseEventWithHitTestResults = EventWithHitTestResults<PlatformMouseEvent>;
 using ExceptionCode = int;
 
@@ -711,6 +712,8 @@ public:
     ResizeObserverController* resizeObserverController() const { return m_resizeObserverController; }
     ResizeObserverController& ensureResizeObserverController();
 
+    VisibilityDocumentSet *requestedVisibility();
+
     void updateViewportDescription();
 
     // Returns the owning element in the parent document. Returns nullptr if
@@ -926,6 +929,7 @@ public:
     void enqueueMediaQueryChangeListeners(HeapVector<Member<MediaQueryListListener>>&);
     void enqueueVisualViewportScrollEvent();
     void enqueueVisualViewportResizeEvent();
+    void enqueueRequestedVisibilityEvent(const String&);
 
     void dispatchEventsForPrinting();
 
@@ -1095,6 +1099,12 @@ public:
 
     bool isInMainFrame() const;
 
+    void set_requestVisibilityRect(FloatRect *r) { m_requestVisibilityRect = r; }
+    void validIronframe();
+    void invalidIronframe();
+    void requestVisibility();
+    void requestVisibilityImpl();
+
 protected:
     Document(const DocumentInit&, DocumentClassFlags = DefaultDocumentClass);
 
@@ -1207,6 +1217,9 @@ private:
     Member<DocumentParser> m_parser;
     Member<ContextFeatures> m_contextFeatures;
 
+    Member<VisibilityDocumentSet> m_requestedVisibility;
+    FloatRect *m_requestVisibilityRect;
+
     bool m_wellFormed;
 
     // Document URLs.
diff --git a/third_party/WebKit/Source/core/dom/Document.idl b/third_party/WebKit/Source/core/dom/Document.idl
index fdd8b9c..c51e969 100644
--- a/third_party/WebKit/Source/core/dom/Document.idl
+++ b/third_party/WebKit/Source/core/dom/Document.idl
@@ -54,6 +54,11 @@ interface Document : Node {
     HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);
     HTMLCollection getElementsByClassName(DOMString classNames);
 
+    void requestVisibility();
+    void validIronframe();
+    void invalidIronframe();
+    void requestVisibilityImpl();
+
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, PerWorldBindings, RaisesException] Element createElement(DOMString localName);
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, RaisesException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName);
     [NewObject] DocumentFragment createDocumentFragment();
diff --git a/third_party/WebKit/Source/core/events/EventTypeNames.in b/third_party/WebKit/Source/core/events/EventTypeNames.in
index f86ff7e..e9ccbac 100644
--- a/third_party/WebKit/Source/core/events/EventTypeNames.in
+++ b/third_party/WebKit/Source/core/events/EventTypeNames.in
@@ -186,6 +186,7 @@ removesourcebuffer
 removestream
 removetrack
 repeatEvent
+requestedvisibility
 reset
 resize
 resourcetimingbufferfull
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp
new file mode 100644
index 0000000..c32b661
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.cpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "core/events/RequestedVisibilityEvent.h"
+
+#include "bindings/core/v8/V8Binding.h"
+#include <v8.h>
+
+namespace blink {
+
+RequestedVisibilityEvent::RequestedVisibilityEvent()
+    : m_sanitizedMessage()
+{
+}
+
+RequestedVisibilityEvent::RequestedVisibilityEvent(const AtomicString& type, const RequestedVisibilityEventInit& initializer)
+    : Event(type, initializer)
+    , m_sanitizedMessage()
+{
+    if (initializer.hasMessage())
+        m_sanitizedMessage = initializer.message();
+}
+
+RequestedVisibilityEvent::RequestedVisibilityEvent(const String& message)
+    : Event(EventTypeNames::requestedvisibility, false, true)
+    , m_sanitizedMessage(message)
+{
+}
+
+void RequestedVisibilityEvent::setUnsanitizedMessage(const String& message)
+{
+    ASSERT(m_unsanitizedMessage.isEmpty());
+    m_unsanitizedMessage = message;
+}
+
+RequestedVisibilityEvent::~RequestedVisibilityEvent()
+{
+}
+
+const AtomicString& RequestedVisibilityEvent::interfaceName() const
+{
+    return EventNames::RequestedVisibilityEvent;
+}
+
+DEFINE_TRACE(RequestedVisibilityEvent)
+{
+    Event::trace(visitor);
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h
new file mode 100644
index 0000000..0f200b8
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RequestedVisibilityEvent_h
+#define RequestedVisibilityEvent_h
+
+#include "bindings/core/v8/DOMWrapperWorld.h"
+#include "bindings/core/v8/SourceLocation.h"
+#include "core/events/RequestedVisibilityEventInit.h"
+#include "core/events/Event.h"
+#include "wtf/RefPtr.h"
+#include "wtf/text/WTFString.h"
+
+namespace blink {
+
+class RequestedVisibilityEvent final : public Event {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    static RequestedVisibilityEvent* create()
+    {
+        return new RequestedVisibilityEvent;
+    }
+    static RequestedVisibilityEvent* create(const String& message)
+    {
+        return new RequestedVisibilityEvent(message);
+    }
+    static RequestedVisibilityEvent* create(const AtomicString& type, const RequestedVisibilityEventInit& initializer)
+    {
+        return new RequestedVisibilityEvent(type, initializer);
+    }
+
+    ~RequestedVisibilityEvent() override;
+
+    // As 'message' is exposed to JavaScript, never return unsanitizedMessage.
+    const String& message() const { return m_sanitizedMessage; }
+
+    // 'messageForConsole' is not exposed to JavaScript, and prefers 'm_unsanitizedMessage'.
+    const String& messageForConsole() const { return !m_unsanitizedMessage.isEmpty() ? m_unsanitizedMessage : m_sanitizedMessage; }
+
+    const AtomicString& interfaceName() const override;
+
+    void setUnsanitizedMessage(const String&);
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    RequestedVisibilityEvent();
+    RequestedVisibilityEvent(const String& message);
+    RequestedVisibilityEvent(const AtomicString&, const RequestedVisibilityEventInit&);
+
+    String m_unsanitizedMessage;
+    String m_sanitizedMessage;
+};
+
+} // namespace blink
+
+#endif // RequestedVisibilityEvent_h
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl
new file mode 100644
index 0000000..aae3453
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEvent.idl
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+[
+    Constructor(DOMString type, optional RequestedVisibilityEventInit eventInitDict),
+] interface RequestedVisibilityEvent : Event {
+    readonly attribute DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl b/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl
new file mode 100644
index 0000000..9d42ea9
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestedVisibilityEventInit.idl
@@ -0,0 +1,7 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+dictionary RequestedVisibilityEventInit : EventInit {
+    DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/frame/FrameView.cpp b/third_party/WebKit/Source/core/frame/FrameView.cpp
index 44f2446..96642cb 100644
--- a/third_party/WebKit/Source/core/frame/FrameView.cpp
+++ b/third_party/WebKit/Source/core/frame/FrameView.cpp
@@ -40,6 +40,7 @@
 #include "core/editing/markers/DocumentMarkerController.h"
 #include "core/fetch/ResourceFetcher.h"
 #include "core/frame/EventHandlerRegistry.h"
+#include "core/frame/FrameConsole.h"
 #include "core/frame/FrameHost.h"
 #include "core/frame/LocalFrame.h"
 #include "core/frame/Location.h"
@@ -2541,6 +2542,15 @@ void FrameView::updateLifecyclePhasesInternal(DocumentLifecycle::LifecycleState
             // This was required for slimming paint v1 but is only temporarily
             // needed for slimming paint v2.
             view.compositor()->updateIfNeededRecursive();
+
+	    Document *d = frame().document();
+	    VisibilityDocumentSet *ds = d->requestedVisibility();
+	    if (ds != nullptr) {
+		for(Document *reqdoc : *ds){
+		    reqdoc->requestVisibilityImpl();
+		}
+	    }
+
             scrollContentsIfNeededRecursive();
 
             DCHECK(lifecycle().state() >= DocumentLifecycle::CompositingClean);
diff --git a/third_party/WebKit/Source/core/frame/UseCounter.h b/third_party/WebKit/Source/core/frame/UseCounter.h
index 944166c..c82c293 100644
--- a/third_party/WebKit/Source/core/frame/UseCounter.h
+++ b/third_party/WebKit/Source/core/frame/UseCounter.h
@@ -1259,6 +1259,8 @@ public:
         SVGSMILAdditiveAnimation = 1484,
         SendBeaconWithNonSimpleContentType = 1485,
 
+        DocumentCreateEventRequestedVisibilityEvent = 1500,
+
         // Add new features immediately above this line. Don't change assigned
         // numbers of any item, and don't reuse removed slots.
         // Also, run update_use_counter_feature_enum.py in chromium/src/tools/metrics/histograms/
diff --git a/third_party/WebKit/Source/core/layout/LayoutTableSection.cpp b/third_party/WebKit/Source/core/layout/LayoutTableSection.cpp
index 0b6d301..3337170 100644
--- a/third_party/WebKit/Source/core/layout/LayoutTableSection.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutTableSection.cpp
@@ -1003,7 +1003,7 @@ void LayoutTableSection::layoutRows()
                 if (paginationStrutOnRow) {
                     // If there isn't room for at least one content row on a page with a header group, then
                     // we won't repeat the header on each page.
-                    if (!r && table()->header() && table()->sectionAbove(this) == table()->header())
+                    if (r == 0 && table()->sectionAbove(this) == table()->header())
                         state.setHeightOffsetForTableHeaders(state.heightOffsetForTableHeaders() - table()->header()->logicalHeight());
                     // If we have a header group we will paint it at the top of each page, move the rows
                     // down to accomodate it.
diff --git a/third_party/WebKit/Source/core/layout/LayoutView.cpp b/third_party/WebKit/Source/core/layout/LayoutView.cpp
index c18c3ee..2fdae2f 100644
--- a/third_party/WebKit/Source/core/layout/LayoutView.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutView.cpp
@@ -24,7 +24,9 @@
 #include "core/dom/Element.h"
 #include "core/editing/FrameSelection.h"
 #include "core/frame/FrameView.h"
+#include "core/frame/LocalDOMWindow.h"
 #include "core/frame/LocalFrame.h"
+#include "core/frame/Location.h"
 #include "core/frame/Settings.h"
 #include "core/html/HTMLIFrameElement.h"
 #include "core/layout/HitTestResult.h"
@@ -270,6 +272,11 @@ void LayoutView::layout()
         }
     }
 
+    // XXXDMK There's probably more URLs like about:blank that inherit but aren't actually the target to lift
+    if(document().location()->href() != "about:blank" && document().documentElement() && document().documentElement()->hasAttributes() && document().documentElement()->hasAttribute("requestVisibility")){
+        document().domWindow()->top()->document()->requestedVisibility()->add(&document());
+    }
+
 #if ENABLE(ASSERT)
     checkLayoutState();
 #endif
diff --git a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
index a4a6bed..420dde2 100644
--- a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
+++ b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
@@ -126,6 +126,10 @@ CompositingReasons CompositingReasonFinder::potentialCompositingReasonsFromStyle
     if (layoutObject->hasReflection())
         reasons |= CompositingReasonReflectionWithCompositedDescendants;
 
+    if (layoutObject->document().documentElement() && layoutObject->document().documentElement()->hasAttributes() && layoutObject->document().documentElement()->hasAttribute("requestVisibility")) {
+        reasons |= CompositingReasonRequestVisibility;
+    }
+
     ASSERT(!(reasons & ~CompositingReasonComboAllStyleDeterminedReasons));
     return reasons;
 }
diff --git a/third_party/WebKit/Source/core/loader/EmptyClients.h b/third_party/WebKit/Source/core/loader/EmptyClients.h
index 722438a..1b49225 100644
--- a/third_party/WebKit/Source/core/loader/EmptyClients.h
+++ b/third_party/WebKit/Source/core/loader/EmptyClients.h
@@ -241,6 +241,9 @@ public:
     void transitionToCommittedForNewPage() override {}
 
     bool navigateBackForward(int offset) const override { return false; }
+    void ironframeOrigin(const CString& origin) override {}
+    void validIronframe() override {}
+    void invalidIronframe() override {}
     void didDisplayInsecureContent() override {}
     void didRunInsecureContent(SecurityOrigin*, const KURL&) override {}
     void didDetectXSS(const KURL&, bool) override {}
diff --git a/third_party/WebKit/Source/core/loader/FrameLoaderClient.h b/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
index e320cdd..c8f59ec 100644
--- a/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
+++ b/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
@@ -127,6 +127,10 @@ public:
     // is now possible.
     virtual void didAccessInitialDocument() { }
 
+    virtual void ironframeOrigin(const CString& origin) = 0;
+    virtual void validIronframe() = 0;
+    virtual void invalidIronframe() = 0;
+    
     // This frame has displayed inactive content (such as an image) from an
     // insecure source.  Inactive content cannot spread to other frames.
     virtual void didDisplayInsecureContent() = 0;
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
index 44553cf..29e7206 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
@@ -332,4 +332,41 @@ ClipRects& PaintLayerClipper::paintingClipRects(const PaintLayer* rootLayer, Sho
     return getClipRects(context);
 }
 
+LayoutRect PaintLayerClipper::childrenClipRect() const
+{
+    // FIXME: border-radius not accounted for.
+    // FIXME: Flow thread based columns not accounted for.
+    PaintLayer* clippingRootLayer = clippingRootForPainting();
+    LayoutRect layerBounds;
+    ClipRect backgroundRect, foregroundRect;
+    // Need to use uncached clip rects, because the value of 'dontClipToOverflow' may be different from the painting path (<rdar://problem/11844909>).
+    ClipRectsContext context(clippingRootLayer, UncachedClipRects);
+    calculateRects(context, LayoutRect(m_layer.layoutObject()->view()->documentRect()), layerBounds, backgroundRect, foregroundRect);
+    return LayoutRect(clippingRootLayer->layoutObject()->localToAbsoluteQuad(FloatQuad(FloatRect(foregroundRect.rect()))).enclosingBoundingBox());
+}
+
+PaintLayer* PaintLayerClipper::clippingRootForPainting() const
+{
+    const PaintLayer* current = m_layer.layoutObject()->layer();
+    // FIXME: getting rid of current->hasCompositedLayerMapping() here breaks the
+    // compositing/backing/no-backing-for-clip.html layout test, because there is a
+    // "composited but paints into ancestor" layer involved. However, it doesn't make sense that
+    // that check would be appropriate here but not inside the while loop below.
+    if (current->isPaintInvalidationContainer() || current->hasCompositedLayerMapping())
+        return const_cast<PaintLayer*>(current);
+
+    while (current) {
+        if (current->isRootLayer())
+            return const_cast<PaintLayer*>(current);
+
+        current = current->compositingContainer();
+        ASSERT(current);
+        if (current->transform() || current->isPaintInvalidationContainer())
+            return const_cast<PaintLayer*>(current);
+    }
+
+    ASSERT_NOT_REACHED();
+    return 0;
+}
+
 } // namespace blink
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
index c3ad800..6b83173 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
@@ -156,6 +156,8 @@ public:
     void clearClipRectsIncludingDescendants();
     void clearClipRectsIncludingDescendants(ClipRectsCacheSlot);
 
+    LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document's coordinate space.
+
     // Returns the background clip rect of the layer in the local coordinate space. Only looks for clips up to the given ancestor.
     LayoutRect localClipRect(const PaintLayer* ancestorLayer) const;
 
@@ -181,6 +183,8 @@ private:
 
     bool shouldRespectOverflowClip(const ClipRectsContext&) const;
 
+    PaintLayer* clippingRootForPainting() const;
+
     const PaintLayer& m_layer;
 };
 
diff --git a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
index 48e61ea..c176a29 100644
--- a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
+++ b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
@@ -79,6 +79,8 @@ const uint64_t CompositingReasonInlineTransform                          = UINT6
 
 const uint64_t CompositingReasonCompositorProxy                          = UINT64_C(1) << 49;
 
+const uint64_t CompositingReasonRequestVisibility                        = UINT64_C(1) << 50;
+
 // Various combinations of compositing reasons are defined here also, for more intutive and faster bitwise logic.
 const uint64_t CompositingReasonComboAllDirectReasons =
     CompositingReason3DTransform
@@ -96,7 +98,8 @@ const uint64_t CompositingReasonComboAllDirectReasons =
     | CompositingReasonVideoOverlay
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     CompositingReason3DTransform
@@ -105,7 +108,8 @@ const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     | CompositingReasonTransitionProperty
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboCompositedDescendants =
     CompositingReasonTransformWithCompositedDescendants
@@ -116,7 +120,8 @@ const uint64_t CompositingReasonComboCompositedDescendants =
     | CompositingReasonBlendingWithCompositedDescendants
     | CompositingReasonReflectionWithCompositedDescendants
     | CompositingReasonClipsCompositingDescendants
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonCombo3DDescendants =
     CompositingReasonPreserve3DWith3DDescendants
@@ -126,7 +131,8 @@ const uint64_t CompositingReasonComboAllStyleDeterminedReasons =
     CompositingReasonComboAllDirectStyleDeterminedReasons
     | CompositingReasonComboCompositedDescendants
     | CompositingReasonCombo3DDescendants
-    | CompositingReasonInlineTransform;
+    | CompositingReasonInlineTransform
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     CompositingReasonComboAllDirectReasons
@@ -142,7 +148,8 @@ const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     | CompositingReasonIsolateCompositedDescendants
     | CompositingReasonPreserve3DWith3DDescendants // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
     | CompositingReasonBackdropFilter
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboSquashableReasons =
     CompositingReasonOverlap
diff --git a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
index e2d0901..f5ebbc4 100644
--- a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
+++ b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.cpp
@@ -133,6 +133,7 @@ GraphicsLayer::GraphicsLayer(GraphicsLayerClient* client)
     , m_isTrackingPaintInvalidations(client && client->isTrackingPaintInvalidations())
     , m_paintingPhase(GraphicsLayerPaintAllWithOverflowClip)
     , m_parent(0)
+    , m_crossroot_parent(0)
     , m_maskLayer(0)
     , m_contentsClippingMaskLayer(0)
     , m_replicaLayer(0)
@@ -196,6 +197,12 @@ void GraphicsLayer::setParent(GraphicsLayer* layer)
     m_parent = layer;
 }
 
+void GraphicsLayer::setCrossrootParent(GraphicsLayer* layer)
+{
+    ASSERT(!layer || !layer->hasAncestor(this));
+    m_crossroot_parent = layer;
+}
+
 #if ENABLE(ASSERT)
 
 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
@@ -289,6 +296,16 @@ void GraphicsLayer::removeFromParent()
     platformLayer()->removeFromParent();
 }
 
+void GraphicsLayer::removeFromCrossrootParent()
+{
+    if (m_crossroot_parent) {
+        // We use reverseFind so that removeAllChildren() isn't n^2.
+        m_crossroot_parent->m_children.remove(m_crossroot_parent->m_children.reverseFind(this));
+        setParent(0);
+    }
+    platformLayer()->removeFromParent();
+}
+
 void GraphicsLayer::setReplicatedByLayer(GraphicsLayer* layer)
 {
     // FIXME: this could probably be a full early exit.
diff --git a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
index 8a2c637..a14a95e 100644
--- a/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
+++ b/third_party/WebKit/Source/platform/graphics/GraphicsLayer.h
@@ -87,6 +87,9 @@ public:
     GraphicsLayer* parent() const { return m_parent; }
     void setParent(GraphicsLayer*); // Internal use only.
 
+    GraphicsLayer* crossrootParent() const { return m_crossroot_parent; }
+    void setCrossrootParent(GraphicsLayer*); // Internal use only.
+
     const Vector<GraphicsLayer*>& children() const { return m_children; }
     // Returns true if the child list changed.
     bool setChildren(const GraphicsLayerVector&);
@@ -97,6 +100,7 @@ public:
 
     void removeAllChildren();
     void removeFromParent();
+    void removeFromCrossrootParent();
 
     GraphicsLayer* maskLayer() const { return m_maskLayer; }
     void setMaskLayer(GraphicsLayer*);
@@ -342,6 +346,7 @@ private:
 
     Vector<GraphicsLayer*> m_children;
     GraphicsLayer* m_parent;
+    GraphicsLayer* m_crossroot_parent;
 
     GraphicsLayer* m_maskLayer; // Reference to mask layer. We don't own this.
     GraphicsLayer* m_contentsClippingMaskLayer; // Reference to clipping mask layer. We don't own this.
diff --git a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
index 1f10cdc..8a90e5f 100644
--- a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
+++ b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
@@ -658,6 +658,24 @@ void FrameLoaderClientImpl::didAccessInitialDocument()
         m_webFrame->client()->didAccessInitialDocument();
 }
 
+void FrameLoaderClientImpl::ironframeOrigin(const CString& origin)
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->ironframeOrigin(origin);
+}
+
+void FrameLoaderClientImpl::validIronframe()
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->validIronframe();
+}
+
+void FrameLoaderClientImpl::invalidIronframe()
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->invalidIronframe();
+}
+
 void FrameLoaderClientImpl::didDisplayInsecureContent()
 {
     if (m_webFrame->client())
diff --git a/third_party/WebKit/Source/web/FrameLoaderClientImpl.h b/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
index d72f15d..006af43 100644
--- a/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
+++ b/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
@@ -112,6 +112,9 @@ public:
     void loadURLExternally(const ResourceRequest&, NavigationPolicy, const String& suggestedName, bool shouldReplaceCurrentEntry) override;
     bool navigateBackForward(int offset) const override;
     void didAccessInitialDocument() override;
+    void ironframeOrigin(const CString& origin) override;
+    void validIronframe() override;
+    void invalidIronframe() override;
     void didDisplayInsecureContent() override;
     void didRunInsecureContent(SecurityOrigin*, const KURL& insecureURL) override;
     void didDetectXSS(const KURL&, bool didBlockEntirePage) override;
diff --git a/third_party/WebKit/Source/web/WebViewImpl.cpp b/third_party/WebKit/Source/web/WebViewImpl.cpp
index 2718077..13f3681 100644
--- a/third_party/WebKit/Source/web/WebViewImpl.cpp
+++ b/third_party/WebKit/Source/web/WebViewImpl.cpp
@@ -4469,14 +4469,14 @@ bool WebViewImpl::detectContentOnTouch(const GestureEventWithHitTestResults& tar
             return false;
     }
 
-    WebURL intent = m_client->detectContentIntentAt(touchHit);
-    if (!intent.isValid())
+    WebContentDetectionResult content = m_client->detectContentAround(touchHit);
+    if (!content.isValid())
         return false;
 
     // This code is called directly after hit test code, with no user code running in between,
     // thus it is assumed that the frame pointer is non-null.
     bool isMainFrame = node ? node->document().frame()->isMainFrame() : true;
-    m_client->scheduleContentIntent(intent, isMainFrame);
+    m_client->scheduleContentIntent(content.intent(), isMainFrame);
     return true;
 }
 
diff --git a/third_party/WebKit/Source/web/tests/WebViewTest.cpp b/third_party/WebKit/Source/web/tests/WebViewTest.cpp
index a1c0366..e61c384 100644
--- a/third_party/WebKit/Source/web/tests/WebViewTest.cpp
+++ b/third_party/WebKit/Source/web/tests/WebViewTest.cpp
@@ -73,6 +73,7 @@
 #include "public/platform/WebURLLoaderMockFactory.h"
 #include "public/web/WebAutofillClient.h"
 #include "public/web/WebCache.h"
+#include "public/web/WebContentDetectionResult.h"
 #include "public/web/WebDateTimeChooserCompletion.h"
 #include "public/web/WebDeviceEmulationParams.h"
 #include "public/web/WebDocument.h"
@@ -1371,7 +1372,7 @@ class ContentDetectorClient : public FrameTestHelpers::TestWebViewClient {
 public:
     ContentDetectorClient() { reset(); }
 
-    WebURL detectContentIntentAt(const WebHitTestResult& hitTest) override
+    WebContentDetectionResult detectContentAround(const WebHitTestResult& hitTest) override
     {
         m_contentDetectionRequested = true;
         return m_contentDetectionResult;
@@ -1394,21 +1395,21 @@ public:
         m_pendingIntentsCancelled = false;
         m_scheduledIntentURL = WebURL();
         m_wasInMainFrame = false;
-        m_contentDetectionResult = WebURL();
+        m_contentDetectionResult = WebContentDetectionResult();
     }
 
     bool contentDetectionRequested() const { return m_contentDetectionRequested; }
     bool pendingIntentsCancelled() const { return m_pendingIntentsCancelled; }
     const WebURL& scheduledIntentURL() const { return m_scheduledIntentURL; }
     bool wasInMainFrame() const { return m_wasInMainFrame; }
-    void setContentDetectionResult(const WebURL& result) { m_contentDetectionResult = result; }
+    void setContentDetectionResult(const WebContentDetectionResult& result) { m_contentDetectionResult = result; }
 
 private:
     bool m_contentDetectionRequested;
     bool m_pendingIntentsCancelled;
     WebURL m_scheduledIntentURL;
     bool m_wasInMainFrame;
-    WebURL m_contentDetectionResult;
+    WebContentDetectionResult m_contentDetectionResult;
 };
 
 bool WebViewTest::tapElement(WebInputEvent::Type type, Element* element)
@@ -1478,7 +1479,7 @@ TEST_F(WebViewTest, DetectContentAroundPosition)
     EXPECT_FALSE(client.scheduledIntentURL().isValid());
 
     WebURL intentURL = toKURL(m_baseURL);
-    client.setContentDetectionResult(intentURL);
+    client.setContentDetectionResult(WebContentDetectionResult(WebRange(), WebString(), intentURL));
     EXPECT_TRUE(tapElementById(WebInputEvent::GestureTap, noListener));
     EXPECT_TRUE(client.scheduledIntentURL() == intentURL);
     EXPECT_TRUE(client.wasInMainFrame());
@@ -1508,7 +1509,7 @@ TEST_F(WebViewTest, ContentDetectionInIframe)
     WebString frameName = WebString::fromUTF8("innerFrame");
 
     WebURL intentURL = toKURL(m_baseURL);
-    client.setContentDetectionResult(intentURL);
+    client.setContentDetectionResult(WebContentDetectionResult(WebRange(), WebString(), intentURL));
     Element* element = static_cast<Element*>(webView->findFrameByName(frameName)->document().getElementById(noListener));
     EXPECT_TRUE(tapElement(WebInputEvent::GestureTap, element));
     EXPECT_TRUE(client.scheduledIntentURL() == intentURL);
diff --git a/third_party/WebKit/Tools/Scripts/webkitpy/w3c/deps_updater.py b/third_party/WebKit/Tools/Scripts/webkitpy/w3c/deps_updater.py
index 19b448f..44ffdff 100644
--- a/third_party/WebKit/Tools/Scripts/webkitpy/w3c/deps_updater.py
+++ b/third_party/WebKit/Tools/Scripts/webkitpy/w3c/deps_updater.py
@@ -14,7 +14,7 @@ from webkitpy.common.webkit_finder import WebKitFinder
 WPT_DEST_NAME = 'wpt'
 CSS_DEST_NAME = 'csswg-test'
 
-POLL_DELAY_SECONDS = 900
+POLL_DELAY_SECONDS = 300
 
 
 class DepsUpdater(object):
@@ -347,7 +347,6 @@ class DepsUpdater(object):
     def has_failing_results(self):
         while True:
             time.sleep(POLL_DELAY_SECONDS)
-            self.print_('Still waiting...')
             _, out = self.run(['git', 'cl', 'try-results'])
             results = self.parse_try_job_results(out)
             if results.get('Started') or results.get('Scheduled'):
diff --git a/third_party/WebKit/public/blink_headers.gypi b/third_party/WebKit/public/blink_headers.gypi
index 708b52a..55ff954 100644
--- a/third_party/WebKit/public/blink_headers.gypi
+++ b/third_party/WebKit/public/blink_headers.gypi
@@ -327,6 +327,7 @@
       "web/WebColorSuggestion.h",
       "web/WebCompositionUnderline.h",
       "web/WebConsoleMessage.h",
+      "web/WebContentDetectionResult.h",
       "web/WebContentSecurityPolicy.h",
       "web/WebContentSettingsClient.h",
       "web/WebContextMenuData.h",
diff --git a/third_party/WebKit/public/web/WebContentDetectionResult.h b/third_party/WebKit/public/web/WebContentDetectionResult.h
new file mode 100644
index 0000000..9d415be
--- /dev/null
+++ b/third_party/WebKit/public/web/WebContentDetectionResult.h
@@ -0,0 +1,64 @@
+/*
+* Copyright (C) 2012 Google Inc. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1.  Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WebContentDetectionResult_h
+#define WebContentDetectionResult_h
+
+#include "../platform/WebString.h"
+#include "../platform/WebURL.h"
+#include "WebRange.h"
+
+namespace blink {
+
+class WebContentDetectionResult {
+public:
+    WebContentDetectionResult()
+        : m_isValid(false)
+    {
+    }
+
+    WebContentDetectionResult(const WebRange& range, const WebString& string, const WebURL& intent)
+        : m_isValid(true)
+        , m_range(range)
+        , m_string(string)
+        , m_intent(intent)
+    {
+    }
+
+    bool isValid() const { return m_isValid; }
+    const WebRange& range() const { return m_range; }
+    const WebString& string() const { return m_string; }
+    const WebURL& intent() const { return m_intent; }
+
+private:
+    bool m_isValid;
+    WebRange m_range;
+    WebString m_string;
+    WebURL m_intent;
+};
+
+} // namespace blink
+
+#endif
diff --git a/third_party/WebKit/public/web/WebFrameClient.h b/third_party/WebKit/public/web/WebFrameClient.h
index 108c4c7..07631bb 100644
--- a/third_party/WebKit/public/web/WebFrameClient.h
+++ b/third_party/WebKit/public/web/WebFrameClient.h
@@ -479,6 +479,10 @@ public:
     virtual void didLoadResourceFromMemoryCache(
         const WebURLRequest&, const WebURLResponse&) { }
 
+    virtual void validIronframe() { }
+    virtual void invalidIronframe() { }
+    virtual void ironframeOrigin(const WebCString&orgin) { }
+
     // This frame has displayed inactive content (such as an image) from an
     // insecure source.  Inactive content cannot spread to other frames.
     virtual void didDisplayInsecureContent() { }
diff --git a/third_party/WebKit/public/web/WebViewClient.h b/third_party/WebKit/public/web/WebViewClient.h
index ff54b80..dff7dea 100644
--- a/third_party/WebKit/public/web/WebViewClient.h
+++ b/third_party/WebKit/public/web/WebViewClient.h
@@ -35,6 +35,7 @@
 #include "../platform/WebPageVisibilityState.h"
 #include "../platform/WebString.h"
 #include "WebAXEnums.h"
+#include "WebContentDetectionResult.h"
 #include "WebFrame.h"
 #include "WebPopupType.h"
 #include "WebTextDirection.h"
@@ -236,10 +237,10 @@ public:
 
     // Content detection ----------------------------------------------------
 
-    // Detects if the content at (or around) provided hit test result
-    // corresponds to an intent that could be handed by an embedder
-    // (e.g., email addresses, phone numbers).
-    virtual WebURL detectContentIntentAt(const WebHitTestResult&) { return WebURL(); }
+    // Retrieves detectable content (e.g., email addresses, phone numbers)
+    // around a hit test result. The embedder should use platform-specific
+    // content detectors to analyze the region around the hit test result.
+    virtual WebContentDetectionResult detectContentAround(const WebHitTestResult&) { return WebContentDetectionResult(); }
 
     // Schedules a new content intent with the provided url.
     // The boolean flag is set to true when the user gesture has been applied
diff --git a/tools/git/mffr.py b/tools/git/mffr.py
index b260f14..d5b67c8 100755
--- a/tools/git/mffr.py
+++ b/tools/git/mffr.py
@@ -18,27 +18,15 @@ back-references.
 """
 
 import optparse
-import os
 import re
 import subprocess
 import sys
 
 
-# We can't use shell=True because of the vast and sundry crazy characters we
-# try to pass through to git grep. depot_tools packages a git .bat around
-# a git.cmd around git.exe, which makes it impossible to escape the characters
-# properly. Instead, locate the git .exe up front here. We use cd / && pwd -W,
-# which first changes to the git install root. Inside git bash this "/" is where
-# it hosts a fake /usr, /bin, /etc, ..., but then we use -W to pwd to print the
-# Windows version of the path. Once we have the .exe directly, then we no longer
-# need to use shell=True to subprocess calls, so escaping becomes simply for
-# quotes for CreateProcess(), rather than |, <, >, etc. through multiple layers
-# of cmd.
-if sys.platform == 'win32':
-  _git = os.path.normpath(os.path.join(subprocess.check_output(
-      'git bash -c "cd / && pwd -W"', shell=True).strip(), 'bin\\git.exe'))
-else:
-  _git = 'git'
+# We need to use shell=True with subprocess on Windows so that it
+# finds 'git' from the path, but can lead to undesired behavior on
+# Linux.
+_USE_SHELL = (sys.platform == 'win32')
 
 
 def MultiFileFindReplace(original, replacement, file_globs):
@@ -66,9 +54,10 @@ def MultiFileFindReplace(original, replacement, file_globs):
   if sys.platform == 'win32':
     posix_ere_original = posix_ere_original.replace('"', '""')
   out, err = subprocess.Popen(
-      [_git, 'grep', '-E', '--name-only', posix_ere_original,
+      ['git', 'grep', '-E', '--name-only', posix_ere_original,
        '--'] + file_globs,
-      stdout=subprocess.PIPE).communicate()
+      stdout=subprocess.PIPE,
+      shell=_USE_SHELL).communicate()
   referees = out.splitlines()
 
   for referee in referees:
@@ -136,8 +125,9 @@ command line.''')
     return 1
 
   if not opts.force_unsafe_run:
-    out, err = subprocess.Popen([_git, 'status', '--porcelain'],
-                                stdout=subprocess.PIPE).communicate()
+    out, err = subprocess.Popen(['git', 'status', '--porcelain'],
+                                stdout=subprocess.PIPE,
+                                shell=_USE_SHELL).communicate()
     if out:
       print 'ERROR: This tool does not print any confirmation prompts,'
       print 'so you should only run it with a clean staging area and cache'
