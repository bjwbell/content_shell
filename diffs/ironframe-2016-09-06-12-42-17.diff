diff --git a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
index dc2889d..604ccf5 100644
--- a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
+++ b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.cc
@@ -80,6 +80,24 @@ ChromeToolbarModelDelegate::GetSecurityLevel() const {
   return client->GetSecurityInfo().security_level;
 }
 
+int
+ChromeToolbarModelDelegate::GetIronframeStatus() const {
+  content::WebContents* web_contents = GetActiveWebContents();
+  // If there is no active WebContents (which can happen during toolbar
+  // initialization), assume no security style.
+  if (!web_contents)
+      return 0;
+  return web_contents->IronframeStatus();
+}
+
+std::string
+ChromeToolbarModelDelegate::GetIronframeOrigin() const {
+  content::WebContents* web_contents = GetActiveWebContents();
+  if (!web_contents)
+      return std::string();
+  return web_contents->IronframeOrigin();
+}
+
 scoped_refptr<net::X509Certificate> ChromeToolbarModelDelegate::GetCertificate()
     const {
   scoped_refptr<net::X509Certificate> cert;
diff --git a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
index 42806b9..711c6f4 100644
--- a/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
+++ b/chrome/browser/ui/toolbar/chrome_toolbar_model_delegate.h
@@ -34,6 +34,8 @@ class ChromeToolbarModelDelegate : public ToolbarModelDelegate {
   bool GetURL(GURL* url) const override;
   bool ShouldDisplayURL() const override;
   SecurityLevel GetSecurityLevel() const override;
+  int GetIronframeStatus() const override;
+  std::string GetIronframeOrigin() const override;
   scoped_refptr<net::X509Certificate> GetCertificate() const override;
 
   // Returns the navigation controller used to retrieve the navigation entry
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index 1946e31..76ad277 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -590,7 +590,9 @@ void LocationBarView::Layout() {
   const int vertical_padding = GetVerticalEdgeThicknessWithPadding();
   const int location_height = std::max(height() - (vertical_padding * 2), 0);
 
-  location_icon_view_->SetLabel(base::string16());
+  if (GetToolbarModel()->GetIronframeStatus() == 0) {
+          location_icon_view_->SetLabel(base::string16());
+  }
   location_icon_view_->SetBackground(false);
   if (ShouldShowKeywordBubble()) {
     leading_decorations.AddDecoration(vertical_padding, location_height, true,
@@ -613,7 +615,9 @@ void LocationBarView::Layout() {
       }
     }
   } else if (ShouldShowSecurityChip()) {
-    location_icon_view_->SetLabel(GetSecurityText());
+    if (GetToolbarModel()->GetIronframeStatus() == 0) {
+          location_icon_view_->SetLabel(GetSecurityText());
+    }
     location_icon_view_->SetBackground(true);
     // The largest fraction of the omnibox that can be taken by the EV bubble.
     const double kMaxBubbleFraction = 0.5;
@@ -859,8 +863,20 @@ void LocationBarView::RefreshLocationIcon() {
     return;
 
   if (ui::MaterialDesignController::IsModeMaterial()) {
-    security_state::SecurityStateModel::SecurityLevel security_level =
-        GetToolbarModel()->GetSecurityLevel(false);
+      int ironframe_status = GetToolbarModel()->GetIronframeStatus();
+      security_state::SecurityStateModel::SecurityLevel security_level =
+          GetToolbarModel()->GetSecurityLevel(false);
+
+      if (ironframe_status != 0) {
+          //security_level = security_state::SecurityStateModel::SECURE;
+          if (ironframe_status == 1) {
+              security_level = security_state::SecurityStateModel::SECURE;
+              location_icon_view_->SetLabel(base::ASCIIToUTF16(GetToolbarModel()->GetIronframeOrigin()));
+          } else if (ironframe_status == 2) {
+              security_level = security_state::SecurityStateModel::SECURITY_ERROR;
+          }
+      }
+
     SkColor icon_color =
         (security_level == security_state::SecurityStateModel::NONE)
             ? color_utils::DeriveDefaultIconColor(GetColor(TEXT))
@@ -1048,8 +1064,13 @@ bool LocationBarView::ShouldShowKeywordBubble() const {
 }
 
 bool LocationBarView::ShouldShowEVBubble() const {
-  return (GetToolbarModel()->GetSecurityLevel(false) ==
-          security_state::SecurityStateModel::EV_SECURE);
+    int ironframe_status = GetToolbarModel()->GetIronframeStatus();
+    if (ironframe_status == 1) {
+        return security_state::SecurityStateModel::EV_SECURE;
+    }
+
+    return (GetToolbarModel()->GetSecurityLevel(false) ==
+            security_state::SecurityStateModel::EV_SECURE);
 }
 
 bool LocationBarView::ShouldShowSecurityChip() const {
diff --git a/components/toolbar/toolbar_model.h b/components/toolbar/toolbar_model.h
index 19c60d1..145b659 100644
--- a/components/toolbar/toolbar_model.h
+++ b/components/toolbar/toolbar_model.h
@@ -43,6 +43,9 @@ class ToolbarModel {
   virtual security_state::SecurityStateModel::SecurityLevel GetSecurityLevel(
       bool ignore_editing) const = 0;
 
+  virtual int GetIronframeStatus() const = 0;
+  virtual std::string GetIronframeOrigin() const = 0;
+
   // Returns the resource_id of the icon to show to the left of the address,
   // based on the current URL.  When search term replacement is active, this
   // returns a search icon.  This doesn't cover specialized icons while the
diff --git a/components/toolbar/toolbar_model_delegate.h b/components/toolbar/toolbar_model_delegate.h
index 4bec77c..6cc8255 100644
--- a/components/toolbar/toolbar_model_delegate.h
+++ b/components/toolbar/toolbar_model_delegate.h
@@ -40,6 +40,10 @@ class ToolbarModelDelegate {
   // user edits that may be in progress.
   virtual SecurityLevel GetSecurityLevel() const = 0;
 
+  virtual int GetIronframeStatus() const = 0;
+
+  virtual std::string GetIronframeOrigin() const = 0;
+
   // Returns the certificate for the current navigation entry.
   virtual scoped_refptr<net::X509Certificate> GetCertificate() const = 0;
 
diff --git a/components/toolbar/toolbar_model_impl.cc b/components/toolbar/toolbar_model_impl.cc
index 47388f7..862df4b 100644
--- a/components/toolbar/toolbar_model_impl.cc
+++ b/components/toolbar/toolbar_model_impl.cc
@@ -70,6 +70,21 @@ SecurityStateModel::SecurityLevel ToolbarModelImpl::GetSecurityLevel(
              : delegate_->GetSecurityLevel();
 }
 
+int ToolbarModelImpl::GetIronframeStatus() const {
+  // When editing or empty, assume no ironframe
+  return ((input_in_progress()) || !ShouldDisplayURL())
+             ? 0
+             : delegate_->GetIronframeStatus();
+}
+
+std::string ToolbarModelImpl::GetIronframeOrigin() const {
+  // When editing or empty, assume no ironframe
+    base::string16 empty;
+  return ((input_in_progress()) || !ShouldDisplayURL())
+      ? std::string()
+             : delegate_->GetIronframeOrigin();
+}
+
 int ToolbarModelImpl::GetIcon() const {
   switch (GetSecurityLevel(false)) {
     case SecurityStateModel::NONE:
diff --git a/components/toolbar/toolbar_model_impl.h b/components/toolbar/toolbar_model_impl.h
index c60177e..725a234 100644
--- a/components/toolbar/toolbar_model_impl.h
+++ b/components/toolbar/toolbar_model_impl.h
@@ -32,6 +32,10 @@ class ToolbarModelImpl : public ToolbarModel {
   GURL GetURL() const override;
   security_state::SecurityStateModel::SecurityLevel GetSecurityLevel(
       bool ignore_editing) const override;
+
+  int GetIronframeStatus() const override;
+  std::string GetIronframeOrigin() const override;
+
   int GetIcon() const override;
   gfx::VectorIconId GetVectorIcon() const override;
   base::string16 GetSecureVerboseText() const override;
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 878d780..45bdbe5 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -692,6 +692,12 @@ bool WebContentsImpl::OnMessageReceived(RenderViewHost* render_view_host,
                         OnFirstVisuallyNonEmptyPaint)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidLoadResourceFromMemoryCache,
                         OnDidLoadResourceFromMemoryCache)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_IronframeOrigin,
+                        OnIronframeOrigin)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_ValidIronframe,
+                        OnValidIronframe)
+    IPC_MESSAGE_HANDLER(FrameHostMsg_InvalidIronframe,
+                        OnInvalidIronframe)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidDisplayInsecureContent,
                         OnDidDisplayInsecureContent)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidRunInsecureContent,
@@ -1186,6 +1192,14 @@ const std::string& WebContentsImpl::GetEncoding() const {
   return canonical_encoding_;
 }
 
+int WebContentsImpl::IronframeStatus() const {
+  return ironframe_status_;
+}
+
+bool WebContentsImpl::DisplayedInsecureContent() const {
+  return displayed_insecure_content_;
+}
+
 void WebContentsImpl::IncrementCapturerCount(const gfx::Size& capture_size) {
   DCHECK(!is_being_destroyed_);
   ++capturer_count_;
@@ -2511,10 +2525,6 @@ void WebContentsImpl::ResizeDueToAutoResize(
     delegate_->ResizeDueToAutoResize(this, new_size);
 }
 
-bool WebContentsImpl::DisplayedInsecureContent() const {
-  return displayed_insecure_content_;
-}
-
 bool WebContentsImpl::DisplayedContentWithCertErrors() const {
   return displayed_content_with_cert_errors_;
 }
@@ -3467,6 +3477,27 @@ void WebContentsImpl::OnDidLoadResourceFromMemoryCache(
   }
 }
 
+
+std::string WebContentsImpl::IronframeOrigin() const {
+      RecordAction(base::UserMetricsAction("Ironframe.Origin"));
+      return ironframe_origin_;
+}
+
+void WebContentsImpl::OnIronframeOrigin(const std::string& origin) {
+    ironframe_origin_ = origin;
+}
+
+void WebContentsImpl::OnValidIronframe() {
+  RecordAction(base::UserMetricsAction("Ironframe.Valid"));
+  ironframe_status_ = 1;
+  this->DidChangeVisibleSSLState();
+}
+void WebContentsImpl::OnInvalidIronframe() {
+  RecordAction(base::UserMetricsAction("Ironframe.Invalid"));
+  ironframe_status_ = 2;
+  this->DidChangeVisibleSSLState();
+}
+
 void WebContentsImpl::OnDidDisplayInsecureContent() {
   RecordAction(base::UserMetricsAction("SSL.DisplayedInsecureContent"));
   displayed_insecure_content_ = true;
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index 9a1fbe0..2533688 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -291,6 +291,9 @@ class CONTENT_EXPORT WebContentsImpl
   uint64_t GetUploadSize() const override;
   uint64_t GetUploadPosition() const override;
   const std::string& GetEncoding() const override;
+  int IronframeStatus() const override;
+  std::string IronframeOrigin() const override;
+  bool DisplayedInsecureContent() const override;
   void IncrementCapturerCount(const gfx::Size& capture_size) override;
   void DecrementCapturerCount() override;
   int GetCapturerCount() const override;
@@ -405,10 +408,6 @@ class CONTENT_EXPORT WebContentsImpl
   bool GetAllowOtherViews() override;
 #endif
 
-  // Returns true if this is a secure page which has displayed content
-  // loaded over insecure HTTP.
-  bool DisplayedInsecureContent() const;
-
   // Returns true if this page has displayed content loaded over HTTPS
   // with certificate errors.
   bool DisplayedContentWithCertErrors() const;
@@ -918,6 +917,9 @@ class CONTENT_EXPORT WebContentsImpl
                                         const std::string& http_request,
                                         const std::string& mime_type,
                                         ResourceType resource_type);
+  void OnIronframeOrigin(const std::string& origin);
+  void OnValidIronframe();
+  void OnInvalidIronframe();
   void OnDidDisplayInsecureContent();
   void OnDidRunInsecureContent(const GURL& security_origin,
                                const GURL& target_url);
@@ -1208,8 +1210,11 @@ class CONTENT_EXPORT WebContentsImpl
   // The canonicalized character encoding.
   std::string canonical_encoding_;
 
-  // True if this is a secure page which displayed mixed content (loaded
-  // over HTTP).
+  //   0 - no ironframe, 1 - valid ironframe, 2 - invalid ironframe
+  int  ironframe_status_;
+  std::string ironframe_origin_;
+
+  // True if this is a secure page which displayed insecure content.
   bool displayed_insecure_content_;
 
   // True if this page displayed subresources loaded with HTTPS
diff --git a/content/common/frame_messages.h b/content/common/frame_messages.h
index 64ef075..6724bdd 100644
--- a/content/common/frame_messages.h
+++ b/content/common/frame_messages.h
@@ -1460,6 +1460,10 @@ IPC_MESSAGE_ROUTED0(FrameHostMsg_DispatchLoad)
 IPC_MESSAGE_ROUTED1(FrameHostMsg_RouteMessageEvent,
                     FrameMsg_PostMessage_Params)
 
+IPC_MESSAGE_ROUTED1(FrameHostMsg_IronframeOrigin, std::string)
+IPC_MESSAGE_ROUTED0(FrameHostMsg_ValidIronframe)
+IPC_MESSAGE_ROUTED0(FrameHostMsg_InvalidIronframe)
+
 // Sent when the renderer displays insecure content in a secure origin.
 IPC_MESSAGE_ROUTED0(FrameHostMsg_DidDisplayInsecureContent)
 
diff --git a/content/public/browser/web_contents.h b/content/public/browser/web_contents.h
index ad3c35a..9ab8cb5 100644
--- a/content/public/browser/web_contents.h
+++ b/content/public/browser/web_contents.h
@@ -364,6 +364,12 @@ class WebContents : public PageNavigator,
   // Returns the character encoding of the page.
   virtual const std::string& GetEncoding() const = 0;
 
+  virtual int IronframeStatus() const = 0;
+  virtual std::string IronframeOrigin() const = 0;
+
+  // True if this is a secure page which displayed insecure content.
+  virtual bool DisplayedInsecureContent() const = 0;
+
   // Internal state ------------------------------------------------------------
 
   // Indicates whether the WebContents is being captured (e.g., for screenshots
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index cefdf2b..e2d01ef 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -4175,6 +4175,18 @@ void RenderFrameImpl::didLoadResourceFromMemoryCache(
       WebURLRequestToResourceType(request)));
 }
 
+void RenderFrameImpl::ironframeOrigin(const blink::WebCString& origin) {
+    Send(new FrameHostMsg_IronframeOrigin(routing_id_, origin));
+}
+
+void RenderFrameImpl::validIronframe() {
+  Send(new FrameHostMsg_ValidIronframe(routing_id_));
+}
+
+void RenderFrameImpl::invalidIronframe() {
+  Send(new FrameHostMsg_InvalidIronframe(routing_id_));
+}
+
 void RenderFrameImpl::didDisplayInsecureContent() {
   Send(new FrameHostMsg_DidDisplayInsecureContent(routing_id_));
 }
diff --git a/content/renderer/render_frame_impl.h b/content/renderer/render_frame_impl.h
index 4427706..5c52e38 100644
--- a/content/renderer/render_frame_impl.h
+++ b/content/renderer/render_frame_impl.h
@@ -566,6 +566,9 @@ class CONTENT_EXPORT RenderFrameImpl
   void didLoadResourceFromMemoryCache(
       const blink::WebURLRequest& request,
       const blink::WebURLResponse& response) override;
+  void validIronframe() override;
+  void invalidIronframe() override;
+  void ironframeOrigin(const blink::WebCString& origin) override;
   void didDisplayInsecureContent() override;
   void didRunInsecureContent(const blink::WebSecurityOrigin& origin,
                              const blink::WebURL& target) override;
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
new file mode 100644
index 0000000..79978b4
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/ironframe.html
@@ -0,0 +1,67 @@
+<!DOCTYPE html>
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<meta name="timeout" content="long"></meta>
+<head>
+</head>
+<body>
+    <pre id="result">UNSET</pre>
+    <div id=prot style="height:480;width:700;background-image:url('tile.gif');">
+        <iframe id=protfr border=0 frameBorder=0 scrolling="no" src="resources/openskies3.html" style="height:270;width:333"></iframe>
+    </div>
+    <script>
+     var t = async_test('IronFrame scroll test');
+     setTimeout(function(){
+         t.step(function () {
+             assert_equals(document.getElementById("result").innerHTML, "PASS", "Scroll incorrect");
+         });
+         t.done();
+     }, 3000);
+    </script>
+    <script>
+     function scrollWindow() {
+         setTimeout(function(){window.scrollTo(0, 1);}, 1000);
+         setTimeout(function(){window.scrollTo(0, 100);}, 2000);
+     }
+     window.addEventListener("load", scrollWindow, false);
+    </script>
+    DUMMY CONTENT
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    <br>
+    DUMMY CONTENT
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
new file mode 100644
index 0000000..1a1dceb
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/fileserver.go
@@ -0,0 +1,15 @@
+// httpserver.go
+package main
+
+import (
+	"flag"
+	"net/http"
+)
+
+var port = flag.String("port", "8080", "Define what TCP port to bind to")
+var root = flag.String("root", ".", "Define the root filesystem path")
+
+func main() {
+	flag.Parse()
+	panic(http.ListenAndServe(":"+*port, http.FileServer(http.Dir(*root))))
+}
\ No newline at end of file
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
new file mode 100644
index 0000000..edecfff
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/openskies3.html
@@ -0,0 +1,7 @@
+<!DOCTYPE html>
+<body>
+  <pre id="result1"></pre>
+  <iframe id="bigframe" style="position:absolute;top:0;left:0" border=0 frameBorder=0 scrolling="no" height=3000 width=3000 src="protected3.html">
+  </iframe>
+</body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png
new file mode 100644
index 0000000..9feafc5
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/paypal.png differ
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
new file mode 100644
index 0000000..00e2193
--- /dev/null
+++ b/third_party/WebKit/LayoutTests/http/tests/ironframe/resources/protected3.html
@@ -0,0 +1,61 @@
+<html requestVisibility=1>
+    <body>
+        <script>
+         var enabled=true;
+         var numAlerts = 0;
+         var width0 = -1;
+         var height0 = -1;
+         var width1 = -1;
+         var height1 = -1;
+        </script>
+        <img src="paypal.png" style="position:absolute;top:0;left:0">
+        <script>
+         var prev;
+         var prevMsg="";
+         var v={};
+         var visible=false;
+
+         var update = function(){
+             if(v.visible.width < 333 || v.visible.height< 270 ) {
+                 visible=false;
+             } else {
+                 visible=true;
+             }
+             if (width0 == - 1) {
+                 if (v.visible.width != 300 || v.visible.height != 150) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PARTIAL PASS";
+                 }
+                 width0 = v.visible.width;
+                 height0 = v.visible.height;
+             } else if (width0 != v.visible.width || height0 != v.visible.height) {
+                 if (v.visible.width != 300 || v.visible.height != 92) {
+                     window.top.document.getElementById("result").innerHTML = "FAIL";
+                 } else {
+                     window.top.document.getElementById("result").innerHTML = "PASS";
+                 }
+
+                 if (width1 == -1) {
+                     width1 = v.visible.width;
+                     height1 = v.visible.height;
+                 }
+             }
+         }
+         function go() {
+             document.documentElement.addEventListener('requestvisibility', function(e) {
+                 if(e.message!=prevMsg){
+                     prev=e.timeStamp;
+                     prevMsg=e.message;
+                 }
+                 v = JSON.parse(e.message);
+                 v.innerHeight = innerHeight;
+                 v.innerWidth  = innerWidth;
+                 v.ancestorOrigins = document.location.ancestorOrigins;
+                 update();
+             });
+         }
+         if(enabled) { window.onload=go; }
+        </script>
+    </body>
+</html>
diff --git a/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif
new file mode 100644
index 0000000..6c950c8
Binary files /dev/null and b/third_party/WebKit/LayoutTests/http/tests/ironframe/tile.gif differ
diff --git a/third_party/WebKit/Source/bindings/core/v8/BUILD.gn b/third_party/WebKit/Source/bindings/core/v8/BUILD.gn
index 4c915e3..da3ec8b 100644
--- a/third_party/WebKit/Source/bindings/core/v8/BUILD.gn
+++ b/third_party/WebKit/Source/bindings/core/v8/BUILD.gn
@@ -56,6 +56,8 @@ generated_core_dictionary_files = [
   "$blink_core_output_dir/events/DragEventInit.h",
   "$blink_core_output_dir/events/ErrorEventInit.cpp",
   "$blink_core_output_dir/events/ErrorEventInit.h",
+  "$blink_core_output_dir/events/RequestVisibilityEventInit.cpp",
+  "$blink_core_output_dir/events/RequestVisibilityEventInit.h",
   "$blink_core_output_dir/events/EventInit.cpp",
   "$blink_core_output_dir/events/EventInit.h",
   "$blink_core_output_dir/events/EventListenerOptions.cpp",
diff --git a/third_party/WebKit/Source/core/BUILD.gn b/third_party/WebKit/Source/core/BUILD.gn
index 56c7040..d45b934 100644
--- a/third_party/WebKit/Source/core/BUILD.gn
+++ b/third_party/WebKit/Source/core/BUILD.gn
@@ -269,6 +269,7 @@ generate_event_interfaces("core_event_interfaces") {
     "events/CustomEvent.idl",
     "events/DragEvent.idl",
     "events/ErrorEvent.idl",
+    "events/RequestVisibilityEvent.idl",
     "events/Event.idl",
     "events/FocusEvent.idl",
     "events/HashChangeEvent.idl",
diff --git a/third_party/WebKit/Source/core/core_idl_files.gni b/third_party/WebKit/Source/core/core_idl_files.gni
index ec915d8..4729134 100644
--- a/third_party/WebKit/Source/core/core_idl_files.gni
+++ b/third_party/WebKit/Source/core/core_idl_files.gni
@@ -137,6 +137,7 @@ core_idl_files = get_path_info([
                                  "events/CustomEvent.idl",
                                  "events/DragEvent.idl",
                                  "events/ErrorEvent.idl",
+                                 "events/RequestVisibilityEvent.idl",
                                  "events/Event.idl",
                                  "events/EventTarget.idl",
                                  "events/FocusEvent.idl",
@@ -509,6 +510,7 @@ core_dictionary_idl_files =
                     "events/CustomEventInit.idl",
                     "events/DragEventInit.idl",
                     "events/ErrorEventInit.idl",
+                    "events/RequestVisibilityEventInit.idl",
                     "events/EventInit.idl",
                     "events/EventListenerOptions.idl",
                     "events/EventModifierInit.idl",
diff --git a/third_party/WebKit/Source/core/dom/Document.cpp b/third_party/WebKit/Source/core/dom/Document.cpp
index 61ee242b..0023a2d 100644
--- a/third_party/WebKit/Source/core/dom/Document.cpp
+++ b/third_party/WebKit/Source/core/dom/Document.cpp
@@ -26,6 +26,7 @@
  */
 
 #include "core/dom/Document.h"
+#include "core/events/ErrorEvent.h"
 
 #include "bindings/core/v8/DOMDataStore.h"
 #include "bindings/core/v8/ExceptionMessages.h"
@@ -121,11 +122,13 @@
 #include "core/editing/serializers/Serialization.h"
 #include "core/editing/spellcheck/SpellChecker.h"
 #include "core/events/BeforeUnloadEvent.h"
+#include "core/events/ErrorEvent.h"
 #include "core/events/Event.h"
 #include "core/events/EventFactory.h"
 #include "core/events/EventListener.h"
 #include "core/events/HashChangeEvent.h"
 #include "core/events/PageTransitionEvent.h"
+#include "core/events/RequestVisibilityEvent.h"
 #include "core/events/ScopedEventQueue.h"
 #include "core/events/VisualViewportResizeEvent.h"
 #include "core/events/VisualViewportScrollEvent.h"
@@ -186,6 +189,7 @@
 #include "core/layout/LayoutView.h"
 #include "core/layout/TextAutosizer.h"
 #include "core/layout/api/LayoutViewItem.h"
+#include "core/layout/compositing/CompositedLayerMapping.h"
 #include "core/layout/compositing/PaintLayerCompositor.h"
 #include "core/loader/CookieJar.h"
 #include "core/loader/DocumentLoader.h"
@@ -212,6 +216,9 @@
 #include "core/svg/SVGScriptElement.h"
 #include "core/svg/SVGTitleElement.h"
 #include "core/svg/SVGUseElement.h"
+#include "core/testing/Internals.h"
+#include "core/testing/InternalRuntimeFlags.h"
+#include "core/testing/InternalSettings.h"
 #include "core/timing/DOMWindowPerformance.h"
 #include "core/timing/Performance.h"
 #include "core/workers/SharedWorkerRepositoryClient.h"
@@ -393,6 +400,9 @@ Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC
     , m_domWindow(m_frame ? m_frame->localDOMWindow() : 0)
     , m_importsController(initializer.importsController())
     , m_contextFeatures(ContextFeatures::defaultSwitch())
+    , m_requestedVisibility(new VisibilityDocumentSet())
+    , m_prevRequestVisibilityEvent()
+    , m_requestVisibilityRect(nullptr)
     , m_wellFormed(false)
     , m_printing(false)
     , m_wasPrinting(false)
@@ -3920,6 +3930,13 @@ void Document::enqueueAnimationFrameEvent(Event* event)
     ensureScriptedAnimationController().enqueueEvent(event);
 }
 
+void Document::enqueueRequestVisibilityEvent(const String& msg)
+{
+    RequestVisibilityEvent* event = RequestVisibilityEvent::create(msg);
+    event->setTarget(documentElement());
+    ensureScriptedAnimationController().enqueueEvent(event);
+}
+
 void Document::enqueueUniqueAnimationFrameEvent(Event* event)
 {
     ensureScriptedAnimationController().enqueuePerFrameEvent(event);
@@ -5812,6 +5829,150 @@ bool Document::hasFocus() const
     return page() && page()->focusController().isDocumentFocused(*this);
 }
 
+
+void Document::validIronframe(){
+    m_frame->loader().client()->ironframeOrigin(this->origin().ascii());
+    m_frame->loader().client()->validIronframe();
+}
+
+void Document::invalidIronframe(){
+    m_frame->loader().client()->invalidIronframe();
+}
+
+VisibilityDocumentSet *Document::requestedVisibility() {
+    return m_requestedVisibility;
+}
+
+void Document::requestVisibility(){
+    // Set attribute.
+    this->documentElement()->setAttribute("requestVisibility", "1", ASSERT_NO_EXCEPTION);
+
+    // When document.requestVisibility() is called /after/ the initial page load use translateZ(0px)
+    // to workaround a bug where CompositingReasonRequestVisibility in
+    // third_party/WebKit/Source/platform/graphics/CompositingReasons.h doesnt create the
+    // root and iframe graphics/paint layers.
+    this->documentElement()->style()->setProperty("transform", "translateZ(0px)", "", ASSERT_NO_EXCEPTION);
+}
+
+void Document::requestVisibilityImpl(){
+    // Step 1:  Block obvious failure modes.  Probably insert SVG test here?
+    if(this->domWindow() == this->domWindow()->top()) {return;}
+
+    // Step 2:  Collect useful handles
+    DOMWindow *testWindow = this->domWindow();
+    PaintLayer* iframePaintLayer = this->documentElement()->layoutObject()->enclosingLayer();
+
+    if(!iframePaintLayer) { return; }
+    GraphicsLayer* iframeGraphicsLayer = iframePaintLayer->graphicsLayerBacking();
+    const PaintLayer* rootPaintLayer = this->domWindow()->top()->document()->body()->layoutObject()->enclosingLayer()->root(); // XXX DMK top scrolling layer
+    GraphicsLayer* rootGraphicsLayer = rootPaintLayer->graphicsLayerBacking();
+    if(!iframeGraphicsLayer || !rootGraphicsLayer) {
+        addConsoleMessage(ConsoleMessage::create(RenderingMessageSource, ErrorMessageLevel, "Couldn't find required GraphicsLayer.  One may not have been created for this document."));
+        return;
+    }
+    // Step 3:  Discover our effective Bounds.  We are effectively trying to compute the "keyhole" that reaches us,
+    //          through multiple iframes and scroll/translateX values.  The "sacred" transform is position and size.
+    //          This is presently being done via boundsInViewportSpace, which works through almost everything.
+    //          Almost.  (Scale3d needs to be corrected for, or rejected.)
+
+    IntRect bounds = this->documentElement()->boundsInViewport();
+    IntRect origBounds = bounds;
+    testWindow = this->domWindow();
+    float sx, sy;
+    sx = sy = 0;
+    bool moreElements = true;
+    Element *testElement = this->documentElement();
+    Document *testDocument = this;
+
+    bool do_move = true;
+    bool hostile = false;
+    while(moreElements){
+        if(testDocument->documentElement()==testElement){
+            testElement = testDocument->domWindow()->frameElement();
+            testDocument = &testElement->document();
+            sx+=testWindow->scrollX();
+            sy+=testWindow->scrollY();
+            testWindow = testWindow->parent();
+        } else {
+            testElement = testElement->parentElement();
+        }
+        // HACK!! Remove use of childrenClipRect
+        IntRect child = IntRect(testElement->layoutObject()->enclosingLayer()->clipper().childrenClipRect());
+        if(testElement->tagName() == "foreignObject"){
+            hostile = true;
+        }
+        if(testElement->tagName() == "IFRAME") {
+            IntRect ifrBounds = testElement->boundsInViewport();
+            child.setWidth(fmin(ifrBounds.size().width(), child.size().width()));
+            child.setHeight(fmin(ifrBounds.size().height(), child.size().height()));
+        }
+        bounds.intersect(child);
+        if(testElement == this->domWindow()->top()->document()->documentElement()) {
+            moreElements = false;
+        }
+    }
+
+    // intersect with visible viewport.  XXX stop using IntRect, start using FloatRect
+    FrameView *mainFrameView = this->page()->deprecatedLocalMainFrame()->view();
+    LayoutRect mainViewRect = mainFrameView->layoutView()->viewRect();
+
+    IntRect mainViewIntRect = IntRect(mainViewRect);
+    bounds.intersect(mainViewIntRect);
+
+    FloatRect mainViewFloatRect = FloatRect(mainViewRect);
+    if(!bounds.size().width() || !bounds.size().height()) do_move = false;
+    // XXX for each registered visibility req, look for collisions with us, if so block the raise
+    VisibilityDocumentSet *ds = this->domWindow()->top()->document()->requestedVisibility();
+
+    for(Document *reqdoc : *ds){
+        if(reqdoc == this) break; // maybe this is right?
+        if(reqdoc->m_requestVisibilityRect && reqdoc->m_requestVisibilityRect->intersects(bounds)) {
+            // XXX DMK better would be to run bounds.subtract but then there'd have to *be* a bounds.subtract method.
+            //         Also, subtraction is a not quite so defined as intersection.  Largest contiguous from 0,0?
+            //         Largest contiguous from any corner?  God forbid, pile-o-rects?  Let's just run for the hills for now
+            hostile = true;
+            //return;  // there is a rather fun attack if you try this
+        }
+    }
+
+    if(hostile){
+        do_move = false;
+        bounds.setWidth(0);
+        bounds.setHeight(0);
+    }
+    if(this->documentElement()->hasAttribute("visibilityOnly")) { do_move = false; } // XXX DMK expand on this, there are uses
+    if (do_move) {
+        FloatRect fbounds = bounds;
+        this->set_requestVisibilityRect(&fbounds);
+        rootGraphicsLayer->addChild(iframeGraphicsLayer);
+
+        // TODO: Use bounds not origBounds:
+        // bounds.intersect(mainViewIntRect) has buggy interaction with scrolling.
+        iframeGraphicsLayer->setPosition(FloatPoint(origBounds.x(), origBounds.y()));
+
+        iframeGraphicsLayer->setSize(FloatSize(bounds.size().width(), bounds.size().height()));
+        iframeGraphicsLayer->setBackgroundColor(Color::black);
+        iframeGraphicsLayer->setMasksToBounds(true);
+        iframeGraphicsLayer->setOpacity(1.0);
+        IntSize offset = IntSize(bounds.x()-origBounds.x()-topDocument().domWindow()->scrollX(), bounds.y()-origBounds.y()-topDocument().domWindow()->scrollY());
+        iframeGraphicsLayer->setOffsetFromLayoutObject(offset, GraphicsLayer::ShouldSetNeedsDisplay::SetNeedsDisplay);
+    }
+    // report.  sx and sy are
+    bounds.setWidth(fmax(bounds.size().width() - sx, 0));
+    bounds.setHeight(fmax(bounds.size().height()- sy, 0));
+    //XXX DMK correctly integrate ancestorOrigins and return a clientRect for the visible region of the frame
+    String s = String("{\"viewport\": {\"x\": " + String::number((int)mainViewFloatRect.x()) + ", \"y\": " + String::number((int)mainViewFloatRect.y()) + ", \"width\": " + String::number((int)mainViewFloatRect.size().width()) + ", \"height\": " + String::number((int)mainViewFloatRect.size().height()) + "},  \"visible\": {\"x\": " + String::number((int)bounds.x()) + ",  \"y\": " + String::number((int)bounds.y()) + ", \"width\": " + String::number((int)bounds.size().width()) + ", \"height\": " + String::number((int)bounds.size().height()) + "}}");
+
+    bool duplicate = false;
+    if (s == m_prevRequestVisibilityEvent) {
+        duplicate = true;
+    }
+    m_prevRequestVisibilityEvent = s;
+    if (!duplicate) {
+        this->enqueueRequestVisibilityEvent(s);
+    }
+};
+
 template<unsigned type>
 bool shouldInvalidateNodeListCachesForAttr(const HeapHashSet<WeakMember<const LiveNodeListBase>> nodeLists[], const QualifiedName& attrName)
 {
@@ -6011,6 +6172,7 @@ DEFINE_TRACE(Document)
     visitor->trace(m_intersectionObserverData);
     visitor->trace(m_snapCoordinator);
     visitor->trace(m_resizeObserverController);
+    visitor->trace(m_requestedVisibility);
     Supplementable<Document>::trace(visitor);
     TreeScope::trace(visitor);
     ContainerNode::trace(visitor);
diff --git a/third_party/WebKit/Source/core/dom/Document.h b/third_party/WebKit/Source/core/dom/Document.h
index d641d20..78f8ff2 100644
--- a/third_party/WebKit/Source/core/dom/Document.h
+++ b/third_party/WebKit/Source/core/dom/Document.h
@@ -176,6 +176,7 @@ struct AnnotatedRegionValue;
 struct FocusParams;
 struct IconURL;
 
+using VisibilityDocumentSet = HeapHashSet<WeakMember<Document>>;
 using MouseEventWithHitTestResults = EventWithHitTestResults<PlatformMouseEvent>;
 using ExceptionCode = int;
 
@@ -715,6 +716,8 @@ public:
     ResizeObserverController* resizeObserverController() const { return m_resizeObserverController; }
     ResizeObserverController& ensureResizeObserverController();
 
+    VisibilityDocumentSet *requestedVisibility();
+
     void updateViewportDescription();
 
     // Returns the owning element in the parent document. Returns nullptr if
@@ -930,6 +933,7 @@ public:
     void enqueueMediaQueryChangeListeners(HeapVector<Member<MediaQueryListListener>>&);
     void enqueueVisualViewportScrollEvent();
     void enqueueVisualViewportResizeEvent();
+    void enqueueRequestVisibilityEvent(const String&);
 
     void dispatchEventsForPrinting();
 
@@ -1094,6 +1098,12 @@ public:
 
     bool isInMainFrame() const;
 
+    void set_requestVisibilityRect(FloatRect *r) { m_requestVisibilityRect = r; }
+    void validIronframe();
+    void invalidIronframe();
+    void requestVisibility();
+    void requestVisibilityImpl();
+
 protected:
     Document(const DocumentInit&, DocumentClassFlags = DefaultDocumentClass);
 
@@ -1206,6 +1216,10 @@ private:
     Member<DocumentParser> m_parser;
     Member<ContextFeatures> m_contextFeatures;
 
+    Member<VisibilityDocumentSet> m_requestedVisibility;
+    String m_prevRequestVisibilityEvent;
+    FloatRect *m_requestVisibilityRect;
+
     bool m_wellFormed;
 
     // Document URLs.
diff --git a/third_party/WebKit/Source/core/dom/Document.idl b/third_party/WebKit/Source/core/dom/Document.idl
index 8598cce..c3eb26d 100644
--- a/third_party/WebKit/Source/core/dom/Document.idl
+++ b/third_party/WebKit/Source/core/dom/Document.idl
@@ -54,6 +54,11 @@ interface Document : Node {
     HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);
     HTMLCollection getElementsByClassName(DOMString classNames);
 
+    void requestVisibility();
+    void validIronframe();
+    void invalidIronframe();
+    void requestVisibilityImpl();
+
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, PerWorldBindings, RaisesException] Element createElement(DOMString localName);
     [NewObject, DoNotTestNewObject, CustomElementCallbacks, RaisesException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName);
     [NewObject] DocumentFragment createDocumentFragment();
diff --git a/third_party/WebKit/Source/core/events/BUILD.gn b/third_party/WebKit/Source/core/events/BUILD.gn
index 778429d..0584a19 100644
--- a/third_party/WebKit/Source/core/events/BUILD.gn
+++ b/third_party/WebKit/Source/core/events/BUILD.gn
@@ -30,6 +30,8 @@ blink_core_sources("events") {
     "DragEvent.h",
     "ErrorEvent.cpp",
     "ErrorEvent.h",
+    "RequestVisibilityEvent.cpp",
+    "RequestVisibilityEvent.h",
     "Event.cpp",
     "EventDispatchMediator.cpp",
     "EventDispatchMediator.h",
diff --git a/third_party/WebKit/Source/core/events/EventTypeNames.in b/third_party/WebKit/Source/core/events/EventTypeNames.in
index 55d5268..2c4edee 100644
--- a/third_party/WebKit/Source/core/events/EventTypeNames.in
+++ b/third_party/WebKit/Source/core/events/EventTypeNames.in
@@ -188,6 +188,7 @@ removesourcebuffer
 removestream
 removetrack
 repeatEvent
+requestvisibility
 reset
 resize
 resourcetimingbufferfull
diff --git a/third_party/WebKit/Source/core/events/RequestVisibilityEvent.cpp b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.cpp
new file mode 100644
index 0000000..b3c583f
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.cpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "core/events/RequestVisibilityEvent.h"
+
+#include "bindings/core/v8/V8Binding.h"
+#include <v8.h>
+
+namespace blink {
+
+RequestVisibilityEvent::RequestVisibilityEvent()
+    : m_sanitizedMessage()
+{
+}
+
+RequestVisibilityEvent::RequestVisibilityEvent(const AtomicString& type, const RequestVisibilityEventInit& initializer)
+    : Event(type, initializer)
+    , m_sanitizedMessage()
+{
+    if (initializer.hasMessage())
+        m_sanitizedMessage = initializer.message();
+}
+
+RequestVisibilityEvent::RequestVisibilityEvent(const String& message)
+    : Event(EventTypeNames::requestvisibility, false, true)
+    , m_sanitizedMessage(message)
+{
+}
+
+void RequestVisibilityEvent::setUnsanitizedMessage(const String& message)
+{
+    ASSERT(m_unsanitizedMessage.isEmpty());
+    m_unsanitizedMessage = message;
+}
+
+RequestVisibilityEvent::~RequestVisibilityEvent()
+{
+}
+
+const AtomicString& RequestVisibilityEvent::interfaceName() const
+{
+    return EventNames::RequestVisibilityEvent;
+}
+
+DEFINE_TRACE(RequestVisibilityEvent)
+{
+    Event::trace(visitor);
+}
+
+} // namespace blink
diff --git a/third_party/WebKit/Source/core/events/RequestVisibilityEvent.h b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.h
new file mode 100644
index 0000000..f4f5731
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RequestVisibilityEvent_h
+#define RequestVisibilityEvent_h
+
+#include "bindings/core/v8/DOMWrapperWorld.h"
+#include "bindings/core/v8/SourceLocation.h"
+#include "core/events/RequestVisibilityEventInit.h"
+#include "core/events/Event.h"
+#include "wtf/RefPtr.h"
+#include "wtf/text/WTFString.h"
+
+namespace blink {
+
+class RequestVisibilityEvent final : public Event {
+    DEFINE_WRAPPERTYPEINFO();
+public:
+    static RequestVisibilityEvent* create()
+    {
+        return new RequestVisibilityEvent;
+    }
+    static RequestVisibilityEvent* create(const String& message)
+    {
+        return new RequestVisibilityEvent(message);
+    }
+    static RequestVisibilityEvent* create(const AtomicString& type, const RequestVisibilityEventInit& initializer)
+    {
+        return new RequestVisibilityEvent(type, initializer);
+    }
+
+    ~RequestVisibilityEvent() override;
+
+    // As 'message' is exposed to JavaScript, never return unsanitizedMessage.
+    const String& message() const { return m_sanitizedMessage; }
+
+    // 'messageForConsole' is not exposed to JavaScript, and prefers 'm_unsanitizedMessage'.
+    const String& messageForConsole() const { return !m_unsanitizedMessage.isEmpty() ? m_unsanitizedMessage : m_sanitizedMessage; }
+
+    const AtomicString& interfaceName() const override;
+
+    void setUnsanitizedMessage(const String&);
+
+    DECLARE_VIRTUAL_TRACE();
+
+private:
+    RequestVisibilityEvent();
+    RequestVisibilityEvent(const String& message);
+    RequestVisibilityEvent(const AtomicString&, const RequestVisibilityEventInit&);
+
+    String m_unsanitizedMessage;
+    String m_sanitizedMessage;
+};
+
+} // namespace blink
+
+#endif // RequestVisibilityEvent_h
diff --git a/third_party/WebKit/Source/core/events/RequestVisibilityEvent.idl b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.idl
new file mode 100644
index 0000000..102ffc0
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestVisibilityEvent.idl
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+[
+    Constructor(DOMString type, optional RequestVisibilityEventInit eventInitDict),
+] interface RequestVisibilityEvent : Event {
+    readonly attribute DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/events/RequestVisibilityEventInit.idl b/third_party/WebKit/Source/core/events/RequestVisibilityEventInit.idl
new file mode 100644
index 0000000..966ff22
--- /dev/null
+++ b/third_party/WebKit/Source/core/events/RequestVisibilityEventInit.idl
@@ -0,0 +1,7 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+dictionary RequestVisibilityEventInit : EventInit {
+    DOMString message;
+};
diff --git a/third_party/WebKit/Source/core/frame/FrameView.cpp b/third_party/WebKit/Source/core/frame/FrameView.cpp
index 28f1607..640c36b 100644
--- a/third_party/WebKit/Source/core/frame/FrameView.cpp
+++ b/third_party/WebKit/Source/core/frame/FrameView.cpp
@@ -41,6 +41,7 @@
 #include "core/events/ErrorEvent.h"
 #include "core/fetch/ResourceFetcher.h"
 #include "core/frame/EventHandlerRegistry.h"
+#include "core/frame/FrameConsole.h"
 #include "core/frame/FrameHost.h"
 #include "core/frame/LocalFrame.h"
 #include "core/frame/Location.h"
@@ -2608,6 +2609,15 @@ void FrameView::updateLifecyclePhasesInternal(DocumentLifecycle::LifecycleState
             // This was required for slimming paint v1 but is only temporarily
             // needed for slimming paint v2.
             view.compositor()->updateIfNeededRecursive();
+
+	    Document *d = frame().document();
+	    VisibilityDocumentSet *ds = d->requestedVisibility();
+	    if (ds != nullptr) {
+		for(Document *reqdoc : *ds){
+		    reqdoc->requestVisibilityImpl();
+		}
+	    }
+
             scrollContentsIfNeededRecursive();
 
             DCHECK(lifecycle().state() >= DocumentLifecycle::CompositingClean);
diff --git a/third_party/WebKit/Source/core/frame/UseCounter.h b/third_party/WebKit/Source/core/frame/UseCounter.h
index 79a4776..b74097f 100644
--- a/third_party/WebKit/Source/core/frame/UseCounter.h
+++ b/third_party/WebKit/Source/core/frame/UseCounter.h
@@ -1286,6 +1286,9 @@ public:
         MetaSetCookieWhenCSPBlocksInlineScript = 1549,
         MetaRefreshWhenCSPBlocksInlineScript = 1550,
 
+        DocumentCreateEventRequestedVisibilityEvent = 1600,
+
+
         // Add new features immediately above this line. Don't change assigned
         // numbers of any item, and don't reuse removed slots.
         // Also, run update_use_counter_feature_enum.py in chromium/src/tools/metrics/histograms/
diff --git a/third_party/WebKit/Source/core/layout/LayoutView.cpp b/third_party/WebKit/Source/core/layout/LayoutView.cpp
index 0112d60..e6a37ad 100644
--- a/third_party/WebKit/Source/core/layout/LayoutView.cpp
+++ b/third_party/WebKit/Source/core/layout/LayoutView.cpp
@@ -24,7 +24,9 @@
 #include "core/dom/Element.h"
 #include "core/editing/FrameSelection.h"
 #include "core/frame/FrameView.h"
+#include "core/frame/LocalDOMWindow.h"
 #include "core/frame/LocalFrame.h"
+#include "core/frame/Location.h"
 #include "core/frame/Settings.h"
 #include "core/html/HTMLIFrameElement.h"
 #include "core/layout/HitTestResult.h"
@@ -272,6 +274,11 @@ void LayoutView::layout()
         }
     }
 
+    // XXXDMK There's probably more URLs like about:blank that inherit but aren't actually the target to lift
+    if(document().location()->href() != "about:blank" && document().documentElement() && document().documentElement()->hasAttributes() && document().documentElement()->hasAttribute("requestVisibility")){
+        document().domWindow()->top()->document()->requestedVisibility()->add(&document());
+    }
+
 #if ENABLE(ASSERT)
     checkLayoutState();
 #endif
diff --git a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
index a4a6bed..420dde2 100644
--- a/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
+++ b/third_party/WebKit/Source/core/layout/compositing/CompositingReasonFinder.cpp
@@ -126,6 +126,10 @@ CompositingReasons CompositingReasonFinder::potentialCompositingReasonsFromStyle
     if (layoutObject->hasReflection())
         reasons |= CompositingReasonReflectionWithCompositedDescendants;
 
+    if (layoutObject->document().documentElement() && layoutObject->document().documentElement()->hasAttributes() && layoutObject->document().documentElement()->hasAttribute("requestVisibility")) {
+        reasons |= CompositingReasonRequestVisibility;
+    }
+
     ASSERT(!(reasons & ~CompositingReasonComboAllStyleDeterminedReasons));
     return reasons;
 }
diff --git a/third_party/WebKit/Source/core/loader/EmptyClients.h b/third_party/WebKit/Source/core/loader/EmptyClients.h
index d5715a0..dcd80e2 100644
--- a/third_party/WebKit/Source/core/loader/EmptyClients.h
+++ b/third_party/WebKit/Source/core/loader/EmptyClients.h
@@ -240,6 +240,9 @@ public:
     void transitionToCommittedForNewPage() override {}
 
     bool navigateBackForward(int offset) const override { return false; }
+    void ironframeOrigin(const CString& origin) override {}
+    void validIronframe() override {}
+    void invalidIronframe() override {}
     void didDisplayInsecureContent() override {}
     void didRunInsecureContent(SecurityOrigin*, const KURL&) override {}
     void didDetectXSS(const KURL&, bool) override {}
diff --git a/third_party/WebKit/Source/core/loader/FrameLoaderClient.h b/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
index 6dceeae..c508e95 100644
--- a/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
+++ b/third_party/WebKit/Source/core/loader/FrameLoaderClient.h
@@ -126,6 +126,10 @@ public:
     // is now possible.
     virtual void didAccessInitialDocument() { }
 
+    virtual void ironframeOrigin(const CString& origin) = 0;
+    virtual void validIronframe() = 0;
+    virtual void invalidIronframe() = 0;
+
     // This frame has displayed inactive content (such as an image) from an
     // insecure source.  Inactive content cannot spread to other frames.
     virtual void didDisplayInsecureContent() = 0;
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
index 214c5be..fb03bce 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.cpp
@@ -331,4 +331,41 @@ ClipRects& PaintLayerClipper::paintingClipRects(const PaintLayer* rootLayer, Sho
     return getClipRects(context);
 }
 
+LayoutRect PaintLayerClipper::childrenClipRect() const
+{
+    // FIXME: border-radius not accounted for.
+    // FIXME: Flow thread based columns not accounted for.
+    PaintLayer* clippingRootLayer = clippingRootForPainting();
+    LayoutRect layerBounds;
+    ClipRect backgroundRect, foregroundRect;
+    // Need to use uncached clip rects, because the value of 'dontClipToOverflow' may be different from the painting path (<rdar://problem/11844909>).
+    ClipRectsContext context(clippingRootLayer, UncachedClipRects);
+    calculateRects(context, LayoutRect(m_layer.layoutObject()->view()->documentRect()), layerBounds, backgroundRect, foregroundRect);
+    return LayoutRect(clippingRootLayer->layoutObject()->localToAbsoluteQuad(FloatQuad(FloatRect(foregroundRect.rect()))).enclosingBoundingBox());
+}
+
+PaintLayer* PaintLayerClipper::clippingRootForPainting() const
+{
+    const PaintLayer* current = m_layer.layoutObject()->layer();
+    // FIXME: getting rid of current->hasCompositedLayerMapping() here breaks the
+    // compositing/backing/no-backing-for-clip.html layout test, because there is a
+    // "composited but paints into ancestor" layer involved. However, it doesn't make sense that
+    // that check would be appropriate here but not inside the while loop below.
+    if (current->isPaintInvalidationContainer() || current->hasCompositedLayerMapping())
+        return const_cast<PaintLayer*>(current);
+
+    while (current) {
+        if (current->isRootLayer())
+            return const_cast<PaintLayer*>(current);
+
+        current = current->compositingContainer();
+        ASSERT(current);
+        if (current->transform() || current->isPaintInvalidationContainer())
+            return const_cast<PaintLayer*>(current);
+    }
+
+    ASSERT_NOT_REACHED();
+    return 0;
+}
+
 } // namespace blink
diff --git a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
index c3ad800..6b83173 100644
--- a/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
+++ b/third_party/WebKit/Source/core/paint/PaintLayerClipper.h
@@ -156,6 +156,8 @@ public:
     void clearClipRectsIncludingDescendants();
     void clearClipRectsIncludingDescendants(ClipRectsCacheSlot);
 
+    LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document's coordinate space.
+
     // Returns the background clip rect of the layer in the local coordinate space. Only looks for clips up to the given ancestor.
     LayoutRect localClipRect(const PaintLayer* ancestorLayer) const;
 
@@ -181,6 +183,8 @@ private:
 
     bool shouldRespectOverflowClip(const ClipRectsContext&) const;
 
+    PaintLayer* clippingRootForPainting() const;
+
     const PaintLayer& m_layer;
 };
 
diff --git a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
index 48e61ea..c176a29 100644
--- a/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
+++ b/third_party/WebKit/Source/platform/graphics/CompositingReasons.h
@@ -79,6 +79,8 @@ const uint64_t CompositingReasonInlineTransform                          = UINT6
 
 const uint64_t CompositingReasonCompositorProxy                          = UINT64_C(1) << 49;
 
+const uint64_t CompositingReasonRequestVisibility                        = UINT64_C(1) << 50;
+
 // Various combinations of compositing reasons are defined here also, for more intutive and faster bitwise logic.
 const uint64_t CompositingReasonComboAllDirectReasons =
     CompositingReason3DTransform
@@ -96,7 +98,8 @@ const uint64_t CompositingReasonComboAllDirectReasons =
     | CompositingReasonVideoOverlay
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     CompositingReason3DTransform
@@ -105,7 +108,8 @@ const uint64_t CompositingReasonComboAllDirectStyleDeterminedReasons =
     | CompositingReasonTransitionProperty
     | CompositingReasonWillChangeCompositingHint
     | CompositingReasonCompositorProxy
-    | CompositingReasonBackdropFilter;
+    | CompositingReasonBackdropFilter
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboCompositedDescendants =
     CompositingReasonTransformWithCompositedDescendants
@@ -116,7 +120,8 @@ const uint64_t CompositingReasonComboCompositedDescendants =
     | CompositingReasonBlendingWithCompositedDescendants
     | CompositingReasonReflectionWithCompositedDescendants
     | CompositingReasonClipsCompositingDescendants
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonCombo3DDescendants =
     CompositingReasonPreserve3DWith3DDescendants
@@ -126,7 +131,8 @@ const uint64_t CompositingReasonComboAllStyleDeterminedReasons =
     CompositingReasonComboAllDirectStyleDeterminedReasons
     | CompositingReasonComboCompositedDescendants
     | CompositingReasonCombo3DDescendants
-    | CompositingReasonInlineTransform;
+    | CompositingReasonInlineTransform
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     CompositingReasonComboAllDirectReasons
@@ -142,7 +148,8 @@ const uint64_t CompositingReasonComboReasonsThatRequireOwnBacking =
     | CompositingReasonIsolateCompositedDescendants
     | CompositingReasonPreserve3DWith3DDescendants // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
     | CompositingReasonBackdropFilter
-    | CompositingReasonPositionFixedWithCompositedDescendants;
+    | CompositingReasonPositionFixedWithCompositedDescendants
+    | CompositingReasonRequestVisibility;
 
 const uint64_t CompositingReasonComboSquashableReasons =
     CompositingReasonOverlap
diff --git a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
index d010d78..88c8c37 100644
--- a/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
+++ b/third_party/WebKit/Source/web/FrameLoaderClientImpl.cpp
@@ -638,6 +638,24 @@ void FrameLoaderClientImpl::didAccessInitialDocument()
         m_webFrame->client()->didAccessInitialDocument();
 }
 
+void FrameLoaderClientImpl::ironframeOrigin(const CString& origin)
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->ironframeOrigin(origin);
+}
+
+void FrameLoaderClientImpl::validIronframe()
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->validIronframe();
+}
+
+void FrameLoaderClientImpl::invalidIronframe()
+{
+    if (m_webFrame->client())
+        m_webFrame->client()->invalidIronframe();
+}
+
 void FrameLoaderClientImpl::didDisplayInsecureContent()
 {
     if (m_webFrame->client())
diff --git a/third_party/WebKit/Source/web/FrameLoaderClientImpl.h b/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
index 582f9d5..04eb3e9 100644
--- a/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
+++ b/third_party/WebKit/Source/web/FrameLoaderClientImpl.h
@@ -110,6 +110,9 @@ public:
     void loadURLExternally(const ResourceRequest&, NavigationPolicy, const String& suggestedName, bool shouldReplaceCurrentEntry) override;
     bool navigateBackForward(int offset) const override;
     void didAccessInitialDocument() override;
+    void ironframeOrigin(const CString& origin) override;
+    void validIronframe() override;
+    void invalidIronframe() override;
     void didDisplayInsecureContent() override;
     void didRunInsecureContent(SecurityOrigin*, const KURL& insecureURL) override;
     void didDetectXSS(const KURL&, bool didBlockEntirePage) override;
diff --git a/third_party/WebKit/public/web/WebFrameClient.h b/third_party/WebKit/public/web/WebFrameClient.h
index 83e75a3..79a6bcf 100644
--- a/third_party/WebKit/public/web/WebFrameClient.h
+++ b/third_party/WebKit/public/web/WebFrameClient.h
@@ -461,6 +461,10 @@ public:
     virtual void didLoadResourceFromMemoryCache(
         const WebURLRequest&, const WebURLResponse&) { }
 
+    virtual void validIronframe() { }
+    virtual void invalidIronframe() { }
+    virtual void ironframeOrigin(const WebCString&orgin) { }
+
     // This frame has displayed inactive content (such as an image) from an
     // insecure source.  Inactive content cannot spread to other frames.
     virtual void didDisplayInsecureContent() { }
